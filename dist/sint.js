(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":3,"core-js/shim":328,"regenerator-runtime/runtime":2}],2:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":24,"../../modules/core.regexp.escape":131}],4:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],5:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":19}],6:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":43,"./_wks":129}],7:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],8:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":52}],9:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":115,"./_to-length":119,"./_to-object":120}],10:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":115,"./_to-length":119,"./_to-object":120}],11:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":40}],12:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":115,"./_to-iobject":118,"./_to-length":119}],13:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":16,"./_ctx":26,"./_iobject":48,"./_to-length":119,"./_to-object":120}],14:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":4,"./_iobject":48,"./_to-length":119,"./_to-object":120}],15:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":50,"./_is-object":52,"./_wks":129}],16:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":15}],17:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":4,"./_invoke":47,"./_is-object":52}],18:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":19,"./_wks":129}],19:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],20:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":7,"./_ctx":26,"./_descriptors":30,"./_for-of":40,"./_iter-define":56,"./_iter-step":58,"./_meta":67,"./_object-create":72,"./_object-dp":73,"./_redefine-all":94,"./_set-species":101,"./_validate-collection":126}],21:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":11,"./_classof":18}],22:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":7,"./_an-object":8,"./_array-methods":13,"./_for-of":40,"./_has":42,"./_is-object":52,"./_meta":67,"./_redefine-all":94,"./_validate-collection":126}],23:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":7,"./_export":34,"./_fails":36,"./_for-of":40,"./_global":41,"./_inherit-if-required":46,"./_is-object":52,"./_iter-detect":57,"./_meta":67,"./_redefine":95,"./_redefine-all":94,"./_set-to-string-tag":102}],24:[function(require,module,exports){
var core = module.exports = { version: '2.5.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],25:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":73,"./_property-desc":93}],26:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":4}],27:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":36}],28:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":8,"./_to-primitive":121}],29:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],30:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":36}],31:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":41,"./_is-object":52}],32:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],33:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":79,"./_object-keys":82,"./_object-pie":83}],34:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":24,"./_ctx":26,"./_global":41,"./_hide":43,"./_redefine":95}],35:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":129}],36:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],37:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":29,"./_fails":36,"./_hide":43,"./_redefine":95,"./_wks":129}],38:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":8}],39:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":26,"./_is-array":50,"./_is-object":52,"./_to-length":119,"./_wks":129}],40:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":8,"./_ctx":26,"./_is-array-iter":49,"./_iter-call":54,"./_to-length":119,"./core.get-iterator-method":130}],41:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],42:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],43:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":30,"./_object-dp":73,"./_property-desc":93}],44:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":41}],45:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":30,"./_dom-create":31,"./_fails":36}],46:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":52,"./_set-proto":100}],47:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],48:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":19}],49:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":59,"./_wks":129}],50:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":19}],51:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":52}],52:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],53:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":19,"./_is-object":52,"./_wks":129}],54:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":8}],55:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":43,"./_object-create":72,"./_property-desc":93,"./_set-to-string-tag":102,"./_wks":129}],56:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":34,"./_has":42,"./_hide":43,"./_iter-create":55,"./_iterators":59,"./_library":61,"./_object-gpo":80,"./_redefine":95,"./_set-to-string-tag":102,"./_wks":129}],57:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":129}],58:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],59:[function(require,module,exports){
module.exports = {};

},{}],60:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
module.exports = function (object, el) {
  var O = toIObject(object);
  var keys = getKeys(O);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) if (O[key = keys[index++]] === el) return key;
};

},{"./_object-keys":82,"./_to-iobject":118}],61:[function(require,module,exports){
module.exports = false;

},{}],62:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],63:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":66}],64:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],65:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],66:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],67:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":36,"./_has":42,"./_is-object":52,"./_object-dp":73,"./_uid":125}],68:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":34,"./_shared":104,"./es6.map":161,"./es6.weak-map":267}],69:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":19,"./_global":41,"./_task":114}],70:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":4}],71:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":36,"./_iobject":48,"./_object-gops":79,"./_object-keys":82,"./_object-pie":83,"./_to-object":120}],72:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":8,"./_dom-create":31,"./_enum-bug-keys":32,"./_html":44,"./_object-dps":74,"./_shared-key":103}],73:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":8,"./_descriptors":30,"./_ie8-dom-define":45,"./_to-primitive":121}],74:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":8,"./_descriptors":30,"./_object-dp":73,"./_object-keys":82}],75:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":36,"./_global":41,"./_library":61}],76:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":30,"./_has":42,"./_ie8-dom-define":45,"./_object-pie":83,"./_property-desc":93,"./_to-iobject":118,"./_to-primitive":121}],77:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":78,"./_to-iobject":118}],78:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":32,"./_object-keys-internal":81}],79:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],80:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":42,"./_shared-key":103,"./_to-object":120}],81:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":12,"./_has":42,"./_shared-key":103,"./_to-iobject":118}],82:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":32,"./_object-keys-internal":81}],83:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],84:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":24,"./_export":34,"./_fails":36}],85:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":82,"./_object-pie":83,"./_to-iobject":118}],86:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":8,"./_global":41,"./_object-gopn":78,"./_object-gops":79}],87:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":41,"./_string-trim":112,"./_string-ws":113}],88:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":41,"./_string-trim":112,"./_string-ws":113}],89:[function(require,module,exports){
'use strict';
var path = require('./_path');
var invoke = require('./_invoke');
var aFunction = require('./_a-function');
module.exports = function (/* ...pargs */) {
  var fn = aFunction(this);
  var length = arguments.length;
  var pargs = Array(length);
  var i = 0;
  var _ = path._;
  var holder = false;
  while (length > i) if ((pargs[i] = arguments[i++]) === _) holder = true;
  return function (/* ...args */) {
    var that = this;
    var aLen = arguments.length;
    var j = 0;
    var k = 0;
    var args;
    if (!holder && !aLen) return invoke(fn, pargs, that);
    args = pargs.slice();
    if (holder) for (;length > j; j++) if (args[j] === _) args[j] = arguments[k++];
    while (aLen > k) args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};

},{"./_a-function":4,"./_invoke":47,"./_path":90}],90:[function(require,module,exports){
module.exports = require('./_global');

},{"./_global":41}],91:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],92:[function(require,module,exports){
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_new-promise-capability":70}],93:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],94:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":95}],95:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":24,"./_global":41,"./_has":42,"./_hide":43,"./_uid":125}],96:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],97:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],98:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":4,"./_ctx":26,"./_export":34,"./_for-of":40}],99:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":34}],100:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":8,"./_ctx":26,"./_is-object":52,"./_object-gopd":76}],101:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":30,"./_global":41,"./_object-dp":73,"./_wks":129}],102:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":42,"./_object-dp":73,"./_wks":129}],103:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":104,"./_uid":125}],104:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":41}],105:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":4,"./_an-object":8,"./_wks":129}],106:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":36}],107:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":29,"./_to-integer":117}],108:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":29,"./_is-regexp":53}],109:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":29,"./_export":34,"./_fails":36}],110:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":29,"./_string-repeat":111,"./_to-length":119}],111:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":29,"./_to-integer":117}],112:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":29,"./_export":34,"./_fails":36,"./_string-ws":113}],113:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],114:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":19,"./_ctx":26,"./_dom-create":31,"./_global":41,"./_html":44,"./_invoke":47}],115:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":117}],116:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":117,"./_to-length":119}],117:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],118:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":29,"./_iobject":48}],119:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":117}],120:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":29}],121:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":52}],122:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":7,"./_array-copy-within":9,"./_array-fill":10,"./_array-includes":12,"./_array-methods":13,"./_classof":18,"./_ctx":26,"./_descriptors":30,"./_export":34,"./_fails":36,"./_global":41,"./_has":42,"./_hide":43,"./_is-array-iter":49,"./_is-object":52,"./_iter-detect":57,"./_iterators":59,"./_library":61,"./_object-create":72,"./_object-dp":73,"./_object-gopd":76,"./_object-gopn":78,"./_object-gpo":80,"./_property-desc":93,"./_redefine-all":94,"./_set-species":101,"./_species-constructor":105,"./_to-absolute-index":115,"./_to-index":116,"./_to-integer":117,"./_to-length":119,"./_to-object":120,"./_to-primitive":121,"./_typed":124,"./_typed-buffer":123,"./_uid":125,"./_wks":129,"./core.get-iterator-method":130,"./es6.array.iterator":142}],123:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":7,"./_array-fill":10,"./_descriptors":30,"./_fails":36,"./_global":41,"./_hide":43,"./_library":61,"./_object-dp":73,"./_object-gopn":78,"./_redefine-all":94,"./_set-to-string-tag":102,"./_to-index":116,"./_to-integer":117,"./_to-length":119,"./_typed":124}],124:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":41,"./_hide":43,"./_uid":125}],125:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],126:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":52}],127:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":24,"./_global":41,"./_library":61,"./_object-dp":73,"./_wks-ext":128}],128:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":129}],129:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":41,"./_shared":104,"./_uid":125}],130:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":18,"./_core":24,"./_iterators":59,"./_wks":129}],131:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":34,"./_replacer":96}],132:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":6,"./_array-copy-within":9,"./_export":34}],133:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":106}],134:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":6,"./_array-fill":10,"./_export":34}],135:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":106}],136:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":6,"./_array-methods":13,"./_export":34}],137:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":6,"./_array-methods":13,"./_export":34}],138:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":106}],139:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":25,"./_ctx":26,"./_export":34,"./_is-array-iter":49,"./_iter-call":54,"./_iter-detect":57,"./_to-length":119,"./_to-object":120,"./core.get-iterator-method":130}],140:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":12,"./_export":34,"./_strict-method":106}],141:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":34,"./_is-array":50}],142:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":6,"./_iter-define":56,"./_iter-step":58,"./_iterators":59,"./_to-iobject":118}],143:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":34,"./_iobject":48,"./_strict-method":106,"./_to-iobject":118}],144:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":34,"./_strict-method":106,"./_to-integer":117,"./_to-iobject":118,"./_to-length":119}],145:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":106}],146:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":25,"./_export":34,"./_fails":36}],147:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":14,"./_export":34,"./_strict-method":106}],148:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":14,"./_export":34,"./_strict-method":106}],149:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":19,"./_export":34,"./_fails":36,"./_html":44,"./_to-absolute-index":115,"./_to-length":119}],150:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":106}],151:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":4,"./_export":34,"./_fails":36,"./_strict-method":106,"./_to-object":120}],152:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":101}],153:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":34}],154:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":27,"./_export":34}],155:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":34,"./_fails":36,"./_to-object":120,"./_to-primitive":121}],156:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":28,"./_hide":43,"./_wks":129}],157:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":95}],158:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":17,"./_export":34}],159:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":52,"./_object-dp":73,"./_object-gpo":80,"./_wks":129}],160:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":30,"./_object-dp":73}],161:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":23,"./_collection-strong":20,"./_validate-collection":126}],162:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":34,"./_math-log1p":64}],163:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":34}],164:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":34}],165:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":34,"./_math-sign":66}],166:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":34}],167:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":34}],168:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":34,"./_math-expm1":62}],169:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":34,"./_math-fround":63}],170:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":34}],171:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":34,"./_fails":36}],172:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":34}],173:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":34,"./_math-log1p":64}],174:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":34}],175:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":34,"./_math-sign":66}],176:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":34,"./_fails":36,"./_math-expm1":62}],177:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":34,"./_math-expm1":62}],178:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":34}],179:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":19,"./_descriptors":30,"./_fails":36,"./_global":41,"./_has":42,"./_inherit-if-required":46,"./_object-create":72,"./_object-dp":73,"./_object-gopd":76,"./_object-gopn":78,"./_redefine":95,"./_string-trim":112,"./_to-primitive":121}],180:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":34}],181:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":34,"./_global":41}],182:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":34,"./_is-integer":51}],183:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":34}],184:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":34,"./_is-integer":51}],185:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":34}],186:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":34}],187:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":34,"./_parse-float":87}],188:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":34,"./_parse-int":88}],189:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":5,"./_export":34,"./_fails":36,"./_string-repeat":111,"./_to-integer":117}],190:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":5,"./_export":34,"./_fails":36}],191:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":34,"./_object-assign":71}],192:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":34,"./_object-create":72}],193:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":30,"./_export":34,"./_object-dps":74}],194:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":30,"./_export":34,"./_object-dp":73}],195:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":52,"./_meta":67,"./_object-sap":84}],196:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":76,"./_object-sap":84,"./_to-iobject":118}],197:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":77,"./_object-sap":84}],198:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":80,"./_object-sap":84,"./_to-object":120}],199:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":52,"./_object-sap":84}],200:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":52,"./_object-sap":84}],201:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":52,"./_object-sap":84}],202:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":34,"./_same-value":97}],203:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":82,"./_object-sap":84,"./_to-object":120}],204:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":52,"./_meta":67,"./_object-sap":84}],205:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":52,"./_meta":67,"./_object-sap":84}],206:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":34,"./_set-proto":100}],207:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":18,"./_redefine":95,"./_wks":129}],208:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":34,"./_parse-float":87}],209:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":34,"./_parse-int":88}],210:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var sameConstructor = LIBRARY ? function (a, b) {
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
} : function (a, b) {
  return a === b;
};
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return sameConstructor($Promise, C)
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
    return promiseResolve(this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":4,"./_an-instance":7,"./_classof":18,"./_core":24,"./_ctx":26,"./_export":34,"./_for-of":40,"./_global":41,"./_is-object":52,"./_iter-detect":57,"./_library":61,"./_microtask":69,"./_new-promise-capability":70,"./_perform":91,"./_promise-resolve":92,"./_redefine-all":94,"./_set-species":101,"./_set-to-string-tag":102,"./_species-constructor":105,"./_task":114,"./_wks":129}],211:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":4,"./_an-object":8,"./_export":34,"./_fails":36,"./_global":41}],212:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":4,"./_an-object":8,"./_bind":17,"./_export":34,"./_fails":36,"./_global":41,"./_is-object":52,"./_object-create":72}],213:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":8,"./_export":34,"./_fails":36,"./_object-dp":73,"./_to-primitive":121}],214:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":8,"./_export":34,"./_object-gopd":76}],215:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":8,"./_export":34,"./_iter-create":55}],216:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":8,"./_export":34,"./_object-gopd":76}],217:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":8,"./_export":34,"./_object-gpo":80}],218:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":8,"./_export":34,"./_has":42,"./_is-object":52,"./_object-gopd":76,"./_object-gpo":80}],219:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":34}],220:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":8,"./_export":34}],221:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":34,"./_own-keys":86}],222:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":8,"./_export":34}],223:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":34,"./_set-proto":100}],224:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":8,"./_export":34,"./_has":42,"./_is-object":52,"./_object-dp":73,"./_object-gopd":76,"./_object-gpo":80,"./_property-desc":93}],225:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":30,"./_fails":36,"./_flags":38,"./_global":41,"./_inherit-if-required":46,"./_is-regexp":53,"./_object-dp":73,"./_object-gopn":78,"./_redefine":95,"./_set-species":101,"./_wks":129}],226:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":30,"./_flags":38,"./_object-dp":73}],227:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":37}],228:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":37}],229:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":37}],230:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":37,"./_is-regexp":53}],231:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":8,"./_descriptors":30,"./_fails":36,"./_flags":38,"./_redefine":95,"./es6.regexp.flags":226}],232:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":23,"./_collection-strong":20,"./_validate-collection":126}],233:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":109}],234:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":109}],235:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":109}],236:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":109}],237:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":34,"./_string-at":107}],238:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":34,"./_fails-is-regexp":35,"./_string-context":108,"./_to-length":119}],239:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":109}],240:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":109}],241:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":109}],242:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":34,"./_to-absolute-index":115}],243:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":34,"./_fails-is-regexp":35,"./_string-context":108}],244:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":109}],245:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":56,"./_string-at":107}],246:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":109}],247:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":34,"./_to-iobject":118,"./_to-length":119}],248:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":34,"./_string-repeat":111}],249:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":109}],250:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":34,"./_fails-is-regexp":35,"./_string-context":108,"./_to-length":119}],251:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":109}],252:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":109}],253:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":109}],254:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":112}],255:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var keyOf = require('./_keyof');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key) {
    if (isSymbol(key)) return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":8,"./_descriptors":30,"./_enum-keys":33,"./_export":34,"./_fails":36,"./_global":41,"./_has":42,"./_hide":43,"./_is-array":50,"./_keyof":60,"./_library":61,"./_meta":67,"./_object-create":72,"./_object-dp":73,"./_object-gopd":76,"./_object-gopn":78,"./_object-gopn-ext":77,"./_object-gops":79,"./_object-keys":82,"./_object-pie":83,"./_property-desc":93,"./_redefine":95,"./_set-to-string-tag":102,"./_shared":104,"./_to-iobject":118,"./_to-primitive":121,"./_uid":125,"./_wks":129,"./_wks-define":127,"./_wks-ext":128}],256:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":8,"./_export":34,"./_fails":36,"./_global":41,"./_is-object":52,"./_set-species":101,"./_species-constructor":105,"./_to-absolute-index":115,"./_to-length":119,"./_typed":124,"./_typed-buffer":123}],257:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":34,"./_typed":124,"./_typed-buffer":123}],258:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],259:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],260:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],261:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],262:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],263:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],264:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],265:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":122}],266:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":122}],267:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":13,"./_collection":23,"./_collection-weak":22,"./_fails":36,"./_is-object":52,"./_meta":67,"./_object-assign":71,"./_redefine":95,"./_validate-collection":126}],268:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":23,"./_collection-weak":22,"./_validate-collection":126}],269:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":4,"./_add-to-unscopables":6,"./_array-species-create":16,"./_export":34,"./_flatten-into-array":39,"./_to-length":119,"./_to-object":120}],270:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":6,"./_array-species-create":16,"./_export":34,"./_flatten-into-array":39,"./_to-integer":117,"./_to-length":119,"./_to-object":120}],271:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":6,"./_array-includes":12,"./_export":34}],272:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":19,"./_export":34,"./_global":41,"./_microtask":69}],273:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":19,"./_export":34}],274:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":34,"./_global":41}],275:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":98}],276:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":99}],277:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":21,"./_export":34}],278:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":34}],279:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":34}],280:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":34}],281:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":34,"./_math-fround":63,"./_math-scale":65}],282:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":34}],283:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":34}],284:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":34}],285:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":34}],286:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":34}],287:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":34,"./_math-scale":65}],288:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":34}],289:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":34}],290:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":4,"./_descriptors":30,"./_export":34,"./_object-dp":73,"./_object-forced-pam":75,"./_to-object":120}],291:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":4,"./_descriptors":30,"./_export":34,"./_object-dp":73,"./_object-forced-pam":75,"./_to-object":120}],292:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":34,"./_object-to-array":85}],293:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":25,"./_export":34,"./_object-gopd":76,"./_own-keys":86,"./_to-iobject":118}],294:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":30,"./_export":34,"./_object-forced-pam":75,"./_object-gopd":76,"./_object-gpo":80,"./_to-object":120,"./_to-primitive":121}],295:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":30,"./_export":34,"./_object-forced-pam":75,"./_object-gopd":76,"./_object-gpo":80,"./_to-object":120,"./_to-primitive":121}],296:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":34,"./_object-to-array":85}],297:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":4,"./_an-instance":7,"./_an-object":8,"./_core":24,"./_export":34,"./_for-of":40,"./_global":41,"./_hide":43,"./_microtask":69,"./_redefine-all":94,"./_set-species":101,"./_wks":129}],298:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":24,"./_export":34,"./_global":41,"./_promise-resolve":92,"./_species-constructor":105}],299:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":34,"./_new-promise-capability":70,"./_perform":91}],300:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":8,"./_metadata":68}],301:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":8,"./_metadata":68}],302:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":8,"./_array-from-iterable":11,"./_metadata":68,"./_object-gpo":80,"./es6.set":232}],303:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":68,"./_object-gpo":80}],304:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":8,"./_metadata":68}],305:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":68}],306:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":68,"./_object-gpo":80}],307:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":68}],308:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":4,"./_an-object":8,"./_metadata":68}],309:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":98}],310:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":99}],311:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":21,"./_export":34}],312:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":34,"./_string-at":107}],313:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":29,"./_export":34,"./_flags":38,"./_is-regexp":53,"./_iter-create":55,"./_to-length":119}],314:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":34,"./_string-pad":110}],315:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":34,"./_string-pad":110}],316:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":112}],317:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":112}],318:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":127}],319:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":127}],320:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":34,"./_global":41}],321:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":98}],322:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":99}],323:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":98}],324:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":99}],325:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":41,"./_hide":43,"./_iterators":59,"./_object-keys":82,"./_redefine":95,"./_wks":129,"./es6.array.iterator":142}],326:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":34,"./_task":114}],327:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var invoke = require('./_invoke');
var partial = require('./_partial');
var navigator = global.navigator;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return MSIE ? function (fn, time /* , ...args */) {
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      // eslint-disable-next-line no-new-func
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":34,"./_global":41,"./_invoke":47,"./_partial":89}],328:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":24,"./modules/es6.array.copy-within":132,"./modules/es6.array.every":133,"./modules/es6.array.fill":134,"./modules/es6.array.filter":135,"./modules/es6.array.find":137,"./modules/es6.array.find-index":136,"./modules/es6.array.for-each":138,"./modules/es6.array.from":139,"./modules/es6.array.index-of":140,"./modules/es6.array.is-array":141,"./modules/es6.array.iterator":142,"./modules/es6.array.join":143,"./modules/es6.array.last-index-of":144,"./modules/es6.array.map":145,"./modules/es6.array.of":146,"./modules/es6.array.reduce":148,"./modules/es6.array.reduce-right":147,"./modules/es6.array.slice":149,"./modules/es6.array.some":150,"./modules/es6.array.sort":151,"./modules/es6.array.species":152,"./modules/es6.date.now":153,"./modules/es6.date.to-iso-string":154,"./modules/es6.date.to-json":155,"./modules/es6.date.to-primitive":156,"./modules/es6.date.to-string":157,"./modules/es6.function.bind":158,"./modules/es6.function.has-instance":159,"./modules/es6.function.name":160,"./modules/es6.map":161,"./modules/es6.math.acosh":162,"./modules/es6.math.asinh":163,"./modules/es6.math.atanh":164,"./modules/es6.math.cbrt":165,"./modules/es6.math.clz32":166,"./modules/es6.math.cosh":167,"./modules/es6.math.expm1":168,"./modules/es6.math.fround":169,"./modules/es6.math.hypot":170,"./modules/es6.math.imul":171,"./modules/es6.math.log10":172,"./modules/es6.math.log1p":173,"./modules/es6.math.log2":174,"./modules/es6.math.sign":175,"./modules/es6.math.sinh":176,"./modules/es6.math.tanh":177,"./modules/es6.math.trunc":178,"./modules/es6.number.constructor":179,"./modules/es6.number.epsilon":180,"./modules/es6.number.is-finite":181,"./modules/es6.number.is-integer":182,"./modules/es6.number.is-nan":183,"./modules/es6.number.is-safe-integer":184,"./modules/es6.number.max-safe-integer":185,"./modules/es6.number.min-safe-integer":186,"./modules/es6.number.parse-float":187,"./modules/es6.number.parse-int":188,"./modules/es6.number.to-fixed":189,"./modules/es6.number.to-precision":190,"./modules/es6.object.assign":191,"./modules/es6.object.create":192,"./modules/es6.object.define-properties":193,"./modules/es6.object.define-property":194,"./modules/es6.object.freeze":195,"./modules/es6.object.get-own-property-descriptor":196,"./modules/es6.object.get-own-property-names":197,"./modules/es6.object.get-prototype-of":198,"./modules/es6.object.is":202,"./modules/es6.object.is-extensible":199,"./modules/es6.object.is-frozen":200,"./modules/es6.object.is-sealed":201,"./modules/es6.object.keys":203,"./modules/es6.object.prevent-extensions":204,"./modules/es6.object.seal":205,"./modules/es6.object.set-prototype-of":206,"./modules/es6.object.to-string":207,"./modules/es6.parse-float":208,"./modules/es6.parse-int":209,"./modules/es6.promise":210,"./modules/es6.reflect.apply":211,"./modules/es6.reflect.construct":212,"./modules/es6.reflect.define-property":213,"./modules/es6.reflect.delete-property":214,"./modules/es6.reflect.enumerate":215,"./modules/es6.reflect.get":218,"./modules/es6.reflect.get-own-property-descriptor":216,"./modules/es6.reflect.get-prototype-of":217,"./modules/es6.reflect.has":219,"./modules/es6.reflect.is-extensible":220,"./modules/es6.reflect.own-keys":221,"./modules/es6.reflect.prevent-extensions":222,"./modules/es6.reflect.set":224,"./modules/es6.reflect.set-prototype-of":223,"./modules/es6.regexp.constructor":225,"./modules/es6.regexp.flags":226,"./modules/es6.regexp.match":227,"./modules/es6.regexp.replace":228,"./modules/es6.regexp.search":229,"./modules/es6.regexp.split":230,"./modules/es6.regexp.to-string":231,"./modules/es6.set":232,"./modules/es6.string.anchor":233,"./modules/es6.string.big":234,"./modules/es6.string.blink":235,"./modules/es6.string.bold":236,"./modules/es6.string.code-point-at":237,"./modules/es6.string.ends-with":238,"./modules/es6.string.fixed":239,"./modules/es6.string.fontcolor":240,"./modules/es6.string.fontsize":241,"./modules/es6.string.from-code-point":242,"./modules/es6.string.includes":243,"./modules/es6.string.italics":244,"./modules/es6.string.iterator":245,"./modules/es6.string.link":246,"./modules/es6.string.raw":247,"./modules/es6.string.repeat":248,"./modules/es6.string.small":249,"./modules/es6.string.starts-with":250,"./modules/es6.string.strike":251,"./modules/es6.string.sub":252,"./modules/es6.string.sup":253,"./modules/es6.string.trim":254,"./modules/es6.symbol":255,"./modules/es6.typed.array-buffer":256,"./modules/es6.typed.data-view":257,"./modules/es6.typed.float32-array":258,"./modules/es6.typed.float64-array":259,"./modules/es6.typed.int16-array":260,"./modules/es6.typed.int32-array":261,"./modules/es6.typed.int8-array":262,"./modules/es6.typed.uint16-array":263,"./modules/es6.typed.uint32-array":264,"./modules/es6.typed.uint8-array":265,"./modules/es6.typed.uint8-clamped-array":266,"./modules/es6.weak-map":267,"./modules/es6.weak-set":268,"./modules/es7.array.flat-map":269,"./modules/es7.array.flatten":270,"./modules/es7.array.includes":271,"./modules/es7.asap":272,"./modules/es7.error.is-error":273,"./modules/es7.global":274,"./modules/es7.map.from":275,"./modules/es7.map.of":276,"./modules/es7.map.to-json":277,"./modules/es7.math.clamp":278,"./modules/es7.math.deg-per-rad":279,"./modules/es7.math.degrees":280,"./modules/es7.math.fscale":281,"./modules/es7.math.iaddh":282,"./modules/es7.math.imulh":283,"./modules/es7.math.isubh":284,"./modules/es7.math.rad-per-deg":285,"./modules/es7.math.radians":286,"./modules/es7.math.scale":287,"./modules/es7.math.signbit":288,"./modules/es7.math.umulh":289,"./modules/es7.object.define-getter":290,"./modules/es7.object.define-setter":291,"./modules/es7.object.entries":292,"./modules/es7.object.get-own-property-descriptors":293,"./modules/es7.object.lookup-getter":294,"./modules/es7.object.lookup-setter":295,"./modules/es7.object.values":296,"./modules/es7.observable":297,"./modules/es7.promise.finally":298,"./modules/es7.promise.try":299,"./modules/es7.reflect.define-metadata":300,"./modules/es7.reflect.delete-metadata":301,"./modules/es7.reflect.get-metadata":303,"./modules/es7.reflect.get-metadata-keys":302,"./modules/es7.reflect.get-own-metadata":305,"./modules/es7.reflect.get-own-metadata-keys":304,"./modules/es7.reflect.has-metadata":306,"./modules/es7.reflect.has-own-metadata":307,"./modules/es7.reflect.metadata":308,"./modules/es7.set.from":309,"./modules/es7.set.of":310,"./modules/es7.set.to-json":311,"./modules/es7.string.at":312,"./modules/es7.string.match-all":313,"./modules/es7.string.pad-end":314,"./modules/es7.string.pad-start":315,"./modules/es7.string.trim-left":316,"./modules/es7.string.trim-right":317,"./modules/es7.symbol.async-iterator":318,"./modules/es7.symbol.observable":319,"./modules/es7.system.global":320,"./modules/es7.weak-map.from":321,"./modules/es7.weak-map.of":322,"./modules/es7.weak-set.from":323,"./modules/es7.weak-set.of":324,"./modules/web.dom.iterable":325,"./modules/web.immediate":326,"./modules/web.timers":327}],329:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var foreach = require('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":343,"object-keys":357}],330:[function(require,module,exports){
'use strict';

var has = require('has');

var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;

var $isNaN = require('./helpers/isNaN');
var $isFinite = require('./helpers/isFinite');
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var assign = require('./helpers/assign');
var sign = require('./helpers/sign');
var mod = require('./helpers/mod');
var isPrimitive = require('./helpers/isPrimitive');
var toPrimitive = require('es-to-primitive/es6');
var parseInteger = parseInt;
var bind = require('function-bind');
var arraySlice = bind.call(Function.call, Array.prototype.slice);
var strSlice = bind.call(Function.call, String.prototype.slice);
var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
var regexExec = bind.call(Function.call, RegExp.prototype.exec);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);

// whitespace from: http://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var replace = bind.call(Function.call, String.prototype.replace);
var trim = function (value) {
	return replace(value, trimRegex, '');
};

var ES5 = require('./es5');

var hasRegExpMatcher = require('is-regex');

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
var ES6 = assign(assign({}, ES5), {

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	Call: function Call(F, V) {
		var args = arguments.length > 2 ? arguments[2] : [];
		if (!this.IsCallable(F)) {
			throw new TypeError(F + ' is not a function');
		}
		return F.apply(V, args);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
	ToPrimitive: toPrimitive,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
	// ToBoolean: ES5.ToBoolean,

	// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
	ToNumber: function ToNumber(argument) {
		var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
		if (typeof value === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a number');
		}
		if (typeof value === 'string') {
			if (isBinary(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 2));
			} else if (isOctal(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 8));
			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
				return NaN;
			} else {
				var trimmed = trim(value);
				if (trimmed !== value) {
					return this.ToNumber(trimmed);
				}
			}
		}
		return Number(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
	// ToInteger: ES5.ToNumber,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
	// ToInt32: ES5.ToInt32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
	// ToUint32: ES5.ToUint32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
	ToInt16: function ToInt16(argument) {
		var int16bit = this.ToUint16(argument);
		return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
	// ToUint16: ES5.ToUint16,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
	ToInt8: function ToInt8(argument) {
		var int8bit = this.ToUint8(argument);
		return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
	ToUint8: function ToUint8(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x100);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
	ToUint8Clamp: function ToUint8Clamp(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number <= 0) { return 0; }
		if (number >= 0xFF) { return 0xFF; }
		var f = Math.floor(argument);
		if (f + 0.5 < number) { return f + 1; }
		if (number < f + 0.5) { return f; }
		if (f % 2 !== 0) { return f + 1; }
		return f;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
	ToString: function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a string');
		}
		return String(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
	ToObject: function ToObject(value) {
		this.RequireObjectCoercible(value);
		return Object(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
	ToPropertyKey: function ToPropertyKey(argument) {
		var key = this.ToPrimitive(argument, String);
		return typeof key === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	ToLength: function ToLength(argument) {
		var len = this.ToInteger(argument);
		if (len <= 0) { return 0; } // includes converting -0 to +0
		if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
		return len;
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
	CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
		if (toStr.call(argument) !== '[object String]') {
			throw new TypeError('must be a string');
		}
		if (argument === '-0') { return -0; }
		var n = this.ToNumber(argument);
		if (this.SameValue(this.ToString(n), argument)) { return n; }
		return void 0;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
	RequireObjectCoercible: ES5.CheckObjectCoercible,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
	IsArray: Array.isArray || function IsArray(argument) {
		return toStr.call(argument) === '[object Array]';
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
	// IsCallable: ES5.IsCallable,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
	IsConstructor: function IsConstructor(argument) {
		return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
	IsExtensible: function IsExtensible(obj) {
		if (!Object.preventExtensions) { return true; }
		if (isPrimitive(obj)) {
			return false;
		}
		return Object.isExtensible(obj);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
	IsInteger: function IsInteger(argument) {
		if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
			return false;
		}
		var abs = Math.abs(argument);
		return Math.floor(abs) === abs;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
	IsPropertyKey: function IsPropertyKey(argument) {
		return typeof argument === 'string' || typeof argument === 'symbol';
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
	IsRegExp: function IsRegExp(argument) {
		if (!argument || typeof argument !== 'object') {
			return false;
		}
		if (hasSymbols) {
			var isRegExp = argument[Symbol.match];
			if (typeof isRegExp !== 'undefined') {
				return ES5.ToBoolean(isRegExp);
			}
		}
		return hasRegExpMatcher(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
	// SameValue: ES5.SameValue,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
	SameValueZero: function SameValueZero(x, y) {
		return (x === y) || ($isNaN(x) && $isNaN(y));
	},

	/**
	 * 7.3.2 GetV (V, P)
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let O be ToObject(V).
	 * 3. ReturnIfAbrupt(O).
	 * 4. Return O.[[Get]](P, V).
	 */
	GetV: function GetV(V, P) {
		// 7.3.2.1
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.2.2-3
		var O = this.ToObject(V);

		// 7.3.2.4
		return O[P];
	},

	/**
	 * 7.3.9 - http://www.ecma-international.org/ecma-262/6.0/#sec-getmethod
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let func be GetV(O, P).
	 * 3. ReturnIfAbrupt(func).
	 * 4. If func is either undefined or null, return undefined.
	 * 5. If IsCallable(func) is false, throw a TypeError exception.
	 * 6. Return func.
	 */
	GetMethod: function GetMethod(O, P) {
		// 7.3.9.1
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.9.2
		var func = this.GetV(O, P);

		// 7.3.9.4
		if (func == null) {
			return undefined;
		}

		// 7.3.9.5
		if (!this.IsCallable(func)) {
			throw new TypeError(P + 'is not a function');
		}

		// 7.3.9.6
		return func;
	},

	/**
	 * 7.3.1 Get (O, P) - http://www.ecma-international.org/ecma-262/6.0/#sec-get-o-p
	 * 1. Assert: Type(O) is Object.
	 * 2. Assert: IsPropertyKey(P) is true.
	 * 3. Return O.[[Get]](P, O).
	 */
	Get: function Get(O, P) {
		// 7.3.1.1
		if (this.Type(O) !== 'Object') {
			throw new TypeError('Assertion failed: Type(O) is not Object');
		}
		// 7.3.1.2
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}
		// 7.3.1.3
		return O[P];
	},

	Type: function Type(x) {
		if (typeof x === 'symbol') {
			return 'Symbol';
		}
		return ES5.Type(x);
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
	SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
		if (this.Type(O) !== 'Object') {
			throw new TypeError('Assertion failed: Type(O) is not Object');
		}
		var C = O.constructor;
		if (typeof C === 'undefined') {
			return defaultConstructor;
		}
		if (this.Type(C) !== 'Object') {
			throw new TypeError('O.constructor is not an Object');
		}
		var S = hasSymbols && Symbol.species ? C[Symbol.species] : undefined;
		if (S == null) {
			return defaultConstructor;
		}
		if (this.IsConstructor(S)) {
			return S;
		}
		throw new TypeError('no constructor found');
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-completepropertydescriptor
	CompletePropertyDescriptor: function CompletePropertyDescriptor(Desc) {
		if (!this.IsPropertyDescriptor(Desc)) {
			throw new TypeError('Desc must be a Property Descriptor');
		}

		if (this.IsGenericDescriptor(Desc) || this.IsDataDescriptor(Desc)) {
			if (!has(Desc, '[[Value]]')) {
				Desc['[[Value]]'] = void 0;
			}
			if (!has(Desc, '[[Writable]]')) {
				Desc['[[Writable]]'] = false;
			}
		} else {
			if (!has(Desc, '[[Get]]')) {
				Desc['[[Get]]'] = void 0;
			}
			if (!has(Desc, '[[Set]]')) {
				Desc['[[Set]]'] = void 0;
			}
		}
		if (!has(Desc, '[[Enumerable]]')) {
			Desc['[[Enumerable]]'] = false;
		}
		if (!has(Desc, '[[Configurable]]')) {
			Desc['[[Configurable]]'] = false;
		}
		return Desc;
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw
	Set: function Set(O, P, V, Throw) {
		if (this.Type(O) !== 'Object') {
			throw new TypeError('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('P must be a Property Key');
		}
		if (this.Type(Throw) !== 'Boolean') {
			throw new TypeError('Throw must be a Boolean');
		}
		if (Throw) {
			O[P] = V;
			return true;
		} else {
			try {
				O[P] = V;
			} catch (e) {
				return false;
			}
		}
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-hasownproperty
	HasOwnProperty: function HasOwnProperty(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new TypeError('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('P must be a Property Key');
		}
		return has(O, P);
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-hasproperty
	HasProperty: function HasProperty(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new TypeError('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('P must be a Property Key');
		}
		return P in O;
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
	IsConcatSpreadable: function IsConcatSpreadable(O) {
		if (this.Type(O) !== 'Object') {
			return false;
		}
		if (hasSymbols && typeof Symbol.isConcatSpreadable === 'symbol') {
			var spreadable = this.Get(O, Symbol.isConcatSpreadable);
			if (typeof spreadable !== 'undefined') {
				return this.ToBoolean(spreadable);
			}
		}
		return this.IsArray(O);
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-invoke
	Invoke: function Invoke(O, P) {
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('P must be a Property Key');
		}
		var argumentsList = arraySlice(arguments, 2);
		var func = this.GetV(O, P);
		return this.Call(func, O, argumentsList);
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject
	CreateIterResultObject: function CreateIterResultObject(value, done) {
		if (this.Type(done) !== 'Boolean') {
			throw new TypeError('Assertion failed: Type(done) is not Boolean');
		}
		return {
			value: value,
			done: done
		};
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-regexpexec
	RegExpExec: function RegExpExec(R, S) {
		if (this.Type(R) !== 'Object') {
			throw new TypeError('R must be an Object');
		}
		if (this.Type(S) !== 'String') {
			throw new TypeError('S must be a String');
		}
		var exec = this.Get(R, 'exec');
		if (this.IsCallable(exec)) {
			var result = this.Call(exec, R, [S]);
			if (result === null || this.Type(result) === 'Object') {
				return result;
			}
			throw new TypeError('"exec" method must return `null` or an Object');
		}
		return regexExec(R, S);
	}
});

delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

module.exports = ES6;

},{"./es5":332,"./helpers/assign":334,"./helpers/isFinite":335,"./helpers/isNaN":336,"./helpers/isPrimitive":337,"./helpers/mod":338,"./helpers/sign":339,"es-to-primitive/es6":341,"function-bind":348,"has":349,"is-regex":352}],331:[function(require,module,exports){
'use strict';

var ES2015 = require('./es2015');
var assign = require('./helpers/assign');

var ES2016 = assign(assign({}, ES2015), {
	// https://github.com/tc39/ecma262/pull/60
	SameValueNonNumber: function SameValueNonNumber(x, y) {
		if (typeof x === 'number' || typeof x !== typeof y) {
			throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
		}
		return this.SameValue(x, y);
	}
});

module.exports = ES2016;

},{"./es2015":330,"./helpers/assign":334}],332:[function(require,module,exports){
'use strict';

var $isNaN = require('./helpers/isNaN');
var $isFinite = require('./helpers/isFinite');

var sign = require('./helpers/sign');
var mod = require('./helpers/mod');

var IsCallable = require('is-callable');
var toPrimitive = require('es-to-primitive/es5');

var has = require('has');

// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: toPrimitive,

	ToBoolean: function ToBoolean(value) {
		return !!value;
	},
	ToNumber: function ToNumber(value) {
		return Number(value);
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number)) { return 0; }
		if (number === 0 || !$isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new TypeError(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: IsCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
		return $isNaN(x) && $isNaN(y);
	},

	// http://www.ecma-international.org/ecma-262/5.1/#sec-8
	Type: function Type(x) {
		if (x === null) {
			return 'Null';
		}
		if (typeof x === 'undefined') {
			return 'Undefined';
		}
		if (typeof x === 'function' || typeof x === 'object') {
			return 'Object';
		}
		if (typeof x === 'number') {
			return 'Number';
		}
		if (typeof x === 'boolean') {
			return 'Boolean';
		}
		if (typeof x === 'string') {
			return 'String';
		}
	},

	// http://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
	IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
		if (this.Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};
		// jscs:disable
		for (var key in Desc) { // eslint-disable-line
			if (has(Desc, key) && !allowed[key]) {
				return false;
			}
		}
		// jscs:enable
		var isData = has(Desc, '[[Value]]');
		var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new TypeError('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	},

	// http://ecma-international.org/ecma-262/5.1/#sec-8.10.1
	IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new TypeError('Desc must be a Property Descriptor');
		}

		if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
			return false;
		}

		return true;
	},

	// http://ecma-international.org/ecma-262/5.1/#sec-8.10.2
	IsDataDescriptor: function IsDataDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new TypeError('Desc must be a Property Descriptor');
		}

		if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
			return false;
		}

		return true;
	},

	// http://ecma-international.org/ecma-262/5.1/#sec-8.10.3
	IsGenericDescriptor: function IsGenericDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new TypeError('Desc must be a Property Descriptor');
		}

		if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
			return true;
		}

		return false;
	},

	// http://ecma-international.org/ecma-262/5.1/#sec-8.10.4
	FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return Desc;
		}

		if (!this.IsPropertyDescriptor(Desc)) {
			throw new TypeError('Desc must be a Property Descriptor');
		}

		if (this.IsDataDescriptor(Desc)) {
			return {
				value: Desc['[[Value]]'],
				writable: !!Desc['[[Writable]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else if (this.IsAccessorDescriptor(Desc)) {
			return {
				get: Desc['[[Get]]'],
				set: Desc['[[Set]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else {
			throw new TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
		}
	},

	// http://ecma-international.org/ecma-262/5.1/#sec-8.10.5
	ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
		if (this.Type(Obj) !== 'Object') {
			throw new TypeError('ToPropertyDescriptor requires an object');
		}

		var desc = {};
		if (has(Obj, 'enumerable')) {
			desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
		}
		if (has(Obj, 'configurable')) {
			desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
		}
		if (has(Obj, 'value')) {
			desc['[[Value]]'] = Obj.value;
		}
		if (has(Obj, 'writable')) {
			desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
		}
		if (has(Obj, 'get')) {
			var getter = Obj.get;
			if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
				throw new TypeError('getter must be a function');
			}
			desc['[[Get]]'] = getter;
		}
		if (has(Obj, 'set')) {
			var setter = Obj.set;
			if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
				throw new TypeError('setter must be a function');
			}
			desc['[[Set]]'] = setter;
		}

		if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
			throw new TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
		}
		return desc;
	}
};

module.exports = ES5;

},{"./helpers/isFinite":335,"./helpers/isNaN":336,"./helpers/mod":338,"./helpers/sign":339,"es-to-primitive/es5":340,"has":349,"is-callable":350}],333:[function(require,module,exports){
'use strict';

module.exports = require('./es2016');

},{"./es2016":331}],334:[function(require,module,exports){
var has = Object.prototype.hasOwnProperty;
module.exports = function assign(target, source) {
	if (Object.assign) {
		return Object.assign(target, source);
	}
	for (var key in source) {
		if (has.call(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
};

},{}],335:[function(require,module,exports){
var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

},{}],336:[function(require,module,exports){
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};

},{}],337:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],338:[function(require,module,exports){
module.exports = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};

},{}],339:[function(require,module,exports){
module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};

},{}],340:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable');

// https://es5.github.io/#x8.12
var ES5internalSlots = {
	'[[DefaultValue]]': function (O, hint) {
		var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// https://es5.github.io/#x9
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
};

},{"./helpers/isPrimitive":342,"is-callable":350}],341:[function(require,module,exports){
'use strict';

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');
var isCallable = require('is-callable');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (PreferredType === String) {
			hint = 'string';
		} else if (PreferredType === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"./helpers/isPrimitive":342,"is-callable":350,"is-date-object":351,"is-symbol":353}],342:[function(require,module,exports){
arguments[4][337][0].apply(exports,arguments)
},{"dup":337}],343:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],344:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("numeric"), require("numeral"), require("jStat"));
	else if(typeof define === 'function' && define.amd)
		define(["numeric", "numeral", "jStat"], factory);
	else if(typeof exports === 'object')
		exports["formulajs"] = factory(require("numeric"), require("numeral"), require("jStat"));
	else
		root["formulajs"] = factory(root["numeric"], root["numeral"], root["jStat"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var categories = [
	  __webpack_require__(1),
	  __webpack_require__(15),
	  __webpack_require__(12),
	  __webpack_require__(16),
	  __webpack_require__(2),
	  __webpack_require__(7),
	  __webpack_require__(14),
	  __webpack_require__(17),
	  __webpack_require__(11),
	  __webpack_require__(18),
	  __webpack_require__(6),
	  __webpack_require__(10)
	];

	for (var c in categories) {
	  var category = categories[c];
	  for (var f in category) {
	    exports[f] = exports[f] || category[f];
	  }
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var statistical = __webpack_require__(6);
	var engineering = __webpack_require__(12);
	var dateTime = __webpack_require__(14);

	function set(fn, root) {
	  if (root) {
	    for (var i in root) {
	      fn[i] = root[i];
	    }
	  }
	  return fn;
	}

	exports.BETADIST = statistical.BETA.DIST;
	exports.BETAINV = statistical.BETA.INV;
	exports.BINOMDIST = statistical.BINOM.DIST;
	exports.CEILING = exports.ISOCEILING = set(mathTrig.CEILING.MATH, mathTrig.CEILING);
	exports.CEILINGMATH = mathTrig.CEILING.MATH;
	exports.CEILINGPRECISE = mathTrig.CEILING.PRECISE;
	exports.CHIDIST = statistical.CHISQ.DIST;
	exports.CHIDISTRT = statistical.CHISQ.DIST.RT;
	exports.CHIINV = statistical.CHISQ.INV;
	exports.CHIINVRT = statistical.CHISQ.INV.RT;
	exports.CHITEST = statistical.CHISQ.TEST;
	exports.CONFIDENCE = set(statistical.CONFIDENCE.NORM, statistical.CONFIDENCE);
	exports.COVAR = statistical.COVARIANCE.P;
	exports.COVARIANCEP = statistical.COVARIANCE.P;
	exports.COVARIANCES = statistical.COVARIANCE.S;
	exports.CRITBINOM = statistical.BINOM.INV;
	exports.EXPONDIST = statistical.EXPON.DIST;
	exports.ERFCPRECISE = engineering.ERFC.PRECISE;
	exports.ERFPRECISE = engineering.ERF.PRECISE;
	exports.FDIST = statistical.F.DIST;
	exports.FDISTRT = statistical.F.DIST.RT;
	exports.FINVRT = statistical.F.INV.RT;
	exports.FINV = statistical.F.INV;
	exports.FLOOR = set(mathTrig.FLOOR.MATH, mathTrig.FLOOR);
	exports.FLOORMATH = mathTrig.FLOOR.MATH;
	exports.FLOORPRECISE = mathTrig.FLOOR.PRECISE;
	exports.FTEST = statistical.F.TEST;
	exports.GAMMADIST = statistical.GAMMA.DIST;
	exports.GAMMAINV = statistical.GAMMA.INV;
	exports.GAMMALNPRECISE = statistical.GAMMALN.PRECISE;
	exports.HYPGEOMDIST = statistical.HYPGEOM.DIST;
	exports.LOGINV = statistical.LOGNORM.INV;
	exports.LOGNORMINV = statistical.LOGNORM.INV;
	exports.LOGNORMDIST = statistical.LOGNORM.DIST;
	exports.MODE = set(statistical.MODE.SNGL, statistical.MODE);
	exports.MODEMULT = statistical.MODE.MULT;
	exports.MODESNGL = statistical.MODE.SNGL;
	exports.NEGBINOMDIST = statistical.NEGBINOM.DIST;
	exports.NETWORKDAYSINTL = dateTime.NETWORKDAYS.INTL;
	exports.NORMDIST = statistical.NORM.DIST;
	exports.NORMINV = statistical.NORM.INV;
	exports.NORMSDIST = statistical.NORM.S.DIST;
	exports.NORMSINV = statistical.NORM.S.INV;
	exports.PERCENTILE = set(statistical.PERCENTILE.EXC, statistical.PERCENTILE);
	exports.PERCENTILEEXC = statistical.PERCENTILE.EXC;
	exports.PERCENTILEINC = statistical.PERCENTILE.INC;
	exports.PERCENTRANK = set(statistical.PERCENTRANK.INC, statistical.PERCENTRANK);
	exports.PERCENTRANKEXC = statistical.PERCENTRANK.EXC;
	exports.PERCENTRANKINC = statistical.PERCENTRANK.INC;
	exports.POISSON = set(statistical.POISSON.DIST, statistical.POISSON);
	exports.POISSONDIST = statistical.POISSON.DIST;
	exports.QUARTILE = set(statistical.QUARTILE.INC, statistical.QUARTILE);
	exports.QUARTILEEXC = statistical.QUARTILE.EXC;
	exports.QUARTILEINC = statistical.QUARTILE.INC;
	exports.RANK = set(statistical.RANK.EQ, statistical.RANK);
	exports.RANKAVG = statistical.RANK.AVG;
	exports.RANKEQ = statistical.RANK.EQ;
	exports.SKEWP = statistical.SKEW.P;
	exports.STDEV = set(statistical.STDEV.S, statistical.STDEV);
	exports.STDEVP = statistical.STDEV.P;
	exports.STDEVS = statistical.STDEV.S;
	exports.TDIST = statistical.T.DIST;
	exports.TDISTRT = statistical.T.DIST.RT;
	exports.TINV = statistical.T.INV;
	exports.TTEST = statistical.T.TEST;
	exports.VAR = set(statistical.VAR.S, statistical.VAR);
	exports.VARP = statistical.VAR.P;
	exports.VARS = statistical.VAR.S;
	exports.WEIBULL = set(statistical.WEIBULL.DIST, statistical.WEIBULL);
	exports.WEIBULLDIST = statistical.WEIBULL.DIST;
	exports.WORKDAYINTL = dateTime.WORKDAY.INTL;
	exports.ZTEST = statistical.Z.TEST;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var numeric = __webpack_require__(3);
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var statistical = __webpack_require__(6);
	var information = __webpack_require__(11);

	exports.ABS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.abs(utils.parseNumber(number));
	};

	exports.ACOS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.acos(number);
	};

	exports.ACOSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number - 1));
	};

	exports.ACOT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(1 / number);
	};

	exports.ACOTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 0.5 * Math.log((number + 1) / (number - 1));
	};

	//TODO: use options
	exports.AGGREGATE = function(function_num, options, ref1, ref2) {
	  function_num = utils.parseNumber(function_num);
	  options = utils.parseNumber(function_num);
	  if (utils.anyIsError(function_num, options)) {
	    return error.value;
	  }
	  switch (function_num) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	    case 12:
	      return statistical.MEDIAN(ref1);
	    case 13:
	      return statistical.MODE.SNGL(ref1);
	    case 14:
	      return statistical.LARGE(ref1, ref2);
	    case 15:
	      return statistical.SMALL(ref1, ref2);
	    case 16:
	      return statistical.PERCENTILE.INC(ref1, ref2);
	    case 17:
	      return statistical.QUARTILE.INC(ref1, ref2);
	    case 18:
	      return statistical.PERCENTILE.EXC(ref1, ref2);
	    case 19:
	      return statistical.QUARTILE.EXC(ref1, ref2);
	  }
	};

	exports.ARABIC = function(text) {
	  // Credits: Rafa? Kukawski
	  if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
	    return error.value;
	  }
	  var r = 0;
	  text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {
	    r += {
	      M: 1000,
	      CM: 900,
	      D: 500,
	      CD: 400,
	      C: 100,
	      XC: 90,
	      L: 50,
	      XL: 40,
	      X: 10,
	      IX: 9,
	      V: 5,
	      IV: 4,
	      I: 1
	    }[i];
	  });
	  return r;
	};

	exports.ASIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.asin(number);
	};

	exports.ASINH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number + 1));
	};

	exports.ATAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(number);
	};

	exports.ATAN2 = function(number_x, number_y) {
	  number_x = utils.parseNumber(number_x);
	  number_y = utils.parseNumber(number_y);
	  if (utils.anyIsError(number_x, number_y)) {
	    return error.value;
	  }
	  return Math.atan2(number_x, number_y);
	};

	exports.ATANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log((1 + number) / (1 - number)) / 2;
	};

	exports.BASE = function(number, radix, min_length) {
	  min_length = min_length || 0;

	  number = utils.parseNumber(number);
	  radix = utils.parseNumber(radix);
	  min_length = utils.parseNumber(min_length);
	  if (utils.anyIsError(number, radix, min_length)) {
	    return error.value;
	  }
	  min_length = (min_length === undefined) ? 0 : min_length;
	  var result = number.toString(radix);
	  return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;
	};

	exports.CEILING = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : Math.abs(significance);
	  mode = mode || 0;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.ceil(number / significance) * significance, precision);
	  } else {
	    if (mode === 0) {
	      return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	    } else {
	      return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	    }
	  }
	};

	exports.CEILING.MATH = exports.CEILING;

	exports.CEILING.PRECISE = exports.CEILING;

	exports.COMBIN = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));
	};

	exports.COMBINA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return (number === 0 && number_chosen === 0) ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);
	};

	exports.COS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.cos(number);
	};

	exports.COSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return (Math.exp(number) + Math.exp(-number)) / 2;
	};

	exports.COT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.tan(number);
	};

	exports.COTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 + 1) / (e2 - 1);
	};

	exports.CSC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.sin(number);
	};

	exports.CSCH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) - Math.exp(-number));
	};

	exports.DECIMAL = function(number, radix) {
	  if (arguments.length < 1) {
	    return error.value;
	  }


	  return parseInt(number, radix);
	};

	exports.DEGREES = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * 180 / Math.PI;
	};

	exports.EVEN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return exports.CEILING(number, -2, -1);
	};

	exports.EXP = Math.exp;

	var MEMOIZED_FACT = [];
	exports.FACT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n === 0 || n === 1) {
	    return 1;
	  } else if (MEMOIZED_FACT[n] > 0) {
	    return MEMOIZED_FACT[n];
	  } else {
	    MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;
	    return MEMOIZED_FACT[n];
	  }
	};

	exports.FACTDOUBLE = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n <= 0) {
	    return 1;
	  } else {
	    return n * exports.FACTDOUBLE(n - 2);
	  }
	};

	exports.FLOOR = function(number, significance) {
	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(number, significance)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  if (!(number > 0 && significance > 0) && !(number < 0 && significance < 0)) {
	    return error.num;
	  }

	  significance = Math.abs(significance);
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance), precision);
	  }
	};

	//TODO: Verify
	exports.FLOOR.MATH = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : significance;
	  mode = (mode === undefined) ? 0 : mode;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  significance = significance ? Math.abs(significance) : 1;
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else if (mode === 0 || mode === undefined) {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	  }
	  return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	};

	// Deprecated
	exports.FLOOR.PRECISE = exports.FLOOR.MATH;

	// adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
	exports.GCD = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var r0 = range[0];
	  var x = r0 < 0 ? -r0 : r0;
	  for (var i = 1; i < n; i++) {
	    var ri = range[i];
	    var y = ri < 0 ? -ri : ri;
	    while (x && y) {
	      if (x > y) {
	        x %= y;
	      } else {
	        y %= x;
	      }
	    }
	    x += y;
	  }
	  return x;
	};


	exports.INT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.floor(number);
	};

	//TODO: verify
	exports.ISO = {
	  CEILING: exports.CEILING
	};

	exports.LCM = function() {
	  // Credits: Jonas Raoni Soares Silva
	  var o = utils.parseNumberArray(utils.flatten(arguments));
	  if (o instanceof Error) {
	    return o;
	  }
	  for (var i, j, n, d, r = 1;
	    (n = o.pop()) !== undefined;) {
	    while (n > 1) {
	      if (n % 2) {
	        for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
	          //empty
	        }
	        d = (i <= j) ? i : n;
	      } else {
	        d = 2;
	      }
	      for (n /= d, r *= d, i = o.length; i;
	        (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
	        //empty
	      }
	    }
	  }
	  return r;
	};

	exports.LN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number);
	};

	exports.LOG = function(number, base) {
	  number = utils.parseNumber(number);
	  base = utils.parseNumber(base);
	  if (utils.anyIsError(number, base)) {
	    return error.value;
	  }
	  base = (base === undefined) ? 10 : base;
	  return Math.log(number) / Math.log(base);
	};

	exports.LOG10 = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number) / Math.log(10);
	};

	exports.MDETERM = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.det(matrix);
	};

	exports.MINVERSE = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.inv(matrix);
	};

	exports.MMULT = function(matrix1, matrix2) {
	  matrix1 = utils.parseMatrix(matrix1);
	  matrix2 = utils.parseMatrix(matrix2);
	  if (utils.anyIsError(matrix1, matrix2)) {
	    return error.value;
	  }
	  return numeric.dot(matrix1, matrix2);
	};

	exports.MOD = function(dividend, divisor) {
	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }
	  if (divisor === 0) {
	    return error.div0;
	  }
	  var modulus = Math.abs(dividend % divisor);
	  return (divisor > 0) ? modulus : -modulus;
	};

	  exports.MROUND = function(number, multiple) {
	  number = utils.parseNumber(number);
	  multiple = utils.parseNumber(multiple);
	  if (utils.anyIsError(number, multiple)) {
	    return error.value;
	  }
	  if (number * multiple < 0) {
	    return error.num;
	  }

	  return Math.round(number / multiple) * multiple;
	};

	exports.MULTINOMIAL = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var sum = 0;
	  var divisor = 1;
	  for (var i = 0; i < args.length; i++) {
	    sum += args[i];
	    divisor *= exports.FACT(args[i]);
	  }
	  return exports.FACT(sum) / divisor;
	};

	exports.MUNIT = function(dimension) {
	  dimension = utils.parseNumber(dimension);
	  if (dimension instanceof Error) {
	    return dimension;
	  }
	  return numeric.identity(dimension);
	};

	exports.ODD = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var temp = Math.ceil(Math.abs(number));
	  temp = (temp & 1) ? temp : temp + 1;
	  return (number > 0) ? temp : -temp;
	};

	exports.PI = function() {
	  return Math.PI;
	};

	exports.POWER = function(number, power) {
	  number = utils.parseNumber(number);
	  power = utils.parseNumber(power);
	  if (utils.anyIsError(number, power)) {
	    return error.value;
	  }
	  var result = Math.pow(number, power);
	  if (isNaN(result)) {
	    return error.num;
	  }

	  return result;
	};

	exports.PRODUCT = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var result = 1;
	  for (var i = 0; i < args.length; i++) {
	    result *= args[i];
	  }
	  return result;
	};

	exports.QUOTIENT = function(numerator, denominator) {
	  numerator = utils.parseNumber(numerator);
	  denominator = utils.parseNumber(denominator);
	  if (utils.anyIsError(numerator, denominator)) {
	    return error.value;
	  }
	  return parseInt(numerator / denominator, 10);
	};

	exports.RADIANS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * Math.PI / 180;
	};

	exports.RAND = function() {
	  return Math.random();
	};

	exports.RANDBETWEEN = function(bottom, top) {
	  bottom = utils.parseNumber(bottom);
	  top = utils.parseNumber(top);
	  if (utils.anyIsError(bottom, top)) {
	    return error.value;
	  }
	  // Creative Commons Attribution 3.0 License
	  // Copyright (c) 2012 eqcode
	  return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
	};

	// TODO
	exports.ROMAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  // The MIT License
	  // Copyright (c) 2008 Steven Levithan
	  var digits = String(number).split('');
	  var key = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
	  var roman = '';
	  var i = 3;
	  while (i--) {
	    roman = (key[+digits.pop() + (i * 10)] || '') + roman;
	  }
	  return new Array(+digits.join('') + 1).join('M') + roman;
	};

	exports.ROUND = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
	};

	exports.ROUNDDOWN = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.ROUNDUP = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.SEC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.cos(number);
	};

	exports.SECH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) + Math.exp(-number));
	};

	exports.SERIESSUM = function(x, n, m, coefficients) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  m = utils.parseNumber(m);
	  coefficients = utils.parseNumberArray(coefficients);
	  if (utils.anyIsError(x, n, m, coefficients)) {
	    return error.value;
	  }
	  var result = coefficients[0] * Math.pow(x, n);
	  for (var i = 1; i < coefficients.length; i++) {
	    result += coefficients[i] * Math.pow(x, n + i * m);
	  }
	  return result;
	};

	exports.SIGN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  if (number < 0) {
	    return -1;
	  } else if (number === 0) {
	    return 0;
	  } else {
	    return 1;
	  }
	};

	exports.SIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.sin(number);
	};

	  exports.SINH = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return (Math.exp(number) - Math.exp(-number)) / 2;
	  };

	  exports.SQRT = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    if (number < 0) {
	      return error.num;
	    }
	    return Math.sqrt(number);
	  };

	  exports.SQRTPI = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return Math.sqrt(number * Math.PI);
	  };

	exports.SUBTOTAL = function(function_code, ref1) {
	  function_code = utils.parseNumber(function_code);
	  if (function_code instanceof Error) {
	    return function_code;
	  }
	  switch (function_code) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	      // no hidden values for us
	    case 101:
	      return statistical.AVERAGE(ref1);
	    case 102:
	      return statistical.COUNT(ref1);
	    case 103:
	      return statistical.COUNTA(ref1);
	    case 104:
	      return statistical.MAX(ref1);
	    case 105:
	      return statistical.MIN(ref1);
	    case 106:
	      return exports.PRODUCT(ref1);
	    case 107:
	      return statistical.STDEV.S(ref1);
	    case 108:
	      return statistical.STDEV.P(ref1);
	    case 109:
	      return exports.SUM(ref1);
	    case 110:
	      return statistical.VAR.S(ref1);
	    case 111:
	      return statistical.VAR.P(ref1);

	  }
	};

	exports.ADD = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 + num2;
	};

	exports.MINUS = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 - num2;
	};

	exports.DIVIDE = function (dividend, divisor) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }

	  if (divisor === 0) {
	    return error.div0;
	  }

	  return dividend / divisor;
	};

	exports.MULTIPLY = function (factor1, factor2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  factor1 = utils.parseNumber(factor1);
	  factor2 = utils.parseNumber(factor2);
	  if (utils.anyIsError(factor1, factor2)) {
	    return error.value;
	  }

	  return factor1 * factor2;
	};

	exports.GTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 >= num2;
	};

	exports.LT = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 < num2;
	};


	exports.LTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 <= num2;
	};

	exports.EQ = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 === value2;
	};

	exports.NE = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 !== value2;
	};

	exports.POW = function (base, exponent) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  base = utils.parseNumber(base);
	  exponent = utils.parseNumber(exponent);
	  if (utils.anyIsError(base, exponent)) {
	    return error.error;
	  }

	  return exports.POWER(base, exponent);
	};

	exports.SUM = function() {
	  var result = 0;
	  var argsKeys = Object.keys(arguments);
	  for (var i = 0; i < argsKeys.length; ++i) {
	    var elt = arguments[argsKeys[i]];
	    if (typeof elt === 'number') {
	      result += elt;
	    } else if (typeof elt === 'string') {
	      var parsed = parseFloat(elt);
	      !isNaN(parsed) && (result += parsed);
	    } else if (Array.isArray(elt)) {
	      result += exports.SUM.apply(null, elt);
	    }
	  }
	  return result;
	};

	exports.SUMIF = function(range, criteria) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (range instanceof Error) {
	    return range;
	  }
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += (eval(range[i] + criteria)) ? range[i] : 0; // jshint ignore:line
	  }
	  return result;
	};

	exports.SUMIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var range = utils.parseNumberArray(utils.flatten(args.shift()));
	  if (range instanceof Error) {
	    return range;
	  }
	  var criteria = args;

	  var n_range_elements = range.length;
	  var n_criterias = criteria.length;

	  var result = 0;
	  for (var i = 0; i < n_range_elements; i++) {
	    var el = range[i];
	    var condition = '';
	    for (var c = 0; c < n_criterias; c++) {
	      condition += el + criteria[c];
	      if (c !== n_criterias - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += el;
	    }
	  }
	  return result;
	};

	exports.SUMPRODUCT = function() {
	  if (!arguments || arguments.length === 0) {
	    return error.value;
	  }
	  var arrays = arguments.length + 1;
	  var result = 0;
	  var product;
	  var k;
	  var _i;
	  var _ij;
	  for (var i = 0; i < arguments[0].length; i++) {
	    if (!(arguments[0][i] instanceof Array)) {
	      product = 1;
	      for (k = 1; k < arrays; k++) {
	        _i = utils.parseNumber(arguments[k - 1][i]);
	        if (_i instanceof Error) {
	          return _i;
	        }
	        product *= _i;
	      }
	      result += product;
	    } else {
	      for (var j = 0; j < arguments[0][i].length; j++) {
	        product = 1;
	        for (k = 1; k < arrays; k++) {
	          _ij = utils.parseNumber(arguments[k - 1][i][j]);
	          if (_ij instanceof Error) {
	            return _ij;
	          }
	          product *= _ij;
	        }
	        result += product;
	      }
	    }
	  }
	  return result;
	};

	exports.SUMSQ = function() {
	  var numbers = utils.parseNumberArray(utils.flatten(arguments));
	  if (numbers instanceof Error) {
	    return numbers;
	  }
	  var result = 0;
	  var length = numbers.length;
	  for (var i = 0; i < length; i++) {
	    result += (information.ISNUMBER(numbers[i])) ? numbers[i] * numbers[i] : 0;
	  }
	  return result;
	};

	exports.SUMX2MY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMX2PY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMXMY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.flatten(array_x);
	  array_y = utils.flatten(array_y);
	  for (var i = 0; i < array_x.length; i++) {
	    result += Math.pow(array_x[i] - array_y[i], 2);
	  }
	  return result;
	};

	exports.TAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.tan(number);
	};

	exports.TANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 - 1) / (e2 + 1);
	};

	exports.TRUNC = function(number, digits) {
	  digits = (digits === undefined) ? 0 : digits;
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	function flattenShallow(array) {
	  if (!array || !array.reduce) { return array; }
	  return array.reduce(function(a, b) {
	    var aIsArray = Array.isArray(a);
	    var bIsArray = Array.isArray(b);
	    if (aIsArray && bIsArray ) {
	      return a.concat(b);
	    }
	    if (aIsArray) {
	      a.push(b);
	      return a;
	    }
	    if (bIsArray) {
	      return [a].concat(b);
	    }
	    return [a, b];
	  });
	}

	function isFlat(array) {
	  if (!array) { return false; }
	  for (var i = 0; i < array.length; ++i) {
	    if (Array.isArray(array[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	exports.flatten = function() {
	  var result = exports.argsToArray.apply(null, arguments);
	  while (!isFlat(result)) {
	    result = flattenShallow(result);
	  }
	  return result;
	};

	exports.argsToArray = function(args) {
	  return Array.prototype.slice.call(args, 0);
	};

	exports.numbers = function() {
	  var possibleNumbers = this.flatten.apply(null, arguments);
	  return possibleNumbers.filter(function(el) {
	    return typeof el === 'number';
	  });
	};

	exports.cleanFloat = function(number) {
	  var power = 1e14;
	  return Math.round(number * power) / power;
	};

	exports.parseBool = function(bool) {
	  if (typeof bool === 'boolean') {
	    return bool;
	  }

	  if (bool instanceof Error) {
	    return bool;
	  }

	  if (typeof bool === 'number') {
	    return bool !== 0;
	  }

	  if (typeof bool === 'string') {
	    var up = bool.toUpperCase();
	    if (up === 'TRUE') {
	      return true;
	    }

	    if (up === 'FALSE') {
	      return false;
	    }
	  }

	  if (bool instanceof Date && !isNaN(bool)) {
	    return true;
	  }

	  return error.value;
	};

	exports.parseNumber = function(string) {
	  if (string === undefined || string === '') {
	    return error.value;
	  }
	  if (!isNaN(string)) {
	    return parseFloat(string);
	  }
	  return error.value;
	};

	exports.parseNumberArray = function(arr) {
	  var len;
	  if (!arr || (len = arr.length) === 0) {
	    return error.value;
	  }
	  var parsed;
	  while (len--) {
	    parsed = exports.parseNumber(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.parseMatrix = function(matrix) {
	  var n;
	  if (!matrix || (n = matrix.length) === 0) {
	    return error.value;
	  }
	  var pnarr;
	  for (var i = 0; i < matrix.length; i++) {
	    pnarr = exports.parseNumberArray(matrix[i]);
	    matrix[i] = pnarr;
	    if (pnarr instanceof Error) {
	      return pnarr;
	    }
	  }
	  return matrix;
	};

	var d1900 = new Date(1900, 0, 1);
	exports.parseDate = function(date) {
	  if (!isNaN(date)) {
	    if (date instanceof Date) {
	      return new Date(date);
	    }
	    var d = parseInt(date, 10);
	    if (d < 0) {
	      return error.num;
	    }
	    if (d <= 60) {
	      return new Date(d1900.getTime() + (d - 1) * 86400000);
	    }
	    return new Date(d1900.getTime() + (d - 2) * 86400000);
	  }
	  if (typeof date === 'string') {
	    date = new Date(date);
	    if (!isNaN(date)) {
	      return date;
	    }
	  }
	  return error.value;
	};

	exports.parseDateArray = function(arr) {
	  var len = arr.length;
	  var parsed;
	  while (len--) {
	    parsed = this.parseDate(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.anyIsError = function() {
	  var n = arguments.length;
	  while (n--) {
	    if (arguments[n] instanceof Error) {
	      return true;
	    }
	  }
	  return false;
	};

	exports.arrayValuesToNumbers = function(arr) {
	  var n = arr.length;
	  var el;
	  while (n--) {
	    el = arr[n];
	    if (typeof el === 'number') {
	      continue;
	    }
	    if (el === true) {
	      arr[n] = 1;
	      continue;
	    }
	    if (el === false) {
	      arr[n] = 0;
	      continue;
	    }
	    if (typeof el === 'string') {
	      var number = this.parseNumber(el);
	      if (number instanceof Error) {
	        arr[n] = 0;
	      } else {
	        arr[n] = number;
	      }
	    }
	  }
	  return arr;
	};

	exports.rest = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(idx);
	};

	exports.initial = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(0, array.length - idx);
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	exports.nil = new Error('#NULL!');
	exports.div0 = new Error('#DIV/0!');
	exports.value = new Error('#VALUE?');
	exports.ref = new Error('#REF!');
	exports.name = new Error('#NAME?');
	exports.num = new Error('#NUM!');
	exports.na = new Error('#N/A');
	exports.error = new Error('#ERROR!');
	exports.data = new Error('#GETTING_DATA');


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var text = __webpack_require__(7);
	var jStat = __webpack_require__(9).jStat;
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var misc = __webpack_require__(10);

	var SQRT2PI = 2.5066282746310002;

	exports.AVEDEV = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return jStat.sum(jStat(range).subtract(jStat.mean(range)).abs()[0]) / range.length;
	};

	exports.AVERAGE = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    sum += range[i];
	    count += 1;
	  }
	  return sum / count;
	};

	exports.AVERAGEA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sum += el;
	    }
	    if (el === true) {
	      sum++;
	    }
	    if (el !== null) {
	      count++;
	    }
	  }
	  return sum / count;
	};

	exports.AVERAGEIF = function(range, criteria, average_range) {
	  average_range = average_range || range;
	  range = utils.flatten(range);
	  average_range = utils.parseNumberArray(utils.flatten(average_range));
	  if (average_range instanceof Error) {
	    return average_range;
	  }
	  var average_count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (eval(range[i] + criteria)) { // jshint ignore:line
	      result += average_range[i];
	      average_count++;
	    }
	  }
	  return result / average_count;
	};

	exports.AVERAGEIFS = function() {
	  // Does not work with multi dimensional ranges yet!
	  //http://office.microsoft.com/en-001/excel-help/averageifs-function-HA010047493.aspx
	  var args = utils.argsToArray(arguments);
	  var criteria = (args.length - 1) / 2;
	  var range = utils.flatten(args[0]);
	  var count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    var condition = '';
	    for (var j = 0; j < criteria; j++) {
	      condition += args[2 * j + 1][i] + args[2 * j + 2];
	      if (j !== criteria - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += range[i];
	      count++;
	    }
	  }

	  var average = result / count;
	  if (isNaN(average)) {
	    return 0;
	  } else {
	    return average;
	  }
	};

	exports.BETA = {};

	exports.BETA.DIST = function(x, alpha, beta, cumulative, A, B) {
	  if (arguments.length < 4) {
	    return error.value;
	  }

	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(x, alpha, beta, A, B)) {
	    return error.value;
	  }

	  x = (x - A) / (B - A);
	  return (cumulative) ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta);
	};

	exports.BETA.INV = function(probability, alpha, beta, A, B) {
	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(probability, alpha, beta, A, B)) {
	    return error.value;
	  }

	  return jStat.beta.inv(probability, alpha, beta) * (B - A) + A;
	};

	exports.BINOM = {};

	exports.BINOM.DIST = function(successes, trials, probability, cumulative) {
	  successes = utils.parseNumber(successes);
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  cumulative = utils.parseNumber(cumulative);
	  if (utils.anyIsError(successes, trials, probability, cumulative)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.binomial.cdf(successes, trials, probability) : jStat.binomial.pdf(successes, trials, probability);
	};

	exports.BINOM.DIST.RANGE = function(trials, probability, successes, successes2) {
	  successes2 = (successes2 === undefined) ? successes : successes2;

	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  successes = utils.parseNumber(successes);
	  successes2 = utils.parseNumber(successes2);
	  if (utils.anyIsError(trials, probability, successes, successes2)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = successes; i <= successes2; i++) {
	    result += mathTrig.COMBIN(trials, i) * Math.pow(probability, i) * Math.pow(1 - probability, trials - i);
	  }
	  return result;
	};

	exports.BINOM.INV = function(trials, probability, alpha) {
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  if (utils.anyIsError(trials, probability, alpha)) {
	    return error.value;
	  }

	  var x = 0;
	  while (x <= trials) {
	    if (jStat.binomial.cdf(x, trials, probability) >= alpha) {
	      return x;
	    }
	    x++;
	  }
	};

	exports.CHISQ = {};

	exports.CHISQ.DIST = function(x, k, cumulative) {
	  x = utils.parseNumber(x);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(x, k)) {
	    return error.value;
	  }

	  return (cumulative) ? jStat.chisquare.cdf(x, k) : jStat.chisquare.pdf(x, k);
	};

	exports.CHISQ.DIST.RT = function(x, k) {
	  if (!x | !k) {
	    return error.na;
	  }

	  if (x < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return 1 -  jStat.chisquare.cdf(x, k);
	};

	exports.CHISQ.INV = function(probability, k) {
	  probability = utils.parseNumber(probability);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(probability, k)) {
	    return error.value;
	  }
	  return jStat.chisquare.inv(probability, k);
	};

	exports.CHISQ.INV.RT = function(p, k) {
	  if (!p | !k) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || k < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return jStat.chisquare.inv(1.0 - p, k);
	};

	exports.CHISQ.TEST = function(observed, expected) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if ((!(observed instanceof Array)) || (!(expected instanceof Array))) {
	    return error.value;
	  }

	  if (observed.length !== expected.length) {
	    return error.value;
	  }

	  if (observed[0] && expected[0] &&
	      observed[0].length !== expected[0].length) {
	    return error.value;
	  }

	  var row = observed.length;
	  var tmp, i, j;

	  // Convert single-dimension array into two-dimension array
	  for (i = 0; i < row; i ++) {
	    if (!(observed[i] instanceof Array)) {
	      tmp = observed[i];
	      observed[i] = [];
	      observed[i].push(tmp);
	    }
	    if (!(expected[i] instanceof Array)) {
	      tmp = expected[i];
	      expected[i] = [];
	      expected[i].push(tmp);
	    }
	  }

	  var col = observed[0].length;
	  var dof = (col === 1) ? row-1 : (row-1)*(col-1);
	  var xsqr = 0;
	  var Pi =Math.PI;

	  for (i = 0; i < row; i ++) {
	    for (j = 0; j < col; j ++) {
	      xsqr += Math.pow((observed[i][j] - expected[i][j]), 2) / expected[i][j];
	    }
	  }

	  // Get independency by X square and its degree of freedom
	  function ChiSq(xsqr, dof) {
	    var p = Math.exp(-0.5 * xsqr);
	    if((dof%2) === 1) {
	      p = p * Math.sqrt(2 * xsqr/Pi);
	    }
	    var k = dof;
	    while(k >= 2) {
	      p = p * xsqr/k;
	      k = k - 2;
	    }
	    var t = p;
	    var a = dof;
	    while (t > 0.0000000001*p) {
	      a = a + 2;
	      t = t * xsqr/a;
	      p = p + t;
	    }
	    return 1-p;
	  }

	  return Math.round(ChiSq(xsqr, dof) * 1000000) / 1000000;
	};

	exports.COLUMN = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.col(matrix, index);
	};

	exports.COLUMNS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.cols(matrix);
	};

	exports.CONFIDENCE = {};

	exports.CONFIDENCE.NORM = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.normalci(1, alpha, sd, n)[1] - 1;
	};

	exports.CONFIDENCE.T = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.tci(1, alpha, sd, n)[1] - 1;
	};

	exports.CORREL = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.corrcoeff(array1, array2);
	};

	exports.COUNT = function() {
	  return utils.numbers(utils.flatten(arguments)).length;
	};

	exports.COUNTA = function() {
	  var range = utils.flatten(arguments);
	  return range.length - exports.COUNTBLANK(range);
	};

	exports.COUNTIN = function (range, value) {
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (range[i] === value) {
	      result++;
	    }
	  }
	  return result;
	};


	exports.COUNTBLANK = function() {
	  var range = utils.flatten(arguments);
	  var blanks = 0;
	  var element;
	  for (var i = 0; i < range.length; i++) {
	    element = range[i];
	    if (element === null || element === '') {
	      blanks++;
	    }
	  }
	  return blanks;
	};

	exports.COUNTIF = function(range, criteria) {
	  range = utils.flatten(range);
	  if (!/[<>=!]/.test(criteria)) {
	    criteria = '=="' + criteria + '"';
	  }
	  var matches = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (typeof range[i] !== 'string') {
	      if (eval(range[i] + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    } else {
	      if (eval('"' + range[i] + '"' + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    }
	  }
	  return matches;
	};

	exports.COUNTIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var results = new Array(utils.flatten(args[0]).length);
	  for (var i = 0; i < results.length; i++) {
	    results[i] = true;
	  }
	  for (i = 0; i < args.length; i += 2) {
	    var range = utils.flatten(args[i]);
	    var criteria = args[i + 1];
	    if (!/[<>=!]/.test(criteria)) {
	      criteria = '=="' + criteria + '"';
	    }
	    for (var j = 0; j < range.length; j++) {
	      if (typeof range[j] !== 'string') {
	        results[j] = results[j] && eval(range[j] + criteria); // jshint ignore:line
	      } else {
	        results[j] = results[j] && eval('"' + range[j] + '"' + criteria); // jshint ignore:line
	      }
	    }
	  }
	  var result = 0;
	  for (i = 0; i < results.length; i++) {
	    if (results[i]) {
	      result++;
	    }
	  }
	  return result;
	};

	exports.COUNTUNIQUE = function () {
	  return misc.UNIQUE.apply(null, utils.flatten(arguments)).length;
	};

	exports.COVARIANCE = {};

	exports.COVARIANCE.P = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  var mean1 = jStat.mean(array1);
	  var mean2 = jStat.mean(array2);
	  var result = 0;
	  var n = array1.length;
	  for (var i = 0; i < n; i++) {
	    result += (array1[i] - mean1) * (array2[i] - mean2);
	  }
	  return result / n;
	};

	exports.COVARIANCE.S = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.covariance(array1, array2);
	};

	exports.DEVSQ = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += Math.pow((range[i] - mean), 2);
	  }
	  return result;
	};

	exports.EXPON = {};

	exports.EXPON.DIST = function(x, lambda, cumulative) {
	  x = utils.parseNumber(x);
	  lambda = utils.parseNumber(lambda);
	  if (utils.anyIsError(x, lambda)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);
	};

	exports.F = {};

	exports.F.DIST = function(x, d1, d2, cumulative) {
	  x = utils.parseNumber(x);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(x, d1, d2)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);
	};

	exports.F.DIST.RT = function(x, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (x < 0 || d1 < 1 || d2 < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.centralF.cdf(x, d1, d2);
	};

	exports.F.INV = function(probability, d1, d2) {
	  probability = utils.parseNumber(probability);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(probability, d1, d2)) {
	    return error.value;
	  }
	  if (probability <= 0.0 || probability > 1.0) {
	    return error.num;
	  }

	  return jStat.centralF.inv(probability, d1, d2);
	};

	exports.F.INV.RT = function(p, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return jStat.centralF.inv(1.0 - p, d1, d2);
	};

	exports.F.TEST = function(array1, array2) {
	  if (!array1 || !array2) {
	    return error.na;
	  }

	  if (!(array1 instanceof Array) || !(array2 instanceof Array)) {
	    return error.na;
	  }

	  if (array1.length < 2 || array2.length < 2) {
	    return error.div0;
	  }

	  var sumOfSquares = function(values, x1) {
	    var sum = 0;
	    for (var i = 0; i < values.length; i++) {
	      sum +=Math.pow((values[i] - x1), 2);
	    }
	    return sum;
	  };

	  var x1 = mathTrig.SUM(array1) / array1.length;
	  var x2 = mathTrig.SUM(array2) / array2.length;
	  var sum1 = sumOfSquares(array1, x1) / (array1.length - 1);
	  var sum2 = sumOfSquares(array2, x2) / (array2.length - 1);

	  return sum1 / sum2;
	};

	exports.FISHER = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return x;
	  }
	  return Math.log((1 + x) / (1 - x)) / 2;
	};

	exports.FISHERINV = function(y) {
	  y = utils.parseNumber(y);
	  if (y instanceof Error) {
	    return y;
	  }
	  var e2y = Math.exp(2 * y);
	  return (e2y - 1) / (e2y + 1);
	};

	exports.FORECAST = function(x, data_y, data_x) {
	  x = utils.parseNumber(x);
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(x, data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var b = num / den;
	  var a = ymean - b * xmean;
	  return a + b * x;
	};

	exports.FREQUENCY = function(data, bins) {
	  data = utils.parseNumberArray(utils.flatten(data));
	  bins = utils.parseNumberArray(utils.flatten(bins));
	  if (utils.anyIsError(data, bins)) {
	    return error.value;
	  }
	  var n = data.length;
	  var b = bins.length;
	  var r = [];
	  for (var i = 0; i <= b; i++) {
	    r[i] = 0;
	    for (var j = 0; j < n; j++) {
	      if (i === 0) {
	        if (data[j] <= bins[0]) {
	          r[0] += 1;
	        }
	      } else if (i < b) {
	        if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
	          r[i] += 1;
	        }
	      } else if (i === b) {
	        if (data[j] > bins[b - 1]) {
	          r[b] += 1;
	        }
	      }
	    }
	  }
	  return r;
	};


	exports.GAMMA = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  if (number === 0) {
	    return error.num;
	  }

	  if (parseInt(number, 10) === number && number < 0) {
	    return error.num;
	  }

	  return jStat.gammafn(number);
	};

	exports.GAMMA.DIST = function(value, alpha, beta, cumulative) {
	  if (arguments.length !== 4) {
	    return error.na;
	  }

	  if (value < 0 || alpha <= 0 || beta <= 0) {
	    return error.value;
	  }

	  if ((typeof value !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return cumulative ? jStat.gamma.cdf(value, alpha, beta, true) : jStat.gamma.pdf(value, alpha, beta, false);
	};

	exports.GAMMA.INV = function(probability, alpha, beta) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
	    return error.num;
	  }

	  if ((typeof probability !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return jStat.gamma.inv(probability, alpha, beta);
	};

	exports.GAMMALN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return jStat.gammaln(number);
	};

	exports.GAMMALN.PRECISE = function(x) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (x <= 0) {
	    return error.num;
	  }

	  if (typeof x !== 'number') {
	    return error.value;
	  }

	  return jStat.gammaln(x);
	};

	exports.GAUSS = function(z) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return z;
	  }
	  return jStat.normal.cdf(z, 0, 1) - 0.5;
	};

	exports.GEOMEAN = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  return jStat.geomean(args);
	};

	exports.GROWTH = function(known_y, known_x, new_x, use_const) {
	  // Credits: Ilmari Karonen (http://stackoverflow.com/questions/14161990/how-to-implement-growth-function-in-javascript)

	  known_y = utils.parseNumberArray(known_y);
	  if (known_y instanceof Error) {
	    return known_y;
	  }

	  // Default values for optional parameters:
	  var i;
	  if (known_x === undefined) {
	    known_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      known_x.push(i);
	    }
	  }
	  if (new_x === undefined) {
	    new_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      new_x.push(i);
	    }
	  }

	  known_x = utils.parseNumberArray(known_x);
	  new_x = utils.parseNumberArray(new_x);
	  if (utils.anyIsError(known_x, new_x)) {
	    return error.value;
	  }


	  if (use_const === undefined) {
	    use_const = true;
	  }

	  // Calculate sums over the data:
	  var n = known_y.length;
	  var avg_x = 0;
	  var avg_y = 0;
	  var avg_xy = 0;
	  var avg_xx = 0;
	  for (i = 0; i < n; i++) {
	    var x = known_x[i];
	    var y = Math.log(known_y[i]);
	    avg_x += x;
	    avg_y += y;
	    avg_xy += x * y;
	    avg_xx += x * x;
	  }
	  avg_x /= n;
	  avg_y /= n;
	  avg_xy /= n;
	  avg_xx /= n;

	  // Compute linear regression coefficients:
	  var beta;
	  var alpha;
	  if (use_const) {
	    beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
	    alpha = avg_y - beta * avg_x;
	  } else {
	    beta = avg_xy / avg_xx;
	    alpha = 0;
	  }

	  // Compute and return result array:
	  var new_y = [];
	  for (i = 0; i < new_x.length; i++) {
	    new_y.push(Math.exp(alpha + beta * new_x[i]));
	  }
	  return new_y;
	};

	exports.HARMEAN = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    den += 1 / range[i];
	  }
	  return n / den;
	};

	exports.HYPGEOM = {};

	exports.HYPGEOM.DIST = function(x, n, M, N, cumulative) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  M = utils.parseNumber(M);
	  N = utils.parseNumber(N);
	  if (utils.anyIsError(x, n, M, N)) {
	    return error.value;
	  }

	  function pdf(x, n, M, N) {
	    return mathTrig.COMBIN(M, x) * mathTrig.COMBIN(N - M, n - x) / mathTrig.COMBIN(N, n);
	  }

	  function cdf(x, n, M, N) {
	    var result = 0;
	    for (var i = 0; i <= x; i++) {
	      result += pdf(i, n, M, N);
	    }
	    return result;
	  }

	  return (cumulative) ? cdf(x, n, M, N) : pdf(x, n, M, N);
	};

	exports.INTERCEPT = function(known_y, known_x) {
	  known_y = utils.parseNumberArray(known_y);
	  known_x = utils.parseNumberArray(known_x);
	  if (utils.anyIsError(known_y, known_x)) {
	    return error.value;
	  }
	  if (known_y.length !== known_x.length) {
	    return error.na;
	  }
	  return exports.FORECAST(0, known_y, known_x);
	};

	exports.KURT = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 4);
	  }
	  sigma = sigma / Math.pow(jStat.stdev(range, true), 4);
	  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));
	};

	exports.LARGE = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return b - a;
	  })[k - 1];
	};

	exports.LINEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var ymean = jStat.mean(data_y);
	  var xmean = jStat.mean(data_x);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var m = num / den;
	  var b = ymean - m * xmean;
	  return [m, b];
	};

	// According to Microsoft:
	// http://office.microsoft.com/en-us/starter-help/logest-function-HP010342665.aspx
	// LOGEST returns are based on the following linear model:
	// ln y = x1 ln m1 + ... + xn ln mn + ln b
	exports.LOGEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  for (var i = 0; i < data_y.length; i ++) {
	    data_y[i] = Math.log(data_y[i]);
	  }

	  var result = exports.LINEST(data_y, data_x);
	  result[0] = Math.round(Math.exp(result[0])*1000000)/1000000;
	  result[1] = Math.round(Math.exp(result[1])*1000000)/1000000;
	  return result;
	};

	exports.LOGNORM = {};

	exports.LOGNORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.lognormal.cdf(x, mean, sd) : jStat.lognormal.pdf(x, mean, sd);
	};

	exports.LOGNORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.lognormal.inv(probability, mean, sd);
	};

	exports.MAX = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MAXA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MEDIAN = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return jStat.median(range);
	};

	exports.MIN = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MINA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MODE = {};

	exports.MODE.MULT = function() {
	  // Credits: Ronan
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var count = {};
	  var maxItems = [];
	  var max = 0;
	  var currentItem;

	  for (var i = 0; i < n; i++) {
	    currentItem = range[i];
	    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
	    if (count[currentItem] > max) {
	      max = count[currentItem];
	      maxItems = [];
	    }
	    if (count[currentItem] === max) {
	      maxItems[maxItems.length] = currentItem;
	    }
	  }
	  return maxItems;
	};

	exports.MODE.SNGL = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return exports.MODE.MULT(range).sort(function(a, b) {
	    return a - b;
	  })[0];
	};

	exports.NEGBINOM = {};

	exports.NEGBINOM.DIST = function(k, r, p, cumulative) {
	  k = utils.parseNumber(k);
	  r = utils.parseNumber(r);
	  p = utils.parseNumber(p);
	  if (utils.anyIsError(k, r, p)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.negbin.cdf(k, r, p) : jStat.negbin.pdf(k, r, p);
	};

	exports.NORM = {};

	exports.NORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  if (sd <= 0) {
	    return error.num;
	  }

	  // Return normal distribution computed by jStat [http://jstat.org]
	  return (cumulative) ? jStat.normal.cdf(x, mean, sd) : jStat.normal.pdf(x, mean, sd);
	};

	exports.NORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, mean, sd);
	};

	exports.NORM.S = {};

	exports.NORM.S.DIST = function(z, cumulative) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);
	};

	exports.NORM.S.INV = function(probability) {
	  probability = utils.parseNumber(probability);
	  if (probability instanceof Error) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, 0, 1);
	};

	exports.PEARSON = function(data_x, data_y) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den1 = 0;
	  var den2 = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den1 += Math.pow(data_x[i] - xmean, 2);
	    den2 += Math.pow(data_y[i] - ymean, 2);
	  }
	  return num / Math.sqrt(den1 * den2);
	};

	exports.PERCENTILE = {};

	exports.PERCENTILE.EXC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    {
	      return a - b;
	    }
	  });
	  var n = array.length;
	  if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
	    return error.num;
	  }
	  var l = k * (n + 1) - 1;
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTILE.INC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var n = array.length;
	  var l = k * (n - 1);
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTRANK = {};

	exports.PERCENTRANK.EXC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = (array.indexOf(uniques[i]) + 1) / (n + 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERCENTRANK.INC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = array.indexOf(uniques[i]) / (n - 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERMUT = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return mathTrig.FACT(number) / mathTrig.FACT(number - number_chosen);
	};

	exports.PERMUTATIONA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return Math.pow(number, number_chosen);
	};

	exports.PHI = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return error.value;
	  }
	  return Math.exp(-0.5 * x * x) / SQRT2PI;
	};

	exports.POISSON = {};

	exports.POISSON.DIST = function(x, mean, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  if (utils.anyIsError(x, mean)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);
	};

	exports.PROB = function(range, probability, lower, upper) {
	  if (lower === undefined) {
	    return 0;
	  }
	  upper = (upper === undefined) ? lower : upper;

	  range = utils.parseNumberArray(utils.flatten(range));
	  probability = utils.parseNumberArray(utils.flatten(probability));
	  lower = utils.parseNumber(lower);
	  upper = utils.parseNumber(upper);
	  if (utils.anyIsError(range, probability, lower, upper)) {
	    return error.value;
	  }

	  if (lower === upper) {
	    return (range.indexOf(lower) >= 0) ? probability[range.indexOf(lower)] : 0;
	  }

	  var sorted = range.sort(function(a, b) {
	    return a - b;
	  });
	  var n = sorted.length;
	  var result = 0;
	  for (var i = 0; i < n; i++) {
	    if (sorted[i] >= lower && sorted[i] <= upper) {
	      result += probability[range.indexOf(sorted[i])];
	    }
	  }
	  return result;
	};

	exports.QUARTILE = {};

	exports.QUARTILE.EXC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.EXC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.EXC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.EXC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.QUARTILE.INC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.INC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.INC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.INC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.RANK = {};

	exports.RANK.AVG = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  range = utils.flatten(range);
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);

	  var length = range.length;
	  var count = 0;
	  for (var i = 0; i < length; i++) {
	    if (range[i] === number) {
	      count++;
	    }
	  }

	  return (count > 1) ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
	};

	exports.RANK.EQ = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);
	  return range.indexOf(number) + 1;
	};

	exports.ROW = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.row(matrix, index);
	};

	exports.ROWS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.rows(matrix);
	};

	exports.RSQ = function(data_x, data_y) { // no need to flatten here, PEARSON will take care of that
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }
	  return Math.pow(exports.PEARSON(data_x, data_y), 2);
	};

	exports.SKEW = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 3);
	  }
	  return n * sigma / ((n - 1) * (n - 2) * Math.pow(jStat.stdev(range, true), 3));
	};

	exports.SKEW.P = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var m2 = 0;
	  var m3 = 0;
	  for (var i = 0; i < n; i++) {
	    m3 += Math.pow(range[i] - mean, 3);
	    m2 += Math.pow(range[i] - mean, 2);
	  }
	  m3 = m3 / n;
	  m2 = m2 / n;
	  return m3 / Math.pow(m2, 3 / 2);
	};

	exports.SLOPE = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return num / den;
	};

	exports.SMALL = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return a - b;
	  })[k - 1];
	};

	exports.STANDARDIZE = function(x, mean, sd) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (x - mean) / sd;
	};

	exports.STDEV = {};

	exports.STDEV.P = function() {
	  var v = exports.VAR.P.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEV.S = function() {
	  var v = exports.VAR.S.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVA = function() {
	  var v = exports.VARA.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVPA = function() {
	  var v = exports.VARPA.apply(this, arguments);
	  return Math.sqrt(v);
	};


	exports.STEYX = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var lft = 0;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    lft += Math.pow(data_y[i] - ymean, 2);
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return Math.sqrt((lft - num * num / den) / (n - 2));
	};

	exports.TRANSPOSE = function(matrix) {
	  if (!matrix) {
	    return error.na;
	  }
	  return jStat.transpose(matrix);
	};

	exports.T = text.T;

	exports.T.DIST = function(x, df, cumulative) {
	  x = utils.parseNumber(x);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(x, df)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.studentt.cdf(x, df) : jStat.studentt.pdf(x, df);
	};

	exports.T.DIST['2T'] = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return (1 - jStat.studentt.cdf(x , df)) * 2;
	};

	exports.T.DIST.RT = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.studentt.cdf(x , df);
	};

	exports.T.INV = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return jStat.studentt.inv(probability, df);
	};

	exports.T.INV['2T'] = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (probability <= 0 || probability > 1 || df < 1) {
	    return error.num;
	  }
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return Math.abs(jStat.studentt.inv(probability/2, df));
	};

	// The algorithm can be found here:
	// http://www.chem.uoa.gr/applets/AppletTtest/Appl_Ttest2.html
	exports.T.TEST = function(data_x, data_y) {
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }

	  var mean_x = jStat.mean(data_x);
	  var mean_y = jStat.mean(data_y);
	  var s_x = 0;
	  var s_y = 0;
	  var i;

	  for (i = 0; i < data_x.length; i++) {
	    s_x += Math.pow(data_x[i] - mean_x, 2);
	  }
	  for (i = 0; i < data_y.length; i++) {
	    s_y += Math.pow(data_y[i] - mean_y, 2);
	  }

	  s_x = s_x / (data_x.length-1);
	  s_y = s_y / (data_y.length-1);

	  var t = Math.abs(mean_x - mean_y) / Math.sqrt(s_x/data_x.length + s_y/data_y.length);

	  return exports.T.DIST['2T'](t, data_x.length+data_y.length-2);
	};

	exports.TREND = function(data_y, data_x, new_data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  new_data_x = utils.parseNumberArray(utils.flatten(new_data_x));
	  if (utils.anyIsError(data_y, data_x, new_data_x)) {
	    return error.value;
	  }
	  var linest = exports.LINEST(data_y, data_x);
	  var m = linest[0];
	  var b = linest[1];
	  var result = [];

	  new_data_x.forEach(function(x) {
	    result.push(m * x + b);
	  });

	  return result;
	};

	exports.TRIMMEAN = function(range, percent) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  percent = utils.parseNumber(percent);
	  if (utils.anyIsError(range, percent)) {
	    return error.value;
	  }
	  var trim = mathTrig.FLOOR(range.length * percent, 2) / 2;
	  return jStat.mean(utils.initial(utils.rest(range.sort(function(a, b) {
	    return a - b;
	  }), trim), trim));
	};

	exports.VAR = {};

	exports.VAR.P = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / n;
	};

	exports.VAR.S = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / (n - 1);
	};

	exports.VARA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / (count - 1);
	};

	exports.VARPA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / count;
	};

	exports.WEIBULL = {};

	exports.WEIBULL.DIST = function(x, alpha, beta, cumulative) {
	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  if (utils.anyIsError(x, alpha, beta)) {
	    return error.value;
	  }
	  return (cumulative) ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
	};

	exports.Z = {};

	exports.Z.TEST = function(range, x, sd) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  x = utils.parseNumber(x);
	  if (utils.anyIsError(range, x)) {
	    return error.value;
	  }

	  sd = sd || exports.STDEV.S(range);
	  var n = range.length;
	  return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var numeral = __webpack_require__(8);

	//TODO
	exports.ASC = function() {
	 throw new Error('ASC is not implemented');
	};

	//TODO
	exports.BAHTTEXT = function() {
	 throw new Error('BAHTTEXT is not implemented');
	};

	exports.CHAR = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return String.fromCharCode(number);
	};

	exports.CLEAN = function(text) {
	  text = text || '';
	  var re = /[\0-\x1F]/g;
	  return text.replace(re, "");
	};

	exports.CODE = function(text) {
	  text = text || '';
	  return text.charCodeAt(0);
	};

	exports.CONCATENATE = function() {
	  var args = utils.flatten(arguments);

	  var trueFound = 0;
	  while ((trueFound = args.indexOf(true)) > -1) {
	    args[trueFound] = 'TRUE';
	  }

	  var falseFound = 0;
	  while ((falseFound = args.indexOf(false)) > -1) {
	    args[falseFound] = 'FALSE';
	  }

	  return args.join('');
	};

	//TODO
	exports.DBCS = function() {
	 throw new Error('DBCS is not implemented');
	};

	exports.DOLLAR = function(number, decimals) {
	  decimals = (decimals === undefined) ? 2 : decimals;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }
	  var format = '';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    format = '($0,0)';
	  } else if (decimals > 0) {
	    format = '($0,0.' + new Array(decimals + 1).join('0') + ')';
	  }
	  return numeral(number).format(format);
	};

	exports.EXACT = function(text1, text2) {
	  return text1 === text2;
	};

	exports.FIND = function(find_text, within_text, position) {
	  position = (position === undefined) ? 0 : position;
	  return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;
	};

	exports.FIXED = function(number, decimals, no_commas) {
	  decimals = (decimals === undefined) ? 2 : decimals;
	  no_commas = (no_commas === undefined) ? false : no_commas;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }

	  var format = no_commas ? '0' : '0,0';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	  } else if (decimals > 0) {
	    format += '.' + new Array(decimals + 1).join('0');
	  }
	  return numeral(number).format(format);
	};

	exports.HTML2TEXT = function (value) {
	  var result = '';

	  if (value) {
	    if (value instanceof Array) {
	      value.forEach(function (line) {
	        if (result !== '') {
	          result += '\n';
	        }
	        result += (line.replace(/<(?:.|\n)*?>/gm, ''));
	      });
	    } else {
	      result = value.replace(/<(?:.|\n)*?>/gm, '');
	    }
	  }

	  return result;
	};

	exports.LEFT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error || typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.substring(0, number) : null;
	};

	exports.LEN = function(text) {
	  if (arguments.length === 0) {
	    return error.error;
	  }

	  if (typeof text === 'string') {
	    return text ? text.length : 0;
	  }

	  if (text.length) {
	    return text.length;
	  }

	  return error.value;
	};

	exports.LOWER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.toLowerCase() : text;
	};

	exports.MID = function(text, start, number) {
	  start = utils.parseNumber(start);
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(start, number) || typeof text !== 'string') {
	    return number;
	  }

	  var begin = start - 1;
	  var end = begin + number;

	  return text.substring(begin, end);
	};

	// TODO
	exports.NUMBERVALUE = function (text, decimal_separator, group_separator)  {
	  decimal_separator = (typeof decimal_separator === 'undefined') ? '.' : decimal_separator;
	  group_separator = (typeof group_separator === 'undefined') ? ',' : group_separator;
	  return Number(text.replace(decimal_separator, '.').replace(group_separator, ''));
	};

	// TODO
	exports.PRONETIC = function() {
	 throw new Error('PRONETIC is not implemented');
	};

	exports.PROPER = function(text) {
	  if (text === undefined || text.length === 0) {
	    return error.value;
	  }
	  if (text === true) {
	    text = 'TRUE';
	  }
	  if (text === false) {
	    text = 'FALSE';
	  }
	  if (isNaN(text) && typeof text === 'number') {
	    return error.value;
	  }
	  if (typeof text === 'number') {
	    text = '' + text;
	  }

	  return text.replace(/\w\S*/g, function(txt) {
	    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	  });
	};

	exports.REGEXEXTRACT = function (text, regular_expression) {
	  var match = text.match(new RegExp(regular_expression));
	  return match ? (match[match.length > 1 ? match.length - 1 : 0]) : null;
	};

	exports.REGEXMATCH = function (text, regular_expression, full) {
	  var match = text.match(new RegExp(regular_expression));
	  return full ? match : !!match;
	};

	exports.REGEXREPLACE = function (text, regular_expression, replacement) {
	  return text.replace(new RegExp(regular_expression), replacement);
	};

	exports.REPLACE = function(text, position, length, new_text) {
	  position = utils.parseNumber(position);
	  length = utils.parseNumber(length);
	  if (utils.anyIsError(position, length) ||
	    typeof text !== 'string' ||
	    typeof new_text !== 'string') {
	    return error.value;
	  }
	  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
	};

	exports.REPT = function(text, number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return new Array(number + 1).join(text);
	};

	exports.RIGHT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return text ? text.substring(text.length - number) : null;
	};

	exports.SEARCH = function(find_text, within_text, position) {
	  var foundAt;
	  if (typeof find_text !== 'string' || typeof within_text !== 'string') {
	    return error.value;
	  }
	  position = (position === undefined) ? 0 : position;
	  foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1)+1;
	  return (foundAt === 0)?error.value:foundAt;
	};

	exports.SPLIT = function (text, separator) {
	  return text.split(separator);
	};

	exports.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
	  if (!text || !old_text || !new_text) {
	    return text;
	  } else if (occurrence === undefined) {
	    return text.replace(new RegExp(old_text, 'g'), new_text);
	  } else {
	    var index = 0;
	    var i = 0;
	    while (text.indexOf(old_text, index) > 0) {
	      index = text.indexOf(old_text, index + 1);
	      i++;
	      if (i === occurrence) {
	        return text.substring(0, index) + new_text + text.substring(index + old_text.length);
	      }
	    }
	  }
	};

	exports.T = function(value) {
	  return (typeof value === "string") ? value : '';
	};

	// TODO incomplete implementation
	exports.TEXT = function(value, format) {
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(value)) {
	    return error.na;
	  }

	  return numeral(value).format(format);
	};

	exports.TRIM = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.replace(/ +/g, ' ').trim();
	};

	exports.UNICHAR = this.CHAR;

	exports.UNICODE = this.CODE;

	exports.UPPER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.toUpperCase();
	};

	exports.VALUE = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return numeral().unformat(text);
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var utils   = __webpack_require__(4);
	var numeral = __webpack_require__(8);

	exports.UNIQUE = function () {
	  var result = [];
	  for (var i = 0; i < arguments.length; ++i) {
	    var hasElement = false;
	    var element    = arguments[i];

	    // Check if we've already seen this element.
	    for (var j = 0; j < result.length; ++j) {
	      hasElement = result[j] === element;
	      if (hasElement) { break; }
	    }

	    // If we did not find it, add it to the result.
	    if (!hasElement) {
	      result.push(element);
	    }
	  }
	  return result;
	};

	exports.FLATTEN = utils.flatten;

	exports.ARGS2ARRAY = function () {
	  return Array.prototype.slice.call(arguments, 0);
	};

	exports.REFERENCE = function (context, reference) {
	  try {
	    var path = reference.split('.');
	    var result = context;
	    for (var i = 0; i < path.length; ++i) {
	      var step = path[i];
	      if (step[step.length - 1] === ']') {
	        var opening = step.indexOf('[');
	        var index = step.substring(opening + 1, step.length - 1);
	        result = result[step.substring(0, opening)][index];
	      } else {
	        result = result[step];
	      }
	    }
	    return result;
	  } catch (error) {}
	};

	exports.JOIN = function (array, separator) {
	  return array.join(separator);
	};

	exports.NUMBERS = function () {
	  var possibleNumbers = utils.flatten(arguments);
	  return possibleNumbers.filter(function (el) {
	    return typeof el === 'number';
	  });
	};

	exports.NUMERAL = function (number, format) {
	  return numeral(number).format(format);
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	// TODO
	exports.CELL = function() {
	 throw new Error('CELL is not implemented');
	};

	exports.ERROR = {};
	exports.ERROR.TYPE = function(error_val) {
	  switch (error_val) {
	    case error.nil: return 1;
	    case error.div0: return 2;
	    case error.value: return 3;
	    case error.ref: return 4;
	    case error.name: return 5;
	    case error.num: return 6;
	    case error.na: return 7;
	    case error.data: return 8;
	  }
	  return error.na;
	};

	// TODO
	exports.INFO = function() {
	 throw new Error('INFO is not implemented');
	};

	exports.ISBLANK = function(value) {
	  return value === null;
	};

	exports.ISBINARY = function (number) {
	  return (/^[01]{1,10}$/).test(number);
	};

	exports.ISERR = function(value) {
	  return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
	    (typeof value === 'number' && (isNaN(value) || !isFinite(value)));
	};

	exports.ISERROR = function(value) {
	  return exports.ISERR(value) || value === error.na;
	};

	exports.ISEVEN = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? false : true;
	};

	// TODO
	exports.ISFORMULA = function() {
	  throw new Error('ISFORMULA is not implemented');
	};

	exports.ISLOGICAL = function(value) {
	  return value === true || value === false;
	};

	exports.ISNA = function(value) {
	  return value === error.na;
	};

	exports.ISNONTEXT = function(value) {
	  return typeof(value) !== 'string';
	};

	exports.ISNUMBER = function(value) {
	  return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
	};

	exports.ISODD = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? true : false;
	};

	// TODO
	exports.ISREF = function() {
	  throw new Error('ISREF is not implemented');
	};

	exports.ISTEXT = function(value) {
	  return typeof(value) === 'string';
	};

	exports.N = function(value) {
	  if (this.ISNUMBER(value)) {
	    return value;
	  }
	  if (value instanceof Date) {
	    return value.getTime();
	  }
	  if (value === true) {
	    return 1;
	  }
	  if (value === false) {
	    return 0;
	  }
	  if (this.ISERROR(value)) {
	    return value;
	  }
	  return 0;
	};

	exports.NA = function() {
	  return error.na;
	};


	// TODO
	exports.SHEET = function() {
	  throw new Error('SHEET is not implemented');
	};

	// TODO
	exports.SHEETS = function() {
	  throw new Error('SHEETS is not implemented');
	};

	exports.TYPE = function(value) {
	  if (this.ISNUMBER(value)) {
	    return 1;
	  }
	  if (this.ISTEXT(value)) {
	    return 2;
	  }
	  if (this.ISLOGICAL(value)) {
	    return 4;
	  }
	  if (this.ISERROR(value)) {
	    return 16;
	  }
	  if (Array.isArray(value)) {
	    return 64;
	  }
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var jStat = __webpack_require__(9).jStat;
	var text = __webpack_require__(7);
	var utils = __webpack_require__(4);
	var bessel = __webpack_require__(13);

	function isValidBinaryNumber(number) {
	  return (/^[01]{1,10}$/).test(number);
	}

	exports.BESSELI = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besseli(x, n);
	};

	exports.BESSELJ = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselj(x, n);
	};

	exports.BESSELK = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselk(x, n);
	};

	exports.BESSELY = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.bessely(x, n);
	};

	exports.BIN2DEC = function(number) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Convert binary number to decimal
	  var result = parseInt(number, 2);

	  // Handle negative numbers
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return parseInt(stringified.substring(1), 2) - 512;
	  } else {
	    return result;
	  }
	};


	exports.BIN2HEX = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
	  }

	  // Convert binary number to hexadecimal
	  var result = parseInt(number, 2).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BIN2OCT = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
	  }

	  // Convert binary number to octal
	  var result = parseInt(number, 2).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BITAND = function(number1, number2) {
	  // Return error if either number is a non-numeric value
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise AND of two numbers
	  return number1 & number2;
	};

	exports.BITLSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the left or to the right if shift is negative
	  return (shift >= 0) ? number << shift : number >> -shift;
	};

	exports.BITOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise OR of two numbers
	  return number1 | number2;
	};

	exports.BITRSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the right or to the left if shift is negative
	  return (shift >= 0) ? number >> shift : number << -shift;
	};

	exports.BITXOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise XOR of two numbers
	  return number1 ^ number2;
	};

	exports.COMPLEX = function(real, imaginary, suffix) {
	  real = utils.parseNumber(real);
	  imaginary = utils.parseNumber(imaginary);
	  if (utils.anyIsError(real, imaginary)) {
	    return real;
	  }

	  // Set suffix
	  suffix = (suffix === undefined) ? 'i' : suffix;

	  // Return error if suffix is neither "i" nor "j"
	  if (suffix !== 'i' && suffix !== 'j') {
	    return error.value;
	  }

	  // Return complex number
	  if (real === 0 && imaginary === 0) {
	    return 0;
	  } else if (real === 0) {
	    return (imaginary === 1) ? suffix : imaginary.toString() + suffix;
	  } else if (imaginary === 0) {
	    return real.toString();
	  } else {
	    var sign = (imaginary > 0) ? '+' : '';
	    return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);
	  }
	};

	exports.CONVERT = function(number, from_unit, to_unit) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // List of units supported by CONVERT and units defined by the International System of Units
	  // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
	  var units = [
	    ["a.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["a.u. of charge", "e", null, "electric_charge", false, false, 1.60217653141414e-19],
	    ["a.u. of energy", "Eh", null, "energy", false, false, 4.35974417757576e-18],
	    ["a.u. of length", "a?", null, "length", false, false, 5.29177210818182e-11],
	    ["a.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["a.u. of time", "?/Eh", null, "time", false, false, 2.41888432650516e-17],
	    ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
	    ["ampere", "A", null, "electric_current", true, false, 1],
	    ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
	    ["ngstrm", "", ["ang"], "length", false, true, 1e-10],
	    ["are", "ar", null, "area", false, true, 100],
	    ["astronomical unit", "ua", null, "length", false, false, 1.49597870691667e-11],
	    ["bar", "bar", null, "pressure", false, false, 100000],
	    ["barn", "b", null, "area", false, false, 1e-28],
	    ["becquerel", "Bq", null, "radioactivity", true, false, 1],
	    ["bit", "bit", ["b"], "information", false, true, 1],
	    ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
	    ["byte", "byte", null, "information", false, true, 8],
	    ["candela", "cd", null, "luminous_intensity", true, false, 1],
	    ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
	    ["coulomb", "C", null, "electric_charge", true, false, 1],
	    ["cubic ngstrm", "ang3", ["ang^3"], "volume", false, true, 1e-30],
	    ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
	    ["cubic inch", "in3", ["in^3"], "volume", false, true, 0.000016387064],
	    ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 8.46786664623715e-47],
	    ["cubic metre", "m?", null, "volume", true, true, 1],
	    ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 4168181825.44058],
	    ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
	    ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 7.58660370370369e-8],
	    ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
	    ["cup", "cup", null, "volume", false, true, 0.0002365882365],
	    ["dalton", "Da", ["u"], "mass", false, false, 1.66053886282828e-27],
	    ["day", "d", ["day"], "time", false, true, 86400],
	    ["degree", "", null, "angle", false, false, 0.0174532925199433],
	    ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
	    ["dyne", "dyn", ["dy"], "force", false, true, 0.00001],
	    ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
	    ["ell", "ell", null, "length", false, true, 1.143],
	    ["erg", "erg", ["e"], "energy", false, true, 1e-7],
	    ["farad", "F", null, "electric_capacitance", true, false, 1],
	    ["fluid ounce", "oz", null, "volume", false, true, 0.0000295735295625],
	    ["foot", "ft", null, "length", false, true, 0.3048],
	    ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
	    ["gal", "Gal", null, "acceleration", false, false, 0.01],
	    ["gallon", "gal", null, "volume", false, true, 0.003785411784],
	    ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
	    ["grain", "grain", null, "mass", false, true, 0.0000647989],
	    ["gram", "g", null, "mass", false, true, 0.001],
	    ["gray", "Gy", null, "absorbed_dose", true, false, 1],
	    ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
	    ["hectare", "ha", null, "area", false, true, 10000],
	    ["henry", "H", null, "inductance", true, false, 1],
	    ["hertz", "Hz", null, "frequency", true, false, 1],
	    ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
	    ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519.538],
	    ["hour", "h", ["hr"], "time", false, true, 3600],
	    ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 0.00454609],
	    ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
	    ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
	    ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
	    ["inch", "in", null, "length", false, true, 0.0254],
	    ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
	    ["IT calorie", "cal", null, "energy", false, true, 4.1868],
	    ["joule", "J", null, "energy", true, true, 1],
	    ["katal", "kat", null, "catalytic_activity", true, false, 1],
	    ["kelvin", "K", ["kel"], "temperature", true, true, 1],
	    ["kilogram", "kg", null, "mass", true, true, 1],
	    ["knot", "kn", null, "speed", false, true, 0.514444444444444],
	    ["light-year", "ly", null, "length", false, true, 9460730472580800],
	    ["litre", "L", ["l", "lt"], "volume", false, true, 0.001],
	    ["lumen", "lm", null, "luminous_flux", true, false, 1],
	    ["lux", "lx", null, "illuminance", true, false, 1],
	    ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
	    ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
	    ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 0.00027777777777778],
	    ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
	    ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
	    ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
	    ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
	    ["metre", "m", null, "length", true, true, 1],
	    ["miles per hour", "mph", null, "speed", false, true, 0.44704],
	    ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
	    ["minute", "?", null, "angle", false, false, 0.000290888208665722],
	    ["minute", "min", ["mn"], "time", false, true, 60],
	    ["modern teaspoon", "tspm", null, "volume", false, true, 0.000005],
	    ["mole", "mol", null, "amount_of_substance", true, false, 1],
	    ["morgen", "Morgen", null, "area", false, true, 2500],
	    ["n.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["n.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
	    ["n.u. of time", "?/(me?c??)", null, "time", false, false, 1.28808866778687e-21],
	    ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
	    ["newton", "N", null, "force", true, true, 1],
	    ["rsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
	    ["ohm", "", null, "electric_resistance", true, false, 1],
	    ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
	    ["pascal", "Pa", null, "pressure", true, false, 1],
	    ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
	    ["pferdestrke", "PS", null, "power", false, true, 735.49875],
	    ["phot", "ph", null, "illuminance", false, false, 0.0001],
	    ["pica (1/6 inch)", "pica", null, "length", false, true, 0.00035277777777778],
	    ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
	    ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
	    ["pond", "pond", null, "force", false, true, 0.00980665],
	    ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
	    ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
	    ["quart", "qt", null, "volume", false, true, 0.000946352946],
	    ["radian", "rad", null, "angle", true, false, 1],
	    ["second", "?", null, "angle", false, false, 0.00000484813681109536],
	    ["second", "s", ["sec"], "time", true, true, 1],
	    ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
	    ["siemens", "S", null, "electrical_conductance", true, false, 1],
	    ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
	    ["slug", "sg", null, "mass", false, true, 14.59390294],
	    ["square ngstrm", "ang2", ["ang^2"], "area", false, true, 1e-20],
	    ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
	    ["square inch", "in2", ["in^2"], "area", false, true, 0.00064516],
	    ["square light-year", "ly2", ["ly^2"], "area", false, true, 8.95054210748189e+31],
	    ["square meter", "m?", null, "area", true, true, 1],
	    ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988.110336],
	    ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
	    ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 0.00001792111111111],
	    ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
	    ["statute mile", "mi", null, "length", false, true, 1609.344],
	    ["steradian", "sr", null, "solid_angle", true, false, 1],
	    ["stilb", "sb", null, "luminance", false, false, 0.0001],
	    ["stokes", "St", null, "kinematic_viscosity", false, false, 0.0001],
	    ["stone", "stone", null, "mass", false, true, 6.35029318],
	    ["tablespoon", "tbs", null, "volume", false, true, 0.0000147868],
	    ["teaspoon", "tsp", null, "volume", false, true, 0.00000492892],
	    ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
	    ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
	    ["ton", "ton", null, "mass", false, true, 907.18474],
	    ["tonne", "t", null, "mass", false, false, 1000],
	    ["U.K. pint", "uk_pt", null, "volume", false, true, 0.00056826125],
	    ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
	    ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
	    ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 0.000473176473],
	    ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
	    ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
	    ["volt", "V", null, "voltage", true, false, 1],
	    ["watt", "W", null, "power", true, true, 1],
	    ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
	    ["weber", "Wb", null, "magnetic_flux", true, false, 1],
	    ["yard", "yd", null, "length", false, true, 0.9144],
	    ["year", "yr", null, "time", false, true, 31557600]
	  ];

	  // Binary prefixes
	  // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
	  var binary_prefixes = {
	    Yi: ["yobi", 80, 1208925819614629174706176, "Yi", "yotta"],
	    Zi: ["zebi", 70, 1180591620717411303424, "Zi", "zetta"],
	    Ei: ["exbi", 60, 1152921504606846976, "Ei", "exa"],
	    Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
	    Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
	    Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
	    Mi: ["mebi", 20, 1048576, "Mi", "mega"],
	    ki: ["kibi", 10, 1024, "ki", "kilo"]
	  };

	  // Unit prefixes
	  // [Name, Multiplier, Abbreviation]
	  var unit_prefixes = {
	    Y: ["yotta", 1e+24, "Y"],
	    Z: ["zetta", 1e+21, "Z"],
	    E: ["exa", 1e+18, "E"],
	    P: ["peta", 1e+15, "P"],
	    T: ["tera", 1e+12, "T"],
	    G: ["giga", 1e+09, "G"],
	    M: ["mega", 1e+06, "M"],
	    k: ["kilo", 1e+03, "k"],
	    h: ["hecto", 1e+02, "h"],
	    e: ["dekao", 1e+01, "e"],
	    d: ["deci", 1e-01, "d"],
	    c: ["centi", 1e-02, "c"],
	    m: ["milli", 1e-03, "m"],
	    u: ["micro", 1e-06, "u"],
	    n: ["nano", 1e-09, "n"],
	    p: ["pico", 1e-12, "p"],
	    f: ["femto", 1e-15, "f"],
	    a: ["atto", 1e-18, "a"],
	    z: ["zepto", 1e-21, "z"],
	    y: ["yocto", 1e-24, "y"]
	  };

	  // Initialize units and multipliers
	  var from = null;
	  var to = null;
	  var base_from_unit = from_unit;
	  var base_to_unit = to_unit;
	  var from_multiplier = 1;
	  var to_multiplier = 1;
	  var alt;

	  // Lookup from and to units
	  for (var i = 0; i < units.length; i++) {
	    alt = (units[i][2] === null) ? [] : units[i][2];
	    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	      from = units[i];
	    }
	    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	      to = units[i];
	    }
	  }

	  // Lookup from prefix
	  if (from === null) {
	    var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
	    var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (from_unit.substring(0, 2) === 'da') {
	      from_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (from_binary_prefix) {
	      from_multiplier = from_binary_prefix[2];
	      base_from_unit = from_unit.substring(2);
	    } else if (from_unit_prefix) {
	      from_multiplier = from_unit_prefix[1];
	      base_from_unit = from_unit.substring(from_unit_prefix[2].length);
	    }

	    // Lookup from unit
	    for (var j = 0; j < units.length; j++) {
	      alt = (units[j][2] === null) ? [] : units[j][2];
	      if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	        from = units[j];
	      }
	    }
	  }

	  // Lookup to prefix
	  if (to === null) {
	    var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
	    var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (to_unit.substring(0, 2) === 'da') {
	      to_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (to_binary_prefix) {
	      to_multiplier = to_binary_prefix[2];
	      base_to_unit = to_unit.substring(2);
	    } else if (to_unit_prefix) {
	      to_multiplier = to_unit_prefix[1];
	      base_to_unit = to_unit.substring(to_unit_prefix[2].length);
	    }

	    // Lookup to unit
	    for (var k = 0; k < units.length; k++) {
	      alt = (units[k][2] === null) ? [] : units[k][2];
	      if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	        to = units[k];
	      }
	    }
	  }

	  // Return error if a unit does not exist
	  if (from === null || to === null) {
	    return error.na;
	  }

	  // Return error if units represent different quantities
	  if (from[3] !== to[3]) {
	    return error.na;
	  }

	  // Return converted number
	  return number * from[6] * from_multiplier / (to[6] * to_multiplier);
	};

	exports.DEC2BIN = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -512, or is greater than 511
	  if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (number < 0) {
	    return '1' + text.REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = parseInt(number, 10).toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2HEX = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  if (number < 0) {
	    return (1099511627776 + number).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = parseInt(number, 10).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2OCT = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (number < 0) {
	    return (1073741824 + number).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = parseInt(number, 10).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DELTA = function(number1, number2) {
	  // Set number2 to zero if undefined
	  number2 = (number2 === undefined) ? 0 : number2;
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return delta
	  return (number1 === number2) ? 1 : 0;
	};

	// TODO: why is upper_bound not used ? The excel documentation has no examples with upper_bound
	exports.ERF = function(lower_bound, upper_bound) {
	  // Set number2 to zero if undefined
	  upper_bound = (upper_bound === undefined) ? 0 : upper_bound;

	  lower_bound = utils.parseNumber(lower_bound);
	  upper_bound = utils.parseNumber(upper_bound);
	  if (utils.anyIsError(lower_bound, upper_bound)) {
	    return error.value;
	  }

	  return jStat.erf(lower_bound);
	};

	// TODO
	exports.ERF.PRECISE = function() {
	 throw new Error('ERF.PRECISE is not implemented');
	};

	exports.ERFC = function(x) {
	  // Return error if x is not a number
	  if (isNaN(x)) {
	    return error.value;
	  }

	  return jStat.erfc(x);
	};

	// TODO
	exports.ERFC.PRECISE = function() {
	 throw new Error('ERFC.PRECISE is not implemented');
	};

	exports.GESTEP = function(number, step) {
	  step = step || 0;
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(step, number)) {
	    return number;
	  }

	  // Return delta
	  return (number >= step) ? 1 : 0;
	};

	exports.HEX2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1).toLowerCase() === 'f') ? true : false;

	  // Convert hexadecimal number to decimal
	  var decimal = (negative) ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.HEX2DEC = function(number) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return decimal number
	  return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;
	};

	exports.HEX2OCT = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return error if number is positive and greater than 0x1fffffff (536870911)
	  if (decimal > 536870911 && decimal < 1098974756864) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 1098974756864) {
	    return (decimal - 1098437885952).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = decimal.toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.IMABS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return absolute value of complex number
	  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
	};

	exports.IMAGINARY = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', 'j'].indexOf(inumber) >= 0) {
	    return 1;
	  }

	  // Normalize imaginary coefficient
	  inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }

	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return imaginary coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(plus + 1, inumber.length - 1));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        -Number(inumber.substring(minus + 1, inumber.length - 1));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : inumber.substring(0, inumber.length - 1);
	    } else {
	      return (isNaN(inumber)) ? error.num : 0;
	    }
	  }
	};

	exports.IMARGUMENT = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return error if inumber is equal to zero
	  if (x === 0 && y === 0) {
	    return error.div0;
	  }

	  // Return PI/2 if x is equal to zero and y is positive
	  if (x === 0 && y > 0) {
	    return Math.PI / 2;
	  }

	  // Return -PI/2 if x is equal to zero and y is negative
	  if (x === 0 && y < 0) {
	    return -Math.PI / 2;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x > 0) {
	    return 0;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x < 0) {
	    return -Math.PI;
	  }

	  // Return argument of complex number
	  if (x > 0) {
	    return Math.atan(y / x);
	  } else if (x < 0 && y >= 0) {
	    return Math.atan(y / x) + Math.PI;
	  } else {
	    return Math.atan(y / x) - Math.PI;
	  }
	};

	exports.IMCONJUGATE = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return conjugate of complex number
	  return (y !== 0) ? exports.COMPLEX(x, -y, unit) : inumber;
	};

	exports.IMCOS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return cosine of complex number
	  return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMCOSH = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic cosine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
	};

	exports.IMCOT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return cotangent of complex number
	  return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));
	};

	exports.IMDIV = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = exports.IMREAL(inumber1);
	  var b = exports.IMAGINARY(inumber1);
	  var c = exports.IMREAL(inumber2);
	  var d = exports.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return error if inumber2 is null
	  if (c === 0 && d === 0) {
	    return error.num;
	  }

	  // Return exponential of complex number
	  var den = c * c + d * d;
	  return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
	};

	exports.IMEXP = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  var e = Math.exp(x);
	  return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
	};

	exports.IMLN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
	};

	exports.IMLOG10 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
	};

	exports.IMLOG2 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
	};

	exports.IMPOWER = function(inumber, number) {
	  number = utils.parseNumber(number);
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);
	  if (utils.anyIsError(number, x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var p = Math.pow(exports.IMABS(inumber), number);

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);
	};

	exports.IMPRODUCT = function() {
	  // Initialize result
	  var result = arguments[0];

	  // Loop on all numbers
	  for (var i = 1; i < arguments.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = exports.IMREAL(result);
	    var b = exports.IMAGINARY(result);
	    var c = exports.IMREAL(arguments[i]);
	    var d = exports.IMAGINARY(arguments[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = exports.COMPLEX(a * c - b * d, a * d + b * c);
	  }

	  // Return product of complex numbers
	  return result;
	};

	exports.IMREAL = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {
	    return 0;
	  }

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }
	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return real coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, plus));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, minus));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : 0;
	    } else {
	      return (isNaN(inumber)) ? error.num : inumber;
	    }
	  }
	};

	exports.IMSEC = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return secant of complex number
	  return exports.IMDIV('1', exports.IMCOS(inumber));
	};

	exports.IMSECH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return hyperbolic secant of complex number
	  return exports.IMDIV('1', exports.IMCOSH(inumber));
	};

	exports.IMSIN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return sine of complex number
	  return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMSINH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic sine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
	};

	exports.IMSQRT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var s = Math.sqrt(exports.IMABS(inumber));

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
	};

	exports.IMCSC = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return cosecant of complex number
	  return exports.IMDIV('1', exports.IMSIN(inumber));
	};

	exports.IMCSCH = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return hyperbolic cosecant of complex number
	  return exports.IMDIV('1', exports.IMSINH(inumber));
	};

	exports.IMSUB = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = this.IMREAL(inumber1);
	  var b = this.IMAGINARY(inumber1);
	  var c = this.IMREAL(inumber2);
	  var d = this.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return _ of two complex numbers
	  return this.COMPLEX(a - c, b - d, unit);
	};

	exports.IMSUM = function() {
	  var args = utils.flatten(arguments);

	  // Initialize result
	  var result = args[0];

	  // Loop on all numbers
	  for (var i = 1; i < args.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = this.IMREAL(result);
	    var b = this.IMAGINARY(result);
	    var c = this.IMREAL(args[i]);
	    var d = this.IMAGINARY(args[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = this.COMPLEX(a + c, b + d);
	  }

	  // Return sum of complex numbers
	  return result;
	};

	exports.IMTAN = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return tangent of complex number
	  return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
	};

	exports.OCT2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;

	  // Convert octal number to decimal
	  var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.OCT2DEC = function(number) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Return decimal number
	  return (decimal >= 536870912) ? decimal - 1073741824 : decimal;
	};

	exports.OCT2HEX = function(number, places) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 536870912) {
	    return 'ff' + (decimal + 3221225472).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = decimal.toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var M = Math;
	function _horner(arr, v) { return arr.reduce(function(z,w){return v * z + w;},0); };
	function _bessel_iter(x, n, f0, f1, sign) {
	  if(!sign) sign = -1;
	  var tdx = 2 / x, f2;
	  if(n === 0) return f0;
	  if(n === 1) return f1;
	  for(var o = 1; o != n; ++o) {
	    f2 = f1 * o * tdx + sign * f0;
	    f0 = f1; f1 = f2;
	  }
	  return f1;
	}
	function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
	  return function bessel(x,n) {
	    if(n === 0) return bessel0(x);
	    if(n === 1) return bessel1(x);
	    if(n < 0) throw name + ': Order (' + n + ') must be nonnegative';
	    if(nonzero == 1 && x === 0) throw name + ': Undefined when x == 0';
	    if(nonzero == 2 && x <= 0) throw name + ': Undefined when x <= 0';
	    var b0 = bessel0(x), b1 = bessel1(x);
	    return _bessel_iter(x, n, b0, b1, sign);
	  };
	}
	var besselj = (function() {
	  var b0_a1a = [57568490574.0,-13362590354.0,651619640.7,-11214424.18,77392.33017,-184.9052456].reverse();
	  var b0_a2a = [57568490411.0,1029532985.0,9494680.718,59272.64853,267.8532712,1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();
	  var W = 0.636619772; // 2 / Math.PI

	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = M.abs(x) - 0.785398164;
	    if(M.abs(x) < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2;
	    }
	    else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	    }
	    return a;
	  }
	  var b1_a1a = [72362614232.0,-7895059235.0,242396853.1,-2972611.439, 15704.48260, -30.16036606].reverse();
	  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = M.abs(x) - 2.356194491;
	    if(Math.abs(x)< 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1 / a2;
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	      if(x < 0) a = -a;
	    }
	    return a;
	  }
	  return function besselj(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(M.abs(x));
	    if(n === 1) return bessel1(M.abs(x));
	    if(n < 0) throw 'BESSELJ: Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, jsum, sum, bjp, bj, bjm;
	    if(M.abs(x) > n) {
	      ret = _bessel_iter(x, n, bessel0(M.abs(x)), bessel1(M.abs(x)),-1);
	    } else {
	      m=2*M.floor((n+M.floor(M.sqrt(40*n)))/2);
	      jsum=0;
	      bjp=ret=sum=0.0;
	      bj=1.0;
	      for (j=m;j>0;j--) {
	        bjm=j*tox*bj-bjp;
	        bjp=bj;
	        bj=bjm;
	        if (M.abs(bj) > 1E10) {
	          bj *= 1E-10;
	          bjp *= 1E-10;
	          ret *= 1E-10;
	          sum *= 1E-10;
	        }
	        if (jsum) sum += bj;
	        jsum=!jsum;
	        if (j == n) ret=bjp;
	      }
	      sum=2.0*sum-bj;
	      ret /= sum;
	    }
	    return x < 0 && (n%2) ? -ret : ret;
	  };
	})();
	var bessely = (function() {
	  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();
	  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();

	  var W = 0.636619772;
	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = x - 0.785398164;
	    if(x < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2 + W * besselj(x,0) * M.log(x);
	    } else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();
	  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = x - 2.356194491;
	    if(x < 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1/a2 + W * (besselj(x,1) * M.log(x) - 1 / x);
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);
	})();
	var besseli = (function() {
	  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();
	  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();
	  function bessel0(x) {
	    if(x <= 3.75) return _horner(b0_a, x*x/(3.75*3.75));
	    return M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b0_b, 3.75/M.abs(x));
	  }

	  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();
	  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();
	  function bessel1(x) {
	    if(x < 3.75) return x * _horner(b1_a, x*x/(3.75*3.75));
	    return (x < 0 ? -1 : 1) * M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b1_b, 3.75/M.abs(x));
	  }

	  return function besseli(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(x);
	    if(n == 1) return bessel1(x);
	    if(n < 0) throw 'BESSELI Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, bip, bi, bim;
	    m=2*M.round((n+M.round(M.sqrt(40*n)))/2);
	    bip=ret=0.0;
	    bi=1.0;
	    for (j=m;j>0;j--) {
	      bim=j*tox*bi + bip;
	      bip=bi; bi=bim;
	      if (M.abs(bi) > 1E10) {
	        bi *= 1E-10;
	        bip *= 1E-10;
	        ret *= 1E-10;
	      }
	      if(j == n) ret = bip;
	    }
	    ret *= besseli(x, 0) / bi;
	    return x < 0 && (n%2) ? -ret : ret;
	  };

	})();

	var besselk = (function() {
	  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();
	  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();
	  function bessel0(x) {
	    if(x <= 2) return -M.log(x/2)*besseli(x,0) + _horner(b0_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b0_b, 2/x);
	  }

	  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();
	  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();
	  function bessel1(x) {
	    if(x <= 2) return M.log(x/2)*besseli(x,1) + (1/x)*_horner(b1_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b1_b, 2/x);
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);
	})();
	if(true) {
	  exports.besselj = besselj;
	  exports.bessely = bessely;
	  exports.besseli = besseli;
	  exports.besselk = besselk;
	}



/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);

	var d1900 = new Date(1900, 0, 1);
	var WEEK_STARTS = [
	  undefined,
	  0,
	  1,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  1,
	  2,
	  3,
	  4,
	  5,
	  6,
	  0
	];
	var WEEK_TYPES = [
	  [],
	  [1, 2, 3, 4, 5, 6, 7],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 0, 1, 2, 3, 4, 5],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 7, 1, 2, 3, 4, 5],
	  [5, 6, 7, 1, 2, 3, 4],
	  [4, 5, 6, 7, 1, 2, 3],
	  [3, 4, 5, 6, 7, 1, 2],
	  [2, 3, 4, 5, 6, 7, 1],
	  [1, 2, 3, 4, 5, 6, 7]
	];
	var WEEKEND_TYPES = [
	  [],
	  [6, 0],
	  [0, 1],
	  [1, 2],
	  [2, 3],
	  [3, 4],
	  [4, 5],
	  [5, 6],
	  undefined,
	  undefined,
	  undefined, [0, 0],
	  [1, 1],
	  [2, 2],
	  [3, 3],
	  [4, 4],
	  [5, 5],
	  [6, 6]
	];

	exports.DATE = function(year, month, day) {
	  year = utils.parseNumber(year);
	  month = utils.parseNumber(month);
	  day = utils.parseNumber(day);
	  if (utils.anyIsError(year, month, day)) {
	    return error.value;
	  }
	  if (year < 0 || month < 0 || day < 0) {
	    return error.num;
	  }
	  var date = new Date(year, month - 1, day);
	  return date;
	};

	exports.DATEVALUE = function(date_text) {
	  if (typeof date_text !== 'string') {
	    return error.value;
	  }
	  var date = Date.parse(date_text);
	  if (isNaN(date)) {
	    return error.value;
	  }
	  if (date <= -2203891200000) {
	    return (date - d1900) / 86400000 + 1;
	  }
	  return (date - d1900) / 86400000 + 2;
	};

	exports.DAY = function(serial_number) {
	  var date = utils.parseDate(serial_number);
	  if (date instanceof Error) {
	    return date;
	  }
	  return date.getDate();
	};

	exports.DAYS = function(end_date, start_date) {
	  end_date = utils.parseDate(end_date);
	  start_date = utils.parseDate(start_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  return serial(end_date) - serial(start_date);
	};

	exports.DAYS360 = function(start_date, end_date, method) {
	  method = utils.parseBool(method);
	  start_date = utils.parseDate(start_date);
	  end_date = utils.parseDate(end_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (method instanceof Error) {
	    return method;
	  }
	  var sm = start_date.getMonth();
	  var em = end_date.getMonth();
	  var sd, ed;
	  if (method) {
	    sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
	    ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
	  } else {
	    var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
	    var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
	    sd = start_date.getDate() === smd ? 30 : start_date.getDate();
	    if (end_date.getDate() === emd) {
	      if (sd < 30) {
	        em++;
	        ed = 1;
	      } else {
	        ed = 30;
	      }
	    } else {
	      ed = end_date.getDate();
	    }
	  }
	  return 360 * (end_date.getFullYear() - start_date.getFullYear()) +
	    30 * (em - sm) + (ed - sd);
	};

	exports.EDATE = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  start_date.setMonth(start_date.getMonth() + months);
	  return serial(start_date);
	};

	exports.EOMONTH = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
	};

	exports.HOUR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getHours();
	};

	exports.INTERVAL = function (second) {
	  if (typeof second !== 'number' && typeof second !== 'string') {
	    return error.value;
	  } else {
	    second = parseInt(second, 10);
	  }

	  var year  = Math.floor(second/946080000);
	  second    = second%946080000;
	  var month = Math.floor(second/2592000);
	  second    = second%2592000;
	  var day   = Math.floor(second/86400);
	  second    = second%86400;

	  var hour  = Math.floor(second/3600);
	  second    = second%3600;
	  var min   = Math.floor(second/60);
	  second    = second%60;
	  var sec   = second;

	  year  = (year  > 0) ? year  + 'Y' : '';
	  month = (month > 0) ? month + 'M' : '';
	  day   = (day   > 0) ? day   + 'D' : '';
	  hour  = (hour  > 0) ? hour  + 'H' : '';
	  min   = (min   > 0) ? min   + 'M' : '';
	  sec   = (sec   > 0) ? sec   + 'S' : '';

	  return 'P' + year + month + day +
	  'T' + hour + min + sec;
	};

	exports.ISOWEEKNUM = function(date) {
	  date = utils.parseDate(date);
	  if (date instanceof Error) {
	    return date;
	  }

	  date.setHours(0, 0, 0);
	  date.setDate(date.getDate() + 4 - (date.getDay() || 7));
	  var yearStart = new Date(date.getFullYear(), 0, 1);
	  return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
	};

	exports.MINUTE = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMinutes();
	};

	exports.MONTH = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMonth() + 1;
	};

	exports.NETWORKDAYS = function(start_date, end_date, holidays) {
	  return this.NETWORKDAYS.INTL(start_date, end_date, 1, holidays);
	};

	exports.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var days = (end_date - start_date) / (1000 * 60 * 60 * 24) + 1;
	  var total = days;
	  var day = start_date;
	  for (i = 0; i < days; i++) {
	    var d = (new Date().getTimezoneOffset() > 0) ? day.getUTCDay() : day.getDay();
	    var dec = false;
	    if (d === weekend[0] || d === weekend[1]) {
	      dec = true;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === day.getDate() &&
	        holiday.getMonth() === day.getMonth() &&
	        holiday.getFullYear() === day.getFullYear()) {
	        dec = true;
	        break;
	      }
	    }
	    if (dec) {
	      total--;
	    }
	    day.setDate(day.getDate() + 1);
	  }
	  return total;
	};

	exports.NOW = function() {
	  return new Date();
	};

	exports.SECOND = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getSeconds();
	};

	exports.TIME = function(hour, minute, second) {
	  hour = utils.parseNumber(hour);
	  minute = utils.parseNumber(minute);
	  second = utils.parseNumber(second);
	  if (utils.anyIsError(hour, minute, second)) {
	    return error.value;
	  }
	  if (hour < 0 || minute < 0 || second < 0) {
	    return error.num;
	  }
	  return (3600 * hour + 60 * minute + second) / 86400;
	};

	exports.TIMEVALUE = function(time_text) {
	  time_text = utils.parseDate(time_text);
	  if (time_text instanceof Error) {
	    return time_text;
	  }
	  return (3600 * time_text.getHours() +
	    60 * time_text.getMinutes() +
	    time_text.getSeconds()) / 86400;
	};

	exports.TODAY = function() {
	  return new Date();
	};

	exports.WEEKDAY = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  var day = serial_number.getDay();
	  return WEEK_TYPES[return_type][day];
	};

	exports.WEEKNUM = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  if (return_type === 21) {
	    return this.ISOWEEKNUM(serial_number);
	  }
	  var week_start = WEEK_STARTS[return_type];
	  var jan = new Date(serial_number.getFullYear(), 0, 1);
	  var inc = jan.getDay() < week_start ? 1 : 0;
	  jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1000;
	  return Math.floor(((serial_number - jan) / (1000 * 60 * 60 * 24)) / 7 + 1) + inc;
	};

	exports.WORKDAY = function(start_date, days, holidays) {
	  return this.WORKDAY.INTL(start_date, days, 1, holidays);
	};

	exports.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  days = utils.parseNumber(days);
	  if (days instanceof Error) {
	    return days;
	  }
	  if (days < 0) {
	    return error.num;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var d = 0;
	  while (d < days) {
	    start_date.setDate(start_date.getDate() + 1);
	    var day = start_date.getDay();
	    if (day === weekend[0] || day === weekend[1]) {
	      continue;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === start_date.getDate() &&
	        holiday.getMonth() === start_date.getMonth() &&
	        holiday.getFullYear() === start_date.getFullYear()) {
	        d--;
	        break;
	      }
	    }
	    d++;
	  }
	  return start_date;
	};

	exports.YEAR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getFullYear();
	};

	function isLeapYear(year) {
	  return new Date(year, 1, 29).getMonth() === 1;
	}

	// TODO : Use DAYS ?
	function daysBetween(start_date, end_date) {
	  return Math.ceil((end_date - start_date) / 1000 / 60 / 60 / 24);
	}

	exports.YEARFRAC = function(start_date, end_date, basis) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }

	  basis = basis || 0;
	  var sd = start_date.getDate();
	  var sm = start_date.getMonth() + 1;
	  var sy = start_date.getFullYear();
	  var ed = end_date.getDate();
	  var em = end_date.getMonth() + 1;
	  var ey = end_date.getFullYear();

	  switch (basis) {
	    case 0:
	      // US (NASD) 30/360
	      if (sd === 31 && ed === 31) {
	        sd = 30;
	        ed = 30;
	      } else if (sd === 31) {
	        sd = 30;
	      } else if (sd === 30 && ed === 31) {
	        ed = 30;
	      }
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	    case 1:
	      // Actual/actual
	      var feb29Between = function(date1, date2) {
	        var year1 = date1.getFullYear();
	        var mar1year1 = new Date(year1, 2, 1);
	        if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
	          return true;
	        }
	        var year2 = date2.getFullYear();
	        var mar1year2 = new Date(year2, 2, 1);
	        return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);
	      };
	      var ylength = 365;
	      if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {
	        if ((sy === ey && isLeapYear(sy)) ||
	            feb29Between(start_date, end_date) ||
	            (em === 1 && ed === 29)) {
	          ylength = 366;
	        }
	        return daysBetween(start_date, end_date) / ylength;
	      }
	      var years = (ey - sy) + 1;
	      var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
	      var average = days / years;
	      return daysBetween(start_date, end_date) / average;
	    case 2:
	      // Actual/360
	      return daysBetween(start_date, end_date) / 360;
	    case 3:
	      // Actual/365
	      return daysBetween(start_date, end_date) / 365;
	    case 4:
	      // European 30/360
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	  }
	};

	function serial(date) {
	  var addOn = (date > -2203891200000)?2:1;
	  return (date - d1900) / 86400000 + addOn;
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var stats = __webpack_require__(6);
	var maths = __webpack_require__(2);
	var utils = __webpack_require__(4);

	function compact(array) {
	  if (!array) { return array; }
	  var result = [];
	  for (var i = 0; i < array.length; ++i) {
	    if (!array[i]) { continue; }
	    result.push(array[i]);
	  }
	  return result;
	}

	exports.FINDFIELD = function(database, title) {
	  var index = null;
	  for (var i = 0; i < database.length; i++) {
	    if (database[i][0] === title) {
	      index = i;
	      break;
	    }
	  }

	  // Return error if the input field title is incorrect
	  if (index == null) {
	    return error.value;
	  }
	  return index;
	};

	function findResultIndex(database, criterias) {
	  var matches = {};
	  for (var i = 1; i < database[0].length; ++i) {
	    matches[i] = true;
	  }
	  var maxCriteriaLength = criterias[0].length;
	  for (i = 1; i < criterias.length; ++i) {
	    if (criterias[i].length > maxCriteriaLength) {
	      maxCriteriaLength = criterias[i].length;
	    }
	  }

	  for (var k = 1; k < database.length; ++k) {
	    for (var l = 1; l < database[k].length; ++l) {
	      var currentCriteriaResult = false;
	      var hasMatchingCriteria   = false;
	      for (var j = 0; j < criterias.length; ++j) {
	        var criteria = criterias[j];
	        if (criteria.length < maxCriteriaLength) {
	          continue;
	        }

	        var criteriaField = criteria[0];
	        if (database[k][0] !== criteriaField) {
	          continue;
	        }
	        hasMatchingCriteria = true;
	        for (var p = 1; p < criteria.length; ++p) {
	          currentCriteriaResult = currentCriteriaResult || eval(database[k][l] + criteria[p]);  // jshint ignore:line
	        }
	      }
	      if (hasMatchingCriteria) {
	        matches[l] = matches[l] && currentCriteriaResult;
	      }
	    }
	  }

	  var result = [];
	  for (var n = 0; n < database[0].length; ++n) {
	    if (matches[n]) {
	      result.push(n - 1);
	    }
	  }
	  return result;
	}

	// Database functions
	exports.DAVERAGE = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var sum = 0;
	  for (var i = 0; i < resultIndexes.length; i++) {
	    sum += targetFields[resultIndexes[i]];
	  }
	  return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;
	};

	exports.DCOUNT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNT(targetValues);
	};

	exports.DCOUNTA = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNTA(targetValues);
	};

	exports.DGET = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  // Return error if no record meets the criteria
	  if (resultIndexes.length === 0) {
	    return error.value;
	  }
	  // Returns the #NUM! error value because more than one record meets the
	  // criteria
	  if (resultIndexes.length > 1) {
	    return error.num;
	  }

	  return targetFields[resultIndexes[0]];
	};

	exports.DMAX = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var maxValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (maxValue < targetFields[resultIndexes[i]]) {
	      maxValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return maxValue;
	};

	exports.DMIN = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var minValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (minValue > targetFields[resultIndexes[i]]) {
	      minValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return minValue;
	};

	exports.DPRODUCT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  var result = 1;
	  for (i = 0; i < targetValues.length; i++) {
	    result *= targetValues[i];
	  }
	  return result;
	};

	exports.DSTDEV = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.S(targetValues);
	};

	exports.DSTDEVP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.P(targetValues);
	};

	exports.DSUM = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return maths.SUM(targetValues);
	};

	exports.DVAR = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.S(targetValues);
	};

	exports.DVARP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.P(targetValues);
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);
	var information = __webpack_require__(11);

	exports.AND = function() {
	  var args = utils.flatten(arguments);
	  var result = true;
	  for (var i = 0; i < args.length; i++) {
	    if (!args[i]) {
	      result = false;
	    }
	  }
	  return result;
	};

	exports.CHOOSE = function() {
	  if (arguments.length < 2) {
	    return error.na;
	  }

	  var index = arguments[0];
	  if (index < 1 || index > 254) {
	    return error.value;
	  }

	  if (arguments.length < index + 1) {
	    return error.value;
	  }

	  return arguments[index];
	};

	exports.FALSE = function() {
	  return false;
	};

	exports.IF = function(test, then_value, otherwise_value) {
	  return test ? then_value : otherwise_value;
	};

	exports.IFERROR = function(value, valueIfError) {
	  if (information.ISERROR(value)) {
	    return valueIfError;
	  }
	  return value;
	};

	exports.IFNA = function(value, value_if_na) {
	  return value === error.na ? value_if_na : value;
	};

	exports.NOT = function(logical) {
	  return !logical;
	};

	exports.OR = function() {
	  var args = utils.flatten(arguments);
	  var result = false;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result = true;
	    }
	  }
	  return result;
	};

	exports.TRUE = function() {
	  return true;
	};

	exports.XOR = function() {
	  var args = utils.flatten(arguments);
	  var result = 0;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result++;
	    }
	  }
	  return (Math.floor(Math.abs(result)) & 1) ? true : false;
	};

	exports.SWITCH = function () {
	  var result;
	  if (arguments.length > 0)  {
	    var targetValue = arguments[0];
	    var argc = arguments.length - 1;
	    var switchCount = Math.floor(argc / 2);
	    var switchSatisfied = false;
	    var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];

	    if (switchCount) {
	      for (var index = 0; index < switchCount; index++) {
	        if (targetValue === arguments[index * 2 + 1]) {
	          result = arguments[index * 2 + 2];
	          switchSatisfied = true;
	          break;
	        }
	      }
	    }

	    if (!switchSatisfied && defaultClause) {
	      result = defaultClause;
	    }
	  }

	  return result;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var dateTime = __webpack_require__(14);
	var utils = __webpack_require__(4);

	function validDate(d) {
	  return d && d.getTime && !isNaN(d.getTime());
	}

	function ensureDate(d) {
	  return (d instanceof Date)?d:new Date(d);
	}

	exports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
	  // Return error if either date is invalid
	  issue      = ensureDate(issue);
	  first      = ensureDate(first);
	  settlement = ensureDate(settlement);
	  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
	    return '#VALUE!';
	  }

	  // Return error if either rate or par are lower than or equal to zero
	  if (rate <= 0 || par <= 0) {
	    return '#NUM!';
	  }

	  // Return error if frequency is neither 1, 2, or 4
	  if ([1, 2, 4].indexOf(frequency) === -1) {
	    return '#NUM!';
	  }

	  // Return error if basis is neither 0, 1, 2, 3, or 4
	  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
	    return '#NUM!';
	  }

	  // Return error if settlement is before or equal to issue
	  if (settlement <= issue) {
	    return '#NUM!';
	  }

	  // Set default values
	  par   = par   || 0;
	  basis = basis || 0;

	  // Compute accrued interest
	  return par * rate * dateTime.YEARFRAC(issue, settlement, basis);
	};

	// TODO
	exports.ACCRINTM = function() {
	 throw new Error('ACCRINTM is not implemented');
	};

	// TODO
	exports.AMORDEGRC = function() {
	 throw new Error('AMORDEGRC is not implemented');
	};

	// TODO
	exports.AMORLINC = function() {
	 throw new Error('AMORLINC is not implemented');
	};

	// TODO
	exports.COUPDAYBS = function() {
	 throw new Error('COUPDAYBS is not implemented');
	};

	// TODO
	exports.COUPDAYS = function() {
	 throw new Error('COUPDAYS is not implemented');
	};

	// TODO
	exports.COUPDAYSNC = function() {
	 throw new Error('COUPDAYSNC is not implemented');
	};

	// TODO
	exports.COUPNCD = function() {
	 throw new Error('COUPNCD is not implemented');
	};

	// TODO
	exports.COUPNUM = function() {
	 throw new Error('COUPNUM is not implemented');
	};

	// TODO
	exports.COUPPCD = function() {
	 throw new Error('COUPPCD is not implemented');
	};

	exports.CUMIPMT = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names
	  // Requires exports.FV() and exports.PMT() from exports.js [http://stoic.com/exports/]

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative interest
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var interest = 0;

	  if (start === 1) {
	    if (type === 0) {
	      interest = -value;
	      start++;
	    }
	  }

	  for (var i = start; i <= end; i++) {
	    if (type === 1) {
	      interest += exports.FV(rate, i - 2, payment, value, 1) - payment;
	    } else {
	      interest += exports.FV(rate, i - 1, payment, value, 0);
	    }
	  }
	  interest *= rate;

	  // Return cumulative interest
	  return interest;
	};

	exports.CUMPRINC = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative principal
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var principal = 0;
	  if (start === 1) {
	    if (type === 0) {
	      principal = payment + value * rate;
	    } else {
	      principal = payment;
	    }
	    start++;
	  }
	  for (var i = start; i <= end; i++) {
	    if (type > 0) {
	      principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;
	    } else {
	      principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;
	    }
	  }

	  // Return cumulative principal
	  return principal;
	};

	exports.DB = function(cost, salvage, life, period, month) {
	  // Initialize month
	  month = (month === undefined) ? 12 : month;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  month = utils.parseNumber(month);
	  if (utils.anyIsError(cost, salvage, life, period, month)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
	    return error.num;
	  }

	  // Return error if month is not an integer between 1 and 12
	  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Rate is rounded to three decimals places
	  var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);

	  // Compute initial depreciation
	  var initial = cost * rate * month / 12;

	  // Compute total depreciation
	  var total = initial;
	  var current = 0;
	  var ceiling = (period === life) ? life - 1 : period;
	  for (var i = 2; i <= ceiling; i++) {
	    current = (cost - total) * rate;
	    total += current;
	  }

	  // Depreciation for the first and last periods are special cases
	  if (period === 1) {
	    // First period
	    return initial;
	  } else if (period === life) {
	    // Last period
	    return (cost - total) * rate;
	  } else {
	    return current;
	  }
	};

	exports.DDB = function(cost, salvage, life, period, factor) {
	  // Initialize factor
	  factor = (factor === undefined) ? 2 : factor;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  factor = utils.parseNumber(factor);
	  if (utils.anyIsError(cost, salvage, life, period, factor)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative or if factor is null
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Compute depreciation
	  var total = 0;
	  var current = 0;
	  for (var i = 1; i <= period; i++) {
	    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));
	    total += current;
	  }

	  // Return depreciation
	  return current;
	};

	// TODO
	exports.DISC = function() {
	 throw new Error('DISC is not implemented');
	};

	exports.DOLLARDE = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;

	  // Round result
	  var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
	  result = Math.round(result * power) / power;

	  // Return converted dollar price
	  return result;
	};

	exports.DOLLARFR = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;

	  // Return converted dollar price
	  return result;
	};

	// TODO
	exports.DURATION = function() {
	 throw new Error('DURATION is not implemented');
	};

	exports.EFFECT = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return effective annual interest rate
	  return Math.pow(1 + rate / periods, periods) - 1;
	};

	exports.FV = function(rate, periods, payment, value, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  value = value || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  value = utils.parseNumber(value);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, value, type)) {
	    return error.value;
	  }

	  // Return future value
	  var result;
	  if (rate === 0) {
	    result = value + payment * periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = value * term + payment * (1 + rate) * (term - 1) / rate;
	    } else {
	      result = value * term + payment * (term - 1) / rate;
	    }
	  }
	  return -result;
	};

	exports.FVSCHEDULE = function(principal, schedule) {
	  principal = utils.parseNumber(principal);
	  schedule = utils.parseNumberArray(utils.flatten(schedule));
	  if (utils.anyIsError(principal, schedule)) {
	    return error.value;
	  }

	  var n = schedule.length;
	  var future = principal;

	  // Apply all interests in schedule
	  for (var i = 0; i < n; i++) {
	    // Apply scheduled interest
	    future *= 1 + schedule[i];
	  }

	  // Return future value
	  return future;
	};

	// TODO
	exports.INTRATE = function() {
	 throw new Error('INTRATE is not implemented');
	};

	exports.IPMT = function(rate, period, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, period, periods, present, future, type)) {
	    return error.value;
	  }

	  // Compute payment
	  var payment = exports.PMT(rate, periods, present, future, type);

	  // Compute interest
	  var interest;
	  if (period === 1) {
	    if (type === 1) {
	      interest = 0;
	    } else {
	      interest = -present;
	    }
	  } else {
	    if (type === 1) {
	      interest = exports.FV(rate, period - 2, payment, present, 1) - payment;
	    } else {
	      interest = exports.FV(rate, period - 1, payment, present, 0);
	    }
	  }

	  // Return interest
	  return interest * rate;
	};

	exports.IRR = function(values, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  guess = guess || 0;

	  values = utils.parseNumberArray(utils.flatten(values));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = (dates[i] - dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Initialize dates and check that values contains at least one positive value and one negative value
	  var dates = [];
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = (guess === undefined) ? 0.1 : guess;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.ISPMT = function(rate, period, periods, value) {
	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, period, periods, value)) {
	    return error.value;
	  }

	  // Return interest
	  return value * rate * (period / periods - 1);
	};

	// TODO
	exports.MDURATION = function() {
	 throw new Error('MDURATION is not implemented');
	};

	exports.MIRR = function(values, finance_rate, reinvest_rate) {
	  values = utils.parseNumberArray(utils.flatten(values));
	  finance_rate = utils.parseNumber(finance_rate);
	  reinvest_rate = utils.parseNumber(reinvest_rate);
	  if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
	    return error.value;
	  }

	  // Initialize number of values
	  var n = values.length;

	  // Lookup payments (negative values) and incomes (positive values)
	  var payments = [];
	  var incomes = [];
	  for (var i = 0; i < n; i++) {
	    if (values[i] < 0) {
	      payments.push(values[i]);
	    } else {
	      incomes.push(values[i]);
	    }
	  }

	  // Return modified internal rate of return
	  var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
	  var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);
	  return Math.pow(num / den, 1 / (n - 1)) - 1;
	};

	exports.NOMINAL = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return nominal annual interest rate
	  return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
	};

	exports.NPER = function(rate, payment, present, future, type) {
	  type = (type === undefined) ? 0 : type;
	  future = (future === undefined) ? 0 : future;

	  rate = utils.parseNumber(rate);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, payment, present, future, type)) {
	    return error.value;
	  }

	  // Return number of periods
	  var num = payment * (1 + rate * type) - future * rate;
	  var den = (present * rate + payment * (1 + rate * type));
	  return Math.log(num / den) / Math.log(1 + rate);
	};

	exports.NPV = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }

	  // Lookup rate
	  var rate = args[0];

	  // Initialize net present value
	  var value = 0;

	  // Loop on all values
	  for (var j = 1; j < args.length; j++) {
	    value += args[j] / Math.pow(1 + rate, j);
	  }

	  // Return net present value
	  return value;
	};

	// TODO
	exports.ODDFPRICE = function() {
	 throw new Error('ODDFPRICE is not implemented');
	};

	// TODO
	exports.ODDFYIELD = function() {
	 throw new Error('ODDFYIELD is not implemented');
	};

	// TODO
	exports.ODDLPRICE = function() {
	 throw new Error('ODDLPRICE is not implemented');
	};

	// TODO
	exports.ODDLYIELD = function() {
	 throw new Error('ODDLYIELD is not implemented');
	};

	exports.PDURATION = function(rate, present, future) {
	  rate = utils.parseNumber(rate);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(rate, present, future)) {
	    return error.value;
	  }

	  // Return error if rate <=0
	  if (rate <= 0) {
	    return error.num;
	  }

	  // Return number of periods
	  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
	};

	exports.PMT = function(rate, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  // Return payment
	  var result;
	  if (rate === 0) {
	    result = (present + future) / periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
	    } else {
	      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
	    }
	  }
	  return -result;
	};

	exports.PPMT = function(rate, period, periods, present, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);
	};

	// TODO
	exports.PRICE = function() {
	 throw new Error('PRICE is not implemented');
	};

	// TODO
	exports.PRICEDISC = function() {
	 throw new Error('PRICEDISC is not implemented');
	};

	// TODO
	exports.PRICEMAT = function() {
	 throw new Error('PRICEMAT is not implemented');
	};

	exports.PV = function(rate, periods, payment, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, future, type)) {
	    return error.value;
	  }

	  // Return present value
	  if (rate === 0) {
	    return -payment * periods - future;
	  } else {
	    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
	  }
	};

	exports.RATE = function(periods, payment, present, future, type, guess) {
	  // Credits: rabugento

	  guess = (guess === undefined) ? 0.01 : guess;
	  future = (future === undefined) ? 0 : future;
	  type = (type === undefined) ? 0 : type;

	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(periods, payment, present, future, type, guess)) {
	    return error.value;
	  }

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-6;

	  // Set maximum number of iterations
	  var iterMax = 100;
	  var iter = 0;
	  var close = false;
	  var rate = guess;

	  while (iter < iterMax && !close) {
	    var t1 = Math.pow(rate + 1, periods);
	    var t2 = Math.pow(rate + 1, periods - 1);

	    var f1 = future + t1 * present + payment * (t1 - 1) * (rate * type + 1) / rate;
	    var f2 = periods * t2 * present - payment * (t1 - 1) *(rate * type + 1) / Math.pow(rate,2);
	    var f3 = periods * payment * t2 * (rate * type + 1) / rate + payment * (t1 - 1) * type / rate;

	    var newRate = rate - f1 / (f2 + f3);

	    if (Math.abs(newRate - rate) < epsMax) close = true;
	    iter++
	    rate = newRate;
	  }

	  if (!close) return Number.NaN + rate;
	  return rate;
	};

	// TODO
	exports.RECEIVED = function() {
	 throw new Error('RECEIVED is not implemented');
	};

	exports.RRI = function(periods, present, future) {
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(periods, present, future)) {
	    return error.value;
	  }

	  // Return error if periods or present is equal to 0 (zero)
	  if (periods === 0 || present === 0) {
	    return error.num;
	  }

	  // Return equivalent interest rate
	  return Math.pow(future / present, 1 / periods) - 1;
	};

	exports.SLN = function(cost, salvage, life) {
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  if (utils.anyIsError(cost, salvage, life)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return straight-line depreciation
	  return (cost - salvage) / life;
	};

	exports.SYD = function(cost, salvage, life, period) {
	  // Return error if any of the parameters is not a number
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  if (utils.anyIsError(cost, salvage, life, period)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return error if period is lower than 1 or greater than life
	  if (period < 1 || period > life) {
	    return error.num;
	  }

	  // Truncate period if it is not an integer
	  period = parseInt(period, 10);

	  // Return straight-line depreciation
	  return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));
	};

	exports.TBILLEQ = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (365 * discount) / (360 - discount * dateTime.DAYS360(settlement, maturity, false));
	};

	exports.TBILLPRICE = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);
	};

	exports.TBILLYIELD = function(settlement, maturity, price) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  price = utils.parseNumber(price);
	  if (utils.anyIsError(settlement, maturity, price)) {
	    return error.value;
	  }

	  // Return error if price is lower than or equal to zero
	  if (price <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));
	};

	// TODO
	exports.VDB = function() {
	 throw new Error('VDB is not implemented');
	};


	exports.XIRR = function(values, dates, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, dates, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, dateTime.DAYS(dates[i], dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = dateTime.DAYS(dates[i], dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Check that values contains at least one positive value and one negative value
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = guess || 0.1;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.XNPV = function(rate, values, dates) {
	  rate = utils.parseNumber(rate);
	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  if (utils.anyIsError(rate, values, dates)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = 0; i < values.length; i++) {
	    result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);
	  }
	  return result;
	};

	// TODO
	exports.YIELD = function() {
	 throw new Error('YIELD is not implemented');
	};

	// TODO
	exports.YIELDDISC = function() {
	 throw new Error('YIELDDISC is not implemented');
	};

	// TODO
	exports.YIELDMAT = function() {
	 throw new Error('YIELDMAT is not implemented');
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	exports.MATCH = function(lookupValue, lookupArray, matchType) {
	  if (!lookupValue && !lookupArray) {
	    return error.na;
	  }

	  if (arguments.length === 2) {
	    matchType = 1;
	  }
	  if (!(lookupArray instanceof Array)) {
	    return error.na;
	  }

	  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
	    return error.na;
	  }
	  var index;
	  var indexValue;
	  for (var idx = 0; idx < lookupArray.length; idx++) {
	    if (matchType === 1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] < lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] > indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    } else if (matchType === 0) {
	      if (typeof lookupValue === 'string') {
	        lookupValue = lookupValue.replace(/\?/g, '.');
	        if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
	          return idx + 1;
	        }
	      } else {
	        if (lookupArray[idx] === lookupValue) {
	          return idx + 1;
	        }
	      }
	    } else if (matchType === -1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] > lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] < indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    }
	  }

	  return index ? index : error.na;
	};

/***/ }
/******/ ])
});
;
},{"jStat":354,"numeral":355,"numeric":356}],345:[function(require,module,exports){
exports.nil = new Error('#NULL!');
exports.div0 = new Error('#DIV/0!');
exports.value = new Error('#VALUE?');
exports.ref = new Error('#REF!');
exports.name = new Error('#NAME?');
exports.num = new Error('#NUM!');
exports.na = new Error('#N/A');
exports.error = new Error('#ERROR!');
exports.data = new Error('#GETTING_DATA');

},{}],346:[function(require,module,exports){
var error = require('./error');

function flattenShallow(array) {
  if (!array || !array.reduce) { return array; }
  return array.reduce(function(a, b) {
    var aIsArray = Array.isArray(a);
    var bIsArray = Array.isArray(b);
    if (aIsArray && bIsArray ) {
      return a.concat(b);
    }
    if (aIsArray) {
      a.push(b);
      return a;
    }
    if (bIsArray) {
      return [a].concat(b);
    }
    return [a, b];
  });
}

function isFlat(array) {
  if (!array) { return false; }
  for (var i = 0; i < array.length; ++i) {
    if (Array.isArray(array[i])) {
      return false;
    }
  }
  return true;
}

exports.flatten = function() {
  var result = exports.argsToArray.apply(null, arguments);
  while (!isFlat(result)) {
    result = flattenShallow(result);
  }
  return result;
};

exports.argsToArray = function(args) {
  return Array.prototype.slice.call(args, 0);
};

exports.numbers = function() {
  var possibleNumbers = this.flatten.apply(null, arguments);
  return possibleNumbers.filter(function(el) {
    return typeof el === 'number';
  });
};

exports.cleanFloat = function(number) {
  var power = 1e14;
  return Math.round(number * power) / power;
};

exports.parseBool = function(bool) {
  if (typeof bool === 'boolean') {
    return bool;
  }

  if (bool instanceof Error) {
    return bool;
  }

  if (typeof bool === 'number') {
    return bool !== 0;
  }

  if (typeof bool === 'string') {
    var up = bool.toUpperCase();
    if (up === 'TRUE') {
      return true;
    }

    if (up === 'FALSE') {
      return false;
    }
  }

  if (bool instanceof Date && !isNaN(bool)) {
    return true;
  }

  return error.value;
};

exports.parseNumber = function(string) {
  if (string === undefined || string === '') {
    return error.value;
  }
  if (!isNaN(string)) {
    return parseFloat(string);
  }
  return error.value;
};

exports.parseNumberArray = function(arr) {
  var len;
  if (!arr || (len = arr.length) === 0) {
    return error.value;
  }
  var parsed;
  while (len--) {
    parsed = exports.parseNumber(arr[len]);
    if (parsed === error.value) {
      return parsed;
    }
    arr[len] = parsed;
  }
  return arr;
};

exports.parseMatrix = function(matrix) {
  var n;
  if (!matrix || (n = matrix.length) === 0) {
    return error.value;
  }
  var pnarr;
  for (var i = 0; i < matrix.length; i++) {
    pnarr = exports.parseNumberArray(matrix[i]);
    matrix[i] = pnarr;
    if (pnarr instanceof Error) {
      return pnarr;
    }
  }
  return matrix;
};

var d1900 = new Date(1900, 0, 1);
exports.parseDate = function(date) {
  if (!isNaN(date)) {
    if (date instanceof Date) {
      return new Date(date);
    }
    var d = parseInt(date, 10);
    if (d < 0) {
      return error.num;
    }
    if (d <= 60) {
      return new Date(d1900.getTime() + (d - 1) * 86400000);
    }
    return new Date(d1900.getTime() + (d - 2) * 86400000);
  }
  if (typeof date === 'string') {
    date = new Date(date);
    if (!isNaN(date)) {
      return date;
    }
  }
  return error.value;
};

exports.parseDateArray = function(arr) {
  var len = arr.length;
  var parsed;
  while (len--) {
    parsed = this.parseDate(arr[len]);
    if (parsed === error.value) {
      return parsed;
    }
    arr[len] = parsed;
  }
  return arr;
};

exports.anyIsError = function() {
  var n = arguments.length;
  while (n--) {
    if (arguments[n] instanceof Error) {
      return true;
    }
  }
  return false;
};

exports.arrayValuesToNumbers = function(arr) {
  var n = arr.length;
  var el;
  while (n--) {
    el = arr[n];
    if (typeof el === 'number') {
      continue;
    }
    if (el === true) {
      arr[n] = 1;
      continue;
    }
    if (el === false) {
      arr[n] = 0;
      continue;
    }
    if (typeof el === 'string') {
      var number = this.parseNumber(el);
      if (number instanceof Error) {
        arr[n] = 0;
      } else {
        arr[n] = number;
      }
    }
  }
  return arr;
};

exports.rest = function(array, idx) {
  idx = idx || 1;
  if (!array || typeof array.slice !== 'function') {
    return array;
  }
  return array.slice(idx);
};

exports.initial = function(array, idx) {
  idx = idx || 1;
  if (!array || typeof array.slice !== 'function') {
    return array;
  }
  return array.slice(0, array.length - idx);
};
},{"./error":345}],347:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],348:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":347}],349:[function(require,module,exports){
var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":348}],350:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFn(value) {
	try {
		var fnStr = fnToStr.call(value);
		var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
		var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
		var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
		return constructorRegex.test(spaceStripped);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionObject(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],351:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],352:[function(require,module,exports){
'use strict';

var has = require('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":349}],353:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') { return false; }
		return symStringRegex.test(symToStr.call(value));
	};
	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') { return true; }
		if (toStr.call(value) !== '[object Symbol]') { return false; }
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {
	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false;
	};
}

},{}],354:[function(require,module,exports){
this.j$ = this.jStat = (function(Math, undefined) {

// For quick reference.
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Calculate correction for IEEE error
// TODO: This calculation can be improved.
function calcRdx(n, m) {
  var val = n > m ? n : m;
  return Math.pow(10,
                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
}


var isArray = Array.isArray || function isArray(arg) {
  return toString.call(arg) === '[object Array]';
};


function isFunction(arg) {
  return toString.call(arg) === '[object Function]';
}


function isNumber(arg) {
  return typeof arg === 'number' && arg === arg;
}


// Converts the jStat matrix to vector.
function toVector(arr) {
  return concat.apply([], arr);
}


// The one and only jStat constructor.
function jStat() {
  return new jStat._init(arguments);
}


// TODO: Remove after all references in src files have been removed.
jStat.fn = jStat.prototype;


// By separating the initializer from the constructor it's easier to handle
// always returning a new instance whether "new" was used or not.
jStat._init = function _init(args) {
  var i;

  // If first argument is an array, must be vector or matrix.
  if (isArray(args[0])) {
    // Check if matrix.
    if (isArray(args[0][0])) {
      // See if a mapping function was also passed.
      if (isFunction(args[1]))
        args[0] = jStat.map(args[0], args[1]);
      // Iterate over each is faster than this.push.apply(this, args[0].
      for (i = 0; i < args[0].length; i++)
        this[i] = args[0][i];
      this.length = args[0].length;

    // Otherwise must be a vector.
    } else {
      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
      this.length = 1;
    }

  // If first argument is number, assume creation of sequence.
  } else if (isNumber(args[0])) {
    this[0] = jStat.seq.apply(null, args);
    this.length = 1;

  // Handle case when jStat object is passed to jStat.
  } else if (args[0] instanceof jStat) {
    // Duplicate the object and pass it back.
    return jStat(args[0].toArray());

  // Unexpected argument value, return empty jStat object.
  // TODO: This is strange behavior. Shouldn't this throw or some such to let
  // the user know they had bad arguments?
  } else {
    this[0] = [];
    this.length = 1;
  }

  return this;
};
jStat._init.prototype = jStat.prototype;
jStat._init.constructor = jStat;


// Utility functions.
// TODO: for internal use only?
jStat.utils = {
  calcRdx: calcRdx,
  isArray: isArray,
  isFunction: isFunction,
  isNumber: isNumber,
  toVector: toVector
};


// Easily extend the jStat object.
// TODO: is this seriously necessary?
jStat.extend = function extend(obj) {
  var i, j;

  if (arguments.length === 1) {
    for (j in obj)
      jStat[j] = obj[j];
    return this;
  }

  for (i = 1; i < arguments.length; i++) {
    for (j in arguments[i])
      obj[j] = arguments[i][j];
  }

  return obj;
};


// Returns the number of rows in the matrix.
jStat.rows = function rows(arr) {
  return arr.length || 1;
};


// Returns the number of columns in the matrix.
jStat.cols = function cols(arr) {
  return arr[0].length || 1;
};


// Returns the dimensions of the object { rows: i, cols: j }
jStat.dimensions = function dimensions(arr) {
  return {
    rows: jStat.rows(arr),
    cols: jStat.cols(arr)
  };
};


// Returns a specified row as a vector
jStat.row = function row(arr, index) {
  return arr[index];
};


// Returns the specified column as a vector
jStat.col = function cols(arr, index) {
  var column = new Array(arr.length);
  for (var i = 0; i < arr.length; i++)
    column[i] = [arr[i][index]];
  return column;
};


// Returns the diagonal of the matrix
jStat.diag = function diag(arr) {
  var nrow = jStat.rows(arr);
  var res = new Array(nrow);
  for (var row = 0; row < nrow; row++)
    res[row] = [arr[row][row]];
  return res;
};


// Returns the anti-diagonal of the matrix
jStat.antidiag = function antidiag(arr) {
  var nrow = jStat.rows(arr) - 1;
  var res = new Array(nrow);
  for (var i = 0; nrow >= 0; nrow--, i++)
    res[i] = [arr[i][nrow]];
  return res;
};

// Transpose a matrix or array.
jStat.transpose = function transpose(arr) {
  var obj = [];
  var objArr, rows, cols, j, i;

  // Make sure arr is in matrix format.
  if (!isArray(arr[0]))
    arr = [arr];

  rows = arr.length;
  cols = arr[0].length;

  for (i = 0; i < cols; i++) {
    objArr = new Array(rows);
    for (j = 0; j < rows; j++)
      objArr[j] = arr[j][i];
    obj.push(objArr);
  }

  // If obj is vector, return only single array.
  return obj.length === 1 ? obj[0] : obj;
};


// Map a function to an array or array of arrays.
// "toAlter" is an internal variable.
jStat.map = function map(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    for (col = 0; col < ncol; col++)
      res[row][col] = func(arr[row][col], row, col);
  }

  return res.length === 1 ? res[0] : res;
};


// Destructively alter an array.
jStat.alter = function alter(arr, func) {
  return jStat.map(arr, func, true);
};


// Generate a rows x cols matrix according to the supplied function.
jStat.create = function  create(rows, cols, func) {
  var res = new Array(rows);
  var i, j;

  if (isFunction(cols)) {
    func = cols;
    cols = rows;
  }

  for (i = 0; i < rows; i++) {
    res[i] = new Array(cols);
    for (j = 0; j < cols; j++)
      res[i][j] = func(i, j);
  }

  return res;
};


function retZero() { return 0; }


// Generate a rows x cols matrix of zeros.
jStat.zeros = function zeros(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retZero);
};


function retOne() { return 1; }


// Generate a rows x cols matrix of ones.
jStat.ones = function ones(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retOne);
};


// Generate a rows x cols matrix of uniformly random numbers.
jStat.rand = function rand(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, Math.random);
};


function retIdent(i, j) { return i === j ? 1 : 0; }


// Generate an identity matrix of size row x cols.
jStat.identity = function identity(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retIdent);
};


// Tests whether a matrix is symmetric
jStat.symmetric = function symmetric(arr) {
  var issymmetric = true;
  var size = arr.length;
  var row, col;

  if (arr.length !== arr[0].length)
    return false;

  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++)
      if (arr[col][row] !== arr[row][col])
        return false;
  }

  return true;
};


// Set all values to zero.
jStat.clear = function clear(arr) {
  return jStat.alter(arr, retZero);
};


// Generate sequence.
jStat.seq = function seq(min, max, length, func) {
  if (!isFunction(func))
    func = false;

  var arr = [];
  var hival = calcRdx(min, max);
  var step = (max * hival - min * hival) / ((length - 1) * hival);
  var current = min;
  var cnt;

  // Current is assigned using a technique to compensate for IEEE error.
  // TODO: Needs better implementation.
  for (cnt = 0;
       current <= max;
       cnt++, current = (min * hival + step * hival * cnt) / hival) {
    arr.push((func ? func(current, cnt) : current));
  }

  return arr;
};


// TODO: Go over this entire implementation. Seems a tragic waste of resources
// doing all this work. Instead, and while ugly, use new Function() to generate
// a custom function for each static method.

// Quick reference.
var jProto = jStat.prototype;

// Default length.
jProto.length = 0;

// For internal use only.
// TODO: Check if they're actually used, and if they are then rename them
// to _*
jProto.push = Array.prototype.push;
jProto.sort = Array.prototype.sort;
jProto.splice = Array.prototype.splice;
jProto.slice = Array.prototype.slice;


// Return a clean array.
jProto.toArray = function toArray() {
  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
};


// Map a function to a matrix or vector.
jProto.map = function map(func, toAlter) {
  return jStat(jStat.map(this, func, toAlter));
};


// Destructively alter an array.
jProto.alter = function alter(func) {
  jStat.alter(this, func);
  return this;
};


// Extend prototype with methods that have no argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(func) {
      var self = this,
      results;
      // Check for callback.
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self));
        });
        return this;
      }
      results = jStat[passfunc](this);
      return isArray(results) ? jStat(results) : results;
    };
  })(funcs[i]);
})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


// Extend prototype with methods that have one argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(index, func) {
      var self = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self, index));
        });
        return this;
      }
      return jStat(jStat[passfunc](this, index));
    };
  })(funcs[i]);
})('row col'.split(' '));


// Extend prototype with simple shortcut methods.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = new Function(
        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');
  })(funcs[i]);
})('create zeros ones rand identity'.split(' '));


// Exposing jStat.
return jStat;

}(Math));
(function(jStat, Math) {

var isFunction = jStat.utils.isFunction;

// Ascending functions for sort
function ascNum(a, b) { return a - b; }

function clip(arg, min, max) {
  return Math.max(min, Math.min(arg, max));
}


// sum of an array
jStat.sum = function sum(arr) {
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};


// sum squared
jStat.sumsqrd = function sumsqrd(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i] * arr[i];
  return sum;
};


// sum of squared errors of prediction (SSE)
jStat.sumsqerr = function sumsqerr(arr) {
  var mean = jStat.mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - mean;
    sum += tmp * tmp;
  }
  return sum;
};


// product of an array
jStat.product = function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0)
    prod *= arr[i];
  return prod;
};


// minimum value of an array
jStat.min = function min(arr) {
  var low = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] < low)
      low = arr[i];
  return low;
};


// maximum value of an array
jStat.max = function max(arr) {
  var high = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] > high)
      high = arr[i];
  return high;
};


// mean value of an array
jStat.mean = function mean(arr) {
  return jStat.sum(arr) / arr.length;
};


// mean squared error (MSE)
jStat.meansqerr = function meansqerr(arr) {
  return jStat.sumsqerr(arr) / arr.length;
};


// geometric mean of an array
jStat.geomean = function geomean(arr) {
  return Math.pow(jStat.product(arr), 1 / arr.length);
};


// median of an array
jStat.median = function median(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  // check if array is even or odd, then return the appropriate
  return !(arrlen & 1)
    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
    : _arr[(arrlen / 2) | 0 ];
};


// cumulative sum of an array
jStat.cumsum = function cumsum(arr) {
  var len = arr.length;
  var sums = new Array(len);
  var i;
  sums[0] = arr[0];
  for (i = 1; i < len; i++)
    sums[i] = sums[i - 1] + arr[i];
  return sums;
};


// successive differences of a sequence
jStat.diff = function diff(arr) {
  var diffs = [];
  var arrLen = arr.length;
  var i;
  for (i = 1; i < arrLen; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
};


// mode of an array
// if there are multiple modes of an array, return all of them
// is this the appropriate way of handling it?
jStat.mode = function mode(arr) {
  var arrLen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  var count = 1;
  var maxCount = 0;
  var numMaxCount = 0;
  var mode_arr = [];
  var i;

  for (i = 0; i < arrLen; i++) {
    if (_arr[i] === _arr[i + 1]) {
      count++;
    } else {
      if (count > maxCount) {
        mode_arr = [_arr[i]];
        maxCount = count;
        numMaxCount = 0;
      }
      // are there multiple max counts
      else if (count === maxCount) {
        mode_arr.push(_arr[i]);
        numMaxCount++;
      }
      // resetting count for new value in array
      count = 1;
    }
  }

  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
};


// range of an array
jStat.range = function range(arr) {
  return jStat.max(arr) - jStat.min(arr);
};

// variance of an array
// flag indicates population vs sample
jStat.variance = function variance(arr, flag) {
  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
};


// standard deviation of an array
// flag indicates population vs sample
jStat.stdev = function stdev(arr, flag) {
  return Math.sqrt(jStat.variance(arr, flag));
};


// mean deviation (mean absolute deviation) of an array
jStat.meandev = function meandev(arr) {
  var devSum = 0;
  var mean = jStat.mean(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - mean);
  return devSum / arr.length;
};


// median deviation (median absolute deviation) of an array
jStat.meddev = function meddev(arr) {
  var devSum = 0;
  var median = jStat.median(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - median);
  return devSum / arr.length;
};


// coefficient of variation
jStat.coeffvar = function coeffvar(arr) {
  return jStat.stdev(arr) / jStat.mean(arr);
};


// quartiles of an array
jStat.quartiles = function quartiles(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  return [
    _arr[ Math.round((arrlen) / 4) - 1 ],
    _arr[ Math.round((arrlen) / 2) - 1 ],
    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
  ];
};


// Arbitary quantiles of an array. Direct port of the scipy.stats
// implementation by Pierre GF Gerard-Marchant.
jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
  var sortedArray = arr.slice().sort(ascNum);
  var quantileVals = [quantilesArray.length];
  var n = arr.length;
  var i, p, m, aleph, k, gamma;

  if (typeof alphap === 'undefined')
    alphap = 3 / 8;
  if (typeof betap === 'undefined')
    betap = 3 / 8;

  for (i = 0; i < quantilesArray.length; i++) {
    p = quantilesArray[i];
    m = alphap + p * (1 - alphap - betap);
    aleph = n * p + m;
    k = Math.floor(clip(aleph, 1, n - 1));
    gamma = clip(aleph - k, 0, 1);
    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
  }

  return quantileVals;
};

// The percentile rank of score in a given array. Returns the percentage
// of all values in the input array that are less than (kind='strict') or
// less or equal than (kind='weak') score. Default is weak.
jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
  var counter = 0;
  var len = arr.length;
  var strict = false;
  var value, i;

  if (kind === 'strict')
    strict = true;

  for (i = 0; i < len; i++) {
    value = arr[i];
    if ((strict && value < score) ||
        (!strict && value <= score)) {
      counter++;
    }
  }

  return counter / len;
};

// covariance of two arrays
jStat.covariance = function covariance(arr1, arr2) {
  var u = jStat.mean(arr1);
  var v = jStat.mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;

  for (i = 0; i < arr1Len; i++)
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

  return jStat.sum(sq_dev) / (arr1Len - 1);
};


// (pearson's) population correlation coefficient, rho
jStat.corrcoeff = function corrcoeff(arr1, arr2) {
  return jStat.covariance(arr1, arr2) /
      jStat.stdev(arr1, 1) /
      jStat.stdev(arr2, 1);
};


var jProto = jStat.prototype;


// Extend jProto with method for calculating cumulative sums, as it does not
// run again in case of true.
// If a matrix is passed, automatically assume operation should be done on the
// columns.
jProto.cumsum = function(fullbool, func) {
  var arr = [];
  var i = 0;
  var tmpthis = this;

  // Assignment reassignation depending on how parameters were passed in.
  if (isFunction(fullbool)) {
    func = fullbool;
    fullbool = false;
  }

  // Check if a callback was passed with the function.
  if (func) {
    setTimeout(function() {
      func.call(tmpthis, jProto.cumsum.call(tmpthis, fullbool));
    });
    return this;
  }

  // Check if matrix and run calculations.
  if (this.length > 1) {
    tmpthis = fullbool === true ? this : this.transpose();
    for (; i < tmpthis.length; i++)
      arr[i] = jStat.cumsum(tmpthis[i]);
    return arr;
  }

  return jStat.cumsum(this[0], fullbool);
};


// Extend jProto with methods which don't require arguments and work on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return fullbool === true
            ? jStat[passfunc](jStat.utils.toVector(arr))
            : arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('sum sumsqrd sumsqerr product min max mean meansqerr geomean median diff ' +
    'mode range variance stdev meandev meddev coeffvar quartiles').split(' '));


// Extend jProto with functions that take arguments. Operations on matrices are
// done on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      var args = Array.prototype.slice.call(arguments);

      // If the last argument is a function, we assume it's a callback; we
      // strip the callback out and call the function again.
      if (isFunction(args[args.length - 1])) {
        var callbackFunction = args[args.length - 1];
        var argsToPass = args.slice(0, args.length - 1);

        setTimeout(function() {
          callbackFunction.call(tmpthis,
                                jProto[passfunc].apply(tmpthis, argsToPass));
        });
        return this;

      // Otherwise we curry the function args and call normally.
      } else {
        var callbackFunction = undefined;
        var curriedFunction = function curriedFunction(vector) {
          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
        }
      }

      // If this is a matrix, run column-by-column.
      if (this.length > 1) {
        tmpthis = tmpthis.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = curriedFunction(tmpthis[i]);
        return arr;
      }

      // Otherwise run on the vector.
      return curriedFunction(this[0]);
    };
  })(funcs[i]);
})('quantiles percentileOfScore'.split(' '));

}(this.jStat, Math));
// Special functions //
(function(jStat, Math) {

// Log-gamma function
jStat.gammaln = function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y;
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
};


// gamma of x
jStat.gammafn = function gammafn(x) {
  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
           629.3311553128184, 866.9662027904133, -31451.272968848367,
           -36144.413418691176, 66456.14382024054
  ];
  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
           -134659.9598649693, -115132.2596755535];
  var fact = false;
  var n = 0;
  var xden = 0;
  var xnum = 0;
  var y = x;
  var i, z, yi, res, sum, ysq;
  if (y <= 0) {
    res = y % 1 + 3.6e-16;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
};


// lower incomplete gamma function P(a,x)
jStat.gammap = function gammap(a, x) {
  var aln = jStat.gammaln(a);
  var ap = a;
  var sum = 1 / a;
  var del = sum;
  var b = x + 1 - a;
  var c = 1 / 1.0e-30;
  var d = 1 / b;
  var h = d;
  var i = 1;
  // calculate maximum number of itterations required for a
  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  var an, endval;

  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return sum * Math.exp(-x + a * Math.log(x) - (aln));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }

  return 1 - h * Math.exp(-x + a * Math.log(x) - (aln));
};


// natural log factorial of n
jStat.factorialln = function factorialln(n) {
  return n < 0 ? NaN : jStat.gammaln(n + 1);
};

// factorial of n
jStat.factorial = function factorial(n) {
  return n < 0 ? NaN : jStat.gammafn(n + 1);
};

// combinations of n, m
jStat.combination = function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return (n > 170 || m > 170)
      ? Math.exp(jStat.combinationln(n, m))
      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
};


jStat.combinationln = function combinationln(n, m){
  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
};


// permutations of n, m
jStat.permutation = function permutation(n, m) {
  return jStat.factorial(n) / jStat.factorial(n - m);
};


// beta function
jStat.betafn = function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0)
    return undefined;
  // make sure x + y doesn't exceed the upper limit of usable values
  return (x + y > 170)
      ? Math.exp(jStat.betaln(x, y))
      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
};


// natural logarithm of beta function
jStat.betaln = function betaln(x, y) {
  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
};


// Evaluates the continued fraction for incomplete beta function by modified
// Lentz's method.
jStat.betacf = function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;

  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7)
      break;
  }

  return h;
};


// Returns the inverse incomplte gamma function
jStat.gammapinv = function gammapinv(p, a) {
  var j = 0;
  var a1 = a - 1;
  var EPS = 1e-8;
  var gln = jStat.gammaln(a);
  var x, err, t, u, pp, lna1, afac;

  if (p >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  if (p <= 0)
    return 0;
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    x = Math.max(1e-3,
                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t)
      x = Math.pow(p / t, 1 / a);
    else
      x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for(; j < 12; j++) {
    if (x <= 0)
      return 0;
    err = jStat.gammap(a, x) - p;
    if (a > 1)
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x)
      break;
  }

  return x;
};


// Returns the error function erf(x)
jStat.erf = function erf(x) {
  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
             -6.886027e-12, 8.94487e-13, 3.13092e-13,
             -1.12708e-13, 3.81e-16, 7.106e-15,
             -1.523e-15, -9.4e-17, 1.21e-16,
             -2.8e-17];
  var j = cof.length - 1;
  var isneg = false;
  var d = 0;
  var dd = 0;
  var t, ty, tmp, res;

  if (x < 0) {
    x = -x;
    isneg = true;
  }

  t = 2 / (2 + x);
  ty = 4 * t - 2;

  for(; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }

  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
};


// Returns the complmentary error function erfc(x)
jStat.erfc = function erfc(x) {
  return 1 - jStat.erf(x);
};


// Returns the inverse of the complementary error function
jStat.erfcinv = function erfcinv(p) {
  var j = 0;
  var x, err, t, pp;
  if (p >= 2)
    return -100;
  if (p <= 0)
    return 100;
  pp = (p < 1) ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) /
                  (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = jStat.erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return (p < 1) ? x : -x;
};


// Returns the inverse of the incomplete beta function
jStat.ibetainv = function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
        (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x = Math.pow(a * w * p, 1 / a);
    else
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
  for(; j < 10; j++) {
    if (x === 0 || x === 1)
      return x;
    err = jStat.ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (x >= 1)
      x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0)
      break;
  }
  return x;
};


// Returns the incomplete beta function I_x(a,b)
jStat.ibeta = function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = (x === 0 || x === 1) ?  0 :
    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
             jStat.gammaln(b) + a * Math.log(x) + b *
             Math.log(1 - x));
  if (x < 0 || x > 1)
    return false;
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    return bt * jStat.betacf(x, a, b) / a;
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
};


// Returns a normal deviate (mu=0, sigma=1).
// If n and m are specified it returns a object of normal deviates.
jStat.randn = function randn(n, m) {
  var u, v, x, y, q, mat;
  if (!m)
    m = n;
  if (n)
    return jStat.create(n, m, function() { return jStat.randn(); });
  do {
    u = Math.random();
    v = 1.7156 * (Math.random() - 0.5);
    x = u - 0.449871;
    y = Math.abs(v) + 0.386595;
    q = x * x + y * (0.19600 * y - 0.25472 * x);
  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
  return v / u;
};


// Returns a gamma deviate by the method of Marsaglia and Tsang.
jStat.randg = function randg(shape, n, m) {
  var oalph = shape;
  var a1, a2, u, v, x, mat;
  if (!m)
    m = n;
  if (!shape)
    shape = 1;
  if (n) {
    mat = jStat.zeros(n,m);
    mat.alter(function() { return jStat.randg(shape); });
    return mat;
  }
  if (shape < 1)
    shape += 1;
  a1 = shape - 1 / 3;
  a2 = 1 / Math.sqrt(9 * a1);
  do {
    do {
      x = jStat.randn();
      v = 1 + a2 * x;
    } while(v <= 0);
    v = v * v * v;
    u = Math.random();
  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
  // alpha > 1
  if (shape == oalph)
    return a1 * v;
  // alpha < 1
  do {
    u = Math.random();
  } while(u === 0);
  return Math.pow(u, 1 / oalph) * a1 * v;
};


// making use of static methods on the instance
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(
          jStat.map(this, function(value) { return jStat[passfunc](value); }));
    }
  })(funcs[i]);
})('gammaln gammafn factorial factorialln'.split(' '));


(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('randn'.split(' '));

}(this.jStat, Math));
(function(jStat, Math) {

// generate all distribution instance methods
(function(list) {
  for (var i = 0; i < list.length; i++) (function(func) {
    // distribution instance method
    jStat[func] = function(a, b, c) {
      if (!(this instanceof arguments.callee))
        return new arguments.callee(a, b, c);
      this._a = a;
      this._b = b;
      this._c = c;
      return this;
    };
    // distribution method to be used on a jStat instance
    jStat.fn[func] = function(a, b, c) {
      var newthis = jStat[func](a, b, c);
      newthis.data = this;
      return newthis;
    };
    // sample instance method
    jStat[func].prototype.sample = function(arr) {
      var a = this._a;
      var b = this._b;
      var c = this._c;
      if (arr)
        return jStat.alter(arr, function() {
          return jStat[func].sample(a, b, c);
        });
      else
        return jStat[func].sample(a, b, c);
    };
    // generate the pdf, cdf and inv instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function(x) {
          var a = this._a;
          var b = this._b;
          var c = this._c;
          if (!x && x !== 0)
            x = this.data;
          if (typeof x !== 'number') {
            return jStat.fn.map.call(x, function(x) {
              return jStat[func][fnfunc](x, a, b, c);
            });
          }
          return jStat[func][fnfunc](x, a, b, c);
        };
      })(vals[i]);
    })('pdf cdf inv'.split(' '));
    // generate the mean, median, mode and variance instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function() {
          return jStat[func][fnfunc](this._a, this._b, this._c);
        };
      })(vals[i]);
    })('mean median mode variance'.split(' '));
  })(list[i]);
})((
  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
  'lognormal normal pareto studentt weibull uniform  binomial negbin hypgeom ' +
  'poisson triangular'
).split(' '));



// extend beta function with static methods
jStat.extend(jStat.beta, {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0)
      return 0;
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1)
      return 1;

    if (alpha < 512 || beta < 512) {
      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
          jStat.betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) +
                      (beta - 1) * Math.log(1 - x) -
                      jStat.betaln(alpha, beta));
    }
  },

  cdf: function cdf(x, alpha, beta) {
    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
  },

  inv: function inv(x, alpha, beta) {
    return jStat.ibetainv(x, alpha, beta);
  },

  mean: function mean(alpha, beta) {
    return alpha / (alpha + beta);
  },

  median: function median(alpha, beta) {
    throw new Error('median not yet implemented');
  },

  mode: function mode(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  },

  // return a random sample
  sample: function sample(alpha, beta) {
    var u = jStat.randg(alpha);
    return u / (u + jStat.randg(beta));
  },

  variance: function variance(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  }
});

// extend F function with static methods
jStat.extend(jStat.centralF, {
  pdf: function pdf(x, df1, df2) {
    if (x < 0)
      return undefined;
    return Math.sqrt((Math.pow(df1 * x, df1) * Math.pow(df2, df2)) /
                     (Math.pow(df1 * x + df2, df1 + df2))) /
                     (x * jStat.betafn(df1/2, df2/2));

  },

  cdf: function cdf(x, df1, df2) {
    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
  },

  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
  },

  mean: function mean(df1, df2) {
    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
  },

  mode: function mode(df1, df2) {
    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
  },

  // return a random sample
  sample: function sample(df1, df2) {
    var x1 = jStat.randg(df1 / 2) * 2;
    var x2 = jStat.randg(df2 / 2) * 2;
    return (x1 / df1) / (x2 / df2);
  },

  variance: function variance(df1, df2) {
    if (df2 <= 4)
      return undefined;
    return 2 * df2 * df2 * (df1 + df2 - 2) /
        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
  }
});


// extend cauchy function with static methods
jStat.extend(jStat.cauchy, {
  pdf: function pdf(x, local, scale) {
    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
  },

  cdf: function cdf(x, local, scale) {
    return Math.atan((x - local) / scale) / Math.PI + 0.5;
  },

  inv: function(p, local, scale) {
    return local + scale * Math.tan(Math.PI * (p - 0.5));
  },

  median: function median(local, scale) {
    return local;
  },

  mode: function mode(local, scale) {
    return local;
  },

  sample: function sample(local, scale) {
    return jStat.randn() *
        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
  }
});



// extend chisquare function with static methods
jStat.extend(jStat.chisquare, {
  pdf: function pdf(x, dof) {
    return Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
                    Math.log(2) - jStat.gammaln(dof / 2));
  },

  cdf: function cdf(x, dof) {
    return jStat.gammap(dof / 2, x / 2);
  },

  inv: function(p, dof) {
    return 2 * jStat.gammapinv(p, 0.5 * dof);
  },

  mean : function(dof) {
    return dof;
  },

  // TODO: this is an approximation (is there a better way?)
  median: function median(dof) {
    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
  },

  mode: function mode(dof) {
    return (dof - 2 > 0) ? dof - 2 : 0;
  },

  sample: function sample(dof) {
    return jStat.randg(dof / 2) * 2;
  },

  variance: function variance(dof) {
    return 2 * dof;
  }
});



// extend exponential function with static methods
jStat.extend(jStat.exponential, {
  pdf: function pdf(x, rate) {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },

  cdf: function cdf(x, rate) {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  },

  inv: function(p, rate) {
    return -Math.log(1 - p) / rate;
  },

  mean : function(rate) {
    return 1 / rate;
  },

  median: function (rate) {
    return (1 / rate) * Math.log(2);
  },

  mode: function mode(rate) {
    return 0;
  },

  sample: function sample(rate) {
    return -1 / rate * Math.log(Math.random());
  },

  variance : function(rate) {
    return Math.pow(rate, -2);
  }
});



// extend gamma function with static methods
jStat.extend(jStat.gamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp((shape - 1) * Math.log(x) - x / scale -
                    jStat.gammaln(shape) - shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return jStat.gammap(shape, x / scale);
  },

  inv: function(p, shape, scale) {
    return jStat.gammapinv(p, shape) * scale;
  },

  mean : function(shape, scale) {
    return shape * scale;
  },

  mode: function mode(shape, scale) {
    if(shape > 1) return (shape - 1) * scale;
    return undefined;
  },

  sample: function sample(shape, scale) {
    return jStat.randg(shape) * scale;
  },

  variance: function variance(shape, scale) {
    return shape * scale * scale;
  }
});

// extend inverse gamma function with static methods
jStat.extend(jStat.invgamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
                    jStat.gammaln(shape) + shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return 1 - jStat.gammap(shape, scale / x);
  },

  inv: function(p, shape, scale) {
    return scale / jStat.gammapinv(1 - p, shape);
  },

  mean : function(shape, scale) {
    return (shape > 1) ? scale / (shape - 1) : undefined;
  },

  mode: function mode(shape, scale) {
    return scale / (shape + 1);
  },

  sample: function sample(shape, scale) {
    return scale / jStat.randg(shape);
  },

  variance: function variance(shape, scale) {
    if (shape <= 2)
      return undefined;
    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
  }
});


// extend kumaraswamy function with static methods
jStat.extend(jStat.kumaraswamy, {
  pdf: function pdf(x, alpha, beta) {
    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
                    Math.log(x) + (beta - 1) *
                    Math.log(1 - Math.pow(x, alpha)));
  },

  cdf: function cdf(x, alpha, beta) {
    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
  },

  mean : function(alpha, beta) {
    return (beta * jStat.gammafn(1 + 1 / alpha) *
            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
  },

  median: function median(alpha, beta) {
    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
  },

  mode: function mode(alpha, beta) {
    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
      return undefined;
    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
  },

  variance: function variance(alpha, beta) {
    throw new Error('variance not yet implemented');
    // TODO: complete this
  }
});



// extend lognormal function with static methods
jStat.extend(jStat.lognormal, {
  pdf: function pdf(x, mu, sigma) {
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
                    (2 * sigma * sigma));
  },

  cdf: function cdf(x, mu, sigma) {
    return 0.5 +
        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
  },

  inv: function(p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
  },

  mean: function mean(mu, sigma) {
    return Math.exp(mu + sigma * sigma / 2);
  },

  median: function median(mu, sigma) {
    return Math.exp(mu);
  },

  mode: function mode(mu, sigma) {
    return Math.exp(mu - sigma * sigma);
  },

  sample: function sample(mu, sigma) {
    return Math.exp(jStat.randn() * sigma + mu);
  },

  variance: function variance(mu, sigma) {
    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
  }
});



// extend normal function with static methods
jStat.extend(jStat.normal, {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },

  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
  },

  inv: function(p, mean, std) {
    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
  },

  mean : function(mean, std) {
    return mean;
  },

  median: function median(mean, std) {
    return mean;
  },

  mode: function (mean, std) {
    return mean;
  },

  sample: function sample(mean, std) {
    return jStat.randn() * std + mean;
  },

  variance : function(mean, std) {
    return std * std;
  }
});



// extend pareto function with static methods
jStat.extend(jStat.pareto, {
  pdf: function pdf(x, scale, shape) {
    if (x <= scale)
      return undefined;
    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
  },

  cdf: function cdf(x, scale, shape) {
    return 1 - Math.pow(scale / x, shape);
  },

  mean: function mean(scale, shape) {
    if (shape <= 1)
      return undefined;
    return (shape * Math.pow(scale, shape)) / (shape - 1);
  },

  median: function median(scale, shape) {
    return scale * (shape * Math.SQRT2);
  },

  mode: function mode(scale, shape) {
    return scale;
  },

  variance : function(scale, shape) {
    if (shape <= 2)
      return undefined;
    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
  }
});



// extend studentt function with static methods
jStat.extend(jStat.studentt, {
  pdf: function pdf(x, dof) {
    return (jStat.gammafn((dof + 1) / 2) / (Math.sqrt(dof * Math.PI) *
        jStat.gammafn(dof / 2))) *
        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
  },

  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },

  inv: function(p, dof) {
    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return (p > 0.5) ? x : -x;
  },

  mean: function mean(dof) {
    return (dof > 1) ? 0 : undefined;
  },

  median: function median(dof) {
    return 0;
  },

  mode: function mode(dof) {
    return 0;
  },

  sample: function sample(dof) {
    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
  },

  variance: function variance(dof) {
    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
  }
});



// extend weibull function with static methods
jStat.extend(jStat.weibull, {
  pdf: function pdf(x, scale, shape) {
    if (x < 0)
      return 0;
    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
        Math.exp(-(Math.pow((x / scale), shape)));
  },

  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
  },

  inv: function(p, scale, shape) {
    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
  },

  mean : function(scale, shape) {
    return scale * jStat.gammafn(1 + 1 / shape);
  },

  median: function median(scale, shape) {
    return scale * Math.pow(Math.log(2), 1 / shape);
  },

  mode: function mode(scale, shape) {
    if (shape <= 1)
      return undefined;
    return scale * Math.pow((shape - 1) / shape, 1 / shape);
  },

  sample: function sample(scale, shape) {
    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);
  },

  variance: function variance(scale, shape) {
    return scale * scale * jStat.gammafn(1 + 2 / shape) -
        Math.pow(this.mean(scale, shape), 2);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.uniform, {
  pdf: function pdf(x, a, b) {
    return (x < a || x > b) ? 0 : 1 / (b - a);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (x - a) / (b - a);
    return 1;
  },

  mean: function mean(a, b) {
    return 0.5 * (a + b);
  },

  median: function median(a, b) {
    return jStat.mean(a, b);
  },

  mode: function mode(a, b) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);
  },

  variance: function variance(a, b) {
    return Math.pow(b - a, 2) / 12;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.binomial, {
  pdf: function pdf(k, n, p) {
    return (p === 0 || p === 1) ?
      ((n * p) === k ? 1 : 0) :
      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },

  cdf: function cdf(x, n, p) {
    var binomarr = [],
    k = 0;
    if (x < 0) {
      return 0;
    }
    if (x < n) {
      for (; k <= x; k++) {
        binomarr[ k ] = jStat.binomial.pdf(k, n, p);
      }
      return jStat.sum(binomarr);
    }
    return 1;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.negbin, {
  pdf: function pdf(k, r, p) {
    return k !== k | 0
      ? false
      : k < 0
        ? 0
        : jStat.combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },

  cdf: function cdf(x, r, p) {
    var sum = 0,
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sum += jStat.negbin.pdf(k, r, p);
    }
    return sum;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.hypgeom, {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.

    // A simplification of the CDF algorithm below.

    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(k !== k | 0) {
      return false;
    } else if(k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if(k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return jStat.hypgeom.pdf(n - k, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return jStat.hypgeom.pdf(m - k, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...

        while(scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          scaledPDF *= 1 - (m / (N - samplesDone));

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },

  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.

    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if(x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...

        while(scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          var factor = 1 - (m / (N - samplesDone));

          scaledPDF *= factor;
          scaledCDF *= factor;

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
});



// extend uniform function with static methods
jStat.extend(jStat.poisson, {
  pdf: function pdf(k, l) {
    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
  },

  cdf: function cdf(x, l) {
    var sumarr = [],
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sumarr.push(jStat.poisson.pdf(k, l));
    }
    return jStat.sum(sumarr);
  },

  mean : function(l) {
    return l;
  },

  variance : function(l) {
    return l;
  },

  sample: function sample(l) {
    var p = 1, k = 0, L = Math.exp(-l);
    do {
      k++;
      p *= Math.random();
    } while (p > L);
    return k - 1;
  }
});

// extend triangular function with static methods
jStat.extend(jStat.triangular, {
  pdf: function pdf(x, a, b, c) {
    return (b <= a || c < a || c > b)
      ? undefined
      : (x < a || x > b)
        ? 0
        : (x <= c)
          ? (2 * (x - a)) / ((b - a) * (c - a))
          : (2 * (b - x)) / ((b - a) * (b - c));
  },

  cdf: function cdf(x, a, b, c) {
    if (b <= a || c < a || c > b)
      return undefined;
    if (x < a) {
      return 0;
    } else {
      if (x <= c)
        return Math.pow(x - a, 2) / ((b - a) * (c - a));
      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
    }
    // never reach this
    return 1;
  },

  mean: function mean(a, b, c) {
    return (a + b + c) / 3;
  },

  median: function median(a, b, c) {
    if (c <= (a + b) / 2) {
      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
    } else if (c > (a + b) / 2) {
      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
    }
  },

  mode: function mode(a, b, c) {
    return c;
  },

  sample: function sample(a, b, c) {
    var u = Math.random();
    if (u < ((c - a) / (b - a)))
      return a + Math.sqrt(u * (b - a) * (c - a))
    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
  },

  variance: function variance(a, b, c) {
    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
  }
});

}(this.jStat, Math));
/* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

(function(jStat, Math) {

var push = Array.prototype.push;
var isArray = jStat.utils.isArray;

jStat.extend({

  // add a vector/matrix to a vector/matrix or scalar
  add: function add(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value + arg[row][col];
      });
    }
    return jStat.map(arr, function(value) { return value + arg; });
  },

  // subtract a vector or scalar from the vector
  subtract: function subtract(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value - arg[row][col] || 0;
      });
    }
    return jStat.map(arr, function(value) { return value - arg; });
  },

  // matrix division
  divide: function divide(arr, arg) {
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.multiply(arr, jStat.inv(arg));
    }
    return jStat.map(arr, function(value) { return value / arg; });
  },

  // matrix multiplication
  multiply: function multiply(arr, arg) {
    var row, col, nrescols, sum,
    nrow = arr.length,
    ncol = arr[0].length,
    res = jStat.zeros(nrow, nrescols = (isArray(arg)) ? arg[0].length : ncol),
    rescols = 0;
    if (isArray(arg)) {
      for (; rescols < nrescols; rescols++) {
        for (row = 0; row < nrow; row++) {
          sum = 0;
          for (col = 0; col < ncol; col++)
          sum += arr[row][col] * arg[col][rescols];
          res[row][rescols] = sum;
        }
      }
      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
    }
    return jStat.map(arr, function(value) { return value * arg; });
  },

  // Returns the dot product of two matricies
  dot: function dot(arr, arg) {
    if (!isArray(arr[0])) arr = [ arr ];
    if (!isArray(arg[0])) arg = [ arg ];
    // convert column to row vector
    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
    res = [],
    row = 0,
    nrow = left.length,
    ncol = left[0].length,
    sum, col;
    for (; row < nrow; row++) {
      res[row] = [];
      sum = 0;
      for (col = 0; col < ncol; col++)
      sum += left[row][col] * right[row][col];
      res[row] = sum;
    }
    return (res.length === 1) ? res[0] : res;
  },

  // raise every element by a scalar
  pow: function pow(arr, arg) {
    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
  },

  // generate the absolute values of the vector
  abs: function abs(arr) {
    return jStat.map(arr, function(value) { return Math.abs(value); });
  },

  // computes the p-norm of the vector
  // In the case that a matrix is passed, uses the first row as the vector
  norm: function norm(arr, p) {
    var nnorm = 0,
    i = 0;
    // check the p-value of the norm, and set for most common case
    if (isNaN(p)) p = 2;
    // check if multi-dimensional array, and make vector correction
    if (isArray(arr[0])) arr = arr[0];
    // vector norm
    for (; i < arr.length; i++) {
      nnorm += Math.pow(Math.abs(arr[i]), p);
    }
    return Math.pow(nnorm, 1 / p);
  },

  // TODO: make compatible with matrices
  // computes the angle between two vectors in rads
  angle: function angle(arr, arg) {
    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
  },

  // augment one matrix by another
  aug: function aug(a, b) {
    var newarr = a.slice(),
    i = 0;
    for (; i < newarr.length; i++) {
      push.apply(newarr[i], b[i]);
    }
    return newarr;
  },

  inv: function inv(a) {
    var rows = a.length,
    cols = a[0].length,
    b = jStat.identity(rows, cols),
    c = jStat.gauss_jordan(a, b),
    obj = [],
    i = 0,
    j;
    for (; i < rows; i++) {
      obj[i] = [];
      for (j = cols - 1; j < c[0].length; j++)
      obj[i][j - cols] = c[i][j];
    }
    return obj;
  },

  // calculate the determinant of a matrix
  det: function det(a) {
    var alen = a.length,
    alend = alen * 2,
    vals = new Array(alend),
    rowshift = alen - 1,
    colshift = alend - 1,
    mrow = rowshift - alen + 1,
    mcol = colshift,
    i = 0,
    result = 0,
    j;
    // check for special 2x2 case
    if (alen === 2) {
      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
    }
    for (; i < alend; i++) {
      vals[i] = 1;
    }
    for (i = 0; i < alen; i++) {
      for (j = 0; j < alen; j++) {
        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];
        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];
        mrow++;
        mcol--;
      }
      mrow = --rowshift - alen + 1;
      mcol = --colshift;
    }
    for (i = 0; i < alen; i++) {
      result += vals[i];
    }
    for (; i < alend; i++) {
      result -= vals[i];
    }
    return result;
  },

  gauss_elimination: function gauss_elimination(a, b) {
    var i = 0,
    j = 0,
    n = a.length,
    m = a[0].length,
    factor = 1,
    sum = 0,
    x = [],
    maug, pivot, temp, k;
    a = jStat.aug(a, b);
    maug = a[0].length;
    for(; i < n; i++) {
      pivot = a[i][i];
      j = i;
      for (k = i + 1; k < m; k++) {
        if (pivot < Math.abs(a[k][i])) {
          pivot = a[k][i];
          j = k;
        }
      }
      if (j != i) {
        for(k = 0; k < maug; k++) {
          temp = a[i][k];
          a[i][k] = a[j][k];
          a[j][k] = temp;
        }
      }
      for (j = i + 1; j < n; j++) {
        factor = a[j][i] / a[i][i];
        for(k = i; k < maug; k++) {
          a[j][k] = a[j][k] - factor * a[i][k];
        }
      }
    }
    for (i = n - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j<= n - 1; j++) {
        sum = x[j] * a[i][j];
      }
      x[i] =(a[i][maug - 1] - sum) / a[i][i];
    }
    return x;
  },

  gauss_jordan: function gauss_jordan(a, b) {
    var m = jStat.aug(a, b),
    h = m.length,
    w = m[0].length;
    // find max pivot
    for (var y = 0; y < h; y++) {
      var maxrow = y;
      for (var y2 = y+1; y2 < h; y2++) {
        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
          maxrow = y2;
      }
      var tmp = m[y];
      m[y] = m[maxrow];
      m[maxrow] = tmp
      for (var y2 = y+1; y2 < h; y2++) {
        c = m[y2][y] / m[y][y];
        for (var x = y; x < w; x++) {
          m[y2][x] -= m[y][x] * c;
        }
      }
    }
    // backsubstitute
    for (var y = h-1; y >= 0; y--) {
      c = m[y][y];
      for (var y2 = 0; y2 < y; y2++) {
        for (var x = w-1; x > y-1; x--) {
          m[y2][x] -= m[y][x] * m[y2][y] / c;
        }
      }
      m[y][y] /= c;
      for (var x = h; x < w; x++) {
        m[y][x] /= c;
      }
    }
    return m;
  },

  lu: function lu(a, b) {
    throw new Error('lu not yet implemented');
  },

  cholesky: function cholesky(a, b) {
    throw new Error('cholesky not yet implemented');
  },

  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
    var i = 0;
    var j = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
    c = jStat.multiply(jStat.inv(d), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  gauss_seidel: function gauss_seidel(a, b, x, r) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i = i + 1;
    }
    return xk;
  },

  SOR: function SOR(a, b, x, r, w) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
                       jStat.subtract(jStat.multiply(d, 1 - w),
                                      jStat.multiply(u, w)));
    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
        jStat.multiply(l, w))), b), w);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  householder: function householder(a) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var alpha, r, k, j, factor;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
      alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, jStat.multiply(a, p));
    }
    return a;
  },

  // TODO: not working properly.
  QR: function QR(a, b) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var x = [];
    var j, alpha, r, k, factor, sum;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
        alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++)
        w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, a);
      b = jStat.multiply(p, b);
    }
    for (i = m - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j <= n - 1; j++)
      sum = x[j] * a[i][j];
      x[i] = b[i][0] / a[i][i];
    }
    return x;
  },

  jacobi: function jacobi(a) {
    var condition = 1;
    var count = 0;
    var n = a.length;
    var e = jStat.identity(n, n);
    var ev = [];
    var b, i, j, p, q, maxim, theta, s;
    // condition === 1 only if tolerance is not reached
    while (condition === 1) {
      count++;
      maxim = a[0][1];
      p = 0;
      q = 1;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j) {
            if (maxim < Math.abs(a[i][j])) {
              maxim = Math.abs(a[i][j]);
              p = i;
              q = j;
            }
          }
        }
      }
      if (a[p][p] === a[q][q])
        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
      else
        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
      s = jStat.identity(n, n);
      s[p][p] = Math.cos(theta);
      s[p][q] = -Math.sin(theta);
      s[q][p] = Math.sin(theta);
      s[q][q] = Math.cos(theta);
      // eigen vector matrix
      e = jStat.multiply(e, s);
      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
      a = b;
      condition = 0;
      for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
          if (i != j && Math.abs(a[i][j]) > 0.001) {
            condition = 1;
          }
        }
      }
    }
    for (i = 0; i < n; i++) ev.push(a[i][i]);
    //returns both the eigenvalue and eigenmatrix
    return [e, ev];
  },

  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
    var k1, k2, u_j1, k3, k4;
    if (order === 2) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h, u_j + k1);
        u_j1 = u_j + (k1 + k2) / 2;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    if (order === 4) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
        k4 = h * f(t_j +h, u_j + k3);
        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    return u_j;
  },

  romberg: function romberg(f, a, b, order) {
    var i = 0;
    var h = (b - a) / 2;
    var x = [];
    var h1 = [];
    var g = [];
    var m, a1, j, k, I, d;
    while (i < order / 2) {
      I = f(a);
      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
      m = x.length;
      for (j = 1; j < m - 1; j++) {
        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
      }
      I = (h / 3) * (I + f(b));
      g[i] = I;
      h /= 2;
      i++;
    }
    a1 = g.length;
    m = 1;
    while (a1 !== 1) {
      for (j = 0; j < a1 - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a1 = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  richardson: function richardson(X, f, x, h) {
    function pos(X, x) {
      var i = 0;
      var n = X.length;
      var p;
      for (; i < n; i++)
        if (X[i] === x) p = i;
      return p;
    }
    var n = X.length,
    h_min = Math.abs(x - X[pos(X, x) + 1]),
    i = 0,
    g = [],
    h1 = [],
    y1, y2, m, a, j;
    while (h >= h_min) {
      y1 = pos(X, x + h);
      y2 = pos(X, x);
      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
      h /= 2;
      i++;
    }
    a = g.length;
    m = 1;
    while (a != 1) {
      for (j = 0; j < a - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  simpson: function simpson(f, a, b, n) {
    var h = (b - a) / n;
    var I = f(a);
    var x = [];
    var j = a;
    var k = 0;
    var i = 1;
    var m;
    for (; j <= b; j = j + h, k++)
      x[k] = j;
    m = x.length;
    for (; i < m - 1; i++) {
      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
    }
    return (h / 3) * (I + f(b));
  },

  hermite: function hermite(X, F, dF, value) {
    var n = X.length;
    var p = 0;
    var i = 0;
    var l = [];
    var dl = [];
    var A = [];
    var B = [];
    var j;
    for (; i < n; i++) {
      l[i] = 1;
      for (j = 0; j < n; j++) {
        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
      }
      dl[i] = 0;
      for (j = 0; j < n; j++) {
        if (i != j) dl[i] += 1 / (X [i] - X[j]);
      }
      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
      B[i] = (value - X[i]) * (l[i] * l[i]);
      p += (A[i] * F[i] + B[i] * dF[i]);
    }
    return p;
  },

  lagrange: function lagrange(X, F, value) {
    var p = 0;
    var i = 0;
    var j, l;
    var n = X.length;
    for (; i < n; i++) {
      l = F[i];
      for (j = 0; j < n; j++) {
        // calculating the lagrange polynomial L_i
        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
      }
      // adding the lagrange polynomials found above
      p += l;
    }
    return p;
  },

  cubic_spline: function cubic_spline(X, F, value) {
    var n = X.length;
    var i = 0, j;
    var A = [];
    var B = [];
    var alpha = [];
    var c = [];
    var h = [];
    var b = [];
    var d = [];
    for (; i < n - 1; i++)
      h[i] = X[i + 1] - X[i];
    alpha[0] = 0;
    for (i = 1; i < n - 1; i++) {
      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
          (3 / h[i-1]) * (F[i] - F[i-1]);
    }
    for (i = 1; i < n - 1; i++) {
      A[i] = [];
      B[i] = [];
      A[i][i-1] = h[i-1];
      A[i][i] = 2 * (h[i - 1] + h[i]);
      A[i][i+1] = h[i];
      B[i][0] = alpha[i];
    }
    c = jStat.multiply(jStat.inv(A), B);
    for (j = 0; j < n - 1; j++) {
      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
    }
    for (j = 0; j < n; j++) {
      if (X[j] > value) break;
    }
    j -= 1;
    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
  },

  gauss_quadrature: function gauss_quadrature() {
    throw new Error('gauss_quadrature not yet implemented');
  },

  PCA: function PCA(X) {
    var m = X.length;
    var n = X[0].length;
    var flag = false;
    var i = 0;
    var j, temp1;
    var u = [];
    var D = [];
    var result = [];
    var temp2 = [];
    var Y = [];
    var Bt = [];
    var B = [];
    var C = [];
    var V = [];
    var Vt = [];
    for (i = 0; i < m; i++) {
      u[i] = jStat.sum(X[i]) / n;
    }
    for (i = 0; i < n; i++) {
      B[i] = [];
      for(j = 0; j < m; j++) {
        B[i][j] = X[j][i] - u[j];
      }
    }
    B = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      C[i] = [];
      for (j = 0; j < m; j++) {
        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
      }
    }
    result = jStat.jacobi(C);
    V = result[0];
    D = result[1];
    Vt = jStat.transpose(V);
    for (i = 0; i < D.length; i++) {
      for (j = i; j < D.length; j++) {
        if(D[i] < D[j])  {
          temp1 = D[i];
          D[i] = D[j];
          D[j] = temp1;
          temp2 = Vt[i];
          Vt[i] = Vt[j];
          Vt[j] = temp2;
        }
      }
    }
    Bt = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      Y[i] = [];
      for (j = 0; j < Bt.length; j++) {
        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
      }
    }
    return [X, D, Vt, Y];
  }
});

// extend jStat.fn with methods that require one argument
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function(arg, func) {
      var tmpthis = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
        }, 15);
        return this;
      }
      if (typeof jStat[passfunc](this, arg) === 'number')
        return jStat[passfunc](this, arg);
      else
        return jStat(jStat[passfunc](this, arg));
    };
  }(funcs[i]));
}('add divide multiply subtract dot pow abs norm angle'.split(' ')));

}(this.jStat, Math));
(function(jStat, Math) {

var slice = [].slice;
var isNumber = jStat.utils.isNumber;

// flag==true denotes use of sample standard deviation
// Z Statistics
jStat.extend({
  // 2 different parameter lists:
  // (value, mean, sd)
  // (value, array, flag)
  zscore: function zscore() {
    var args = slice.call(arguments);
    if (isNumber(args[1])) {
      return (args[0] - args[1]) / args[2];
    }
    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
  },

  // 3 different paramter lists:
  // (value, mean, sd, sides)
  // (zscore, sides)
  // (value, array, sides, flag)
  ztest: function ztest() {
    var args = slice.call(arguments);
    if (args.length === 4) {
      if(isNumber(args[1])) {
        var z = jStat.zscore(args[0],args[1],args[2])
        return (args[3] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
      }
      var z = args[0]
      return (args[2] === 1) ?
        (jStat.normal.cdf(-Math.abs(z),0,1)) :
        (jStat.normal.cdf(-Math.abs(z),0,1)*2);
    }
    var z = jStat.zscore(args[0],args[1],args[3])
    return (args[1] === 1) ?
      (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
      (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
  }
});

jStat.extend(jStat.fn, {
  zscore: function zscore(value, flag) {
    return (value - this.mean()) / this.stdev(flag);
  },

  ztest: function ztest(value, sides, flag) {
    var zscore = Math.abs(this.zscore(value, flag));
    return (sides === 1) ?
      (jStat.normal.cdf(-zscore, 0, 1)) :
      (jStat.normal.cdf(-zscore, 0, 1) * 2);
  }
});

// T Statistics
jStat.extend({
  // 2 parameter lists
  // (value, mean, sd, n)
  // (value, array)
  tscore: function tscore() {
    var args = slice.call(arguments);
    return (args.length === 4) ?
      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
      ((args[0] - jStat.mean(args[1])) /
       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
  },

  // 3 different paramter lists:
  // (value, mean, sd, n, sides)
  // (tscore, n, sides)
  // (value, array, sides)
  ttest: function ttest() {
    var args = slice.call(arguments);
    var tscore;
    if (args.length === 5) {
      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
      return (args[4] === 1) ?
        (jStat.studentt.cdf(-tscore, args[3]-1)) :
        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
    }
    if (isNumber(args[1])) {
      tscore = Math.abs(args[0])
      return (args[2] == 1) ?
        (jStat.studentt.cdf(-tscore, args[1]-1)) :
        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
    }
    tscore = Math.abs(jStat.tscore(args[0], args[1]))
    return (args[2] == 1) ?
      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
  }
});

jStat.extend(jStat.fn, {
  tscore: function tscore(value) {
    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
  },

  ttest: function ttest(value, sides) {
    return (sides === 1) ?
      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
  }
});

// F Statistics
jStat.extend({
  // Paramter list is as follows:
  // (array1, array2, array3, ...)
  // or it is an array of arrays
  // array of arrays conversion
  anovafscore: function anovafscore() {
    var args = slice.call(arguments),
    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
    if (args.length === 1) {
      tmpargs = new Array(args[0].length);
      for (i = 0; i < args[0].length; i++) {
        tmpargs[i] = args[0][i];
      }
      args = tmpargs;
    }
    // 2 sample case
    if (args.length === 2) {
      return jStat.variance(args[0]) / jStat.variance(args[1]);
    }
    // Builds sample array
    sample = new Array();
    for (i = 0; i < args.length; i++) {
      sample = sample.concat(args[i]);
    }
    sampMean = jStat.mean(sample);
    // Computes the explained variance
    expVar = 0;
    for (i = 0; i < args.length; i++) {
      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
    }
    expVar /= (args.length - 1);
    // Computes unexplained variance
    unexpVar = 0;
    for (i = 0; i < args.length; i++) {
      sampSampMean = jStat.mean(args[i]);
      for (j = 0; j < args[i].length; j++) {
        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
      }
    }
    unexpVar /= (sample.length - args.length);
    return expVar / unexpVar;
  },

  // 2 different paramter setups
  // (array1, array2, array3, ...)
  // (anovafscore, df1, df2)
  anovaftest: function anovaftest() {
    var args = slice.call(arguments),
    df1, df2, n, i;
    if (isNumber(args[0])) {
      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
    }
    anovafscore = jStat.anovafscore(args);
    df1 = args.length - 1;
    n = 0;
    for (i = 0; i < args.length; i++) {
      n = n + args[i].length;
    }
    df2 = n - df1 - 1;
    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
  },

  ftest: function ftest(fscore, df1, df2) {
    return 1 - jStat.centralF.cdf(fscore, df1, df2);
  }
});

jStat.extend(jStat.fn, {
  anovafscore: function anovafscore() {
    return jStat.anovafscore(this.toArray());
  },

  anovaftes: function anovaftes() {
    var n = 0;
    var i;
    for (i = 0; i < this.length; i++) {
      n = n + this[i].length;
    }
    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
  }
});

// Error Bounds
jStat.extend({
  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  normalci: function normalci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  tci: function tci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  significant: function significant(pvalue, alpha) {
    return pvalue < alpha;
  }
});

jStat.extend(jStat.fn, {
  normalci: function normalci(value, alpha) {
    return jStat.normalci(value, alpha, this.toArray());
  },

  tci: function tci(value, alpha) {
    return jStat.tci(value, alpha, this.toArray());
  }
});

}(this.jStat, Math));

},{}],355:[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],356:[function(require,module,exports){
(function (global){
"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sbastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],357:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":358}],358:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],359:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');
var has = require('has');
var bind = require('function-bind');
var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function values(O) {
	var obj = ES.RequireObjectCoercible(O);
	var vals = [];
	for (var key in obj) {
		if (has(obj, key) && isEnumerable(obj, key)) {
			vals.push(obj[key]);
		}
	}
	return vals;
};

},{"es-abstract/es7":333,"function-bind":348,"has":349}],360:[function(require,module,exports){
'use strict';

var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var polyfill = getPolyfill();

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;

},{"./implementation":359,"./polyfill":361,"./shim":362,"define-properties":329}],361:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.values === 'function' ? Object.values : implementation;
};

},{"./implementation":359}],362:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimValues() {
	var polyfill = getPolyfill();
	define(Object, { values: polyfill }, {
		values: function testValues() {
			return Object.values !== polyfill;
		}
	});
	return polyfill;
};

},{"./polyfill":361,"define-properties":329}],363:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FUNCTIONS = exports.OP_FUNCTIONS = exports.OPERATORS = exports.ERRORS = exports.TOKENS = undefined;

var _functions = require('./parser/functions');

/**
 * Token list
 *
 * @static
 * @constant
 * @type {object}
 * @property {string} EOL - End of line.
 * @property {string} NUMBER - Number constant.
 * @property {string} STRING - String constant.
 * @property {string} BOOLEAN - Boolean constant.
 * @property {string} ERROR - Error constant.
 * @property {string} ID - Function name or Cell reference.
 * @property {string} SHEET - Sheet.
 * @property {string} RANGE - Range.
 * @property {string} PLUS - The plus sign (+).
 * @property {string} MINUS - The minus sign (-).
 * @property {string} MULT - The multiplication sign (*).
 * @property {string} DIV - The division sign (/).
 * @property {string} POW - The exponent sign (^).
 * @property {string} LT - The less than sign (<).
 * @property {string} GT - The greater than sign (>).
 * @property {string} EQ - The equal sign (=).
 * @property {string} LE - The less than or equal sign (<=).
 * @property {string} GE - The greater than or equal sign (>=).
 * @property {string} NE - The not equal sign (<>).
 * @property {string} CONCAT - The string concatenation sign (&).
 * @property {string} EXCLAMATION - The exclamation sign (!).
 * @property {string} PERCENT - The percent sign (%).
 * @property {string} COLON - The colon sign (:).
 * @property {string} COMMA - The comma sign (,).
 * @property {string} SEMICOLON - The semi-colon sign (;).
 * @property {string} PERIOD - The dot sign (.).
 * @property {string} DOLLAR - The dollar sign ($).
 * @property {string} LPAREN - The left parentheses sign (().
 * @property {string} RPAREN - The right parentheses sign ()).
 * @property {string} LBRACE - The left brace sign ({).
 * @property {string} RBRACE - The right brace sign (}).
 * @property {string} LBRACKET - The left bracket sign ([).
 * @property {string} RBRACKET - The right bracket sign (]).
 */
var TOKENS = exports.TOKENS = {
    EOL: '(eol)',

    // Constants
    NUMBER: '(number)',
    STRING: '(string)',
    BOOLEAN: '(boolean)',
    ERROR: '(error)',
    ID: '(identifier)',
    SHEET: '(sheet)',
    RANGE: '(range)',

    // Operators
    PLUS: '+',
    MINUS: '-',
    MULT: '*',
    DIV: '/',
    POW: '^',
    LT: '<',
    GT: '>',
    EQ: '=',
    LE: '<=',
    GE: '>=',
    NE: '<>',
    CONCAT: '&',
    EXCLAMATION: '!',
    PERCENT: '%',
    COLON: ':',
    COMMA: ',',
    SEMICOLON: ';',
    PERIOD: '.',
    DOLLAR: '$',
    LPAREN: '(',
    RPAREN: ')',
    LBRACE: '{',
    RBRACE: '}',
    LBRACKET: '[',
    RBRACKET: ']'
};

/**
 * Spreadsheet Error list
 * @see {@link http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part2.html#__RefHeading__1017966_715980110|5.12Constant Errors}
 *
 * @static
 * @constant
 * @type {object}
 * @property {string} #DIV/0! - Attempt to divide by zero, including division by an empty cell. ERROR.TYPE of 2.
 * @property {string} #NAME? - Unrecognized/deleted name. ERROR.TYPE of 5.
 * @property {string} #N/A - Not available. ISNA() applied to this value will return True. Lookup functions which failed, and NA(), return this value. ERROR.TYPE of 7.
 * @property {string} #NULL! - Intersection of ranges produced zero cells. ERROR.TYPE of 1.
 * @property {string} #NUM! - Failed to meet domain constraints (e.g., input was too large or too small). ERROR.TYPE of 6.
 * @property {string} #REF! - Reference to invalid cell (e.g., beyond the application's abilities). ERROR.TYPE of 4.
 * @property {string} #VALUE! - Parameter is wrong type. ERROR.TYPE of 3.
 */
var ERRORS = exports.ERRORS = {
    DIV: '#DIV/0!',
    NAME: '#NAME?',
    NA: '#N/A',
    NULL: '#NULL!',
    NUM: '#NUM!',
    REF: '#REF!',
    VALUE: '#VALUE!'
};

/**
 * Basic operators
 *
 * @static
 * @constant
 * @type {object}
 * @property {string} + - The plus type, PLUS.
 * @property {string} - - The minus type, MINUS.
 * @property {string} * - The multiplication type, MULT.
 * @property {string} / - The division type, DIV.
 * @property {string} ^ - The exponent type, POW.
 * @property {string} < - The less than type, LT.
 * @property {string} > - The greater than type, GT.
 * @property {string} = - The equal type, EQ.
 * @property {string} <= - The less than or equal type, LE.
 * @property {string} >= - The greater than or equal type, GE.
 * @property {string} <> - The not equal type, NE.
 * @property {string} & - The string concatenation type, CONCAT.
 * @property {string} ! - The exclamation type, EXCLAMATION.
 * @property {string} % - The percent type, PERCENT.
 * @property {string} : - The colon type, COLON.
 * @property {string} , - The comma type, COMMA.
 * @property {string} ; - The semi-colon type, SEMICOLON.
 * @property {string} ( - The left parentheses type, LPAREN.
 * @property {string} ) - The right parentheses type, RPAREN.
 */
var OPERATORS = exports.OPERATORS = {
    '+': TOKENS.PLUS,
    '-': TOKENS.MINUS,
    '*': TOKENS.MULT,
    '/': TOKENS.DIV,
    '^': TOKENS.POW,
    '<': TOKENS.LT,
    '>': TOKENS.GT,
    '=': TOKENS.EQ,
    '<=': TOKENS.LE,
    '>=': TOKENS.GE,
    '<>': TOKENS.NE,
    '&': TOKENS.CONCAT,
    '!': TOKENS.EXCLAMATION,
    '%': TOKENS.PERCENT,
    ':': TOKENS.COLON,
    ',': TOKENS.COMMA,
    ';': TOKENS.SEMICOLON,
    '.': TOKENS.PERIOD,
    '(': TOKENS.LPAREN,
    ')': TOKENS.RPAREN,
    '{': TOKENS.LBRACE,
    '}': TOKENS.RBRACE,
    '[': TOKENS.LBRACKET,
    ']': TOKENS.RBRACKET
};

/**
 * Operation functions.
 *
 * @static
 * @constant
 * @type {object}
 */
var OP_FUNCTIONS = exports.OP_FUNCTIONS = {
    // Basic operations
    '+': function _(left, right) {
        return left + right;
    },
    '-': function _(left, right) {
        return left - right;
    },
    '*': function _(left, right) {
        return left * right;
    },
    '/': function _(left, right) {
        return left / right;
    },
    '^': function _(left, right) {
        return _functions.FUNCTIONS.POW(left, right);
    },

    // Relational operations
    '<': function _(left, right) {
        return left < right;
    },
    '>': function _(left, right) {
        return left > right;
    },
    '=': function _(left, right) {
        return left == right;
    }, // eslint-disable-line eqeqeq
    '<=': function _(left, right) {
        return left <= right;
    },
    '>=': function _(left, right) {
        return left >= right;
    },
    '<>': function _(left, right) {
        return left != right;
    }, // eslint-disable-line eqeqeq

    // Other operations
    '&': function _(left, right) {
        return _functions.FUNCTIONS.CONCAT(left, right);
    }
};

exports.FUNCTIONS = _functions.FUNCTIONS;

},{"./parser/functions":388}],364:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.consts = undefined;

var _parser = require('./parser');

Object.keys(_parser).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _parser[key];
        }
    });
});

require('babel-polyfill');

var _Constants = require('./Constants');

var consts = _interopRequireWildcard(_Constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.consts = consts;


var Sint = exports; // eslint-disable-line

global.Sint = Sint; // eslint-disable-line

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') // eslint-disable-line
    {
        module.exports = Sint; // eslint-disable-line
    } else if (typeof define === 'function' && define.amd) // eslint-disable-line
    {
        define([], function () // eslint-disable-line
        {
            return Sint;
        });
    } else {
    window.Sint = Sint; // eslint-disable-line
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Constants":363,"./parser":395,"babel-polyfill":1}],365:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Iterable list of characters.
 */
var Characters = function () {
    /**
    * Creates a Characters objects from text.
    * @param {string} [text] - The text source.
    */
    function Characters() {
        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        _classCallCheck(this, Characters);

        this.text = text;
    }

    /**
     * Advance to the next character.
     * @return {string} Next character.
     */


    _createClass(Characters, [{
        key: 'advance',
        value: function advance() {
            this.pointer++;

            return this.current;
        }

        /**
         * Peek the next character without advancing.
         * @return {string} Next character.
         */

    }, {
        key: 'isWhitespace',


        /**
         * Returns true if the current character is a white space.
         * @return {boolean} True if is a white space.
         */
        value: function isWhitespace() {
            return (/^\s+$/.test(this.current)
            );
        }

        /**
         * Returns true if the current character is alphabetic.
         * @return {boolean} True if is a alphabetic.
         */

    }, {
        key: 'isAlpha',
        value: function isAlpha() {
            return (/^[a-zA-Z]+$/.test(this.current)
            );
        }

        /**
         * Returns true if the current character is Unicode.
         * @return {boolean} True if is a non-ascii character.
         */

    }, {
        key: 'isUnicode',
        value: function isUnicode() {
            // https://stackoverflow.com/questions/2124010/grep-regex-to-match-non-ascii-characters
            return (/[^\x00-\x7F]+$/.test(this.current)
            ); // eslint-disable-line
        }

        /**
         * Returns true if the current character is a digit.
         * @return {boolean} True if is a digit.
         */

    }, {
        key: 'isDigit',
        value: function isDigit() {
            return (/^[0-9]+$/.test(this.current)
            );
        }

        /**
         * Returns true if the current character is a valid Identifier character.
         * @return {boolean} True if is a valid identifier.
         */

    }, {
        key: 'isIdentifier',
        value: function isIdentifier() {
            return this.isAlpha() || this.isUnicode() || this.isDigit() || /^[\_\$\.]+$/.test(this.current);
        }
    }, {
        key: 'peek',
        get: function get() {
            return this._text[this.pointer + 1];
        }

        /**
         * Returns true if pointer is equal or greater than text length.
         * @return {boolean} Did pointer reach the last position?
         */

    }, {
        key: 'end',
        get: function get() {
            return this.pointer >= this._text.length;
        }

        /**
         * Returns the first character of text.
         * @return {string} First text character.
         */

    }, {
        key: 'start',
        get: function get() {
            return this._text[0];
        }

        /**
         * Get current character
         * @readonly
         * @return {string} Current character.
         */

    }, {
        key: 'current',
        get: function get() {
            return this._text[this.pointer];
        }

        /**
         * Set a new text and set pointer to zero.
         * @param {string} [value] - Code content.
         */

    }, {
        key: 'text',
        set: function set(value) {
            this._text = String(value);
            this.pointer = 0;
        },
        get: function get() // eslint-disable-line require-jsdoc
        {
            return this._text;
        }
    }]);

    return Characters;
}();

Characters.displayName = 'Characters';
exports.default = Characters;

},{}],366:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _object = require('object.values');

var _object2 = _interopRequireDefault(_object);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

if (!Object.values) {
    _object2.default.shim();
}

/**
 * Data from a Worksheet.
 */

var DataGrid = function () {
    /**
    * Creates a Data map.
    * @param {object} [values] - List of values.
    */
    function DataGrid() {
        var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, DataGrid);

        this.values = values;
    }

    /**
     * Get a Cell value;
     * @param {CellIdentifier} [cell] - The Cell.
     * @return {*}                      Cell value.
     */


    _createClass(DataGrid, [{
        key: 'getValue',
        value: function getValue(cell) {
            var name = cell.clean();

            return this.values[name];
        }

        /**
         * Get a Range array.
         * @todo implement this.
         * @param {RangeReference} [range] - Range.
         * @return {array}                   Range values.
         */

    }, {
        key: 'getRange',
        value: function getRange(range) {
            var _range$pair = range.pair(),
                _range$pair2 = _slicedToArray(_range$pair, 2),
                first = _range$pair2[0],
                last = _range$pair2[1]; // eslint-disable-line no-unused-vars


            var result = Object.values(this.values);

            return result;
        }
    }]);

    return DataGrid;
}();

DataGrid.displayName = 'DataGrid';
exports.default = DataGrid;

},{"object.values":360}],367:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Lexer = require('./Lexer');

var _Lexer2 = _interopRequireDefault(_Lexer);

var _Parser = require('./Parser');

var _Parser2 = _interopRequireDefault(_Parser);

var _DataGrid = require('./DataGrid');

var _DataGrid2 = _interopRequireDefault(_DataGrid);

var _ast = require('./ast');

var _Constants = require('./../Constants');

var _NodeVisitor2 = require('./NodeVisitor');

var _NodeVisitor3 = _interopRequireDefault(_NodeVisitor2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Execute an AST.
 * @todo Implement promises as return from function calls.
 * @todo Implement error handling.
 * @todo Implement worksheet data structure.
 */
var Interpreter = function (_NodeVisitor) {
    _inherits(Interpreter, _NodeVisitor);

    /**
     * Create a Interpreter
     * @param {DataGrid} [data] - Data object.
     * @param {object}   [list] - List of functions.
     */
    function Interpreter() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, Interpreter);

        var _this = _possibleConstructorReturn(this, (Interpreter.__proto__ || Object.getPrototypeOf(Interpreter)).call(this));

        _this.data = data ? data : new _DataGrid2.default();
        _this.functions = list ? list : _Constants.FUNCTIONS;
        return _this;
    }

    /**
     * Visit a FunctionCall object.
     * @throws Will throw an error if function doesn't exists.
     * @param {AST} [node] - The tree or node.
     * @return {*} Result of operation.
     */


    _createClass(Interpreter, [{
        key: 'visitFunctionCall',
        value: function visitFunctionCall(node) {
            var name = node.name;
            var fn = this.functionByName(name);

            if (fn && typeof fn === 'function') {
                var args = [];

                for (var index in node.params) {
                    var arg = node.params[index];

                    args.push(this.visit(arg));
                }

                return fn.apply(null, args);
            }

            throw new Error('Function "' + name + '" doesn\'t exists.');
        }

        /**
         * Visit a CellIdentifier object
         * @param {AST} [node] - The tree or node.
         * @return {*}           Cell value or null.
         */

    }, {
        key: 'visitCellIdentifier',
        value: function visitCellIdentifier(node) {
            if (this.data) {
                return this.data.getValue(node);
            }

            return null;
        }

        /**
         * Visit a RangeReference object
         * @param {AST} [node] - The tree or node.
         * @return {array}       Range as array.
         */

    }, {
        key: 'visitRangeReference',
        value: function visitRangeReference(node) {
            if (this.data) {
                return this.data.getRange(node);
            }

            return null;
        }

        /**
         * Visit a BinOp object
         * @param {AST} [node] - The tree or node.
         * @return {*} Result of operation.
         */

    }, {
        key: 'visitBinOp',
        value: function visitBinOp(node) {
            var sign = node.op.value;
            var operator = _Constants.OP_FUNCTIONS[sign];

            if (operator) {
                return operator(this.visit(node.left), this.visit(node.right));
            }

            return null;
        }

        /**
         * Visit a UnaryOp object
         * @param {AST} [node] - The tree or node.
         * @return {*} Result of operation.
         */

    }, {
        key: 'visitUnaryOp',
        value: function visitUnaryOp(node) {
            if (node.op.type === _Constants.TOKENS.MINUS) {
                return -this.visit(node.expr);
            }

            return +this.visit(node.expr); // eslint-disable-line no-implicit-coercion
        }

        /**
         * Visit a PostfixOp object
         * @param {AST} [node] - The tree or node.
         * @return {*} Result of operation.
         */

    }, {
        key: 'visitPostfixOp',
        value: function visitPostfixOp(node) {
            return Number(this.visit(node.expr) / 100);
        }

        /**
         * Visit a ArrayConstant object
         * @param {AST} [node] - The tree or node.
         * @return {number} Node value.
         */

    }, {
        key: 'visitArrayConstant',
        value: function visitArrayConstant(node) {
            if (!Array.isArray(node.value)) {
                return [];
            }

            var columns = node.value;
            var constant = [];
            var column = [];
            var row = [];

            for (var i in columns) {
                column = columns[i];
                constant[i] = [];
                for (var j in column) {
                    row = column[j];
                    constant[i][j] = this.visit(row);
                }
            }

            return constant;
        }

        /**
         * Visit a NumberConstant object
         * @param {AST} [node] - The tree or node.
         * @return {number} Node value.
         */

    }, {
        key: 'visitNumberConstant',
        value: function visitNumberConstant(node) {
            return node.value;
        }

        /**
         * Visit a StringConstant object
         * @param {AST} [node] - The tree or node.
         * @return {string} Node value.
         */

    }, {
        key: 'visitStringConstant',
        value: function visitStringConstant(node) {
            return node.value;
        }

        /**
         * Visit a BooleanConstant object
         * @param {AST} [node] - The tree or node.
         * @return {boolean} Node value.
         */

    }, {
        key: 'visitBooleanConstant',
        value: function visitBooleanConstant(node) {
            return node.value;
        }

        /**
         * Visit a ErrorConstant object
         * @param {AST} [node] - The tree or node.
         * @return {null} Node value.
         */

    }, {
        key: 'visitErrorConstant',
        value: function visitErrorConstant(node) {
            return node.value;
        }

        /**
         * Return a function from a list.
         * @param {string} [name] - Function name.
         * @return {Function} The function.
         */

    }, {
        key: 'functionByName',
        value: function functionByName(name) {
            var fns = this.functions;

            return fns[name];
        }

        /**
         * Add more functions to the function list.
         * @param  {object} [list] - Pairs of name : function.
         * @return {object} Function list.
         */

    }, {
        key: 'addFunctions',
        value: function addFunctions(list) {
            this.functions = Object.assign(this.functions, list);

            return this.functions;
        }

        /**
         * Set functions.
         * @param  {object} [list] - Pairs of name : function.
         */

    }, {
        key: 'execute',


        /**
         * Execute a AST or parse and then execute a code.
         * @throws Will throw an error if is a invalid code.
         * @param {string|AST} [source] - Source code or AST.
         * @return {*}                    The result of the code.
         */
        value: function execute(source) {
            if (typeof source === 'string') {
                var lexer = new _Lexer2.default(source);
                var parser = new _Parser2.default(lexer);
                var tree = parser.parse();

                return this.execute(tree);
            } else if (source instanceof _ast.AST) {
                return this.visit(source);
            }

            return null;
        }

        /**
         * Execute a AST or parse and then execute a code.
         * @throws Will throw an error if is a invalid code.
         * @param {string|AST} [source] - Source code or AST.
         * @param {DataGrid}   [data]   - Data object.
         * @return {*}                    The result of the code.
         */

    }, {
        key: 'run',
        value: function run() {
            var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (data !== null) {
                this.data = data;
            }

            return this.execute(source);
        }
    }, {
        key: 'functions',
        set: function set(list) {
            this._functions = list;
        }

        /**
         * Return functions.
         * @return {object} Function list.
         */
        ,
        get: function get() {
            return this._functions;
        }
    }]);

    return Interpreter;
}(_NodeVisitor3.default);

Interpreter.displayName = 'Interpreter';
exports.default = Interpreter;

},{"./../Constants":363,"./DataGrid":366,"./Lexer":368,"./NodeVisitor":369,"./Parser":370,"./ast":386}],368:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Constants = require('./../Constants');

var _Characters2 = require('./Characters');

var _Characters3 = _interopRequireDefault(_Characters2);

var _Token = require('./Token');

var _Token2 = _interopRequireDefault(_Token);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var START_CHAR = '=';
var UNDERSCORE = '_';
var DOLLAR_SIGN = '$';
var SINGLE_QUOTE = '\'';
var DOUBLE_QUOTE = '"';

// Error characteres
var HASH_SIGN = '#';
var EXCLAMATION_MARK = '!';
var QUESTION_MARK = '?';
var SLASH = '/';

// Returns true if it's a number or number string.
function isNumber(number) {
    return !isNaN(parseFloat(number)) && isFinite(number);
}

/**
 * A class to do Lexical analysis.
 *
 * @extends Characters
 */

var Lexer = function (_Characters) {
    _inherits(Lexer, _Characters);

    /**
    * Creates a Lexer.
    * @param {string} [text] - Code content.
    */
    function Lexer() {
        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        _classCallCheck(this, Lexer);

        return _possibleConstructorReturn(this, (Lexer.__proto__ || Object.getPrototypeOf(Lexer)).call(this, text));
    }

    /**
     * Skip white space characters
     */


    _createClass(Lexer, [{
        key: 'skipWhitespace',
        value: function skipWhitespace() {
            while (!this.end && this.isWhitespace()) {
                this.advance();
            }
        }

        /**
         * Returns all contents from text.
         * @return {string} Text contents.
         */

    }, {
        key: 'contents',
        value: function contents() {
            var result = '';

            while (!this.end) {
                result += this.current;
                this.advance();
            }

            return result;
        }

        /**
         * Returns a constant or EOF. Constants can be Strings, numbers and Booleans.
         * @return {Token} A Constant token.
         */

    }, {
        key: 'constant',
        value: function constant() {
            var isSingleQuoted = this.current === SINGLE_QUOTE;
            var result = void 0;

            if (isSingleQuoted) {
                this.advance();
                result = this.contents();

                return new _Token2.default(_Constants.TOKENS.STRING, String(result));
            }

            result = this.contents();
            if (result) {
                var lower = result.toUpperCase();
                var error = lower.trim();

                for (var key in _Constants.ERRORS) {
                    if (_Constants.ERRORS[key] === error) {
                        return new _Token2.default(_Constants.TOKENS.ERROR, error);
                    }
                }

                if (lower === 'TRUE') {
                    return new _Token2.default(_Constants.TOKENS.BOOLEAN, true);
                } else if (lower === 'FALSE') {
                    return new _Token2.default(_Constants.TOKENS.BOOLEAN, false);
                } else if (isNumber(result)) {
                    return new _Token2.default(_Constants.TOKENS.NUMBER, parseFloat(result));
                }

                return new _Token2.default(_Constants.TOKENS.STRING, String(result));
            }

            return new _Token2.default(_Constants.TOKENS.EOL);
        }

        /**
         * Returns a digit
         * @return {string} A Number string.
         */

    }, {
        key: 'digit',
        value: function digit() {
            var result = '';

            while (this.isDigit()) {
                result += this.current;
                this.advance();
            }

            return result;
        }

        /**
         * Returns a number token or a range (e.g. 1:3) token.
         * @return {Token} A Number or Range token.
         */

    }, {
        key: 'number',
        value: function number() {
            var result = this.digit();

            if (this.current === '.') {
                this.advance(); // Skip dot sign.
                result = result + '.' + this.digit();
            } else if (this.current === ':') {
                this.advance(); // Skip colon sign.
                result = result + ':' + this.digit();

                return new _Token2.default(_Constants.TOKENS.RANGE, result);
            }
            result = parseFloat(result);

            return new _Token2.default(_Constants.TOKENS.NUMBER, result);
        }

        /**
         * Returns a identifier, that can be a Function name, cell reference or range.
         * @return {string} An Identifier.
         */

    }, {
        key: 'name',
        value: function name() {
            var result = '';

            while (!this.end && this.isIdentifier()) {
                result += this.current;
                this.advance();
            }

            return result.toUpperCase();
        }

        /**
         * Returns a identifier or range token.
         * @return {Token} An ID or RANGE token.
         */

    }, {
        key: 'identifier',
        value: function identifier() {
            var result = this.name();
            var isBoolean = result === 'TRUE' || result === 'FALSE';

            // Checks if its not a function, e.g. TRUE() or FALSE().
            if (isBoolean) {
                this.skipWhitespace();
                if (this.current !== '(') {
                    return new _Token2.default(_Constants.TOKENS.BOOLEAN, result === 'TRUE');
                }
            }

            // Checks if it's a Range
            if (this.current === ':') {
                // Skip the colon mark.
                this.advance();

                var first = result;
                var last = this.name();

                result = first + ':' + last;

                return new _Token2.default(_Constants.TOKENS.RANGE, result);
            }

            // Checks if it's a Sheet
            if (this.current === '!') {
                // Skip the exclamation mark.
                this.advance();

                return new _Token2.default(_Constants.TOKENS.SHEET, result);
            }

            return new _Token2.default(_Constants.TOKENS.ID, result);
        }

        /**
         * Returns a string.
         * @param {string} [end] - the End character.
         * @return {string} The whole string.
         */

    }, {
        key: 'literal',
        value: function literal() {
            var end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DOUBLE_QUOTE;

            var result = '';

            // Skip the first quote sign.
            this.advance();
            while (!this.end && this.current !== end) {
                result += this.current;
                this.advance();
            }

            // Skip the last quote sign.
            this.advance();

            return String(result);
        }

        /**
         * Returns a string
         * @return {Token} A String token.
         */

    }, {
        key: 'string',
        value: function string() {
            var result = this.literal(DOUBLE_QUOTE);

            return new _Token2.default(_Constants.TOKENS.STRING, result);
        }

        /**
         * Returns a sheet token.
         * @throws Will throw an error if it's an empty sheet.
         * @return {Token} A ID token.
         */

    }, {
        key: 'sheet',
        value: function sheet() {
            var result = this.literal(SINGLE_QUOTE).trim().toUpperCase();

            if (!result.length) {
                throw new Error('Empty sheet name');
            }

            // Skip exclamation point.
            this.advance();

            return new _Token2.default(_Constants.TOKENS.SHEET, result);
        }

        /**
         * Returns a Error string.
         * @throws Will throw an error if it's not a valid Error.
         * @return {Token} A Error token.
         */

    }, {
        key: 'error',
        value: function error() {
            var finalChars = [EXCLAMATION_MARK, QUESTION_MARK, SLASH];
            var result = '';

            while (!this.end && !finalChars.includes(this.current)) {
                result += this.current;
                this.advance();
            }

            var isSlash = this.current === SLASH;

            result += this.current;
            this.advance();

            if (isSlash) {
                switch (this.current) {
                    // #DIV/0!
                    case '0':
                        result += this.current;
                        this.advance();
                        result += this.current;
                        this.advance();
                        break;

                    // #N/A
                    case 'a':
                    case 'A':
                        result += this.current;
                        this.advance();
                        break;
                }
            }

            result = result.toUpperCase();
            for (var key in _Constants.ERRORS) {
                if (_Constants.ERRORS[key] === result) {
                    return new _Token2.default(_Constants.TOKENS.ERROR, result);
                }
            }

            return result;
        }

        /**
         * Returns a operator
         * @return {Token} A String token.
         */

    }, {
        key: 'operator',
        value: function operator() {
            var result = this.current;
            var next = this.advance();

            if (result === '<' && next === '=') {
                result += this.current;
                this.advance();
            } else if (result === '>' && next === '=') {
                result += this.current;
                this.advance();
            } else if (result === '<' && next === '>') {
                result += this.current;
                this.advance();
            }

            return new _Token2.default(_Constants.OPERATORS[result], result);
        }

        /**
         * Return the next token and reset pointer.
         * @return {Token} A Token.
         */

    }, {
        key: 'peek',
        value: function peek() {
            var oldPointer = this.pointer;
            var token = this.next();

            this.pointer = oldPointer;

            return token;
        }

        /**
         * Return the next token for a formula
         * @throws Will throw an error if is a invalid character.
         * @return {Token} A Token.
         */

    }, {
        key: '_nextToken',
        value: function _nextToken() {
            // If it's the first character, skip it.
            if (this.pointer === 0) {
                this.advance();

                return new _Token2.default(_Constants.TOKENS.EQ, START_CHAR);
            }

            while (!this.end) {
                // While is Whitespace, skip.
                if (this.isWhitespace()) {
                    this.skipWhitespace();
                }

                // Get numbers
                if (this.isDigit()) {
                    return this.number();
                }

                // Get identifier
                if (this.isAlpha() || this.isUnicode() || this.current === UNDERSCORE || this.current === DOLLAR_SIGN) {
                    return this.identifier();
                }

                // Get Strings
                if (this.current === DOUBLE_QUOTE) {
                    return this.string();
                }

                // Get Sheets
                if (this.current === SINGLE_QUOTE) {
                    return this.sheet();
                }

                // Get Error
                if (this.current === HASH_SIGN) {
                    return this.error();
                }

                // Get Operators
                if (this.current in _Constants.OPERATORS) {
                    return this.operator();
                }

                throw new SyntaxError('Invalid character "' + this.current + '"');
            }

            return new _Token2.default(_Constants.TOKENS.EOL);
        }

        /**
         * Return the next token
         * @return {Token} A Token.
         */

    }, {
        key: 'next',
        value: function next() {
            // Check if starts with "=".
            if (this.start === START_CHAR) {
                return this._nextToken();
            }

            // Return a String, Number or Boolean
            return this.constant();
        }
    }]);

    return Lexer;
}(_Characters3.default);

Lexer.displayName = 'Lexer';
exports.default = Lexer;

},{"./../Constants":363,"./Characters":365,"./Token":373}],369:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Node visitor is a walker for the abstract sysntax tree.
 */
var NodeVisitor = function () {
    function NodeVisitor() {
        _classCallCheck(this, NodeVisitor);
    }

    _createClass(NodeVisitor, [{
        key: "visit",

        /**
         * Visit all nodes of a tree.
         * @param {AST} [node] - The tree or node.
         * @return {*} The result of visiting all nodes.
         */
        value: function visit(node) {
            var methodName = void 0;
            var visitor = void 0;

            if (node) {
                methodName = "visit" + node.constructor.displayName;
                visitor = this[methodName];
            }

            if (!visitor) {
                throw new Error("No " + methodName + " method");
            }

            return visitor.call(this, node);
        }
    }]);

    return NodeVisitor;
}();

NodeVisitor.displayName = "NodeVisitor";
exports.default = NodeVisitor;

},{}],370:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Constants = require('./../Constants');

var _ast = require('./ast');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Syntax analyzer
 *
 * @example <caption>Grammar:</caption>
 *
 * start : constant
 *       | '=' expr
 *       ;
 *
 * expr : relExp ((EQ | NE) relExp)* ;
 *
 * relExp : addExp ((LT | LE | GT | GE) addExp)* ;
 *
 * addExp : mulExp ((PLUS | MINUS | CONCAT) mulExp)* ;
 *
 * mulExp : expExp ((MULT | DIV) expExp)* ;
 *
 * expExp : term ((EXP) term)* ;
 *
 * term : (PLUS | MINUS) factor (PERCENT)? ;
 *
 * factor : constant
 *        | formula
 *        | '{' arraycolumns '}'
 *        | '(' expr ')'
 *        ;
 *
 * arraycolumns : arrayrows
 *              | arrayrows ';' arraycolumns
 *              ;
 *
 * arrayrows : expr
 *           | expr ',' arrayrows
 *           ;
 *
 * formula : (SHEET)? reference ;
 *
 * reference : ID ('(' parameters ')')?
 *           | RANGE
 *           ;
 *
 * parameters : expr (',' expr)
 *            | empty
 *            ;
 *
 * constant : NUMBER
 *          | STRING
 *          | BOOL
 *          | ERROR
 *          ;
 */
var Parser = function () {
    /**
     * Creates a Parser.
     * @param {Lexer} lexer - Lexical analyzer object.
     */
    function Parser() {
        var lexer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, Parser);

        this.lexer = lexer;
    }

    /**
     * Start rule.
     *
     * @example <caption>Grammar:</caption>
     *
     *  start : constant
     *        | '=' expr
     *        ;
     *
     * @return {AST} Abstract Syntax tree.
     */


    _createClass(Parser, [{
        key: 'start',
        value: function start() {
            if (this.lookahead.type === _Constants.TOKENS.EQ) {
                this.match(_Constants.TOKENS.EQ);

                return this.expr();
            }

            return this.constant();
        }

        /**
         * Expression rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * expr : relExp ((EQ | NE) relExp)* ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'expr',
        value: function expr() {
            var node = this.relExp();

            while ([_Constants.TOKENS.EQ, _Constants.TOKENS.NE].includes(this.lookahead.type)) {
                var token = this.lookahead;

                this.match(token.type);
                node = new _ast.BinOp(node, token, this.relExp());
            }

            return node;
        }

        /**
         * Relational operators rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * relExp : addExp ((LT | LE | GT | GE) addExp)* ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'relExp',
        value: function relExp() {
            var node = this.addExp();

            while ([_Constants.TOKENS.LT, _Constants.TOKENS.LE, _Constants.TOKENS.GT, _Constants.TOKENS.GE].includes(this.lookahead.type)) {
                var token = this.lookahead;

                this.match(token.type);
                node = new _ast.BinOp(node, token, this.addExp());
            }

            return node;
        }

        /**
         * Addition and subtraction Expression rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * addExp : mulExp ((PLUS | MINUS | CONCAT) mulExp)* ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'addExp',
        value: function addExp() {
            var node = this.mulExp();

            while ([_Constants.TOKENS.PLUS, _Constants.TOKENS.MINUS, _Constants.TOKENS.CONCAT].includes(this.lookahead.type)) {
                var token = this.lookahead;

                this.match(token.type);
                node = new _ast.BinOp(node, token, this.mulExp());
            }

            return node;
        }

        /**
         * Multiplication and division rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * mulExp : expExp ((MULT | DIV) expExp)* ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'mulExp',
        value: function mulExp() {
            var node = this.expExp();

            while ([_Constants.TOKENS.MULT, _Constants.TOKENS.DIV].includes(this.lookahead.type)) {
                var token = this.lookahead;

                this.match(token.type);
                node = new _ast.BinOp(node, token, this.expExp());
            }

            return node;
        }

        /**
         * Exponentiation rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * expExp : term ((EXP) term)* ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'expExp',
        value: function expExp() {
            var node = this.term();

            while ([_Constants.TOKENS.POW].includes(this.lookahead.type)) {
                var token = this.lookahead;

                this.match(token.type);
                node = new _ast.BinOp(node, token, this.term());
            }

            return node;
        }

        /**
         * Term rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * term : (PLUS | MINUS) factor (PERCENT)? ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'term',
        value: function term() {
            var unary = null;
            var postfix = null;

            if ([_Constants.TOKENS.PLUS, _Constants.TOKENS.MINUS].includes(this.lookahead.type)) {
                unary = this.lookahead;
                this.match(this.lookahead.type);
            }

            var node = this.factor();

            if (this.lookahead.type === _Constants.TOKENS.PERCENT) {
                postfix = this.lookahead;
                this.match(_Constants.TOKENS.PERCENT);
            }

            if (unary !== null) {
                if (postfix !== null) {
                    return new _ast.PostfixOp(postfix, new _ast.UnaryOp(unary, node));
                }

                return new _ast.UnaryOp(unary, node);
            } else if (postfix !== null) {
                return new _ast.PostfixOp(postfix, node);
            }

            return node;
        }
        /**
         * Factor rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * factor : constant
         *        | formula
         *        | '{' arraycolumns '}'
         *        | '(' expr ')'
         *        ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'factor',
        value: function factor() {
            var constants = [_Constants.TOKENS.NUMBER, _Constants.TOKENS.STRING, _Constants.TOKENS.BOOLEAN, _Constants.TOKENS.ERROR];
            var token = this.lookahead;

            if (token.type === _Constants.TOKENS.LPAREN) {
                this.match(_Constants.TOKENS.LPAREN);

                var node = this.expr();

                this.match(_Constants.TOKENS.RPAREN);

                return node;
            }
            if (token.type === _Constants.TOKENS.LBRACE) {
                this.match(_Constants.TOKENS.LBRACE);

                var items = this.arraycolumns();

                this.match(_Constants.TOKENS.RBRACE);

                return new _ast.ArrayConstant(items);
            } else if (constants.includes(token.type)) {
                return this.constant();
            }

            return this.formula();
        }

        /**
         * Array Columns rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * arraycolumns : arrayrows
         *              | arrayrows ';' arraycolumns
         *              ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'arraycolumns',
        value: function arraycolumns() {
            var columns = [this.arrayrows()];

            while (this.lookahead.type === _Constants.TOKENS.SEMICOLON) {
                this.match(_Constants.TOKENS.SEMICOLON);

                var column = this.arrayrows();

                columns.push(column);
            }

            return columns;
        }

        /**
         * Array Rows rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * arrayrows : expr
         *           | expr ',' arrayrows
         *           ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'arrayrows',
        value: function arrayrows() {
            var rows = [this.expr()];

            while (this.lookahead.type === _Constants.TOKENS.COMMA) {
                this.match(_Constants.TOKENS.COMMA);

                var row = this.expr();

                rows.push(row);
            }

            return rows;
        }

        /**
         * Formula rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * formula : (SHEET)? reference ;
         *
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'formula',
        value: function formula() {
            var token = this.lookahead;
            var name = null;

            if (token.type === _Constants.TOKENS.SHEET) {
                this.match(_Constants.TOKENS.SHEET);
                name = token.value;
            }

            return this.reference(name);
        }

        /**
         * Reference rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * reference : ID ('(' parameters ')')?
         *           | RANGE
         *           ;
         *
         * @param {string} [sheet] - Sheet name
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'reference',
        value: function reference() {
            var sheet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            var token = this.lookahead;

            if (this.nextToken().type === _Constants.TOKENS.LPAREN) {
                this.match(_Constants.TOKENS.ID);
                this.match(_Constants.TOKENS.LPAREN);

                var params = this.parameters();

                this.match(_Constants.TOKENS.RPAREN);

                return new _ast.FunctionCall(token.value, params);
            } else if (token.type === _Constants.TOKENS.RANGE) {
                this.match(_Constants.TOKENS.RANGE);

                return new _ast.RangeReference(token, sheet);
            }

            this.match(_Constants.TOKENS.ID);

            return new _ast.CellIdentifier(token.value, sheet);
        }

        /**
         * Parameters rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * parameters : expr (',' expr)
         *            | empty
         *            ;
         *
         * @todo   Should accept empty parameters like "=COUNT(,,,,)".
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'parameters',
        value: function parameters() {
            var params = [];

            while (this.lookahead.type !== _Constants.TOKENS.RPAREN && this.lookahead.type !== _Constants.TOKENS.EOL) {
                var param = this.expr();

                params.push(param);

                if (this.lookahead.type === _Constants.TOKENS.COMMA) {
                    this.match(_Constants.TOKENS.COMMA);
                }
            }

            return params;
        }

        /**
         * Constant rule.
         *
         * @example <caption>Grammar:</caption>
         *
         * constant : NUMBER
         *          | STRING
         *          | BOOL
         *
         * @throws Will throw an error if it's not a constant.
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'constant',
        value: function constant() {
            var token = this.lookahead;
            var node = void 0;

            if (token.type === _Constants.TOKENS.NUMBER) {
                this.match(_Constants.TOKENS.NUMBER);
                node = new _ast.NumberConstant(token.value);
            } else if (token.type === _Constants.TOKENS.STRING) {
                this.match(_Constants.TOKENS.STRING);
                node = new _ast.StringConstant(token.value);
            } else if (token.type === _Constants.TOKENS.BOOLEAN) {
                this.match(_Constants.TOKENS.BOOLEAN);
                node = new _ast.BooleanConstant(token.value);
            } else if (token.type === _Constants.TOKENS.ERROR) {
                this.match(_Constants.TOKENS.ERROR);
                node = new _ast.ErrorConstant(token.value);
            }

            return node;
        }

        /**
         * Get the next token
         * @return {Token} Next token
         */

    }, {
        key: 'nextToken',
        value: function nextToken() {
            return this.lexer.peek();
        }

        /**
         * Match the current token and move to the next.
         * @param {string} tokenType - Token type.
         * @throws Will throw an error if is a invalid token.
         */

    }, {
        key: 'match',
        value: function match(tokenType) {
            if (this.lookahead.type === tokenType) {
                this.lookahead = this.lexer.next();
            } else {
                throw new SyntaxError('Invalid syntax. Expecting "' + tokenType + '"');
            }
        }

        /**
         * Parse a list of tokens.
         * @throws Will throw an error if is a invalid token.
         * @return {AST} Abstract Syntax tree.
         */

    }, {
        key: 'parse',
        value: function parse() {
            if (this.lookahead === null) {
                return null;
            }

            var node = this.start();

            if (this.lookahead.type !== _Constants.TOKENS.EOL) {
                throw new SyntaxError('Invalid syntax. Expecting end of line.');
            }

            return node;
        }

        /**
         * Set a new Lexer.
         * @param {Lexer} value - Lexical analyzer object.
         */

    }, {
        key: 'lexer',
        set: function set(value) {
            this._lexer = value;
            if (this._lexer) {
                this.lookahead = this._lexer.next();
            } else {
                this.lookahead = null;
            }
        },
        get: function get() // eslint-disable-line require-jsdoc
        {
            return this._lexer;
        }
    }]);

    return Parser;
}();

Parser.displayName = 'Parser';
exports.default = Parser;

},{"./../Constants":363,"./ast":386}],371:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Position object.
 */
var Position =
/**
 * Cell Position
 * @param {number} column - Cell column.
 * @param {number} row - Cell row.
 */
function Position() {
  var column = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var row = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  _classCallCheck(this, Position);

  this.column = column;
  this.row = row;
};

Position.displayName = "Position";
exports.default = Position;

},{}],372:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Range object.
 */
var Range = function () {
    /**
    * Creates a Range.
    * @param {Position} first - First position.
    * @param {Position} last - Last position.
    */
    function Range(first, last) {
        _classCallCheck(this, Range);

        this.first = first;
        this.last = last;
    }

    /**
     * Returns correct range, even if last column or row is smaller than first.
     * @return {Range} Correct range.
     */


    _createClass(Range, [{
        key: "correct",
        value: function correct() {
            var first = this.first;
            var last = this.last;

            if (first.column > last.column) {
                var oldCol = first.column;

                first.column = last.column;
                last.column = oldCol;
            }

            if (first.row > last.row) {
                var oldRow = first.row;

                first.row = last.row;
                last.row = oldRow;
            }

            return new Range(first, last);
        }
    }]);

    return Range;
}();

Range.displayName = "Range";
exports.default = Range;

},{}],373:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A Lexical token.
 */
var Token =
/**
* Creates a Token.
* @param {string} type - Token Type.
* @param {string} value - Token value.
*/
function Token(type) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Token);

    this.type = type;
    this.value = value;
};

Token.displayName = "Token";
exports.default = Token;

},{}],374:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Abstract Syntax Tree node
 */
var AST = function AST() {
  _classCallCheck(this, AST);
};

AST.displayName = "AST";
exports.default = AST;

},{}],375:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ArrayConstant represents an array.
 *
 * @extends AST
 */
var ArrayConstant = function (_AST) {
  _inherits(ArrayConstant, _AST);

  /**
   * Create a Array constant.
   * @param {array} value - List of items.
   */
  function ArrayConstant(value) {
    _classCallCheck(this, ArrayConstant);

    var _this = _possibleConstructorReturn(this, (ArrayConstant.__proto__ || Object.getPrototypeOf(ArrayConstant)).call(this));

    _this.value = value;
    return _this;
  }

  return ArrayConstant;
}(_AST3.default);

ArrayConstant.displayName = 'ArrayConstant';
exports.default = ArrayConstant;

},{"./AST":374}],376:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Binary Operator. A binary operator is an operator that operates on two operands.
 *
 * @extends AST
 */
var BinOp = function (_AST) {
  _inherits(BinOp, _AST);

  /**
   * Create a Binary Operator.
   * @param {string} left - Left operand.
   * @param {Token} op - Operator.
   * @param {string} right - Right operand.
   */
  function BinOp(left, op, right) {
    _classCallCheck(this, BinOp);

    var _this = _possibleConstructorReturn(this, (BinOp.__proto__ || Object.getPrototypeOf(BinOp)).call(this));

    _this.left = left;
    _this.token = _this.op = op;
    _this.right = right;
    return _this;
  }

  return BinOp;
}(_AST3.default);

BinOp.displayName = 'BinOp';
exports.default = BinOp;

},{"./AST":374}],377:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * BooleanConstant represents Booleans.
 *
 * @extends AST
 */
var BooleanConstant = function (_AST) {
  _inherits(BooleanConstant, _AST);

  /**
   * Create a Boolean constant.
   * @param {boolean} value - Boolean.
   */
  function BooleanConstant(value) {
    _classCallCheck(this, BooleanConstant);

    var _this = _possibleConstructorReturn(this, (BooleanConstant.__proto__ || Object.getPrototypeOf(BooleanConstant)).call(this));

    _this.value = value;
    return _this;
  }

  return BooleanConstant;
}(_AST3.default);

BooleanConstant.displayName = 'BooleanConstant';
exports.default = BooleanConstant;

},{"./AST":374}],378:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

var _Position = require('./../Position');

var _Position2 = _interopRequireDefault(_Position);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Cell identifier.
 *
 * @extends AST
 */
var CellIdentifier = function (_AST) {
    _inherits(CellIdentifier, _AST);

    /**
     * Create a Cell identifier object.
     * @param {string} [name] - Function name.
     * @param {string} [sheet] - Sheet name.
     */
    function CellIdentifier(name) {
        var sheet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, CellIdentifier);

        var _this = _possibleConstructorReturn(this, (CellIdentifier.__proto__ || Object.getPrototypeOf(CellIdentifier)).call(this));

        _this.name = name;
        _this.sheet = sheet;
        return _this;
    }

    /**
     * Get cell name (without dollar sign).
     * @return {string} Cell name.
     */


    _createClass(CellIdentifier, [{
        key: 'clean',
        value: function clean() {
            return this.name.toUpperCase().replace(/\$/g, '');
        }

        /**
         * Get cell column and row numbers.
         * @return {Position} Cell position.
         */

    }, {
        key: 'position',
        value: function position() {
            var ref = this.clean();
            var columnString = ref.replace(/[^a-z]/gi, '');
            var column = CellIdentifier.toDecimal(columnString);
            var rowString = ref.replace(/[^0-9]/g, '');
            var row = parseInt(rowString, 10);

            return new _Position2.default(column, row);
        }

        /**
         * From Column string to number. Example: AA => 27
         * Based on: https://stackoverflow.com/questions/12699030/implement-numbering-scheme-like-a-b-c-aa-ab-aaa-similar-to-converting-a-num
         * @param {string} str - Column string
         * @return {number} Column number
         */

    }], [{
        key: 'toDecimal',
        value: function toDecimal(str) {
            var decimal = 0;
            var letters = str.toUpperCase().split(new RegExp());

            for (var i = letters.length - 1; i >= 0; i--) {
                decimal += (letters[i].charCodeAt(0) - 64) * Math.pow(26, letters.length - (i + 1));
            }

            return decimal;
        }

        /**
         * From Column number to string. Example: 27 => AA
         * Based on: https://stackoverflow.com/questions/12699030/implement-numbering-scheme-like-a-b-c-aa-ab-aaa-similar-to-converting-a-num
         * @param {number} value - Column number
         * @return {string} Column string
         */

    }, {
        key: 'toLetters',
        value: function toLetters(value) {
            var digits = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
            var result = [];

            value = value - 1;
            if (value === 0) {
                return digits[0];
            }

            while (value >= 0) {
                result.unshift(digits[value % 26]);
                value = Math.floor(value / 26) - 1;
            }

            return result.join('');
        }
    }]);

    return CellIdentifier;
}(_AST3.default);

CellIdentifier.displayName = 'CellIdentifier';
exports.default = CellIdentifier;

},{"./../Position":371,"./AST":374}],379:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ErrorConstant represents Error references.
 *
 * @extends AST
 */
var ErrorConstant = function (_AST) {
  _inherits(ErrorConstant, _AST);

  /**
   * Create a Error constant.
   * @param {string} [value] - Error description.
   */
  function ErrorConstant(value) {
    _classCallCheck(this, ErrorConstant);

    var _this = _possibleConstructorReturn(this, (ErrorConstant.__proto__ || Object.getPrototypeOf(ErrorConstant)).call(this));

    _this.value = value;
    return _this;
  }

  return ErrorConstant;
}(_AST3.default);

ErrorConstant.displayName = 'ErrorConstant';
exports.default = ErrorConstant;

},{"./AST":374}],380:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Function call.
 *
 * @extends AST
 */
var FunctionCall = function (_AST) {
  _inherits(FunctionCall, _AST);

  /**
   * Create a Function call object.
   * @param {string} [name] - Function name.
   * @param {array} [params] - Function parameters.
   */
  function FunctionCall(name, params) {
    _classCallCheck(this, FunctionCall);

    var _this = _possibleConstructorReturn(this, (FunctionCall.__proto__ || Object.getPrototypeOf(FunctionCall)).call(this));

    _this.name = name;
    _this.params = params;
    return _this;
  }

  return FunctionCall;
}(_AST3.default);

FunctionCall.displayName = 'FunctionCall';
exports.default = FunctionCall;

},{"./AST":374}],381:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * NumberConstant represents Numbers.
 *
 * @extends AST
 */
var NumberConstant = function (_AST) {
  _inherits(NumberConstant, _AST);

  /**
   * Create a Number constant.
   * @param {number} value - Integer or float value.
   */
  function NumberConstant(value) {
    _classCallCheck(this, NumberConstant);

    var _this = _possibleConstructorReturn(this, (NumberConstant.__proto__ || Object.getPrototypeOf(NumberConstant)).call(this));

    _this.value = value;
    return _this;
  }

  return NumberConstant;
}(_AST3.default);

NumberConstant.displayName = 'NumberConstant';
exports.default = NumberConstant;

},{"./AST":374}],382:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An AST node class to represent postfix operators
 *
 * @extends AST
 */
var PostfixOp = function (_AST) {
  _inherits(PostfixOp, _AST);

  /**
   * Create a Postfix Operator.
   * @param {Token} op - Operator.
   * @param {AST} expr - Expression.
   */
  function PostfixOp(op, expr) {
    _classCallCheck(this, PostfixOp);

    var _this = _possibleConstructorReturn(this, (PostfixOp.__proto__ || Object.getPrototypeOf(PostfixOp)).call(this));

    _this.token = _this.op = op;
    _this.expr = expr;
    return _this;
  }

  return PostfixOp;
}(_AST3.default);

PostfixOp.displayName = 'PostfixOp';
exports.default = PostfixOp;

},{"./AST":374}],383:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

var _CellIdentifier = require('./CellIdentifier');

var _CellIdentifier2 = _interopRequireDefault(_CellIdentifier);

var _Range = require('./../Range');

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Range reference.
 *
 * @extends AST
 */
var RangeReference = function (_AST) {
    _inherits(RangeReference, _AST);

    /**
     * Create a Cell identifier object.
     * @param {Token} [token] - Range token.
     * @param {string} [sheet] - Sheet name.
     */
    function RangeReference(token) {
        var sheet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, RangeReference);

        var _this = _possibleConstructorReturn(this, (RangeReference.__proto__ || Object.getPrototypeOf(RangeReference)).call(this));

        _this.token = token;
        _this.rangeValue = token.value;
        _this.sheet = sheet;
        return _this;
    }

    /**
     * Get Range pair
     * @return {array} Two CellIdentifier
     */


    _createClass(RangeReference, [{
        key: 'pair',
        value: function pair() {
            var pairs = this.rangeValue.split(':');

            return [new _CellIdentifier2.default(pairs[0]), new _CellIdentifier2.default(pairs[1])];
        }

        /**
         * Get range information
         * @return {Range} Range object
         */

    }, {
        key: 'range',
        value: function range() {
            var pairs = this.pair();

            return new _Range2.default(pairs[0].position(), pairs[1].position());
        }
    }]);

    return RangeReference;
}(_AST3.default);

RangeReference.displayName = 'RangeReference';
exports.default = RangeReference;

},{"./../Range":372,"./AST":374,"./CellIdentifier":378}],384:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * StringConstant represents Strings.
 *
 * @extends AST
 */
var StringConstant = function (_AST) {
  _inherits(StringConstant, _AST);

  /**
   * Create a String constant.
   * @param {string} value - String.
   */
  function StringConstant(value) {
    _classCallCheck(this, StringConstant);

    var _this = _possibleConstructorReturn(this, (StringConstant.__proto__ || Object.getPrototypeOf(StringConstant)).call(this));

    _this.value = value;
    return _this;
  }

  return StringConstant;
}(_AST3.default);

StringConstant.displayName = 'StringConstant';
exports.default = StringConstant;

},{"./AST":374}],385:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AST2 = require('./AST');

var _AST3 = _interopRequireDefault(_AST2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An AST node class to represent unary operators
 *
 * @extends AST
 */
var UnaryOp = function (_AST) {
  _inherits(UnaryOp, _AST);

  /**
   * Create a Unary Operator.
   * @param {Token} op - Operator.
   * @param {AST} expr - Expression.
   */
  function UnaryOp(op, expr) {
    _classCallCheck(this, UnaryOp);

    var _this = _possibleConstructorReturn(this, (UnaryOp.__proto__ || Object.getPrototypeOf(UnaryOp)).call(this));

    _this.token = _this.op = op;
    _this.expr = expr;
    return _this;
  }

  return UnaryOp;
}(_AST3.default);

UnaryOp.displayName = 'UnaryOp';
exports.default = UnaryOp;

},{"./AST":374}],386:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorConstant = exports.BooleanConstant = exports.StringConstant = exports.NumberConstant = exports.ArrayConstant = exports.PostfixOp = exports.UnaryOp = exports.BinOp = exports.RangeReference = exports.CellIdentifier = exports.FunctionCall = exports.AST = undefined;

var _AST = require('./AST');

var _AST2 = _interopRequireDefault(_AST);

var _FunctionCall = require('./FunctionCall');

var _FunctionCall2 = _interopRequireDefault(_FunctionCall);

var _CellIdentifier = require('./CellIdentifier');

var _CellIdentifier2 = _interopRequireDefault(_CellIdentifier);

var _RangeReference = require('./RangeReference');

var _RangeReference2 = _interopRequireDefault(_RangeReference);

var _BinOp = require('./BinOp');

var _BinOp2 = _interopRequireDefault(_BinOp);

var _UnaryOp = require('./UnaryOp');

var _UnaryOp2 = _interopRequireDefault(_UnaryOp);

var _PostfixOp = require('./PostfixOp');

var _PostfixOp2 = _interopRequireDefault(_PostfixOp);

var _ArrayConstant = require('./ArrayConstant');

var _ArrayConstant2 = _interopRequireDefault(_ArrayConstant);

var _NumberConstant = require('./NumberConstant');

var _NumberConstant2 = _interopRequireDefault(_NumberConstant);

var _StringConstant = require('./StringConstant');

var _StringConstant2 = _interopRequireDefault(_StringConstant);

var _BooleanConstant = require('./BooleanConstant');

var _BooleanConstant2 = _interopRequireDefault(_BooleanConstant);

var _ErrorConstant = require('./ErrorConstant');

var _ErrorConstant2 = _interopRequireDefault(_ErrorConstant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.AST = _AST2.default;
exports.FunctionCall = _FunctionCall2.default;
exports.CellIdentifier = _CellIdentifier2.default;
exports.RangeReference = _RangeReference2.default;
exports.BinOp = _BinOp2.default;
exports.UnaryOp = _UnaryOp2.default;
exports.PostfixOp = _PostfixOp2.default;
exports.ArrayConstant = _ArrayConstant2.default;
exports.NumberConstant = _NumberConstant2.default;
exports.StringConstant = _StringConstant2.default;
exports.BooleanConstant = _BooleanConstant2.default;
exports.ErrorConstant = _ErrorConstant2.default;

},{"./AST":374,"./ArrayConstant":375,"./BinOp":376,"./BooleanConstant":377,"./CellIdentifier":378,"./ErrorConstant":379,"./FunctionCall":380,"./NumberConstant":381,"./PostfixOp":382,"./RangeReference":383,"./StringConstant":384,"./UnaryOp":385}],387:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DATE_TIME_FUNCTIONS = undefined;

var _formulajs = require('formulajs');

var formula = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DATE_TIME_FUNCTIONS = {
    DATE: formula.DATE,
    // DATEVALUE: formula.DATEVALUE, // Not working
    DAY: formula.DAY,
    // DAYS: formula.DAYS,
    // DAYS360: formula.DAYS360,
    // EDATE: formula.EDATE,
    // EOMONTH: formula.EOMONTH,
    // HOUR: formula.HOUR, // Not working
    // INTERVAL: formula.INTERVAL,
    // ISOWEEKNUM: formula.ISOWEEKNUM,
    // MINUTE: formula.MINUTE, // Not working
    MONTH: formula.MONTH,
    // NETWORKDAYS: formula.NETWORKDAYS,
    NOW: formula.NOW,
    // SECOND: formula.SECOND, // Not working
    TIME: formula.TIME,
    // TIMEVALUE: formula.TIMEVALUE,
    TODAY: formula.TODAY,
    // WEEKDAY: formula.WEEKDAY,
    // WEEKNUM: formula.WEEKNUM,
    // WORKDAY: formula.WORKDAY,
    YEAR: formula.YEAR
    // YEARFRAC: formula.YEARFRAC,
};

exports.DATE_TIME_FUNCTIONS = DATE_TIME_FUNCTIONS;

},{"formulajs":344}],388:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FUNCTIONS = undefined;

var _dateTime = require('./date-time');

var _information = require('./information');

var _logical = require('./logical');

var _mathTrig = require('./math-trig');

var _miscellaneous = require('./miscellaneous');

var _statistical = require('./statistical');

var _text = require('./text');

/**
 * Default functions
 *
 * @static
 * @constant
 * @type {object}
 */

// import { LOOKUP_REFERENCE_FUNCTIONS } from './lookup-reference';

// import { ENGINEERING_FUNCTIONS } from './engineering';
// import { FINANCIAL_FUNCTIONS } from './financial';
var FUNCTIONS = Object.assign(_dateTime.DATE_TIME_FUNCTIONS,
// DATABASE_FUNCTIONS,
// ENGINEERING_FUNCTIONS,
// FINANCIAL_FUNCTIONS,
_information.INFORMATION_FUNCTIONS, _logical.LOGICAL_FUNCTIONS,
// LOOKUP_REFERENCE_FUNCTIONS,
_mathTrig.MATH_TRIG_FUNCTIONS, _miscellaneous.MISCELLANEOUS_FUNCTIONS, _statistical.STATISTICAL_FUNCTIONS, _text.TEXT_FUNCTIONS); // import { DATABASE_FUNCTIONS } from './database';
exports.FUNCTIONS = FUNCTIONS;

},{"./date-time":387,"./information":389,"./logical":390,"./math-trig":391,"./miscellaneous":392,"./statistical":393,"./text":394}],389:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.INFORMATION_FUNCTIONS = undefined;

var _formulajs = require('formulajs');

var formula = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var INFORMATION_FUNCTIONS = {
    // INFO: formula.INFO,
    // ISBLANK: formula.ISBLANK,
    ISBINARY: formula.ISBINARY,
    // ISERR: formula.ISERR, // How to handle error?
    ISERR: formula.ISERR,
    ISERROR: formula.ISERROR, // @todo test this
    ISEVEN: formula.ISEVEN,
    // ISFORMULA: formula.ISFORMULA, // How to handle formula?
    ISLOGICAL: formula.ISLOGICAL,
    // ISNA: formula.ISNA, // How to handle error?
    ISNONTEXT: formula.ISNONTEXT,
    ISNUMBER: formula.ISNUMBER,
    ISODD: formula.ISODD,
    // ISREF: formula.ISREF, // How to handle reference?
    ISTEXT: formula.ISTEXT,
    N: function N(value) {
        return formula.N.apply(INFORMATION_FUNCTIONS, [value]);
    },
    // NA: formula.NA, // How to handle error?
    // SHEET: formula.SHEET,
    // SHEETS: formula.SHEETS,
    TYPE: function TYPE(value) {
        return formula.TYPE.apply(INFORMATION_FUNCTIONS, [value]);
    }
};

exports.INFORMATION_FUNCTIONS = INFORMATION_FUNCTIONS;

},{"formulajs":344}],390:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LOGICAL_FUNCTIONS = undefined;

var _formulajs = require('formulajs');

var formula = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var LOGICAL_FUNCTIONS = {
    AND: formula.AND,
    // CHOOSE: formula.CHOOSE,
    FALSE: formula.FALSE,
    IF: formula.IF,
    // IFERROR: formula.IFERROR,
    // IFNA: formula.IFNA,
    NOT: formula.NOT,
    OR: formula.OR,
    TRUE: formula.TRUE
    // XOR: formula.XOR,
    // SWITCH: formula.SWITCH,
};

exports.LOGICAL_FUNCTIONS = LOGICAL_FUNCTIONS;

},{"formulajs":344}],391:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MATH_TRIG_FUNCTIONS = undefined;

var _formulajs = require('formulajs');

var formula = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var MATH_TRIG_FUNCTIONS = {
    ABS: formula.ABS,
    // ACOS: formula.ACOS,
    // ACOSH: formula.ACOSH,
    // ACOT: formula.ACOT,
    // ACOTH: formula.ACOTH,
    // AGGREGATE: formula.AGGREGATE,
    // PRODUCT: formula.PRODUCT,
    SUM: formula.SUM,
    ARABIC: formula.ARABIC,
    // ASIN: formula.ASIN,
    // ASINH: formula.ASINH,
    // ATAN: formula.ATAN,
    // ATAN2: formula.ATAN2,
    // ATANH: formula.ATANH,
    // BASE: formula.BASE,
    // CEILING: formula.CEILING,
    ROUND: formula.ROUND,
    // COMBIN: formula.COMBIN,
    // FACT: formula.FACT,
    // COMBINA: formula.COMBINA,
    // COS: formula.COS,
    // COSH: formula.COSH,
    // COT: formula.COT,
    // COTH: formula.COTH,
    // CSC: formula.CSC,
    // CSCH: formula.CSCH,
    // DECIMAL: formula.DECIMAL,
    // DEGREES: formula.DEGREES,
    // EVEN: formula.EVEN,
    // EXP: formula.EXP,
    // FACTDOUBLE: formula.FACTDOUBLE,
    // FLOOR: formula.FLOOR,
    // GCD: formula.GCD,
    // INT: formula.INT,
    // ISO: formula.ISO,
    // LCM: formula.LCM,
    // LN: formula.LN,
    // LOG: formula.LOG,
    // LOG10: formula.LOG10,
    // MDETERM: formula.MDETERM,
    // MINVERSE: formula.MINVERSE,
    // MMULT: formula.MMULT,
    MOD: formula.MOD,
    // MROUND: formula.MROUND,
    // MULTINOMIAL: formula.MULTINOMIAL,
    // MUNIT: formula.MUNIT,
    // ODD: formula.ODD,
    PI: formula.PI,
    // POWER: formula.POWER,
    // QUOTIENT: formula.QUOTIENT,
    RADIANS: formula.RADIANS,
    RAND: formula.RAND,
    RANDBETWEEN: formula.RANDBETWEEN,
    ROMAN: formula.ROMAN,
    ROUNDDOWN: formula.ROUNDDOWN,
    ROUNDUP: formula.ROUNDUP,
    // SEC: formula.SEC,
    // SECH: formula.SECH,
    // SERIESSUM: formula.SERIESSUM,
    SIGN: formula.SIGN,
    // SIN: formula.SIN,
    // SINH: formula.SINH,
    SQRT: formula.SQRT,
    // SQRTPI: formula.SQRTPI,
    // SUBTOTAL: formula.SUBTOTAL,
    ADD: formula.ADD,
    MINUS: formula.MINUS,
    DIVIDE: formula.DIVIDE,
    MULTIPLY: formula.MULTIPLY,
    GTE: formula.GTE,
    LT: formula.LT,
    LTE: formula.LTE,
    EQ: formula.EQ,
    NE: formula.NE,
    POW: formula.POW,
    // SUMIF: formula.SUMIF,
    // SUMIFS: formula.SUMIFS,
    SUMPRODUCT: formula.SUMPRODUCT,
    SUMSQ: formula.SUMSQ
    // SUMX2MY2: formula.SUMX2MY2,
    // SUMX2PY2: formula.SUMX2PY2,
    // SUMXMY2: formula.SUMXMY2,
    // TAN: formula.TAN,
    // TANH: formula.TANH,
    // TRUNC: formula.TRUNC,
};

exports.MATH_TRIG_FUNCTIONS = MATH_TRIG_FUNCTIONS;

},{"formulajs":344}],392:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MISCELLANEOUS_FUNCTIONS = undefined;

var _formulajs = require('formulajs');

var formula = _interopRequireWildcard(_formulajs);

var _utils = require('formulajs/lib/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var MISCELLANEOUS_FUNCTIONS = {
    UNIQUE: function UNIQUE() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return formula.UNIQUE.apply(null, (0, _utils.flatten)(args));
    }
    // FLATTEN: formula.FLATTEN,
    // ARGS2ARRAY: formula.ARGS2ARRAY,
    // REFERENCE: formula.REFERENCE,
    // JOIN: formula.JOIN,
    // NUMBERS: formula.NUMBERS,
    // NUMERAL: formula.NUMERAL,
};

exports.MISCELLANEOUS_FUNCTIONS = MISCELLANEOUS_FUNCTIONS;

},{"formulajs":344,"formulajs/lib/utils":346}],393:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.STATISTICAL_FUNCTIONS = undefined;

var _formulajs = require('formulajs');

var formula = _interopRequireWildcard(_formulajs);

var _utils = require('formulajs/lib/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var STATISTICAL_FUNCTIONS = {
    AVERAGE: formula.AVERAGE,
    AVERAGEA: formula.AVERAGEA,
    // AVERAGEIF: formula.AVERAGEIF, // Not secure, can pass any JS code as criteria
    // AVERAGEIFS: formula.AVERAGEIFS,
    // COLUMN: formula.COLUMN,
    // COLUMNS: formula.COLUMNS,
    // CORREL: formula.CORREL,
    COUNT: formula.COUNT,
    COUNTA: formula.COUNTA,
    COUNTBLANK: formula.COUNTBLANK,
    COUNTIN: function COUNTIN(range, value) {
        return formula.COUNTIN((0, _utils.flatten)(range), value);
    },
    // COUNTIF: formula.COUNTIF,
    // COUNTIFS: formula.COUNTIFS,
    COUNTUNIQUE: formula.COUNTUNIQUE,
    // DEVSQ: formula.DEVSQ,
    // FISHER: formula.FISHER,
    // FISHERINV: formula.FISHERINV,
    // FORECAST: formula.FORECAST,
    // FREQUENCY: formula.FREQUENCY,
    // GAMMA: formula.GAMMA,
    // GAMMALN: formula.GAMMALN,
    // GAUSS: formula.GAUSS,
    // GEOMEAN: formula.GEOMEAN,
    // GROWTH: formula.GROWTH,
    // HARMEAN: formula.HARMEAN,
    // INTERCEPT: formula.INTERCEPT,
    // KURT: formula.KURT,
    // LARGE: formula.LARGE,
    // LINEST: formula.LINEST,
    // LOGEST: formula.LOGEST,
    MAX: formula.MAX,
    // MAXA: formula.MAXA,
    // MEDIAN: formula.MEDIAN,
    MIN: formula.MIN
    // MINA: formula.MINA,
    // PEARSON: formula.PEARSON,
    // PERMUT: formula.PERMUT,
    // PERMUTATIONA: formula.PERMUTATIONA,
    // PHI: formula.PHI,
    // PROB: formula.PROB,
    // ROW: formula.ROW,
    // ROWS: formula.ROWS,
    // RSQ: formula.RSQ,
    // SKEW: formula.SKEW,
    // SLOPE: formula.SLOPE,
    // SMALL: formula.SMALL,
    // STANDARDIZE: formula.STANDARDIZE,
    // STDEV: formula.STDEV,
    // STDEVA: formula.STDEVA,
    // VARA: formula.VARA,
    // STDEVPA: formula.STDEVPA,
    // VARPA: formula.VARPA,
    // STEYX: formula.STEYX,
    // TRANSPOSE: formula.TRANSPOSE,
    // TREND: formula.TREND,
    // TRIMMEAN: formula.TRIMMEAN,
    // BETADIST: formula.BETADIST,
    // BETAINV: formula.BETAINV,
    // BINOMDIST: formula.BINOMDIST,
    // CEILING: formula.CEILING,
    // ISOCEILING: formula.ISOCEILING,
    // CEILINGMATH: formula.CEILINGMATH,
    // CEILINGPRECISE: formula.CEILINGPRECISE,
    // CHIDIST: formula.CHIDIST,
    // CHIDISTRT: formula.CHIDISTRT,
    // CHIINV: formula.CHIINV,
    // CHIINVRT: formula.CHIINVRT,
    // CHITEST: formula.CHITEST,
    // COVAR: formula.COVAR,
    // COVARIANCEP: formula.COVARIANCEP,
    // COVARIANCES: formula.COVARIANCES,
    // CRITBINOM: formula.CRITBINOM,
    // EXPONDIST: formula.EXPONDIST,
    // ERFCPRECISE: formula.ERFCPRECISE,
    // ERFPRECISE: formula.ERFPRECISE,
    // FDIST: formula.FDIST,
    // FDISTRT: formula.FDISTRT,
    // FINVRT: formula.FINVRT,
    // FINV: formula.FINV,
    // FLOOR: formula.FLOOR,
    // FLOORMATH: formula.FLOORMATH,
    // FLOORPRECISE: formula.FLOORPRECISE,
    // FTEST: formula.FTEST,
    // GAMMADIST: formula.GAMMADIST,
    // GAMMAINV: formula.GAMMAINV,
    // GAMMALNPRECISE: formula.GAMMALNPRECISE,
    // HYPGEOMDIST: formula.HYPGEOMDIST,
    // LOGINV: formula.LOGINV,
    // LOGNORMINV: formula.LOGNORMINV,
    // LOGNORMDIST: formula.LOGNORMDIST,
    // MODEMULT: formula.MODEMULT,
    // MODESNGL: formula.MODESNGL,
    // NEGBINOMDIST: formula.NEGBINOMDIST,
    // NETWORKDAYSINTL: formula.NETWORKDAYSINTL,
    // NORMDIST: formula.NORMDIST,
    // NORMINV: formula.NORMINV,
    // NORMSDIST: formula.NORMSDIST,
    // NORMSINV: formula.NORMSINV,
    // PERCENTILEEXC: formula.PERCENTILEEXC,
    // PERCENTILEINC: formula.PERCENTILEINC,
    // PERCENTRANKEXC: formula.PERCENTRANKEXC,
    // PERCENTRANKINC: formula.PERCENTRANKINC,
    // POISSONDIST: formula.POISSONDIST,
    // QUARTILEEXC: formula.QUARTILEEXC,
    // QUARTILEINC: formula.QUARTILEINC,
    // RANKAVG: formula.RANKAVG,
    // RANKEQ: formula.RANKEQ,
    // SKEWP: formula.SKEWP,
    // STDEVP: formula.STDEVP,
    // STDEVS: formula.STDEVS,
    // TDIST: formula.TDIST,
    // TDISTRT: formula.TDISTRT,
    // TINV: formula.TINV,
    // TTEST: formula.TTEST,
    // VARP: formula.VARP,
    // VARS: formula.VARS,
    // WEIBULLDIST: formula.WEIBULLDIST,
    // WORKDAYINTL: formula.WORKDAYINTL,
    // ZTEST: formula.ZTEST,
};

exports.STATISTICAL_FUNCTIONS = STATISTICAL_FUNCTIONS;

},{"formulajs":344,"formulajs/lib/utils":346}],394:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TEXT_FUNCTIONS = undefined;

var _formulajs = require('formulajs');

var formula = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var TEXT_FUNCTIONS = {
    // ASC: formula.ASC,
    // BAHTTEXT: formula.BAHTTEXT,
    // CHAR: formula.CHAR,
    // CLEAN: formula.CLEAN,
    // CODE: formula.CODE,
    CONCAT: function CONCAT(left, right) {
        return formula.CONCATENATE(left, right);
    },
    CONCATENATE: formula.CONCATENATE,
    // DBCS: formula.DBCS,
    // DOLLAR: formula.DOLLAR,
    // EXACT: formula.EXACT,
    // FIND: formula.FIND,
    // FIXED: formula.FIXED,
    // HTML2TEXT: formula.HTML2TEXT,
    LEFT: formula.LEFT,
    LEN: formula.LEN,
    LOWER: formula.LOWER,
    MID: formula.MID,
    // NUMBERVALUE: formula.NUMBERVALUE,
    // PRONETIC: formula.PRONETIC,
    PROPER: formula.PROPER,
    // REGEXEXTRACT: formula.REGEXEXTRACT,
    // REGEXMATCH: formula.REGEXMATCH,
    // REGEXREPLACE: formula.REGEXREPLACE,
    // REPLACE: formula.REPLACE,
    REPT: formula.REPT,
    RIGHT: formula.RIGHT,
    // SEARCH: formula.SEARCH,
    // SPLIT: formula.SPLIT,
    // SUBSTITUTE: formula.SUBSTITUTE,
    // T: formula.T,
    TEXT: formula.TEXT,
    TRIM: formula.TRIM,
    // UNICHAR: formula.UNICHAR,
    // UNICODE: formula.UNICODE,
    UPPER: formula.UPPER
    // VALUE: formula.VALUE,
};

exports.TEXT_FUNCTIONS = TEXT_FUNCTIONS;

},{"formulajs":344}],395:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Token = require('./Token');

Object.defineProperty(exports, 'Token', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Token).default;
  }
});

var _Characters = require('./Characters');

Object.defineProperty(exports, 'Characters', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Characters).default;
  }
});

var _Lexer = require('./Lexer');

Object.defineProperty(exports, 'Lexer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Lexer).default;
  }
});

var _Parser = require('./Parser');

Object.defineProperty(exports, 'Parser', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Parser).default;
  }
});

var _NodeVisitor = require('./NodeVisitor');

Object.defineProperty(exports, 'NodeVisitor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_NodeVisitor).default;
  }
});

var _Interpreter = require('./Interpreter');

Object.defineProperty(exports, 'Interpreter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Interpreter).default;
  }
});

var _DataGrid = require('./DataGrid');

Object.defineProperty(exports, 'DataGrid', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DataGrid).default;
  }
});

var _Position = require('./Position');

Object.defineProperty(exports, 'Position', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Position).default;
  }
});

var _Range = require('./Range');

Object.defineProperty(exports, 'Range', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Range).default;
  }
});

var _ast = require('./ast');

Object.keys(_ast).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _ast[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./Characters":365,"./DataGrid":366,"./Interpreter":367,"./Lexer":368,"./NodeVisitor":369,"./Parser":370,"./Position":371,"./Range":372,"./Token":373,"./ast":386}]},{},[364])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWZyb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvZXMyMDE1LmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2VzMjAxNi5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9lczUuanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvZXM3LmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNGaW5pdGUuanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvbW9kLmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvZXM1LmpzIiwibm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9lczYuanMiLCJub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mb3JtdWxhanMvZGlzdC9mb3JtdWxhLmpzIiwibm9kZV9tb2R1bGVzL2Zvcm11bGFqcy9saWIvZXJyb3IuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1jYWxsYWJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kYXRlLW9iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvalN0YXQvZGlzdC9qc3RhdC5qcyIsIm5vZGVfbW9kdWxlcy9udW1lcmFsL251bWVyYWwuanMiLCJub2RlX21vZHVsZXMvbnVtZXJpYy9udW1lcmljLTEuMi42LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC52YWx1ZXMvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LnZhbHVlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QudmFsdWVzL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC52YWx1ZXMvc2hpbS5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9Db25zdGFudHMuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvaW5kZXguanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL0NoYXJhY3RlcnMuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL0RhdGFHcmlkLmpzIiwiL2h0ZG9jcy9TaW50L2h0bWwvc3JjL3BhcnNlci9JbnRlcnByZXRlci5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvTGV4ZXIuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL05vZGVWaXNpdG9yLmpzIiwiL2h0ZG9jcy9TaW50L2h0bWwvc3JjL3BhcnNlci9QYXJzZXIuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL1Bvc2l0aW9uLmpzIiwiL2h0ZG9jcy9TaW50L2h0bWwvc3JjL3BhcnNlci9SYW5nZS5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvVG9rZW4uanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2FzdC9BU1QuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2FzdC9BcnJheUNvbnN0YW50LmpzIiwiL2h0ZG9jcy9TaW50L2h0bWwvc3JjL3BhcnNlci9hc3QvQmluT3AuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2FzdC9Cb29sZWFuQ29uc3RhbnQuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2FzdC9DZWxsSWRlbnRpZmllci5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvYXN0L0Vycm9yQ29uc3RhbnQuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2FzdC9GdW5jdGlvbkNhbGwuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2FzdC9OdW1iZXJDb25zdGFudC5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvYXN0L1Bvc3RmaXhPcC5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvYXN0L1JhbmdlUmVmZXJlbmNlLmpzIiwiL2h0ZG9jcy9TaW50L2h0bWwvc3JjL3BhcnNlci9hc3QvU3RyaW5nQ29uc3RhbnQuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2FzdC9VbmFyeU9wLmpzIiwiL2h0ZG9jcy9TaW50L2h0bWwvc3JjL3BhcnNlci9hc3QvaW5kZXguanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2Z1bmN0aW9ucy9kYXRlLXRpbWUuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2Z1bmN0aW9ucy9pbmRleC5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvZnVuY3Rpb25zL2luZm9ybWF0aW9uLmpzIiwiL2h0ZG9jcy9TaW50L2h0bWwvc3JjL3BhcnNlci9mdW5jdGlvbnMvbG9naWNhbC5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvZnVuY3Rpb25zL21hdGgtdHJpZy5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvZnVuY3Rpb25zL21pc2NlbGxhbmVvdXMuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2Z1bmN0aW9ucy9zdGF0aXN0aWNhbC5qcyIsIi9odGRvY3MvU2ludC9odG1sL3NyYy9wYXJzZXIvZnVuY3Rpb25zL3RleHQuanMiLCIvaHRkb2NzL1NpbnQvaHRtbC9zcmMvcGFyc2VyL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaHVCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4MElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2RBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NPLElBQU0sMEJBQVM7QUFDbEIsU0FBSyxPQURhOztBQUdsQjtBQUNBLFlBQVEsVUFKVTtBQUtsQixZQUFRLFVBTFU7QUFNbEIsYUFBUyxXQU5TO0FBT2xCLFdBQU8sU0FQVztBQVFsQixRQUFJLGNBUmM7QUFTbEIsV0FBTyxTQVRXO0FBVWxCLFdBQU8sU0FWVzs7QUFZbEI7QUFDQSxVQUFNLEdBYlk7QUFjbEIsV0FBTyxHQWRXO0FBZWxCLFVBQU0sR0FmWTtBQWdCbEIsU0FBSyxHQWhCYTtBQWlCbEIsU0FBSyxHQWpCYTtBQWtCbEIsUUFBSSxHQWxCYztBQW1CbEIsUUFBSSxHQW5CYztBQW9CbEIsUUFBSSxHQXBCYztBQXFCbEIsUUFBSSxJQXJCYztBQXNCbEIsUUFBSSxJQXRCYztBQXVCbEIsUUFBSSxJQXZCYztBQXdCbEIsWUFBUSxHQXhCVTtBQXlCbEIsaUJBQWEsR0F6Qks7QUEwQmxCLGFBQVMsR0ExQlM7QUEyQmxCLFdBQU8sR0EzQlc7QUE0QmxCLFdBQU8sR0E1Qlc7QUE2QmxCLGVBQVcsR0E3Qk87QUE4QmxCLFlBQVEsR0E5QlU7QUErQmxCLFlBQVEsR0EvQlU7QUFnQ2xCLFlBQVEsR0FoQ1U7QUFpQ2xCLFlBQVEsR0FqQ1U7QUFrQ2xCLFlBQVEsR0FsQ1U7QUFtQ2xCLFlBQVEsR0FuQ1U7QUFvQ2xCLGNBQVUsR0FwQ1E7QUFxQ2xCLGNBQVU7QUFyQ1EsQ0FBZjs7QUF3Q1A7Ozs7Ozs7Ozs7Ozs7OztBQWVPLElBQU0sMEJBQVM7QUFDbEIsU0FBSyxTQURhO0FBRWxCLFVBQU0sUUFGWTtBQUdsQixRQUFJLE1BSGM7QUFJbEIsVUFBTSxRQUpZO0FBS2xCLFNBQUssT0FMYTtBQU1sQixTQUFLLE9BTmE7QUFPbEIsV0FBTztBQVBXLENBQWY7O0FBVVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJPLElBQU0sZ0NBQVk7QUFDckIsU0FBSyxPQUFPLElBRFM7QUFFckIsU0FBSyxPQUFPLEtBRlM7QUFHckIsU0FBSyxPQUFPLElBSFM7QUFJckIsU0FBSyxPQUFPLEdBSlM7QUFLckIsU0FBSyxPQUFPLEdBTFM7QUFNckIsU0FBSyxPQUFPLEVBTlM7QUFPckIsU0FBSyxPQUFPLEVBUFM7QUFRckIsU0FBSyxPQUFPLEVBUlM7QUFTckIsVUFBTSxPQUFPLEVBVFE7QUFVckIsVUFBTSxPQUFPLEVBVlE7QUFXckIsVUFBTSxPQUFPLEVBWFE7QUFZckIsU0FBSyxPQUFPLE1BWlM7QUFhckIsU0FBSyxPQUFPLFdBYlM7QUFjckIsU0FBSyxPQUFPLE9BZFM7QUFlckIsU0FBSyxPQUFPLEtBZlM7QUFnQnJCLFNBQUssT0FBTyxLQWhCUztBQWlCckIsU0FBSyxPQUFPLFNBakJTO0FBa0JyQixTQUFLLE9BQU8sTUFsQlM7QUFtQnJCLFNBQUssT0FBTyxNQW5CUztBQW9CckIsU0FBSyxPQUFPLE1BcEJTO0FBcUJyQixTQUFLLE9BQU8sTUFyQlM7QUFzQnJCLFNBQUssT0FBTyxNQXRCUztBQXVCckIsU0FBSyxPQUFPLFFBdkJTO0FBd0JyQixTQUFLLE9BQU87QUF4QlMsQ0FBbEI7O0FBMkJQOzs7Ozs7O0FBT08sSUFBTSxzQ0FBZTtBQUN4QjtBQUNBLFNBQUssV0FBQyxJQUFELEVBQU8sS0FBUDtBQUFBLGVBQWtCLE9BQU8sS0FBekI7QUFBQSxLQUZtQjtBQUd4QixTQUFLLFdBQUMsSUFBRCxFQUFPLEtBQVA7QUFBQSxlQUFrQixPQUFPLEtBQXpCO0FBQUEsS0FIbUI7QUFJeEIsU0FBSyxXQUFDLElBQUQsRUFBTyxLQUFQO0FBQUEsZUFBa0IsT0FBTyxLQUF6QjtBQUFBLEtBSm1CO0FBS3hCLFNBQUssV0FBQyxJQUFELEVBQU8sS0FBUDtBQUFBLGVBQWtCLE9BQU8sS0FBekI7QUFBQSxLQUxtQjtBQU14QixTQUFLLFdBQUMsSUFBRCxFQUFPLEtBQVA7QUFBQSxlQUFpQixxQkFBVSxHQUFWLENBQWMsSUFBZCxFQUFvQixLQUFwQixDQUFqQjtBQUFBLEtBTm1COztBQVF4QjtBQUNBLFNBQUssV0FBQyxJQUFELEVBQU8sS0FBUDtBQUFBLGVBQWtCLE9BQU8sS0FBekI7QUFBQSxLQVRtQjtBQVV4QixTQUFLLFdBQUMsSUFBRCxFQUFPLEtBQVA7QUFBQSxlQUFrQixPQUFPLEtBQXpCO0FBQUEsS0FWbUI7QUFXeEIsU0FBSyxXQUFDLElBQUQsRUFBTyxLQUFQO0FBQUEsZUFBa0IsUUFBUSxLQUExQjtBQUFBLEtBWG1CLEVBV2U7QUFDdkMsVUFBTSxXQUFDLElBQUQsRUFBTyxLQUFQO0FBQUEsZUFBa0IsUUFBUSxLQUExQjtBQUFBLEtBWmtCO0FBYXhCLFVBQU0sV0FBQyxJQUFELEVBQU8sS0FBUDtBQUFBLGVBQWtCLFFBQVEsS0FBMUI7QUFBQSxLQWJrQjtBQWN4QixVQUFNLFdBQUMsSUFBRCxFQUFPLEtBQVA7QUFBQSxlQUFrQixRQUFRLEtBQTFCO0FBQUEsS0Fka0IsRUFjZ0I7O0FBRXhDO0FBQ0EsU0FBSyxXQUFDLElBQUQsRUFBTyxLQUFQO0FBQUEsZUFBaUIscUJBQVUsTUFBVixDQUFpQixJQUFqQixFQUF1QixLQUF2QixDQUFqQjtBQUFBO0FBakJtQixDQUFyQjs7UUFxQkgsUzs7Ozs7Ozs7Ozs7OztBQ3pMSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSEE7O0FBQ0E7O0lBQVksTTs7OztRQUtSLE0sR0FBQSxNOzs7QUFHSixJQUFNLE9BQU8sT0FBYixDLENBQXNCOztBQUV0QixPQUFPLElBQVAsR0FBYyxJQUFkLEMsQ0FBb0I7O0FBRXBCLElBQUksT0FBTyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDLE9BQU8sT0FBTyxPQUFkLEtBQTBCLFdBQS9ELEVBQTRFO0FBQzVFO0FBQ0ksZUFBTyxPQUFQLEdBQWlCLElBQWpCLENBREosQ0FDMkI7QUFDMUIsS0FIRCxNQUlLLElBQUksT0FBTyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU8sR0FBM0MsRUFBZ0Q7QUFDckQ7QUFDSSxlQUFPLEVBQVAsRUFBVyxZQUFZO0FBQ3ZCO0FBQ0ksbUJBQU8sSUFBUDtBQUNILFNBSEQ7QUFJSCxLQU5JLE1BUUw7QUFDSSxXQUFPLElBQVAsR0FBYyxJQUFkLENBREosQ0FDd0I7QUFDdkI7Ozs7Ozs7Ozs7Ozs7OztBQzNCRDs7O0lBR3FCLFU7QUFFakI7Ozs7QUFJQSwwQkFDQTtBQUFBLFlBRFksSUFDWix1RUFEbUIsRUFDbkI7O0FBQUE7O0FBQ0ksYUFBSyxJQUFMLEdBQVksSUFBWjtBQUNIOztBQUVEOzs7Ozs7OztrQ0FLQTtBQUNJLGlCQUFLLE9BQUw7O0FBRUEsbUJBQU8sS0FBSyxPQUFaO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQW9EQTs7Ozt1Q0FLQTtBQUNJLG1CQUFRLFFBQUQsQ0FBVSxJQUFWLENBQWUsS0FBSyxPQUFwQjtBQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7a0NBS0E7QUFDSSxtQkFBUSxjQUFELENBQWdCLElBQWhCLENBQXFCLEtBQUssT0FBMUI7QUFBUDtBQUNIOztBQUVEOzs7Ozs7O29DQUtBO0FBQ0k7QUFDQSxtQkFBUSxpQkFBRCxDQUFtQixJQUFuQixDQUF3QixLQUFLLE9BQTdCO0FBQVAsY0FGSixDQUVrRDtBQUNqRDs7QUFFRDs7Ozs7OztrQ0FLQTtBQUNJLG1CQUFRLFdBQUQsQ0FBYSxJQUFiLENBQWtCLEtBQUssT0FBdkI7QUFBUDtBQUNIOztBQUVEOzs7Ozs7O3VDQUtBO0FBQ0ksbUJBQVEsS0FBSyxPQUFMLE1BQWtCLEtBQUssU0FBTCxFQUFsQixJQUFzQyxLQUFLLE9BQUwsRUFBdEMsSUFBeUQsYUFBRCxDQUFnQixJQUFoQixDQUFxQixLQUFLLE9BQTFCLENBQWhFO0FBQ0g7Ozs0QkEzRkQ7QUFDSSxtQkFBTyxLQUFLLEtBQUwsQ0FBVyxLQUFLLE9BQUwsR0FBZSxDQUExQixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7NEJBS0E7QUFDSSxtQkFBTyxLQUFLLE9BQUwsSUFBZ0IsS0FBSyxLQUFMLENBQVcsTUFBbEM7QUFDSDs7QUFFRDs7Ozs7Ozs0QkFLQTtBQUNJLG1CQUFPLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs0QkFNQTtBQUNJLG1CQUFPLEtBQUssS0FBTCxDQUFXLEtBQUssT0FBaEIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7OzBCQUlTLEssRUFDVDtBQUNJLGlCQUFLLEtBQUwsR0FBYSxPQUFPLEtBQVAsQ0FBYjtBQUNBLGlCQUFLLE9BQUwsR0FBZSxDQUFmO0FBQ0gsUzs0QkFFVTtBQUNYO0FBQ0ksbUJBQU8sS0FBSyxLQUFaO0FBQ0g7Ozs7Ozs7a0JBeEVnQixVOzs7Ozs7Ozs7Ozs7O0FDSHJCOzs7Ozs7OztBQUVBLElBQUksQ0FBQyxPQUFPLE1BQVosRUFDQTtBQUNJLHFCQUFPLElBQVA7QUFDSDs7QUFFRDs7OztJQUdxQixRO0FBRWpCOzs7O0FBSUEsd0JBQ0E7QUFBQSxZQURZLE1BQ1osdUVBRHFCLEVBQ3JCOztBQUFBOztBQUNJLGFBQUssTUFBTCxHQUFjLE1BQWQ7QUFDSDs7QUFFRDs7Ozs7Ozs7O2lDQUtTLEksRUFDVDtBQUNJLGdCQUFNLE9BQU8sS0FBSyxLQUFMLEVBQWI7O0FBRUEsbUJBQU8sS0FBSyxNQUFMLENBQVksSUFBWixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztpQ0FNUyxLLEVBQ1Q7QUFBQSw4QkFDMEIsTUFBTSxJQUFOLEVBRDFCO0FBQUE7QUFBQSxnQkFDVyxLQURYO0FBQUEsZ0JBQ2tCLElBRGxCLG9CQUN3Qzs7O0FBQ3BDLGdCQUFNLFNBQVMsT0FBTyxNQUFQLENBQWMsS0FBSyxNQUFuQixDQUFmOztBQUVBLG1CQUFPLE1BQVA7QUFDSDs7Ozs7OztrQkFuQ2dCLFE7Ozs7Ozs7Ozs7O0FDVnJCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7O0lBTXFCLFc7OztBQUVqQjs7Ozs7QUFLQSwyQkFDQTtBQUFBLFlBRFksSUFDWix1RUFEbUIsSUFDbkI7QUFBQSxZQUR5QixJQUN6Qix1RUFEZ0MsSUFDaEM7O0FBQUE7O0FBQUE7O0FBRUksY0FBSyxJQUFMLEdBQWEsT0FBTyxJQUFQLEdBQWMsd0JBQTNCO0FBQ0EsY0FBSyxTQUFMLEdBQWtCLE9BQU8sSUFBUCx1QkFBbEI7QUFISjtBQUlDOztBQUVEOzs7Ozs7Ozs7OzBDQU1rQixJLEVBQ2xCO0FBQ0ksZ0JBQU0sT0FBTyxLQUFLLElBQWxCO0FBQ0EsZ0JBQU0sS0FBSyxLQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBWDs7QUFFQSxnQkFBSSxNQUFNLE9BQU8sRUFBUCxLQUFjLFVBQXhCLEVBQ0E7QUFDSSxvQkFBTSxPQUFPLEVBQWI7O0FBRUEscUJBQUssSUFBTSxLQUFYLElBQW9CLEtBQUssTUFBekIsRUFDQTtBQUNJLHdCQUFNLE1BQU0sS0FBSyxNQUFMLENBQVksS0FBWixDQUFaOztBQUVBLHlCQUFLLElBQUwsQ0FBVSxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQVY7QUFDSDs7QUFFRCx1QkFBTyxHQUFHLEtBQUgsQ0FBUyxJQUFULEVBQWUsSUFBZixDQUFQO0FBQ0g7O0FBRUQsa0JBQU0sSUFBSSxLQUFKLGdCQUF1QixJQUF2Qix3QkFBTjtBQUNIOztBQUVEOzs7Ozs7Ozs0Q0FLb0IsSSxFQUNwQjtBQUNJLGdCQUFJLEtBQUssSUFBVCxFQUNBO0FBQ0ksdUJBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixJQUFuQixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs0Q0FLb0IsSSxFQUNwQjtBQUNJLGdCQUFJLEtBQUssSUFBVCxFQUNBO0FBQ0ksdUJBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixJQUFuQixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7OzttQ0FLVyxJLEVBQ1g7QUFDSSxnQkFBTSxPQUFPLEtBQUssRUFBTCxDQUFRLEtBQXJCO0FBQ0EsZ0JBQU0sV0FBVyx3QkFBYSxJQUFiLENBQWpCOztBQUVBLGdCQUFJLFFBQUosRUFDQTtBQUNJLHVCQUFPLFNBQVMsS0FBSyxLQUFMLENBQVcsS0FBSyxJQUFoQixDQUFULEVBQWdDLEtBQUssS0FBTCxDQUFXLEtBQUssS0FBaEIsQ0FBaEMsQ0FBUDtBQUNIOztBQUVELG1CQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7cUNBS2EsSSxFQUNiO0FBQ0ksZ0JBQUksS0FBSyxFQUFMLENBQVEsSUFBUixLQUFpQixrQkFBTyxLQUE1QixFQUNBO0FBQ0ksdUJBQU8sQ0FBRSxLQUFLLEtBQUwsQ0FBVyxLQUFLLElBQWhCLENBQVQ7QUFDSDs7QUFFRCxtQkFBTyxDQUFFLEtBQUssS0FBTCxDQUFXLEtBQUssSUFBaEIsQ0FBVCxDQU5KLENBTXFDO0FBQ3BDOztBQUVEOzs7Ozs7Ozt1Q0FLZSxJLEVBQ2Y7QUFDSSxtQkFBTyxPQUFPLEtBQUssS0FBTCxDQUFXLEtBQUssSUFBaEIsSUFBd0IsR0FBL0IsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7OzsyQ0FLbUIsSSxFQUNuQjtBQUNJLGdCQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsS0FBSyxLQUFuQixDQUFMLEVBQ0E7QUFDSSx1QkFBTyxFQUFQO0FBQ0g7O0FBRUQsZ0JBQU0sVUFBVSxLQUFLLEtBQXJCO0FBQ0EsZ0JBQU0sV0FBVyxFQUFqQjtBQUNBLGdCQUFJLFNBQVMsRUFBYjtBQUNBLGdCQUFJLE1BQU0sRUFBVjs7QUFFQSxpQkFBSyxJQUFNLENBQVgsSUFBZ0IsT0FBaEIsRUFDQTtBQUNJLHlCQUFTLFFBQVEsQ0FBUixDQUFUO0FBQ0EseUJBQVMsQ0FBVCxJQUFjLEVBQWQ7QUFDQSxxQkFBSyxJQUFNLENBQVgsSUFBZ0IsTUFBaEIsRUFDQTtBQUNJLDBCQUFNLE9BQU8sQ0FBUCxDQUFOO0FBQ0EsNkJBQVMsQ0FBVCxFQUFZLENBQVosSUFBaUIsS0FBSyxLQUFMLENBQVcsR0FBWCxDQUFqQjtBQUNIO0FBQ0o7O0FBRUQsbUJBQU8sUUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs0Q0FLb0IsSSxFQUNwQjtBQUNJLG1CQUFPLEtBQUssS0FBWjtBQUNIOztBQUVEOzs7Ozs7Ozs0Q0FLb0IsSSxFQUNwQjtBQUNJLG1CQUFPLEtBQUssS0FBWjtBQUNIOztBQUVEOzs7Ozs7Ozs2Q0FLcUIsSSxFQUNyQjtBQUNJLG1CQUFPLEtBQUssS0FBWjtBQUNIOztBQUVEOzs7Ozs7OzsyQ0FLbUIsSSxFQUNuQjtBQUNJLG1CQUFPLEtBQUssS0FBWjtBQUNIOztBQUVEOzs7Ozs7Ozt1Q0FLZSxJLEVBQ2Y7QUFDSSxnQkFBTSxNQUFNLEtBQUssU0FBakI7O0FBRUEsbUJBQU8sSUFBSSxJQUFKLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7cUNBS2EsSSxFQUNiO0FBQ0ksaUJBQUssU0FBTCxHQUFpQixPQUFPLE1BQVAsQ0FBYyxLQUFLLFNBQW5CLEVBQThCLElBQTlCLENBQWpCOztBQUVBLG1CQUFPLEtBQUssU0FBWjtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFrQkE7Ozs7OztnQ0FNUSxNLEVBQ1I7QUFDSSxnQkFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBdEIsRUFDQTtBQUNJLG9CQUFNLFFBQVEsb0JBQVUsTUFBVixDQUFkO0FBQ0Esb0JBQU0sU0FBUyxxQkFBVyxLQUFYLENBQWY7QUFDQSxvQkFBTSxPQUFPLE9BQU8sS0FBUCxFQUFiOztBQUVBLHVCQUFPLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBUDtBQUNILGFBUEQsTUFRSyxJQUFJLDBCQUFKLEVBQ0w7QUFDSSx1QkFBTyxLQUFLLEtBQUwsQ0FBVyxNQUFYLENBQVA7QUFDSDs7QUFFRCxtQkFBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OEJBUUE7QUFBQSxnQkFESSxNQUNKLHVFQURhLElBQ2I7QUFBQSxnQkFEbUIsSUFDbkIsdUVBRDBCLElBQzFCOztBQUNJLGdCQUFJLFNBQVMsSUFBYixFQUNBO0FBQ0kscUJBQUssSUFBTCxHQUFZLElBQVo7QUFDSDs7QUFFRCxtQkFBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQVA7QUFDSDs7OzBCQXJEYSxJLEVBQ2Q7QUFDSSxpQkFBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0g7O0FBRUQ7Ozs7OzRCQUtBO0FBQ0ksbUJBQU8sS0FBSyxVQUFaO0FBQ0g7Ozs7Ozs7a0JBbE9nQixXOzs7Ozs7Ozs7OztBQ2JyQjs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFNLGFBQWEsR0FBbkI7QUFDQSxJQUFNLGFBQWEsR0FBbkI7QUFDQSxJQUFNLGNBQWMsR0FBcEI7QUFDQSxJQUFNLGVBQWUsSUFBckI7QUFDQSxJQUFNLGVBQWUsR0FBckI7O0FBRUE7QUFDQSxJQUFNLFlBQVksR0FBbEI7QUFDQSxJQUFNLG1CQUFtQixHQUF6QjtBQUNBLElBQU0sZ0JBQWdCLEdBQXRCO0FBQ0EsSUFBTSxRQUFRLEdBQWQ7O0FBRUE7QUFDQSxTQUFTLFFBQVQsQ0FBa0IsTUFBbEIsRUFDQTtBQUNJLFdBQU8sQ0FBQyxNQUFNLFdBQVcsTUFBWCxDQUFOLENBQUQsSUFBOEIsU0FBUyxNQUFULENBQXJDO0FBQ0g7O0FBRUQ7Ozs7OztJQUtxQixLOzs7QUFFakI7Ozs7QUFJQSxxQkFDQTtBQUFBLFlBRFksSUFDWix1RUFEbUIsRUFDbkI7O0FBQUE7O0FBQUEsNkdBQ1UsSUFEVjtBQUVDOztBQUVEOzs7Ozs7O3lDQUlBO0FBQ0ksbUJBQU8sQ0FBQyxLQUFLLEdBQU4sSUFBYSxLQUFLLFlBQUwsRUFBcEIsRUFDQTtBQUNJLHFCQUFLLE9BQUw7QUFDSDtBQUNKOztBQUVEOzs7Ozs7O21DQUtBO0FBQ0ksZ0JBQUksU0FBUyxFQUFiOztBQUVBLG1CQUFPLENBQUMsS0FBSyxHQUFiLEVBQ0E7QUFDSSwwQkFBVSxLQUFLLE9BQWY7QUFDQSxxQkFBSyxPQUFMO0FBQ0g7O0FBRUQsbUJBQU8sTUFBUDtBQUNIOztBQUVEOzs7Ozs7O21DQUtBO0FBQ0ksZ0JBQU0saUJBQWtCLEtBQUssT0FBTCxLQUFpQixZQUF6QztBQUNBLGdCQUFJLGVBQUo7O0FBRUEsZ0JBQUksY0FBSixFQUNBO0FBQ0kscUJBQUssT0FBTDtBQUNBLHlCQUFTLEtBQUssUUFBTCxFQUFUOztBQUVBLHVCQUFPLG9CQUFVLGtCQUFPLE1BQWpCLEVBQXlCLE9BQU8sTUFBUCxDQUF6QixDQUFQO0FBQ0g7O0FBRUQscUJBQVMsS0FBSyxRQUFMLEVBQVQ7QUFDQSxnQkFBSSxNQUFKLEVBQ0E7QUFDSSxvQkFBTSxRQUFRLE9BQU8sV0FBUCxFQUFkO0FBQ0Esb0JBQU0sUUFBUSxNQUFNLElBQU4sRUFBZDs7QUFFQSxxQkFBSyxJQUFNLEdBQVgsdUJBQ0E7QUFDSSx3QkFBSSxrQkFBTyxHQUFQLE1BQWdCLEtBQXBCLEVBQ0E7QUFDSSwrQkFBTyxvQkFBVSxrQkFBTyxLQUFqQixFQUF3QixLQUF4QixDQUFQO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSSxVQUFVLE1BQWQsRUFDQTtBQUNJLDJCQUFPLG9CQUFVLGtCQUFPLE9BQWpCLEVBQTBCLElBQTFCLENBQVA7QUFDSCxpQkFIRCxNQUlLLElBQUksVUFBVSxPQUFkLEVBQ0w7QUFDSSwyQkFBTyxvQkFBVSxrQkFBTyxPQUFqQixFQUEwQixLQUExQixDQUFQO0FBQ0gsaUJBSEksTUFJQSxJQUFJLFNBQVMsTUFBVCxDQUFKLEVBQ0w7QUFDSSwyQkFBTyxvQkFBVSxrQkFBTyxNQUFqQixFQUF5QixXQUFXLE1BQVgsQ0FBekIsQ0FBUDtBQUNIOztBQUVELHVCQUFPLG9CQUFVLGtCQUFPLE1BQWpCLEVBQXlCLE9BQU8sTUFBUCxDQUF6QixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sb0JBQVUsa0JBQU8sR0FBakIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7O2dDQUtBO0FBQ0ksZ0JBQUksU0FBUyxFQUFiOztBQUVBLG1CQUFPLEtBQUssT0FBTCxFQUFQLEVBQ0E7QUFDSSwwQkFBVSxLQUFLLE9BQWY7QUFDQSxxQkFBSyxPQUFMO0FBQ0g7O0FBRUQsbUJBQU8sTUFBUDtBQUNIOztBQUVEOzs7Ozs7O2lDQUtBO0FBQ0ksZ0JBQUksU0FBUyxLQUFLLEtBQUwsRUFBYjs7QUFFQSxnQkFBSSxLQUFLLE9BQUwsS0FBaUIsR0FBckIsRUFDQTtBQUNJLHFCQUFLLE9BQUwsR0FESixDQUNvQjtBQUNoQix5QkFBWSxNQUFaLFNBQXNCLEtBQUssS0FBTCxFQUF0QjtBQUNILGFBSkQsTUFLSyxJQUFJLEtBQUssT0FBTCxLQUFpQixHQUFyQixFQUNMO0FBQ0kscUJBQUssT0FBTCxHQURKLENBQ29CO0FBQ2hCLHlCQUFZLE1BQVosU0FBc0IsS0FBSyxLQUFMLEVBQXRCOztBQUVBLHVCQUFPLG9CQUFVLGtCQUFPLEtBQWpCLEVBQXdCLE1BQXhCLENBQVA7QUFDSDtBQUNELHFCQUFTLFdBQVcsTUFBWCxDQUFUOztBQUVBLG1CQUFPLG9CQUFVLGtCQUFPLE1BQWpCLEVBQXlCLE1BQXpCLENBQVA7QUFDSDs7QUFFRDs7Ozs7OzsrQkFLQTtBQUNJLGdCQUFJLFNBQVMsRUFBYjs7QUFFQSxtQkFBTyxDQUFDLEtBQUssR0FBTixJQUFhLEtBQUssWUFBTCxFQUFwQixFQUNBO0FBQ0ksMEJBQVUsS0FBSyxPQUFmO0FBQ0EscUJBQUssT0FBTDtBQUNIOztBQUVELG1CQUFPLE9BQU8sV0FBUCxFQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7cUNBS0E7QUFDSSxnQkFBSSxTQUFTLEtBQUssSUFBTCxFQUFiO0FBQ0EsZ0JBQU0sWUFBYSxXQUFXLE1BQVgsSUFBcUIsV0FBVyxPQUFuRDs7QUFFQTtBQUNBLGdCQUFJLFNBQUosRUFDQTtBQUNJLHFCQUFLLGNBQUw7QUFDQSxvQkFBSSxLQUFLLE9BQUwsS0FBaUIsR0FBckIsRUFDQTtBQUNJLDJCQUFPLG9CQUFVLGtCQUFPLE9BQWpCLEVBQTBCLFdBQVcsTUFBckMsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQ7QUFDQSxnQkFBSSxLQUFLLE9BQUwsS0FBaUIsR0FBckIsRUFDQTtBQUNJO0FBQ0EscUJBQUssT0FBTDs7QUFFQSxvQkFBTSxRQUFRLE1BQWQ7QUFDQSxvQkFBTSxPQUFPLEtBQUssSUFBTCxFQUFiOztBQUVBLHlCQUFZLEtBQVosU0FBcUIsSUFBckI7O0FBRUEsdUJBQU8sb0JBQVUsa0JBQU8sS0FBakIsRUFBd0IsTUFBeEIsQ0FBUDtBQUNIOztBQUVEO0FBQ0EsZ0JBQUksS0FBSyxPQUFMLEtBQWlCLEdBQXJCLEVBQ0E7QUFDSTtBQUNBLHFCQUFLLE9BQUw7O0FBRUEsdUJBQU8sb0JBQVUsa0JBQU8sS0FBakIsRUFBd0IsTUFBeEIsQ0FBUDtBQUNIOztBQUVELG1CQUFPLG9CQUFVLGtCQUFPLEVBQWpCLEVBQXFCLE1BQXJCLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7a0NBTUE7QUFBQSxnQkFEUSxHQUNSLHVFQURjLFlBQ2Q7O0FBQ0ksZ0JBQUksU0FBUyxFQUFiOztBQUVBO0FBQ0EsaUJBQUssT0FBTDtBQUNBLG1CQUFPLENBQUMsS0FBSyxHQUFOLElBQWEsS0FBSyxPQUFMLEtBQWlCLEdBQXJDLEVBQ0E7QUFDSSwwQkFBVSxLQUFLLE9BQWY7QUFDQSxxQkFBSyxPQUFMO0FBQ0g7O0FBRUQ7QUFDQSxpQkFBSyxPQUFMOztBQUVBLG1CQUFPLE9BQU8sTUFBUCxDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7aUNBS0E7QUFDSSxnQkFBTSxTQUFTLEtBQUssT0FBTCxDQUFhLFlBQWIsQ0FBZjs7QUFFQSxtQkFBTyxvQkFBVSxrQkFBTyxNQUFqQixFQUF5QixNQUF6QixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7O2dDQU1BO0FBQ0ksZ0JBQU0sU0FBUyxLQUFLLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLElBQTNCLEdBQWtDLFdBQWxDLEVBQWY7O0FBRUEsZ0JBQUksQ0FBQyxPQUFPLE1BQVosRUFDQTtBQUNJLHNCQUFNLElBQUksS0FBSixvQkFBTjtBQUNIOztBQUVEO0FBQ0EsaUJBQUssT0FBTDs7QUFFQSxtQkFBTyxvQkFBVSxrQkFBTyxLQUFqQixFQUF3QixNQUF4QixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7O2dDQU1BO0FBQ0ksZ0JBQU0sYUFBYSxDQUFDLGdCQUFELEVBQW1CLGFBQW5CLEVBQWtDLEtBQWxDLENBQW5CO0FBQ0EsZ0JBQUksU0FBUyxFQUFiOztBQUVBLG1CQUFPLENBQUMsS0FBSyxHQUFOLElBQWEsQ0FBQyxXQUFXLFFBQVgsQ0FBb0IsS0FBSyxPQUF6QixDQUFyQixFQUNBO0FBQ0ksMEJBQVUsS0FBSyxPQUFmO0FBQ0EscUJBQUssT0FBTDtBQUNIOztBQUVELGdCQUFNLFVBQVcsS0FBSyxPQUFMLEtBQWlCLEtBQWxDOztBQUVBLHNCQUFVLEtBQUssT0FBZjtBQUNBLGlCQUFLLE9BQUw7O0FBRUEsZ0JBQUksT0FBSixFQUNBO0FBQ0ksd0JBQVEsS0FBSyxPQUFiO0FBRUk7QUFDQSx5QkFBSyxHQUFMO0FBQ0ksa0NBQVUsS0FBSyxPQUFmO0FBQ0EsNkJBQUssT0FBTDtBQUNBLGtDQUFVLEtBQUssT0FBZjtBQUNBLDZCQUFLLE9BQUw7QUFDQTs7QUFFSjtBQUNBLHlCQUFLLEdBQUw7QUFDQSx5QkFBSyxHQUFMO0FBQ0ksa0NBQVUsS0FBSyxPQUFmO0FBQ0EsNkJBQUssT0FBTDtBQUNBO0FBZlI7QUFpQkg7O0FBRUQscUJBQVMsT0FBTyxXQUFQLEVBQVQ7QUFDQSxpQkFBSyxJQUFNLEdBQVgsdUJBQ0E7QUFDSSxvQkFBSSxrQkFBTyxHQUFQLE1BQWdCLE1BQXBCLEVBQ0E7QUFDSSwyQkFBTyxvQkFBVSxrQkFBTyxLQUFqQixFQUF3QixNQUF4QixDQUFQO0FBQ0g7QUFDSjs7QUFFRCxtQkFBTyxNQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7bUNBS0E7QUFDSSxnQkFBSSxTQUFTLEtBQUssT0FBbEI7QUFDQSxnQkFBTSxPQUFPLEtBQUssT0FBTCxFQUFiOztBQUVBLGdCQUFJLFdBQVcsR0FBWCxJQUFrQixTQUFTLEdBQS9CLEVBQ0E7QUFDSSwwQkFBVSxLQUFLLE9BQWY7QUFDQSxxQkFBSyxPQUFMO0FBQ0gsYUFKRCxNQUtLLElBQUksV0FBVyxHQUFYLElBQWtCLFNBQVMsR0FBL0IsRUFDTDtBQUNJLDBCQUFVLEtBQUssT0FBZjtBQUNBLHFCQUFLLE9BQUw7QUFDSCxhQUpJLE1BS0EsSUFBSSxXQUFXLEdBQVgsSUFBa0IsU0FBUyxHQUEvQixFQUNMO0FBQ0ksMEJBQVUsS0FBSyxPQUFmO0FBQ0EscUJBQUssT0FBTDtBQUNIOztBQUVELG1CQUFPLG9CQUFVLHFCQUFVLE1BQVYsQ0FBVixFQUE2QixNQUE3QixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7K0JBS0E7QUFDSSxnQkFBTSxhQUFhLEtBQUssT0FBeEI7QUFDQSxnQkFBTSxRQUFRLEtBQUssSUFBTCxFQUFkOztBQUVBLGlCQUFLLE9BQUwsR0FBZSxVQUFmOztBQUVBLG1CQUFPLEtBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7cUNBTUE7QUFDSTtBQUNBLGdCQUFJLEtBQUssT0FBTCxLQUFpQixDQUFyQixFQUNBO0FBQ0kscUJBQUssT0FBTDs7QUFFQSx1QkFBTyxvQkFBVSxrQkFBTyxFQUFqQixFQUFxQixVQUFyQixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sQ0FBQyxLQUFLLEdBQWIsRUFDQTtBQUNJO0FBQ0Esb0JBQUksS0FBSyxZQUFMLEVBQUosRUFDQTtBQUNJLHlCQUFLLGNBQUw7QUFDSDs7QUFFRDtBQUNBLG9CQUFJLEtBQUssT0FBTCxFQUFKLEVBQ0E7QUFDSSwyQkFBTyxLQUFLLE1BQUwsRUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksS0FBSyxPQUFMLE1BQWtCLEtBQUssU0FBTCxFQUFsQixJQUFzQyxLQUFLLE9BQUwsS0FBaUIsVUFBdkQsSUFBcUUsS0FBSyxPQUFMLEtBQWlCLFdBQTFGLEVBQ0E7QUFDSSwyQkFBTyxLQUFLLFVBQUwsRUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksS0FBSyxPQUFMLEtBQWlCLFlBQXJCLEVBQ0E7QUFDSSwyQkFBTyxLQUFLLE1BQUwsRUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksS0FBSyxPQUFMLEtBQWlCLFlBQXJCLEVBQ0E7QUFDSSwyQkFBTyxLQUFLLEtBQUwsRUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksS0FBSyxPQUFMLEtBQWlCLFNBQXJCLEVBQ0E7QUFDSSwyQkFBTyxLQUFLLEtBQUwsRUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksS0FBSyxPQUFMLHdCQUFKLEVBQ0E7QUFDSSwyQkFBTyxLQUFLLFFBQUwsRUFBUDtBQUNIOztBQUVELHNCQUFNLElBQUksV0FBSix5QkFBc0MsS0FBSyxPQUEzQyxPQUFOO0FBQ0g7O0FBRUQsbUJBQU8sb0JBQVUsa0JBQU8sR0FBakIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7OytCQUtBO0FBQ0k7QUFDQSxnQkFBSSxLQUFLLEtBQUwsS0FBZSxVQUFuQixFQUNBO0FBQ0ksdUJBQU8sS0FBSyxVQUFMLEVBQVA7QUFDSDs7QUFFRDtBQUNBLG1CQUFPLEtBQUssUUFBTCxFQUFQO0FBQ0g7Ozs7Ozs7a0JBdGFnQixLOzs7Ozs7Ozs7Ozs7O0FDM0JyQjs7O0lBR3FCLFc7Ozs7Ozs7O0FBRWpCOzs7Ozs4QkFLTSxJLEVBQ047QUFDSSxnQkFBSSxtQkFBSjtBQUNBLGdCQUFJLGdCQUFKOztBQUVBLGdCQUFJLElBQUosRUFDQTtBQUNJLHVDQUFxQixLQUFLLFdBQUwsQ0FBaUIsV0FBdEM7QUFDQSwwQkFBVSxLQUFLLFVBQUwsQ0FBVjtBQUNIOztBQUVELGdCQUFJLENBQUMsT0FBTCxFQUNBO0FBQ0ksc0JBQU0sSUFBSSxLQUFKLFNBQWdCLFVBQWhCLGFBQU47QUFDSDs7QUFFRCxtQkFBTyxRQUFRLElBQVIsQ0FBYSxJQUFiLEVBQW1CLElBQW5CLENBQVA7QUFDSDs7Ozs7OztrQkF4QmdCLFc7Ozs7Ozs7Ozs7O0FDSHJCOztBQUNBOzs7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW1EcUIsTTtBQUVqQjs7OztBQUlBLHNCQUNBO0FBQUEsWUFEWSxLQUNaLHVFQURvQixJQUNwQjs7QUFBQTs7QUFDSSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztnQ0FZQTtBQUNJLGdCQUFJLEtBQUssU0FBTCxDQUFlLElBQWYsS0FBd0Isa0JBQU8sRUFBbkMsRUFDQTtBQUNJLHFCQUFLLEtBQUwsQ0FBVyxrQkFBTyxFQUFsQjs7QUFFQSx1QkFBTyxLQUFLLElBQUwsRUFBUDtBQUNIOztBQUVELG1CQUFPLEtBQUssUUFBTCxFQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OzsrQkFVQTtBQUNJLGdCQUFJLE9BQU8sS0FBSyxNQUFMLEVBQVg7O0FBRUEsbUJBQU8sQ0FBQyxrQkFBTyxFQUFSLEVBQVksa0JBQU8sRUFBbkIsRUFBdUIsUUFBdkIsQ0FBZ0MsS0FBSyxTQUFMLENBQWUsSUFBL0MsQ0FBUCxFQUNBO0FBQ0ksb0JBQU0sUUFBUSxLQUFLLFNBQW5COztBQUVBLHFCQUFLLEtBQUwsQ0FBVyxNQUFNLElBQWpCO0FBQ0EsdUJBQU8sZUFBVSxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCLEtBQUssTUFBTCxFQUF2QixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7aUNBVUE7QUFDSSxnQkFBSSxPQUFPLEtBQUssTUFBTCxFQUFYOztBQUVBLG1CQUFPLENBQUMsa0JBQU8sRUFBUixFQUFZLGtCQUFPLEVBQW5CLEVBQXVCLGtCQUFPLEVBQTlCLEVBQWtDLGtCQUFPLEVBQXpDLEVBQTZDLFFBQTdDLENBQXNELEtBQUssU0FBTCxDQUFlLElBQXJFLENBQVAsRUFDQTtBQUNJLG9CQUFNLFFBQVEsS0FBSyxTQUFuQjs7QUFFQSxxQkFBSyxLQUFMLENBQVcsTUFBTSxJQUFqQjtBQUNBLHVCQUFPLGVBQVUsSUFBVixFQUFnQixLQUFoQixFQUF1QixLQUFLLE1BQUwsRUFBdkIsQ0FBUDtBQUNIOztBQUVELG1CQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O2lDQVVBO0FBQ0ksZ0JBQUksT0FBTyxLQUFLLE1BQUwsRUFBWDs7QUFFQSxtQkFBTyxDQUFDLGtCQUFPLElBQVIsRUFBYyxrQkFBTyxLQUFyQixFQUE0QixrQkFBTyxNQUFuQyxFQUEyQyxRQUEzQyxDQUFvRCxLQUFLLFNBQUwsQ0FBZSxJQUFuRSxDQUFQLEVBQ0E7QUFDSSxvQkFBTSxRQUFRLEtBQUssU0FBbkI7O0FBRUEscUJBQUssS0FBTCxDQUFXLE1BQU0sSUFBakI7QUFDQSx1QkFBTyxlQUFVLElBQVYsRUFBZ0IsS0FBaEIsRUFBdUIsS0FBSyxNQUFMLEVBQXZCLENBQVA7QUFDSDs7QUFFRCxtQkFBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OztpQ0FVQTtBQUNJLGdCQUFJLE9BQU8sS0FBSyxNQUFMLEVBQVg7O0FBRUEsbUJBQU8sQ0FBQyxrQkFBTyxJQUFSLEVBQWMsa0JBQU8sR0FBckIsRUFBMEIsUUFBMUIsQ0FBbUMsS0FBSyxTQUFMLENBQWUsSUFBbEQsQ0FBUCxFQUNBO0FBQ0ksb0JBQU0sUUFBUSxLQUFLLFNBQW5COztBQUVBLHFCQUFLLEtBQUwsQ0FBVyxNQUFNLElBQWpCO0FBQ0EsdUJBQU8sZUFBVSxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCLEtBQUssTUFBTCxFQUF2QixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7aUNBVUE7QUFDSSxnQkFBSSxPQUFPLEtBQUssSUFBTCxFQUFYOztBQUVBLG1CQUFPLENBQUMsa0JBQU8sR0FBUixFQUFhLFFBQWIsQ0FBc0IsS0FBSyxTQUFMLENBQWUsSUFBckMsQ0FBUCxFQUNBO0FBQ0ksb0JBQU0sUUFBUSxLQUFLLFNBQW5COztBQUVBLHFCQUFLLEtBQUwsQ0FBVyxNQUFNLElBQWpCO0FBQ0EsdUJBQU8sZUFBVSxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCLEtBQUssSUFBTCxFQUF2QixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7K0JBVUE7QUFDSSxnQkFBSSxRQUFRLElBQVo7QUFDQSxnQkFBSSxVQUFVLElBQWQ7O0FBRUEsZ0JBQUksQ0FBQyxrQkFBTyxJQUFSLEVBQWMsa0JBQU8sS0FBckIsRUFBNEIsUUFBNUIsQ0FBcUMsS0FBSyxTQUFMLENBQWUsSUFBcEQsQ0FBSixFQUNBO0FBQ0ksd0JBQVEsS0FBSyxTQUFiO0FBQ0EscUJBQUssS0FBTCxDQUFXLEtBQUssU0FBTCxDQUFlLElBQTFCO0FBQ0g7O0FBRUQsZ0JBQU0sT0FBTyxLQUFLLE1BQUwsRUFBYjs7QUFFQSxnQkFBSSxLQUFLLFNBQUwsQ0FBZSxJQUFmLEtBQXdCLGtCQUFPLE9BQW5DLEVBQ0E7QUFDSSwwQkFBVSxLQUFLLFNBQWY7QUFDQSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sT0FBbEI7QUFDSDs7QUFFRCxnQkFBSSxVQUFVLElBQWQsRUFDQTtBQUNJLG9CQUFJLFlBQVksSUFBaEIsRUFDQTtBQUNJLDJCQUFPLG1CQUFjLE9BQWQsRUFBdUIsaUJBQVksS0FBWixFQUFtQixJQUFuQixDQUF2QixDQUFQO0FBQ0g7O0FBRUQsdUJBQU8saUJBQVksS0FBWixFQUFtQixJQUFuQixDQUFQO0FBQ0gsYUFSRCxNQVNLLElBQUksWUFBWSxJQUFoQixFQUNMO0FBQ0ksdUJBQU8sbUJBQWMsT0FBZCxFQUF1QixJQUF2QixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBY0E7QUFDSSxnQkFBTSxZQUFZLENBQUMsa0JBQU8sTUFBUixFQUFnQixrQkFBTyxNQUF2QixFQUErQixrQkFBTyxPQUF0QyxFQUErQyxrQkFBTyxLQUF0RCxDQUFsQjtBQUNBLGdCQUFNLFFBQVEsS0FBSyxTQUFuQjs7QUFFQSxnQkFBSSxNQUFNLElBQU4sS0FBZSxrQkFBTyxNQUExQixFQUNBO0FBQ0kscUJBQUssS0FBTCxDQUFXLGtCQUFPLE1BQWxCOztBQUVBLG9CQUFNLE9BQU8sS0FBSyxJQUFMLEVBQWI7O0FBRUEscUJBQUssS0FBTCxDQUFXLGtCQUFPLE1BQWxCOztBQUVBLHVCQUFPLElBQVA7QUFDSDtBQUNELGdCQUFJLE1BQU0sSUFBTixLQUFlLGtCQUFPLE1BQTFCLEVBQ0E7QUFDSSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sTUFBbEI7O0FBRUEsb0JBQU0sUUFBUSxLQUFLLFlBQUwsRUFBZDs7QUFFQSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sTUFBbEI7O0FBRUEsdUJBQU8sdUJBQWtCLEtBQWxCLENBQVA7QUFDSCxhQVRELE1BVUssSUFBSSxVQUFVLFFBQVYsQ0FBbUIsTUFBTSxJQUF6QixDQUFKLEVBQ0w7QUFDSSx1QkFBTyxLQUFLLFFBQUwsRUFBUDtBQUNIOztBQUVELG1CQUFPLEtBQUssT0FBTCxFQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O3VDQVlBO0FBQ0ksZ0JBQU0sVUFBVSxDQUFDLEtBQUssU0FBTCxFQUFELENBQWhCOztBQUVBLG1CQUFPLEtBQUssU0FBTCxDQUFlLElBQWYsS0FBd0Isa0JBQU8sU0FBdEMsRUFDQTtBQUNJLHFCQUFLLEtBQUwsQ0FBVyxrQkFBTyxTQUFsQjs7QUFFQSxvQkFBTSxTQUFTLEtBQUssU0FBTCxFQUFmOztBQUVBLHdCQUFRLElBQVIsQ0FBYSxNQUFiO0FBQ0g7O0FBRUQsbUJBQU8sT0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7OztvQ0FZQTtBQUNJLGdCQUFNLE9BQU8sQ0FBQyxLQUFLLElBQUwsRUFBRCxDQUFiOztBQUVBLG1CQUFPLEtBQUssU0FBTCxDQUFlLElBQWYsS0FBd0Isa0JBQU8sS0FBdEMsRUFDQTtBQUNJLHFCQUFLLEtBQUwsQ0FBVyxrQkFBTyxLQUFsQjs7QUFFQSxvQkFBTSxNQUFNLEtBQUssSUFBTCxFQUFaOztBQUVBLHFCQUFLLElBQUwsQ0FBVSxHQUFWO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7a0NBVUE7QUFDSSxnQkFBTSxRQUFRLEtBQUssU0FBbkI7QUFDQSxnQkFBSSxPQUFPLElBQVg7O0FBRUEsZ0JBQUksTUFBTSxJQUFOLEtBQWUsa0JBQU8sS0FBMUIsRUFDQTtBQUNJLHFCQUFLLEtBQUwsQ0FBVyxrQkFBTyxLQUFsQjtBQUNBLHVCQUFPLE1BQU0sS0FBYjtBQUNIOztBQUVELG1CQUFPLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7b0NBYUE7QUFBQSxnQkFEVSxLQUNWLHVFQURrQixJQUNsQjs7QUFDSSxnQkFBTSxRQUFRLEtBQUssU0FBbkI7O0FBRUEsZ0JBQUksS0FBSyxTQUFMLEdBQWlCLElBQWpCLEtBQTBCLGtCQUFPLE1BQXJDLEVBQ0E7QUFDSSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sRUFBbEI7QUFDQSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sTUFBbEI7O0FBRUEsb0JBQU0sU0FBUyxLQUFLLFVBQUwsRUFBZjs7QUFFQSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sTUFBbEI7O0FBRUEsdUJBQU8sc0JBQWlCLE1BQU0sS0FBdkIsRUFBOEIsTUFBOUIsQ0FBUDtBQUNILGFBVkQsTUFXSyxJQUFJLE1BQU0sSUFBTixLQUFlLGtCQUFPLEtBQTFCLEVBQ0w7QUFDSSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sS0FBbEI7O0FBRUEsdUJBQU8sd0JBQW1CLEtBQW5CLEVBQTBCLEtBQTFCLENBQVA7QUFDSDs7QUFFRCxpQkFBSyxLQUFMLENBQVcsa0JBQU8sRUFBbEI7O0FBRUEsbUJBQU8sd0JBQW1CLE1BQU0sS0FBekIsRUFBZ0MsS0FBaEMsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7cUNBYUE7QUFDSSxnQkFBTSxTQUFTLEVBQWY7O0FBRUEsbUJBQU8sS0FBSyxTQUFMLENBQWUsSUFBZixLQUF3QixrQkFBTyxNQUEvQixJQUF5QyxLQUFLLFNBQUwsQ0FBZSxJQUFmLEtBQXdCLGtCQUFPLEdBQS9FLEVBQ0E7QUFDSSxvQkFBTSxRQUFRLEtBQUssSUFBTCxFQUFkOztBQUVBLHVCQUFPLElBQVAsQ0FBWSxLQUFaOztBQUVBLG9CQUFJLEtBQUssU0FBTCxDQUFlLElBQWYsS0FBd0Isa0JBQU8sS0FBbkMsRUFDQTtBQUNJLHlCQUFLLEtBQUwsQ0FBVyxrQkFBTyxLQUFsQjtBQUNIO0FBQ0o7O0FBRUQsbUJBQU8sTUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7bUNBYUE7QUFDSSxnQkFBTSxRQUFRLEtBQUssU0FBbkI7QUFDQSxnQkFBSSxhQUFKOztBQUVBLGdCQUFJLE1BQU0sSUFBTixLQUFlLGtCQUFPLE1BQTFCLEVBQ0E7QUFDSSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sTUFBbEI7QUFDQSx1QkFBTyx3QkFBbUIsTUFBTSxLQUF6QixDQUFQO0FBQ0gsYUFKRCxNQUtLLElBQUksTUFBTSxJQUFOLEtBQWUsa0JBQU8sTUFBMUIsRUFDTDtBQUNJLHFCQUFLLEtBQUwsQ0FBVyxrQkFBTyxNQUFsQjtBQUNBLHVCQUFPLHdCQUFtQixNQUFNLEtBQXpCLENBQVA7QUFDSCxhQUpJLE1BS0EsSUFBSSxNQUFNLElBQU4sS0FBZSxrQkFBTyxPQUExQixFQUNMO0FBQ0kscUJBQUssS0FBTCxDQUFXLGtCQUFPLE9BQWxCO0FBQ0EsdUJBQU8seUJBQW9CLE1BQU0sS0FBMUIsQ0FBUDtBQUNILGFBSkksTUFLQSxJQUFJLE1BQU0sSUFBTixLQUFlLGtCQUFPLEtBQTFCLEVBQ0w7QUFDSSxxQkFBSyxLQUFMLENBQVcsa0JBQU8sS0FBbEI7QUFDQSx1QkFBTyx1QkFBa0IsTUFBTSxLQUF4QixDQUFQO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7O29DQUtBO0FBQ0ksbUJBQU8sS0FBSyxLQUFMLENBQVcsSUFBWCxFQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7OzhCQUtNLFMsRUFDTjtBQUNJLGdCQUFJLEtBQUssU0FBTCxDQUFlLElBQWYsS0FBd0IsU0FBNUIsRUFDQTtBQUNJLHFCQUFLLFNBQUwsR0FBaUIsS0FBSyxLQUFMLENBQVcsSUFBWCxFQUFqQjtBQUNILGFBSEQsTUFLQTtBQUNJLHNCQUFNLElBQUksV0FBSixpQ0FBOEMsU0FBOUMsT0FBTjtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7O2dDQU1BO0FBQ0ksZ0JBQUksS0FBSyxTQUFMLEtBQW1CLElBQXZCLEVBQ0E7QUFDSSx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQsZ0JBQU0sT0FBTyxLQUFLLEtBQUwsRUFBYjs7QUFFQSxnQkFBSSxLQUFLLFNBQUwsQ0FBZSxJQUFmLEtBQXdCLGtCQUFPLEdBQW5DLEVBQ0E7QUFDSSxzQkFBTSxJQUFJLFdBQUosMENBQU47QUFDSDs7QUFFRCxtQkFBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7MEJBSVUsSyxFQUNWO0FBQ0ksaUJBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxnQkFBSSxLQUFLLE1BQVQsRUFDQTtBQUNJLHFCQUFLLFNBQUwsR0FBaUIsS0FBSyxNQUFMLENBQVksSUFBWixFQUFqQjtBQUNILGFBSEQsTUFLQTtBQUNJLHFCQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDSDtBQUNKLFM7NEJBRVc7QUFDWjtBQUNJLG1CQUFPLEtBQUssTUFBWjtBQUNIOzs7Ozs7O2tCQXBmZ0IsTTs7Ozs7Ozs7Ozs7QUNsRXJCOzs7SUFHcUIsUTtBQUVqQjs7Ozs7QUFLQSxvQkFDQTtBQUFBLE1BRFksTUFDWix1RUFEcUIsQ0FDckI7QUFBQSxNQUR3QixHQUN4Qix1RUFEOEIsQ0FDOUI7O0FBQUE7O0FBQ0ksT0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLE9BQUssR0FBTCxHQUFXLEdBQVg7QUFDSCxDOzs7a0JBWGdCLFE7Ozs7Ozs7Ozs7Ozs7QUNIckI7OztJQUdxQixLO0FBRWpCOzs7OztBQUtBLG1CQUFZLEtBQVosRUFBbUIsSUFBbkIsRUFDQTtBQUFBOztBQUNJLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7O0FBRUQ7Ozs7Ozs7O2tDQUtBO0FBQ0ksZ0JBQU0sUUFBUSxLQUFLLEtBQW5CO0FBQ0EsZ0JBQU0sT0FBTyxLQUFLLElBQWxCOztBQUVBLGdCQUFJLE1BQU0sTUFBTixHQUFlLEtBQUssTUFBeEIsRUFDQTtBQUNJLG9CQUFNLFNBQVMsTUFBTSxNQUFyQjs7QUFFQSxzQkFBTSxNQUFOLEdBQWUsS0FBSyxNQUFwQjtBQUNBLHFCQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0g7O0FBRUQsZ0JBQUksTUFBTSxHQUFOLEdBQVksS0FBSyxHQUFyQixFQUNBO0FBQ0ksb0JBQU0sU0FBUyxNQUFNLEdBQXJCOztBQUVBLHNCQUFNLEdBQU4sR0FBWSxLQUFLLEdBQWpCO0FBQ0EscUJBQUssR0FBTCxHQUFXLE1BQVg7QUFDSDs7QUFFRCxtQkFBTyxJQUFJLEtBQUosQ0FBVSxLQUFWLEVBQWlCLElBQWpCLENBQVA7QUFDSDs7Ozs7OztrQkF2Q2dCLEs7Ozs7Ozs7Ozs7O0FDSHJCOzs7SUFHcUIsSztBQUVqQjs7Ozs7QUFLQSxlQUFZLElBQVosRUFDQTtBQUFBLFFBRGtCLEtBQ2xCLHVFQUQwQixJQUMxQjs7QUFBQTs7QUFDSSxTQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNILEM7OztrQkFYZ0IsSzs7Ozs7Ozs7Ozs7QUNIckI7OztJQUdxQixHOzs7OztrQkFBQSxHOzs7Ozs7Ozs7QUNIckI7Ozs7Ozs7Ozs7OztBQUVBOzs7OztJQUtxQixhOzs7QUFFakI7Ozs7QUFJQSx5QkFBWSxLQUFaLEVBQ0E7QUFBQTs7QUFBQTs7QUFHSSxVQUFLLEtBQUwsR0FBYSxLQUFiO0FBSEo7QUFJQzs7Ozs7O2tCQVhnQixhOzs7Ozs7Ozs7QUNQckI7Ozs7Ozs7Ozs7OztBQUVBOzs7OztJQUtxQixLOzs7QUFFakI7Ozs7OztBQU1BLGlCQUFZLElBQVosRUFBa0IsRUFBbEIsRUFBc0IsS0FBdEIsRUFDQTtBQUFBOztBQUFBOztBQUdJLFVBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxVQUFLLEtBQUwsR0FBYSxNQUFLLEVBQUwsR0FBVSxFQUF2QjtBQUNBLFVBQUssS0FBTCxHQUFhLEtBQWI7QUFMSjtBQU1DOzs7Ozs7a0JBZmdCLEs7Ozs7Ozs7OztBQ1ByQjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS3FCLGU7OztBQUVqQjs7OztBQUlBLDJCQUFZLEtBQVosRUFDQTtBQUFBOztBQUFBOztBQUdJLFVBQUssS0FBTCxHQUFhLEtBQWI7QUFISjtBQUlDOzs7Ozs7a0JBWGdCLGU7Ozs7Ozs7Ozs7O0FDUHJCOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7OztJQUtxQixjOzs7QUFFakI7Ozs7O0FBS0EsNEJBQVksSUFBWixFQUNBO0FBQUEsWUFEa0IsS0FDbEIsdUVBRDBCLElBQzFCOztBQUFBOztBQUFBOztBQUdJLGNBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxjQUFLLEtBQUwsR0FBYSxLQUFiO0FBSko7QUFLQzs7QUFFRDs7Ozs7Ozs7Z0NBS0E7QUFDSSxtQkFBTyxLQUFLLElBQUwsQ0FBVSxXQUFWLEdBQXdCLE9BQXhCLENBQWdDLEtBQWhDLEVBQXVDLEVBQXZDLENBQVA7QUFDSDs7QUFFRDs7Ozs7OzttQ0FLQTtBQUNJLGdCQUFNLE1BQU0sS0FBSyxLQUFMLEVBQVo7QUFDQSxnQkFBTSxlQUFlLElBQUksT0FBSixDQUFZLFVBQVosRUFBd0IsRUFBeEIsQ0FBckI7QUFDQSxnQkFBTSxTQUFTLGVBQWUsU0FBZixDQUF5QixZQUF6QixDQUFmO0FBQ0EsZ0JBQU0sWUFBWSxJQUFJLE9BQUosQ0FBWSxTQUFaLEVBQXVCLEVBQXZCLENBQWxCO0FBQ0EsZ0JBQU0sTUFBTSxTQUFTLFNBQVQsRUFBb0IsRUFBcEIsQ0FBWjs7QUFFQSxtQkFBTyx1QkFBYSxNQUFiLEVBQXFCLEdBQXJCLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7O2tDQU1pQixHLEVBQ2pCO0FBQ0ksZ0JBQUksVUFBVSxDQUFkO0FBQ0EsZ0JBQU0sVUFBVSxJQUFJLFdBQUosR0FBa0IsS0FBbEIsQ0FBd0IsSUFBSSxNQUFKLEVBQXhCLENBQWhCOztBQUVBLGlCQUFLLElBQUksSUFBSSxRQUFRLE1BQVIsR0FBaUIsQ0FBOUIsRUFBaUMsS0FBSyxDQUF0QyxFQUF5QyxHQUF6QyxFQUNBO0FBQ0ksMkJBQVcsQ0FBQyxRQUFRLENBQVIsRUFBVyxVQUFYLENBQXNCLENBQXRCLElBQTJCLEVBQTVCLElBQW1DLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxRQUFRLE1BQVIsSUFBa0IsSUFBSSxDQUF0QixDQUFiLENBQTlDO0FBQ0g7O0FBRUQsbUJBQU8sT0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7a0NBTWlCLEssRUFDakI7QUFDSSxnQkFBTSxTQUFTLENBQ1gsR0FEVyxFQUNOLEdBRE0sRUFDRCxHQURDLEVBQ0ksR0FESixFQUNTLEdBRFQsRUFDYyxHQURkLEVBQ21CLEdBRG5CLEVBQ3dCLEdBRHhCLEVBQzZCLEdBRDdCLEVBQ2tDLEdBRGxDLEVBRVgsR0FGVyxFQUVOLEdBRk0sRUFFRCxHQUZDLEVBRUksR0FGSixFQUVTLEdBRlQsRUFFYyxHQUZkLEVBRW1CLEdBRm5CLEVBRXdCLEdBRnhCLEVBRTZCLEdBRjdCLEVBRWtDLEdBRmxDLEVBR1gsR0FIVyxFQUdOLEdBSE0sRUFHRCxHQUhDLEVBR0ksR0FISixFQUdTLEdBSFQsRUFHYyxHQUhkLENBQWY7QUFLQSxnQkFBTSxTQUFTLEVBQWY7O0FBRUEsb0JBQVEsUUFBUSxDQUFoQjtBQUNBLGdCQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUFFLHVCQUFPLE9BQU8sQ0FBUCxDQUFQO0FBQW1COztBQUV0QyxtQkFBTyxTQUFTLENBQWhCLEVBQ0E7QUFDSSx1QkFBTyxPQUFQLENBQWUsT0FBTyxRQUFRLEVBQWYsQ0FBZjtBQUNBLHdCQUFRLEtBQUssS0FBTCxDQUFXLFFBQVEsRUFBbkIsSUFBeUIsQ0FBakM7QUFDSDs7QUFFRCxtQkFBTyxPQUFPLElBQVAsQ0FBWSxFQUFaLENBQVA7QUFDSDs7Ozs7OztrQkFuRmdCLGM7Ozs7Ozs7OztBQ1JyQjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS3FCLGE7OztBQUVqQjs7OztBQUlBLHlCQUFZLEtBQVosRUFDQTtBQUFBOztBQUFBOztBQUdJLFVBQUssS0FBTCxHQUFhLEtBQWI7QUFISjtBQUlDOzs7Ozs7a0JBWGdCLGE7Ozs7Ozs7OztBQ1ByQjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS3FCLFk7OztBQUVqQjs7Ozs7QUFLQSx3QkFBWSxJQUFaLEVBQWtCLE1BQWxCLEVBQ0E7QUFBQTs7QUFBQTs7QUFHSSxVQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsVUFBSyxNQUFMLEdBQWMsTUFBZDtBQUpKO0FBS0M7Ozs7OztrQkFiZ0IsWTs7Ozs7Ozs7O0FDUHJCOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLcUIsYzs7O0FBRWpCOzs7O0FBSUEsMEJBQVksS0FBWixFQUNBO0FBQUE7O0FBQUE7O0FBR0ksVUFBSyxLQUFMLEdBQWEsS0FBYjtBQUhKO0FBSUM7Ozs7OztrQkFYZ0IsYzs7Ozs7Ozs7O0FDUHJCOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLcUIsUzs7O0FBRWpCOzs7OztBQUtBLHFCQUFZLEVBQVosRUFBZ0IsSUFBaEIsRUFDQTtBQUFBOztBQUFBOztBQUdJLFVBQUssS0FBTCxHQUFhLE1BQUssRUFBTCxHQUFVLEVBQXZCO0FBQ0EsVUFBSyxJQUFMLEdBQVksSUFBWjtBQUpKO0FBS0M7Ozs7OztrQkFiZ0IsUzs7Ozs7Ozs7Ozs7QUNQckI7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLcUIsYzs7O0FBRWpCOzs7OztBQUtBLDRCQUFZLEtBQVosRUFDQTtBQUFBLFlBRG1CLEtBQ25CLHVFQUQyQixJQUMzQjs7QUFBQTs7QUFBQTs7QUFHSSxjQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsY0FBSyxVQUFMLEdBQWtCLE1BQU0sS0FBeEI7QUFDQSxjQUFLLEtBQUwsR0FBYSxLQUFiO0FBTEo7QUFNQzs7QUFFRDs7Ozs7Ozs7K0JBS0E7QUFDSSxnQkFBTSxRQUFRLEtBQUssVUFBTCxDQUFnQixLQUFoQixDQUFzQixHQUF0QixDQUFkOztBQUVBLG1CQUFPLENBQ0gsNkJBQW1CLE1BQU0sQ0FBTixDQUFuQixDQURHLEVBRUgsNkJBQW1CLE1BQU0sQ0FBTixDQUFuQixDQUZHLENBQVA7QUFJSDs7QUFFRDs7Ozs7OztnQ0FLQTtBQUNJLGdCQUFNLFFBQVEsS0FBSyxJQUFMLEVBQWQ7O0FBRUEsbUJBQU8sb0JBQVUsTUFBTSxDQUFOLEVBQVMsUUFBVCxFQUFWLEVBQStCLE1BQU0sQ0FBTixFQUFTLFFBQVQsRUFBL0IsQ0FBUDtBQUNIOzs7Ozs7O2tCQXZDZ0IsYzs7Ozs7Ozs7O0FDVHJCOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLcUIsYzs7O0FBRWpCOzs7O0FBSUEsMEJBQVksS0FBWixFQUNBO0FBQUE7O0FBQUE7O0FBR0ksVUFBSyxLQUFMLEdBQWEsS0FBYjtBQUhKO0FBSUM7Ozs7OztrQkFYZ0IsYzs7Ozs7Ozs7O0FDUHJCOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLcUIsTzs7O0FBRWpCOzs7OztBQUtBLG1CQUFZLEVBQVosRUFBZ0IsSUFBaEIsRUFDQTtBQUFBOztBQUFBOztBQUdJLFVBQUssS0FBTCxHQUFhLE1BQUssRUFBTCxHQUFVLEVBQXZCO0FBQ0EsVUFBSyxJQUFMLEdBQVksSUFBWjtBQUpKO0FBS0M7Ozs7OztrQkFiZ0IsTzs7Ozs7Ozs7OztBQ1ByQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztRQUdJLEc7UUFDQSxZO1FBQ0EsYztRQUNBLGM7UUFDQSxLO1FBQ0EsTztRQUNBLFM7UUFDQSxhO1FBQ0EsYztRQUNBLGM7UUFDQSxlO1FBQ0EsYTs7Ozs7Ozs7OztBQ3pCSjs7SUFBWSxPOzs7O0FBRVosSUFBTSxzQkFBc0I7QUFDeEIsVUFBTSxRQUFRLElBRFU7QUFFeEI7QUFDQSxTQUFLLFFBQVEsR0FIVztBQUl4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBTyxRQUFRLEtBWlM7QUFheEI7QUFDQSxTQUFLLFFBQVEsR0FkVztBQWV4QjtBQUNBLFVBQU0sUUFBUSxJQWhCVTtBQWlCeEI7QUFDQSxXQUFPLFFBQVEsS0FsQlM7QUFtQnhCO0FBQ0E7QUFDQTtBQUNBLFVBQU0sUUFBUTtBQUNkO0FBdkJ3QixDQUE1Qjs7UUEyQkksbUIsR0FBQSxtQjs7Ozs7Ozs7OztBQzVCSjs7QUFHQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFOQTs7QUFKQTtBQUNBO0FBZ0JBLElBQU0sWUFBWSxPQUFPLE1BQVA7QUFFZDtBQUNBO0FBQ0E7QUFKYztBQU9kO0FBUGMsZ0lBQWxCLEMsQ0FuQkE7UUFrQ0ksUyxHQUFBLFM7Ozs7Ozs7Ozs7QUNsQ0o7O0lBQVksTzs7OztBQUVaLElBQU0sd0JBQXdCO0FBQzFCO0FBQ0E7QUFDQSxjQUFVLFFBQVEsUUFIUTtBQUkxQjtBQUNBLFdBQU8sUUFBUSxLQUxXO0FBTTFCLGFBQVMsUUFBUSxPQU5TLEVBTUE7QUFDMUIsWUFBUSxRQUFRLE1BUFU7QUFRMUI7QUFDQSxlQUFXLFFBQVEsU0FUTztBQVUxQjtBQUNBLGVBQVcsUUFBUSxTQVhPO0FBWTFCLGNBQVUsUUFBUSxRQVpRO0FBYTFCLFdBQU8sUUFBUSxLQWJXO0FBYzFCO0FBQ0EsWUFBUSxRQUFRLE1BZlU7QUFnQjFCLE9BQUcsV0FBQyxLQUFEO0FBQUEsZUFBVyxRQUFRLENBQVIsQ0FBVSxLQUFWLENBQWdCLHFCQUFoQixFQUF1QyxDQUFDLEtBQUQsQ0FBdkMsQ0FBWDtBQUFBLEtBaEJ1QjtBQWlCMUI7QUFDQTtBQUNBO0FBQ0EsVUFBTSxjQUFDLEtBQUQ7QUFBQSxlQUFXLFFBQVEsSUFBUixDQUFhLEtBQWIsQ0FBbUIscUJBQW5CLEVBQTBDLENBQUMsS0FBRCxDQUExQyxDQUFYO0FBQUE7QUFwQm9CLENBQTlCOztRQXdCSSxxQixHQUFBLHFCOzs7Ozs7Ozs7O0FDMUJKOztJQUFZLE87Ozs7QUFFWixJQUFNLG9CQUFvQjtBQUN0QixTQUFLLFFBQVEsR0FEUztBQUV0QjtBQUNBLFdBQU8sUUFBUSxLQUhPO0FBSXRCLFFBQUksUUFBUSxFQUpVO0FBS3RCO0FBQ0E7QUFDQSxTQUFLLFFBQVEsR0FQUztBQVF0QixRQUFJLFFBQVEsRUFSVTtBQVN0QixVQUFNLFFBQVE7QUFDZDtBQUNBO0FBWHNCLENBQTFCOztRQWVJLGlCLEdBQUEsaUI7Ozs7Ozs7Ozs7QUNqQko7O0lBQVksTzs7OztBQUVaLElBQU0sc0JBQXNCO0FBQ3hCLFNBQUssUUFBUSxHQURXO0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUssUUFBUSxHQVJXO0FBU3hCLFlBQVEsUUFBUSxNQVRRO0FBVXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBTyxRQUFRLEtBakJTO0FBa0J4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUssUUFBUSxHQTNDVztBQTRDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLFFBQVEsRUFoRFk7QUFpRHhCO0FBQ0E7QUFDQSxhQUFTLFFBQVEsT0FuRE87QUFvRHhCLFVBQU0sUUFBUSxJQXBEVTtBQXFEeEIsaUJBQWEsUUFBUSxXQXJERztBQXNEeEIsV0FBTyxRQUFRLEtBdERTO0FBdUR4QixlQUFXLFFBQVEsU0F2REs7QUF3RHhCLGFBQVMsUUFBUSxPQXhETztBQXlEeEI7QUFDQTtBQUNBO0FBQ0EsVUFBTSxRQUFRLElBNURVO0FBNkR4QjtBQUNBO0FBQ0EsVUFBTSxRQUFRLElBL0RVO0FBZ0V4QjtBQUNBO0FBQ0EsU0FBSyxRQUFRLEdBbEVXO0FBbUV4QixXQUFPLFFBQVEsS0FuRVM7QUFvRXhCLFlBQVEsUUFBUSxNQXBFUTtBQXFFeEIsY0FBVSxRQUFRLFFBckVNO0FBc0V4QixTQUFLLFFBQVEsR0F0RVc7QUF1RXhCLFFBQUksUUFBUSxFQXZFWTtBQXdFeEIsU0FBSyxRQUFRLEdBeEVXO0FBeUV4QixRQUFJLFFBQVEsRUF6RVk7QUEwRXhCLFFBQUksUUFBUSxFQTFFWTtBQTJFeEIsU0FBSyxRQUFRLEdBM0VXO0FBNEV4QjtBQUNBO0FBQ0EsZ0JBQVksUUFBUSxVQTlFSTtBQStFeEIsV0FBTyxRQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckZ3QixDQUE1Qjs7UUF5RkksbUIsR0FBQSxtQjs7Ozs7Ozs7OztBQzNGSjs7SUFBWSxPOztBQUNaOzs7O0FBRUEsSUFBTSwwQkFBMEI7QUFDNUIsWUFBUTtBQUFBLDBDQUFJLElBQUo7QUFBSSxnQkFBSjtBQUFBOztBQUFBLGVBQWEsUUFBUSxNQUFSLENBQWUsS0FBZixDQUFxQixJQUFyQixFQUEyQixvQkFBUSxJQUFSLENBQTNCLENBQWI7QUFBQTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVA0QixDQUFoQzs7UUFXSSx1QixHQUFBLHVCOzs7Ozs7Ozs7O0FDZEo7O0lBQVksTzs7QUFDWjs7OztBQUVBLElBQU0sd0JBQXdCO0FBQzFCLGFBQVMsUUFBUSxPQURTO0FBRTFCLGNBQVUsUUFBUSxRQUZRO0FBRzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPLFFBQVEsS0FSVztBQVMxQixZQUFRLFFBQVEsTUFUVTtBQVUxQixnQkFBWSxRQUFRLFVBVk07QUFXMUIsYUFBUyxpQkFBQyxLQUFELEVBQVEsS0FBUjtBQUFBLGVBQWtCLFFBQVEsT0FBUixDQUFnQixvQkFBUSxLQUFSLENBQWhCLEVBQWdDLEtBQWhDLENBQWxCO0FBQUEsS0FYaUI7QUFZMUI7QUFDQTtBQUNBLGlCQUFhLFFBQVEsV0FkSztBQWUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUssUUFBUSxHQS9CYTtBQWdDMUI7QUFDQTtBQUNBLFNBQUssUUFBUTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkgwQixDQUE5Qjs7UUEySEkscUIsR0FBQSxxQjs7Ozs7Ozs7OztBQzlISjs7SUFBWSxPOzs7O0FBRVosSUFBTSxpQkFBaUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVEsZ0JBQUMsSUFBRCxFQUFPLEtBQVA7QUFBQSxlQUFpQixRQUFRLFdBQVIsQ0FBb0IsSUFBcEIsRUFBMEIsS0FBMUIsQ0FBakI7QUFBQSxLQU5XO0FBT25CLGlCQUFhLFFBQVEsV0FQRjtBQVFuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFNLFFBQVEsSUFkSztBQWVuQixTQUFLLFFBQVEsR0FmTTtBQWdCbkIsV0FBTyxRQUFRLEtBaEJJO0FBaUJuQixTQUFLLFFBQVEsR0FqQk07QUFrQm5CO0FBQ0E7QUFDQSxZQUFRLFFBQVEsTUFwQkc7QUFxQm5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBTSxRQUFRLElBekJLO0FBMEJuQixXQUFPLFFBQVEsS0ExQkk7QUEyQm5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBTSxRQUFRLElBL0JLO0FBZ0NuQixVQUFNLFFBQVEsSUFoQ0s7QUFpQ25CO0FBQ0E7QUFDQSxXQUFPLFFBQVE7QUFDZjtBQXBDbUIsQ0FBdkI7O1FBd0NJLGMsR0FBQSxjOzs7Ozs7Ozs7Ozs7OzswQ0MxQ0ssTzs7Ozs7Ozs7OytDQUNBLE87Ozs7Ozs7OzswQ0FDQSxPOzs7Ozs7Ozs7MkNBQ0EsTzs7Ozs7Ozs7O2dEQUNBLE87Ozs7Ozs7OztnREFDQSxPOzs7Ozs7Ozs7NkNBQ0EsTzs7Ozs7Ozs7OzZDQUNBLE87Ozs7Ozs7OzswQ0FDQSxPOzs7Ozs7QUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbC5wcm9jZXNzID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5wcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gZ2xvYmFsLnByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMCcgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuICB2YXIgZm5zID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pO1xuICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gIHZhciByeGZuID0gZm5zWzFdO1xuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSkge1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG5mdW5jdGlvbiBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICB2YXIgdGFyZ2V0SW5kZXggPSBzdGFydDtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgdmFyIG1hcEZuID0gbWFwcGVyID8gY3R4KG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIHNwcmVhZGFibGU7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICAgIHNwcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmIChpc09iamVjdChlbGVtZW50KSkge1xuICAgICAgICBzcHJlYWRhYmxlID0gZWxlbWVudFtJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gICAgICAgIHNwcmVhZGFibGUgPSBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ByZWFkYWJsZSAmJiBkZXB0aCA+IDApIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MWZmZmZmZmZmZmZmZmYpIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkludG9BcnJheTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgZWwpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgaWYgKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKSByZXR1cm4ga2V5O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcbiIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBFUFNJTE9OID0gcG93KDIsIC01Mik7XG52YXIgRVBTSUxPTjMyID0gcG93KDIsIC0yMyk7XG52YXIgTUFYMzIgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKTtcbnZhciBNSU4zMiA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mcm91bmQgfHwgZnVuY3Rpb24gZnJvdW5kKHgpIHtcbiAgdmFyICRhYnMgPSBNYXRoLmFicyh4KTtcbiAgdmFyICRzaWduID0gc2lnbih4KTtcbiAgdmFyIGEsIHJlc3VsdDtcbiAgaWYgKCRhYnMgPCBNSU4zMikgcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdCkgcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbn07XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zY2FsZSB8fCBmdW5jdGlvbiBzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgaWYgKFxuICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDBcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IHggIT0geFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5Mb3cgIT0gaW5Mb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IGluSGlnaCAhPSBpbkhpZ2hcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dExvdyAhPSBvdXRMb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dEhpZ2ggIT0gb3V0SGlnaFxuICApIHJldHVybiBOYU47XG4gIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHJldHVybiB4O1xuICByZXR1cm4gKHggLSBpbkxvdykgKiAob3V0SGlnaCAtIG91dExvdykgLyAoaW5IaWdoIC0gaW5Mb3cpICsgb3V0TG93O1xufTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgTWFwID0gcmVxdWlyZSgnLi9lczYubWFwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpO1xudmFyIHN0b3JlID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKCkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKSB7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZiAoIXRhcmdldE1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZiAoIWtleU1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgaWYgKG1ldGFkYXRhTWFwKSBtZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChfLCBrZXkpIHsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG52YXIgZXhwID0gZnVuY3Rpb24gKE8pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYgKE9ic2VydmVyKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5JykgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XG4gIC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZiwgbm8tdXNlbGVzcy1jYWxsXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsInZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG4iLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgd3MgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBoZXggPSAvXlstK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4vX3BhdGgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKiAuLi5wYXJncyAqLykge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgcGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBfID0gcGF0aC5fO1xuICB2YXIgaG9sZGVyID0gZmFsc2U7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBpZiAoKHBhcmdzW2ldID0gYXJndW1lbnRzW2krK10pID09PSBfKSBob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgayA9IDA7XG4gICAgdmFyIGFyZ3M7XG4gICAgaWYgKCFob2xkZXIgJiYgIWFMZW4pIHJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZiAoaG9sZGVyKSBmb3IgKDtsZW5ndGggPiBqOyBqKyspIGlmIChhcmdzW2pdID09PSBfKSBhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUgKGFMZW4gPiBrKSBhcmdzLnB1c2goYXJndW1lbnRzW2srK10pO1xuICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR107XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlZ0V4cCwgcmVwbGFjZSkge1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xuICB9IDogcmVwbGFjZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59O1xuIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IEFycmF5KGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGxcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHF1b3QgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgdmFyIHAxID0gJzwnICsgdGFnO1xuICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgZXhlYykge1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgdmFyIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzcGFjZXMgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBzcGFjZSA9ICdbJyArIHNwYWNlcyArICddJztcbnZhciBub24gPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgQUxJQVMpIHtcbiAgdmFyIGV4cCA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmIChBTElBUykgZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uIChzdHJpbmcsIFRZUEUpIHtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSkge1xuICB2YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbiAgdmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuICB2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuICB2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuICB2YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbiAgdmFyICRidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbiAgdmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG4gIHZhciBwcm9wZXJ0eURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG4gIHZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuICB2YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbiAgdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG4gIHZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG4gIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG4gIHZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG4gIHZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbiAgdmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbiAgdmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuICB2YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbiAgdmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG4gIHZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbiAgdmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuICB2YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG4gIHZhciBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKTtcbiAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbiAgdmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbiAgdmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuICB2YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xuICB2YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG4gIHZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG4gIHZhciBhcnJheUNvcHlXaXRoaW4gPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpO1xuICB2YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG4gIHZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG4gIHZhciBkUCA9ICREUC5mO1xuICB2YXIgZ09QRCA9ICRHT1BELmY7XG4gIHZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4gIHZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuICB2YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuICB2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiAgdmFyIFNIQVJFRF9CVUZGRVIgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUjtcbiAgdmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgQXJyYXlQcm90byA9IEFycmF5W1BST1RPVFlQRV07XG4gIHZhciAkQXJyYXlCdWZmZXIgPSAkYnVmZmVyLkFycmF5QnVmZmVyO1xuICB2YXIgJERhdGFWaWV3ID0gJGJ1ZmZlci5EYXRhVmlldztcbiAgdmFyIGFycmF5Rm9yRWFjaCA9IGNyZWF0ZUFycmF5TWV0aG9kKDApO1xuICB2YXIgYXJyYXlGaWx0ZXIgPSBjcmVhdGVBcnJheU1ldGhvZCgyKTtcbiAgdmFyIGFycmF5U29tZSA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpO1xuICB2YXIgYXJyYXlFdmVyeSA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpO1xuICB2YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG4gIHZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xuICB2YXIgYXJyYXlJbmNsdWRlcyA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSk7XG4gIHZhciBhcnJheUluZGV4T2YgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgdmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xuICB2YXIgYXJyYXlLZXlzID0gQXJyYXlJdGVyYXRvcnMua2V5cztcbiAgdmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG4gIHZhciBhcnJheUxhc3RJbmRleE9mID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZjtcbiAgdmFyIGFycmF5UmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2U7XG4gIHZhciBhcnJheVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcbiAgdmFyIGFycmF5Sm9pbiA9IEFycmF5UHJvdG8uam9pbjtcbiAgdmFyIGFycmF5U29ydCA9IEFycmF5UHJvdG8uc29ydDtcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xuICB2YXIgYXJyYXlUb1N0cmluZyA9IEFycmF5UHJvdG8udG9TdHJpbmc7XG4gIHZhciBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZztcbiAgdmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xuICB2YXIgVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xuICB2YXIgVFlQRURfQ09OU1RSVUNUT1IgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBERUZfQ09OU1RSVUNUT1IgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpO1xuICB2YXIgQUxMX0NPTlNUUlVDVE9SUyA9ICR0eXBlZC5DT05TVFI7XG4gIHZhciBUWVBFRF9BUlJBWSA9ICR0eXBlZC5UWVBFRDtcbiAgdmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbiAgdmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcblxuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdCkgcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gKEMsIGxlbmd0aCkge1xuICAgIGlmICghKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH0gcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uIChPLCBsaXN0KSB7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXksIGludGVybmFsKSB7XG4gICAgZFAoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdOyB9IH0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfSBPID0gdmFsdWVzO1xuICAgIH1cbiAgICBpZiAobWFwcGluZyAmJiBhTGVuID4gMikgbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTsgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiAsIGVuZCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGg7XG4gICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBPID0gdmFsaWRhdGUodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gICAgICB2YXIgJGJlZ2luID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIGlmIChpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoIUFMTF9DT05TVFJVQ1RPUlMpIHtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogJHNldERlc2NcbiAgfSk7XG5cbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAkc2xpY2UsXG4gICAgc2V0OiAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpIHtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIEtFWTtcbiAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBLRVk7XG4gICAgdmFyIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV07XG4gICAgdmFyIEJhc2UgPSBUeXBlZEFycmF5IHx8IHt9O1xuICAgIHZhciBUQUMgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpO1xuICAgIHZhciBGT1JDRUQgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVjtcbiAgICB2YXIgTyA9IHt9O1xuICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXkoMSk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9KSB8fCAhJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzO1xuICAgICAgICAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IEJhc2UodG9JbmRleChkYXRhKSk7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXkpKSBoaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmICghTElCUkFSWSkgVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXTtcbiAgICB2YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvclxuICAgICAgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG4gICAgdmFyICRpdGVyYXRvciA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYgKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkge1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVNcbiAgICB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBCYXNlLm9mLmNhbGwoVHlwZWRBcnJheSwgMSk7IH0pLCBOQU1FLCB7XG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwgeyBzZXQ6ICRzZXQgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG5cbiAgICBpZiAoIUxJQlJBUlkgJiYgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nID0gYXJyYXlUb1N0cmluZztcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwgeyBzbGljZTogJHNsaWNlIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7IHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmcgfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZiAoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gQXJyYXkobkJ5dGVzKTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICB2YXIgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiB1bnBhY2tJRUVFNzU0KGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBlTGVuIC0gNztcbiAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICB2YXIgcyA9IGJ1ZmZlcltpLS1dO1xuICB2YXIgZSA9IHMgJiAxMjc7XG4gIHZhciBtO1xuICBzID4+PSA3O1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufVxuZnVuY3Rpb24gcGFja0k4KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMTYoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrRjY0KGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufVxuZnVuY3Rpb24gcGFja0YzMihpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn1cblxuZnVuY3Rpb24gYWRkR2V0dGVyKEMsIGtleSwgaW50ZXJuYWwpIHtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykgc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59XG5cbmlmICghJHR5cGVkLkFCVikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcbiAgICB0aGlzLl9iID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlID0gcmVxdWlyZSgnLi9fcmVwbGFjZXInKSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWdFeHAnLCB7IGVzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KSB7IHJldHVybiAkcmUoaXQpOyB9IH0pO1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpO1xudmFyIEtFWSA9ICdmaW5kSW5kZXgnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgU1RSSUNUID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5JykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgJG5hdGl2ZSA9IFtdLmxhc3RJbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IEBbKi0xXSAqLykge1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPID0gdG9JT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvciAoO2luZGV4ID49IDA7IGluZGV4LS0pIGlmIChpbmRleCBpbiBPKSBpZiAoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGlmIChodG1sKSBhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmIChrbGFzcyA9PSAnQXJyYXknKSByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuKTtcbiAgICB2YXIgdXBUbyA9IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbik7XG4gICAgdmFyIHNpemUgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpO1xuICAgIHZhciBjbG9uZWQgPSBBcnJheShzaXplKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzaXplOyBpKyspIGNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkc29tZSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTtcbiIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuIiwiLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL19kYXRlLXRvLWlzby1zdHJpbmcnKTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAhPT0gdG9JU09TdHJpbmcpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IHRvSVNPU3RyaW5nXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbFxuICAgIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0gfSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuIiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpO1xudmFyIHByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmICghKFRPX1BSSU1JVElWRSBpbiBwcm90bykpIHJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTtcbiIsInZhciBEYXRlUHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IERhdGVQcm90b1tUT19TVFJJTkddO1xudmFyIGdldFRpbWUgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cbiIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7IGJpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKSB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIEhBU19JTlNUQU5DRSA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpO1xudmFyIEZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmICghKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHsgdmFsdWU6IGZ1bmN0aW9uIChPKSB7XG4gIGlmICh0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSkgcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKSBpZiAodGhpcy5wcm90b3R5cGUgPT09IE8pIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59IH0pO1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcbiIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuIiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXRhbmggPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7IGV4cG0xOiAkZXhwbTEgfSk7XG4iLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgZnJvdW5kOiByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpIH0pO1xuIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbXVsID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpIH0pO1xuIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7XG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ09GID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUjtcbnZhciBUUklNID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYgKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSkge1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgaXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJykgfSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcikge1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyICR0b0ZpeGVkID0gMS4wLnRvRml4ZWQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGRhdGEgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG52YXIgRVJST1IgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISc7XG52YXIgWkVSTyA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGMyID0gYztcbiAgd2hpbGUgKCsraSA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgYyA9IDA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IDY7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApIHtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbiA9IDA7XG4gIHZhciB4MiA9IHg7XG4gIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgbiArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKTtcbiAgICB2YXIgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgbSA9IFpFUk87XG4gICAgdmFyIGUsIHosIGosIGs7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkgdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmICh4ICE9IHgpIHJldHVybiAnTmFOJztcbiAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciAkdG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7XG4gIH1cbn0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcbiIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbiAoJGlzRXh0ZW5zaWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbiAoJGlzRnJvemVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uICgkaXNTZWFsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGlzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJykgfSk7XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24gKCRwcmV2ZW50RXh0ZW5zaW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbiAoJHNlYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpIHtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gTElCUkFSWSA/IGZ1bmN0aW9uIChhLCBiKSB7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufSA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX2ggPT0gMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2M7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlYWN0aW9uO1xuICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkge1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZiAocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpIHJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZiAoeCBpbnN0YW5jZW9mICRQcm9taXNlICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSkgcmV0dXJuIHg7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHJBcHBseSA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseTtcbnZhciBmQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIHZhciBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9fYmluZCcpO1xudmFyIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwgeyB2YWx1ZTogMSB9KSwgMSwgeyB2YWx1ZTogMiB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW107ICAgICAgLy8ga2V5c1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBpdGVyYXRlZCkga2V5cy5wdXNoKGtleSk7XG59O1xucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKShFbnVtZXJhdGUsICdPYmplY3QnLCBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGtleXMgPSB0aGF0Ll9rO1xuICB2YXIga2V5O1xuICBkbyB7XG4gICAgaWYgKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfSB3aGlsZSAoISgoa2V5ID0ga2V5c1t0aGF0Ll9pKytdKSBpbiB0aGF0Ll90KSk7XG4gIHJldHVybiB7IHZhbHVlOiBrZXksIGRvbmU6IGZhbHNlIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZSh0YXJnZXQpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2MsIHByb3RvO1xuICBpZiAoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpIHJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZiAoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IGdldDogZ2V0IH0pO1xuIiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgb3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKSB9KTtcbiIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoJHByZXZlbnRFeHRlbnNpb25zKSAkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmIChzZXRQcm90bykgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xudmFyIEJhc2UgPSAkUmVnRXhwO1xudmFyIHByb3RvID0gJFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nO1xuLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpIHtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKSB7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cDtcbiAgICB2YXIgcGlSRSA9IGlzUmVnRXhwKHApO1xuICAgIHZhciBmaVUgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTspIHByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG4iLCIvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJykgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTtcbiIsIi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCkge1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJG1hdGNoXTtcbn0pO1xuIiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UpIHtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sICRyZXBsYWNlXTtcbn0pO1xuIiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIFNFQVJDSCwgJHNlYXJjaCkge1xuICAvLyAyMS4xLjMuMTUgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIHNlYXJjaChyZWdleHApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7XG4iLCIvLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbiAgdmFyIF9zcGxpdCA9ICRzcGxpdDtcbiAgdmFyICRwdXNoID0gW10ucHVzaDtcbiAgdmFyICRTUExJVCA9ICdzcGxpdCc7XG4gIHZhciBMRU5HVEggPSAnbGVuZ3RoJztcbiAgdmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbiAgaWYgKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApIHtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZiAoIU5QQ0cpIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAvLyBgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgICBpZiAoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKSBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSkge1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYgKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy43IFN0cmluZy5wcm90b3R5cGUuZm9udGNvbG9yKGNvbG9yKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udGNvbG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcikge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ2NvbG9yJywgY29sb3IpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH07XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlIChhTGVuID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9O1xufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpIHtcbiAgICB2YXIgdHBsID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZW4gPiBpKSB7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmIChpIDwgYUxlbikgcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCc7XG52YXIgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdWIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnLi9fa2V5b2YnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSkge1xuICAgIGlmIChpc1N5bWJvbChrZXkpKSByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIGlmIChpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYgKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgkcmVwbGFjZXIpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW5hbCA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluYWwpIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXRNYXBcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiwgQTtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdE1hcCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXR0ZW5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbigvKiBkZXB0aEFyZyA9IDEgKi8pIHtcbiAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCBkZXB0aEFyZyA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aEFyZykpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXR0ZW4nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCkge1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiBNYXRoLm1pbih1cHBlciwgTWF0aC5tYXgobG93ZXIsIHgpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IERFR19QRVJfUkFEOiBNYXRoLlBJIC8gMTgwIH0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBSQURfUEVSX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBSQURfUEVSX0RFRztcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNjYWxlID0gcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpO1xudmFyIGZyb3VuZCA9IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnNjYWxlOiBmdW5jdGlvbiBmc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gICAgcmV0dXJuIGZyb3VuZChzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBSQURfUEVSX0RFRzogMTgwIC8gTWF0aC5QSSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgREVHX1BFUl9SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogREVHX1BFUl9SQUQ7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzY2FsZTogcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpIH0pO1xuIiwiLy8gaHR0cDovL2pmYmFzdGllbi5naXRodWIuaW8vcGFwZXJzL01hdGguc2lnbmJpdC5odG1sXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ25iaXQ6IGZ1bmN0aW9uIHNpZ25iaXQoeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSAhPSB4ID8geCA6IHggPT0gMCA/IDEgLyB4ID09IEluZmluaXR5IDogeCA+IDA7XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+Pj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHsgc2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCkge1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4vX293bi1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELmdldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELnNldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgT0JTRVJWQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgUkVUVVJOID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYgKGNsZWFudXApIHtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpO1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmICghbSkgdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KSBpdGVtc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xuICAgIHJldHVybiBuZXcgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlKShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2pdKTtcbiAgICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9XG59KTtcblxuaGlkZSgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9CU0VSVkFCTEUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywgeyBPYnNlcnZhYmxlOiAkT2JzZXJ2YWJsZSB9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoeyBkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5tYXA7XG52YXIgc3RvcmUgPSBtZXRhZGF0YS5zdG9yZTtcblxubWV0YWRhdGEuZXhwKHsgZGVsZXRlTWV0YWRhdGE6IGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgdmFyIHRhcmdldEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSk7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIGlmIChtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChtZXRhZGF0YU1hcC5zaXplKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xufSB9KTtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL2VzNi5zZXQnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xudmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIHZhciBvS2V5cyA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpIHJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0O1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5R2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZiAoaGFzT3duKSByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRNZXRhZGF0YTogZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGdldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoeyBoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyICRtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9NZXRhS2V5ID0gJG1ldGFkYXRhLmtleTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gJG1ldGFkYXRhLnNldDtcblxuJG1ldGFkYXRhLmV4cCh7IG1ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShcbiAgICAgIG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLFxuICAgICAgKHRhcmdldEtleSAhPT0gdW5kZWZpbmVkID8gYW5PYmplY3QgOiBhRnVuY3Rpb24pKHRhcmdldCksXG4gICAgICB0b01ldGFLZXkodGFyZ2V0S2V5KVxuICAgICk7XG4gIH07XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBnZXRGbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24gKHJlZ2V4cCwgc3RyaW5nKSB7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7IHZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGwgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYgKCFpc1JlZ0V4cChyZWdleHApKSB0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApO1xuICAgIHZhciByeCA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywgeyBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrU2V0Jyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcbiIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgcGFydGlhbCA9IHJlcXVpcmUoJy4vX3BhcnRpYWwnKTtcbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xudmFyIE1TSUUgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgcmV0dXJuIE1TSUUgPyBmdW5jdGlvbiAoZm4sIHRpbWUgLyogLCAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIHNldChpbnZva2UoXG4gICAgICBwYXJ0aWFsLFxuICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTtcbiIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuZmxhdHRlbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5jbGFtcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZy1wZXItcmFkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZC1wZXItZGVnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgudW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zaWduYml0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBmb3JlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woKSA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG9iaiA9IHt9O1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4gICAgICAgIGZvciAodmFyIF8gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuXHRcdHJldHVybiBvYmoueCA9PT0gb2JqO1xuXHR9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgSUUgOC4gKi9cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkKCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7XG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gcHJvcHMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yZWFjaChwcm9wcywgZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgcHJlZGljYXRlc1tuYW1lXSk7XG5cdH0pO1xufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJztcbnZhciBzeW1ib2xUb1N0ciA9IGhhc1N5bWJvbHMgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogdG9TdHI7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNOYU4nKTtcbnZhciAkaXNGaW5pdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNGaW5pdGUnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTWF0aC5wb3coMiwgNTMpIC0gMTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vaGVscGVycy9hc3NpZ24nKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NpZ24nKTtcbnZhciBtb2QgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kJyk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2VzLXRvLXByaW1pdGl2ZS9lczYnKTtcbnZhciBwYXJzZUludGVnZXIgPSBwYXJzZUludDtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGFycmF5U2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcbnZhciBzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciBpc0JpbmFyeSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eMGJbMDFdKyQvaSk7XG52YXIgaXNPY3RhbCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eMG9bMC03XSskL2kpO1xudmFyIHJlZ2V4RXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xudmFyIG5vbldTID0gWydcXHUwMDg1JywgJ1xcdTIwMGInLCAnXFx1ZmZmZSddLmpvaW4oJycpO1xudmFyIG5vbldTcmVnZXggPSBuZXcgUmVnRXhwKCdbJyArIG5vbldTICsgJ10nLCAnZycpO1xudmFyIGhhc05vbldTID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgbm9uV1NyZWdleCk7XG52YXIgaW52YWxpZEhleExpdGVyYWwgPSAvXlstK10weFswLTlhLWZdKyQvaTtcbnZhciBpc0ludmFsaWRIZXhMaXRlcmFsID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgaW52YWxpZEhleExpdGVyYWwpO1xuXG4vLyB3aGl0ZXNwYWNlIGZyb206IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG4vLyBpbXBsZW1lbnRhdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL3YzLjQuMC9lczUtc2hpbS5qcyNMMTMwNC1MMTMyNFxudmFyIHdzID0gW1xuXHQnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnLFxuXHQnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnLFxuXHQnXFx1MjAyOVxcdUZFRkYnXG5dLmpvaW4oJycpO1xudmFyIHRyaW1SZWdleCA9IG5ldyBSZWdFeHAoJyheWycgKyB3cyArICddKyl8KFsnICsgd3MgKyAnXSskKScsICdnJyk7XG52YXIgcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyIHRyaW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHJlcGxhY2UodmFsdWUsIHRyaW1SZWdleCwgJycpO1xufTtcblxudmFyIEVTNSA9IHJlcXVpcmUoJy4vZXM1Jyk7XG5cbnZhciBoYXNSZWdFeHBNYXRjaGVyID0gcmVxdWlyZSgnaXMtcmVnZXgnKTtcblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWFic3RyYWN0LW9wZXJhdGlvbnNcbnZhciBFUzYgPSBhc3NpZ24oYXNzaWduKHt9LCBFUzUpLCB7XG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWNhbGwtZi12LWFyZ3Ncblx0Q2FsbDogZnVuY3Rpb24gQ2FsbChGLCBWKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXHRcdGlmICghdGhpcy5Jc0NhbGxhYmxlKEYpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKEYgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHRcdHJldHVybiBGLmFwcGx5KFYsIGFyZ3MpO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3ByaW1pdGl2ZVxuXHRUb1ByaW1pdGl2ZTogdG9QcmltaXRpdmUsXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvYm9vbGVhblxuXHQvLyBUb0Jvb2xlYW46IEVTNS5Ub0Jvb2xlYW4sXG5cblx0Ly8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbnVtYmVyXG5cdFRvTnVtYmVyOiBmdW5jdGlvbiBUb051bWJlcihhcmd1bWVudCkge1xuXHRcdHZhciB2YWx1ZSA9IGlzUHJpbWl0aXZlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdG9QcmltaXRpdmUoYXJndW1lbnQsICdudW1iZXInKTtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlmIChpc0JpbmFyeSh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuVG9OdW1iZXIocGFyc2VJbnRlZ2VyKHN0clNsaWNlKHZhbHVlLCAyKSwgMikpO1xuXHRcdFx0fSBlbHNlIGlmIChpc09jdGFsKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5Ub051bWJlcihwYXJzZUludGVnZXIoc3RyU2xpY2UodmFsdWUsIDIpLCA4KSk7XG5cdFx0XHR9IGVsc2UgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRyaW1tZWQgPSB0cmltKHZhbHVlKTtcblx0XHRcdFx0aWYgKHRyaW1tZWQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuVG9OdW1iZXIodHJpbW1lZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE51bWJlcih2YWx1ZSk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvaW50ZWdlclxuXHQvLyBUb0ludGVnZXI6IEVTNS5Ub051bWJlcixcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9pbnQzMlxuXHQvLyBUb0ludDMyOiBFUzUuVG9JbnQzMixcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG91aW50MzJcblx0Ly8gVG9VaW50MzI6IEVTNS5Ub1VpbnQzMixcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9pbnQxNlxuXHRUb0ludDE2OiBmdW5jdGlvbiBUb0ludDE2KGFyZ3VtZW50KSB7XG5cdFx0dmFyIGludDE2Yml0ID0gdGhpcy5Ub1VpbnQxNihhcmd1bWVudCk7XG5cdFx0cmV0dXJuIGludDE2Yml0ID49IDB4ODAwMCA/IGludDE2Yml0IC0gMHgxMDAwMCA6IGludDE2Yml0O1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3VpbnQxNlxuXHQvLyBUb1VpbnQxNjogRVM1LlRvVWludDE2LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2ludDhcblx0VG9JbnQ4OiBmdW5jdGlvbiBUb0ludDgoYXJndW1lbnQpIHtcblx0XHR2YXIgaW50OGJpdCA9IHRoaXMuVG9VaW50OChhcmd1bWVudCk7XG5cdFx0cmV0dXJuIGludDhiaXQgPj0gMHg4MCA/IGludDhiaXQgLSAweDEwMCA6IGludDhiaXQ7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvdWludDhcblx0VG9VaW50ODogZnVuY3Rpb24gVG9VaW50OChhcmd1bWVudCkge1xuXHRcdHZhciBudW1iZXIgPSB0aGlzLlRvTnVtYmVyKGFyZ3VtZW50KTtcblx0XHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwIHx8ICEkaXNGaW5pdGUobnVtYmVyKSkgeyByZXR1cm4gMDsgfVxuXHRcdHZhciBwb3NJbnQgPSBzaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xuXHRcdHJldHVybiBtb2QocG9zSW50LCAweDEwMCk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvdWludDhjbGFtcFxuXHRUb1VpbnQ4Q2xhbXA6IGZ1bmN0aW9uIFRvVWludDhDbGFtcChhcmd1bWVudCkge1xuXHRcdHZhciBudW1iZXIgPSB0aGlzLlRvTnVtYmVyKGFyZ3VtZW50KTtcblx0XHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyIDw9IDApIHsgcmV0dXJuIDA7IH1cblx0XHRpZiAobnVtYmVyID49IDB4RkYpIHsgcmV0dXJuIDB4RkY7IH1cblx0XHR2YXIgZiA9IE1hdGguZmxvb3IoYXJndW1lbnQpO1xuXHRcdGlmIChmICsgMC41IDwgbnVtYmVyKSB7IHJldHVybiBmICsgMTsgfVxuXHRcdGlmIChudW1iZXIgPCBmICsgMC41KSB7IHJldHVybiBmOyB9XG5cdFx0aWYgKGYgJSAyICE9PSAwKSB7IHJldHVybiBmICsgMTsgfVxuXHRcdHJldHVybiBmO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3N0cmluZ1xuXHRUb1N0cmluZzogZnVuY3Rpb24gVG9TdHJpbmcoYXJndW1lbnQpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAnc3ltYm9sJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcblx0XHR9XG5cdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvb2JqZWN0XG5cdFRvT2JqZWN0OiBmdW5jdGlvbiBUb09iamVjdCh2YWx1ZSkge1xuXHRcdHRoaXMuUmVxdWlyZU9iamVjdENvZXJjaWJsZSh2YWx1ZSk7XG5cdFx0cmV0dXJuIE9iamVjdCh2YWx1ZSk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvcHJvcGVydHlrZXlcblx0VG9Qcm9wZXJ0eUtleTogZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xuXHRcdHZhciBrZXkgPSB0aGlzLlRvUHJpbWl0aXZlKGFyZ3VtZW50LCBTdHJpbmcpO1xuXHRcdHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3ltYm9sJyA/IHN5bWJvbFRvU3RyLmNhbGwoa2V5KSA6IHRoaXMuVG9TdHJpbmcoa2V5KTtcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcblx0VG9MZW5ndGg6IGZ1bmN0aW9uIFRvTGVuZ3RoKGFyZ3VtZW50KSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMuVG9JbnRlZ2VyKGFyZ3VtZW50KTtcblx0XHRpZiAobGVuIDw9IDApIHsgcmV0dXJuIDA7IH0gLy8gaW5jbHVkZXMgY29udmVydGluZyAtMCB0byArMFxuXHRcdGlmIChsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7IHJldHVybiBNQVhfU0FGRV9JTlRFR0VSOyB9XG5cdFx0cmV0dXJuIGxlbjtcblx0fSxcblxuXHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY2Fub25pY2FsbnVtZXJpY2luZGV4c3RyaW5nXG5cdENhbm9uaWNhbE51bWVyaWNJbmRleFN0cmluZzogZnVuY3Rpb24gQ2Fub25pY2FsTnVtZXJpY0luZGV4U3RyaW5nKGFyZ3VtZW50KSB7XG5cdFx0aWYgKHRvU3RyLmNhbGwoYXJndW1lbnQpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdH1cblx0XHRpZiAoYXJndW1lbnQgPT09ICctMCcpIHsgcmV0dXJuIC0wOyB9XG5cdFx0dmFyIG4gPSB0aGlzLlRvTnVtYmVyKGFyZ3VtZW50KTtcblx0XHRpZiAodGhpcy5TYW1lVmFsdWUodGhpcy5Ub1N0cmluZyhuKSwgYXJndW1lbnQpKSB7IHJldHVybiBuOyB9XG5cdFx0cmV0dXJuIHZvaWQgMDtcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxuXHRSZXF1aXJlT2JqZWN0Q29lcmNpYmxlOiBFUzUuQ2hlY2tPYmplY3RDb2VyY2libGUsXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWlzYXJyYXlcblx0SXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBJc0FycmF5KGFyZ3VtZW50KSB7XG5cdFx0cmV0dXJuIHRvU3RyLmNhbGwoYXJndW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2NhbGxhYmxlXG5cdC8vIElzQ2FsbGFibGU6IEVTNS5Jc0NhbGxhYmxlLFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2NvbnN0cnVjdG9yXG5cdElzQ29uc3RydWN0b3I6IGZ1bmN0aW9uIElzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnZnVuY3Rpb24nICYmICEhYXJndW1lbnQucHJvdG90eXBlOyAvLyB1bmZvcnR1bmF0ZWx5IHRoZXJlJ3Mgbm8gd2F5IHRvIHRydWx5IGNoZWNrIHRoaXMgd2l0aG91dCB0cnkvY2F0Y2ggYG5ldyBhcmd1bWVudGBcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtaXNleHRlbnNpYmxlLW9cblx0SXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBJc0V4dGVuc2libGUob2JqKSB7XG5cdFx0aWYgKCFPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoaXNQcmltaXRpdmUob2JqKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShvYmopO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2ludGVnZXJcblx0SXNJbnRlZ2VyOiBmdW5jdGlvbiBJc0ludGVnZXIoYXJndW1lbnQpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3VtZW50ICE9PSAnbnVtYmVyJyB8fCAkaXNOYU4oYXJndW1lbnQpIHx8ICEkaXNGaW5pdGUoYXJndW1lbnQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBhYnMgPSBNYXRoLmFicyhhcmd1bWVudCk7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoYWJzKSA9PT0gYWJzO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc3Byb3BlcnR5a2V5XG5cdElzUHJvcGVydHlLZXk6IGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJndW1lbnQgPT09ICdzeW1ib2wnO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc3JlZ2V4cFxuXHRJc1JlZ0V4cDogZnVuY3Rpb24gSXNSZWdFeHAoYXJndW1lbnQpIHtcblx0XHRpZiAoIWFyZ3VtZW50IHx8IHR5cGVvZiBhcmd1bWVudCAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRcdHZhciBpc1JlZ0V4cCA9IGFyZ3VtZW50W1N5bWJvbC5tYXRjaF07XG5cdFx0XHRpZiAodHlwZW9mIGlzUmVnRXhwICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm4gRVM1LlRvQm9vbGVhbihpc1JlZ0V4cCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBoYXNSZWdFeHBNYXRjaGVyKGFyZ3VtZW50KTtcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlXG5cdC8vIFNhbWVWYWx1ZTogRVM1LlNhbWVWYWx1ZSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVyb1xuXHRTYW1lVmFsdWVaZXJvOiBmdW5jdGlvbiBTYW1lVmFsdWVaZXJvKHgsIHkpIHtcblx0XHRyZXR1cm4gKHggPT09IHkpIHx8ICgkaXNOYU4oeCkgJiYgJGlzTmFOKHkpKTtcblx0fSxcblxuXHQvKipcblx0ICogNy4zLjIgR2V0ViAoViwgUClcblx0ICogMS4gQXNzZXJ0OiBJc1Byb3BlcnR5S2V5KFApIGlzIHRydWUuXG5cdCAqIDIuIExldCBPIGJlIFRvT2JqZWN0KFYpLlxuXHQgKiAzLiBSZXR1cm5JZkFicnVwdChPKS5cblx0ICogNC4gUmV0dXJuIE8uW1tHZXRdXShQLCBWKS5cblx0ICovXG5cdEdldFY6IGZ1bmN0aW9uIEdldFYoViwgUCkge1xuXHRcdC8vIDcuMy4yLjFcblx0XHRpZiAoIXRoaXMuSXNQcm9wZXJ0eUtleShQKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogSXNQcm9wZXJ0eUtleShQKSBpcyBub3QgdHJ1ZScpO1xuXHRcdH1cblxuXHRcdC8vIDcuMy4yLjItM1xuXHRcdHZhciBPID0gdGhpcy5Ub09iamVjdChWKTtcblxuXHRcdC8vIDcuMy4yLjRcblx0XHRyZXR1cm4gT1tQXTtcblx0fSxcblxuXHQvKipcblx0ICogNy4zLjkgLSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZ2V0bWV0aG9kXG5cdCAqIDEuIEFzc2VydDogSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuXHQgKiAyLiBMZXQgZnVuYyBiZSBHZXRWKE8sIFApLlxuXHQgKiAzLiBSZXR1cm5JZkFicnVwdChmdW5jKS5cblx0ICogNC4gSWYgZnVuYyBpcyBlaXRoZXIgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybiB1bmRlZmluZWQuXG5cdCAqIDUuIElmIElzQ2FsbGFibGUoZnVuYykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cblx0ICogNi4gUmV0dXJuIGZ1bmMuXG5cdCAqL1xuXHRHZXRNZXRob2Q6IGZ1bmN0aW9uIEdldE1ldGhvZChPLCBQKSB7XG5cdFx0Ly8gNy4zLjkuMVxuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBJc1Byb3BlcnR5S2V5KFApIGlzIG5vdCB0cnVlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gNy4zLjkuMlxuXHRcdHZhciBmdW5jID0gdGhpcy5HZXRWKE8sIFApO1xuXG5cdFx0Ly8gNy4zLjkuNFxuXHRcdGlmIChmdW5jID09IG51bGwpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gNy4zLjkuNVxuXHRcdGlmICghdGhpcy5Jc0NhbGxhYmxlKGZ1bmMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFAgKyAnaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHR9XG5cblx0XHQvLyA3LjMuOS42XG5cdFx0cmV0dXJuIGZ1bmM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIDcuMy4xIEdldCAoTywgUCkgLSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZ2V0LW8tcFxuXHQgKiAxLiBBc3NlcnQ6IFR5cGUoTykgaXMgT2JqZWN0LlxuXHQgKiAyLiBBc3NlcnQ6IElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cblx0ICogMy4gUmV0dXJuIE8uW1tHZXRdXShQLCBPKS5cblx0ICovXG5cdEdldDogZnVuY3Rpb24gR2V0KE8sIFApIHtcblx0XHQvLyA3LjMuMS4xXG5cdFx0aWYgKHRoaXMuVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHRcdH1cblx0XHQvLyA3LjMuMS4yXG5cdFx0aWYgKCF0aGlzLklzUHJvcGVydHlLZXkoUCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0XHR9XG5cdFx0Ly8gNy4zLjEuM1xuXHRcdHJldHVybiBPW1BdO1xuXHR9LFxuXG5cdFR5cGU6IGZ1bmN0aW9uIFR5cGUoeCkge1xuXHRcdGlmICh0eXBlb2YgeCA9PT0gJ3N5bWJvbCcpIHtcblx0XHRcdHJldHVybiAnU3ltYm9sJztcblx0XHR9XG5cdFx0cmV0dXJuIEVTNS5UeXBlKHgpO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zcGVjaWVzY29uc3RydWN0b3Jcblx0U3BlY2llc0NvbnN0cnVjdG9yOiBmdW5jdGlvbiBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG5cdFx0aWYgKHRoaXMuVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHRcdH1cblx0XHR2YXIgQyA9IE8uY29uc3RydWN0b3I7XG5cdFx0aWYgKHR5cGVvZiBDID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRDb25zdHJ1Y3Rvcjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuVHlwZShDKSAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ08uY29uc3RydWN0b3IgaXMgbm90IGFuIE9iamVjdCcpO1xuXHRcdH1cblx0XHR2YXIgUyA9IGhhc1N5bWJvbHMgJiYgU3ltYm9sLnNwZWNpZXMgPyBDW1N5bWJvbC5zcGVjaWVzXSA6IHVuZGVmaW5lZDtcblx0XHRpZiAoUyA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdENvbnN0cnVjdG9yO1xuXHRcdH1cblx0XHRpZiAodGhpcy5Jc0NvbnN0cnVjdG9yKFMpKSB7XG5cdFx0XHRyZXR1cm4gUztcblx0XHR9XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignbm8gY29uc3RydWN0b3IgZm91bmQnKTtcblx0fSxcblxuXHQvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1jb21wbGV0ZXByb3BlcnR5ZGVzY3JpcHRvclxuXHRDb21wbGV0ZVByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gQ29tcGxldGVQcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykge1xuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5RGVzY3JpcHRvcihEZXNjKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRGVzYyBtdXN0IGJlIGEgUHJvcGVydHkgRGVzY3JpcHRvcicpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLklzR2VuZXJpY0Rlc2NyaXB0b3IoRGVzYykgfHwgdGhpcy5Jc0RhdGFEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0XHRpZiAoIWhhcyhEZXNjLCAnW1tWYWx1ZV1dJykpIHtcblx0XHRcdFx0RGVzY1snW1tWYWx1ZV1dJ10gPSB2b2lkIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWhhcyhEZXNjLCAnW1tXcml0YWJsZV1dJykpIHtcblx0XHRcdFx0RGVzY1snW1tXcml0YWJsZV1dJ10gPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFoYXMoRGVzYywgJ1tbR2V0XV0nKSkge1xuXHRcdFx0XHREZXNjWydbW0dldF1dJ10gPSB2b2lkIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWhhcyhEZXNjLCAnW1tTZXRdXScpKSB7XG5cdFx0XHRcdERlc2NbJ1tbU2V0XV0nXSA9IHZvaWQgMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFoYXMoRGVzYywgJ1tbRW51bWVyYWJsZV1dJykpIHtcblx0XHRcdERlc2NbJ1tbRW51bWVyYWJsZV1dJ10gPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFoYXMoRGVzYywgJ1tbQ29uZmlndXJhYmxlXV0nKSkge1xuXHRcdFx0RGVzY1snW1tDb25maWd1cmFibGVdXSddID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBEZXNjO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNldC1vLXAtdi10aHJvd1xuXHRTZXQ6IGZ1bmN0aW9uIFNldChPLCBQLCBWLCBUaHJvdykge1xuXHRcdGlmICh0aGlzLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQIG11c3QgYmUgYSBQcm9wZXJ0eSBLZXknKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuVHlwZShUaHJvdykgIT09ICdCb29sZWFuJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVGhyb3cgbXVzdCBiZSBhIEJvb2xlYW4nKTtcblx0XHR9XG5cdFx0aWYgKFRocm93KSB7XG5cdFx0XHRPW1BdID0gVjtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRPW1BdID0gVjtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1oYXNvd25wcm9wZXJ0eVxuXHRIYXNPd25Qcm9wZXJ0eTogZnVuY3Rpb24gSGFzT3duUHJvcGVydHkoTywgUCkge1xuXHRcdGlmICh0aGlzLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQIG11c3QgYmUgYSBQcm9wZXJ0eSBLZXknKTtcblx0XHR9XG5cdFx0cmV0dXJuIGhhcyhPLCBQKTtcblx0fSxcblxuXHQvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1oYXNwcm9wZXJ0eVxuXHRIYXNQcm9wZXJ0eTogZnVuY3Rpb24gSGFzUHJvcGVydHkoTywgUCkge1xuXHRcdGlmICh0aGlzLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5Jc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQIG11c3QgYmUgYSBQcm9wZXJ0eSBLZXknKTtcblx0XHR9XG5cdFx0cmV0dXJuIFAgaW4gTztcblx0fSxcblxuXHQvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc2NvbmNhdHNwcmVhZGFibGVcblx0SXNDb25jYXRTcHJlYWRhYmxlOiBmdW5jdGlvbiBJc0NvbmNhdFNwcmVhZGFibGUoTykge1xuXHRcdGlmICh0aGlzLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlID09PSAnc3ltYm9sJykge1xuXHRcdFx0dmFyIHNwcmVhZGFibGUgPSB0aGlzLkdldChPLCBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlKTtcblx0XHRcdGlmICh0eXBlb2Ygc3ByZWFkYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuVG9Cb29sZWFuKHNwcmVhZGFibGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5Jc0FycmF5KE8pO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWludm9rZVxuXHRJbnZva2U6IGZ1bmN0aW9uIEludm9rZShPLCBQKSB7XG5cdFx0aWYgKCF0aGlzLklzUHJvcGVydHlLZXkoUCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1AgbXVzdCBiZSBhIFByb3BlcnR5IEtleScpO1xuXHRcdH1cblx0XHR2YXIgYXJndW1lbnRzTGlzdCA9IGFycmF5U2xpY2UoYXJndW1lbnRzLCAyKTtcblx0XHR2YXIgZnVuYyA9IHRoaXMuR2V0VihPLCBQKTtcblx0XHRyZXR1cm4gdGhpcy5DYWxsKGZ1bmMsIE8sIGFyZ3VtZW50c0xpc3QpO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWNyZWF0ZWl0ZXJyZXN1bHRvYmplY3Rcblx0Q3JlYXRlSXRlclJlc3VsdE9iamVjdDogZnVuY3Rpb24gQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh2YWx1ZSwgZG9uZSkge1xuXHRcdGlmICh0aGlzLlR5cGUoZG9uZSkgIT09ICdCb29sZWFuJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShkb25lKSBpcyBub3QgQm9vbGVhbicpO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0ZG9uZTogZG9uZVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcmVnZXhwZXhlY1xuXHRSZWdFeHBFeGVjOiBmdW5jdGlvbiBSZWdFeHBFeGVjKFIsIFMpIHtcblx0XHRpZiAodGhpcy5UeXBlKFIpICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUiBtdXN0IGJlIGFuIE9iamVjdCcpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5UeXBlKFMpICE9PSAnU3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUyBtdXN0IGJlIGEgU3RyaW5nJyk7XG5cdFx0fVxuXHRcdHZhciBleGVjID0gdGhpcy5HZXQoUiwgJ2V4ZWMnKTtcblx0XHRpZiAodGhpcy5Jc0NhbGxhYmxlKGV4ZWMpKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5DYWxsKGV4ZWMsIFIsIFtTXSk7XG5cdFx0XHRpZiAocmVzdWx0ID09PSBudWxsIHx8IHRoaXMuVHlwZShyZXN1bHQpID09PSAnT2JqZWN0Jykge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignXCJleGVjXCIgbWV0aG9kIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBPYmplY3QnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlZ2V4RXhlYyhSLCBTKTtcblx0fVxufSk7XG5cbmRlbGV0ZSBFUzYuQ2hlY2tPYmplY3RDb2VyY2libGU7IC8vIHJlbmFtZWQgaW4gRVM2IHRvIFJlcXVpcmVPYmplY3RDb2VyY2libGVcblxubW9kdWxlLmV4cG9ydHMgPSBFUzY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFUzIwMTUgPSByZXF1aXJlKCcuL2VzMjAxNScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vaGVscGVycy9hc3NpZ24nKTtcblxudmFyIEVTMjAxNiA9IGFzc2lnbihhc3NpZ24oe30sIEVTMjAxNSksIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9wdWxsLzYwXG5cdFNhbWVWYWx1ZU5vbk51bWJlcjogZnVuY3Rpb24gU2FtZVZhbHVlTm9uTnVtYmVyKHgsIHkpIHtcblx0XHRpZiAodHlwZW9mIHggPT09ICdudW1iZXInIHx8IHR5cGVvZiB4ICE9PSB0eXBlb2YgeSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignU2FtZVZhbHVlTm9uTnVtYmVyIHJlcXVpcmVzIHR3byBub24tbnVtYmVyIHZhbHVlcyBvZiB0aGUgc2FtZSB0eXBlLicpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5TYW1lVmFsdWUoeCwgeSk7XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVTMjAxNjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJy4vaGVscGVycy9pc05hTicpO1xudmFyICRpc0Zpbml0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0Zpbml0ZScpO1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vaGVscGVycy9zaWduJyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZCcpO1xuXG52YXIgSXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCdlcy10by1wcmltaXRpdmUvZXM1Jyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcblxuLy8gaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OVxudmFyIEVTNSA9IHtcblx0VG9QcmltaXRpdmU6IHRvUHJpbWl0aXZlLFxuXG5cdFRvQm9vbGVhbjogZnVuY3Rpb24gVG9Cb29sZWFuKHZhbHVlKSB7XG5cdFx0cmV0dXJuICEhdmFsdWU7XG5cdH0sXG5cdFRvTnVtYmVyOiBmdW5jdGlvbiBUb051bWJlcih2YWx1ZSkge1xuXHRcdHJldHVybiBOdW1iZXIodmFsdWUpO1xuXHR9LFxuXHRUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcih2YWx1ZSkge1xuXHRcdHZhciBudW1iZXIgPSB0aGlzLlRvTnVtYmVyKHZhbHVlKTtcblx0XHRpZiAoJGlzTmFOKG51bWJlcikpIHsgcmV0dXJuIDA7IH1cblx0XHRpZiAobnVtYmVyID09PSAwIHx8ICEkaXNGaW5pdGUobnVtYmVyKSkgeyByZXR1cm4gbnVtYmVyOyB9XG5cdFx0cmV0dXJuIHNpZ24obnVtYmVyKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSk7XG5cdH0sXG5cdFRvSW50MzI6IGZ1bmN0aW9uIFRvSW50MzIoeCkge1xuXHRcdHJldHVybiB0aGlzLlRvTnVtYmVyKHgpID4+IDA7XG5cdH0sXG5cdFRvVWludDMyOiBmdW5jdGlvbiBUb1VpbnQzMih4KSB7XG5cdFx0cmV0dXJuIHRoaXMuVG9OdW1iZXIoeCkgPj4+IDA7XG5cdH0sXG5cdFRvVWludDE2OiBmdW5jdGlvbiBUb1VpbnQxNih2YWx1ZSkge1xuXHRcdHZhciBudW1iZXIgPSB0aGlzLlRvTnVtYmVyKHZhbHVlKTtcblx0XHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwIHx8ICEkaXNGaW5pdGUobnVtYmVyKSkgeyByZXR1cm4gMDsgfVxuXHRcdHZhciBwb3NJbnQgPSBzaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xuXHRcdHJldHVybiBtb2QocG9zSW50LCAweDEwMDAwKTtcblx0fSxcblx0VG9TdHJpbmc6IGZ1bmN0aW9uIFRvU3RyaW5nKHZhbHVlKSB7XG5cdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cdH0sXG5cdFRvT2JqZWN0OiBmdW5jdGlvbiBUb09iamVjdCh2YWx1ZSkge1xuXHRcdHRoaXMuQ2hlY2tPYmplY3RDb2VyY2libGUodmFsdWUpO1xuXHRcdHJldHVybiBPYmplY3QodmFsdWUpO1xuXHR9LFxuXHRDaGVja09iamVjdENvZXJjaWJsZTogZnVuY3Rpb24gQ2hlY2tPYmplY3RDb2VyY2libGUodmFsdWUsIG9wdE1lc3NhZ2UpIHtcblx0XHQvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihvcHRNZXNzYWdlIHx8ICdDYW5ub3QgY2FsbCBtZXRob2Qgb24gJyArIHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRJc0NhbGxhYmxlOiBJc0NhbGxhYmxlLFxuXHRTYW1lVmFsdWU6IGZ1bmN0aW9uIFNhbWVWYWx1ZSh4LCB5KSB7XG5cdFx0aWYgKHggPT09IHkpIHsgLy8gMCA9PT0gLTAsIGJ1dCB0aGV5IGFyZSBub3QgaWRlbnRpY2FsLlxuXHRcdFx0aWYgKHggPT09IDApIHsgcmV0dXJuIDEgLyB4ID09PSAxIC8geTsgfVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAkaXNOYU4oeCkgJiYgJGlzTmFOKHkpO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04XG5cdFR5cGU6IGZ1bmN0aW9uIFR5cGUoeCkge1xuXHRcdGlmICh4ID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gJ051bGwnO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gJ1VuZGVmaW5lZCc7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiAnT2JqZWN0Jztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuXHRcdFx0cmV0dXJuICdOdW1iZXInO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHggPT09ICdib29sZWFuJykge1xuXHRcdFx0cmV0dXJuICdCb29sZWFuJztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuICdTdHJpbmcnO1xuXHRcdH1cblx0fSxcblxuXHQvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wcm9wZXJ0eS1kZXNjcmlwdG9yLXNwZWNpZmljYXRpb24tdHlwZVxuXHRJc1Byb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gSXNQcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykge1xuXHRcdGlmICh0aGlzLlR5cGUoRGVzYykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBhbGxvd2VkID0ge1xuXHRcdFx0J1tbQ29uZmlndXJhYmxlXV0nOiB0cnVlLFxuXHRcdFx0J1tbRW51bWVyYWJsZV1dJzogdHJ1ZSxcblx0XHRcdCdbW0dldF1dJzogdHJ1ZSxcblx0XHRcdCdbW1NldF1dJzogdHJ1ZSxcblx0XHRcdCdbW1ZhbHVlXV0nOiB0cnVlLFxuXHRcdFx0J1tbV3JpdGFibGVdXSc6IHRydWVcblx0XHR9O1xuXHRcdC8vIGpzY3M6ZGlzYWJsZVxuXHRcdGZvciAodmFyIGtleSBpbiBEZXNjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHRcdGlmIChoYXMoRGVzYywga2V5KSAmJiAhYWxsb3dlZFtrZXldKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8ganNjczplbmFibGVcblx0XHR2YXIgaXNEYXRhID0gaGFzKERlc2MsICdbW1ZhbHVlXV0nKTtcblx0XHR2YXIgSXNBY2Nlc3NvciA9IGhhcyhEZXNjLCAnW1tHZXRdXScpIHx8IGhhcyhEZXNjLCAnW1tTZXRdXScpO1xuXHRcdGlmIChpc0RhdGEgJiYgSXNBY2Nlc3Nvcikge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUHJvcGVydHkgRGVzY3JpcHRvcnMgbWF5IG5vdCBiZSBib3RoIGFjY2Vzc29yIGFuZCBkYXRhIGRlc2NyaXB0b3JzJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguMTAuMVxuXHRJc0FjY2Vzc29yRGVzY3JpcHRvcjogZnVuY3Rpb24gSXNBY2Nlc3NvckRlc2NyaXB0b3IoRGVzYykge1xuXHRcdGlmICh0eXBlb2YgRGVzYyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuSXNQcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Rlc2MgbXVzdCBiZSBhIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0XHR9XG5cblx0XHRpZiAoIWhhcyhEZXNjLCAnW1tHZXRdXScpICYmICFoYXMoRGVzYywgJ1tbU2V0XV0nKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguMTAuMlxuXHRJc0RhdGFEZXNjcmlwdG9yOiBmdW5jdGlvbiBJc0RhdGFEZXNjcmlwdG9yKERlc2MpIHtcblx0XHRpZiAodHlwZW9mIERlc2MgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLklzUHJvcGVydHlEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdEZXNjIG11c3QgYmUgYSBQcm9wZXJ0eSBEZXNjcmlwdG9yJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFoYXMoRGVzYywgJ1tbVmFsdWVdXScpICYmICFoYXMoRGVzYywgJ1tbV3JpdGFibGVdXScpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC4xMC4zXG5cdElzR2VuZXJpY0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIElzR2VuZXJpY0Rlc2NyaXB0b3IoRGVzYykge1xuXHRcdGlmICh0eXBlb2YgRGVzYyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuSXNQcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Rlc2MgbXVzdCBiZSBhIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuSXNBY2Nlc3NvckRlc2NyaXB0b3IoRGVzYykgJiYgIXRoaXMuSXNEYXRhRGVzY3JpcHRvcihEZXNjKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguMTAuNFxuXHRGcm9tUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBGcm9tUHJvcGVydHlEZXNjcmlwdG9yKERlc2MpIHtcblx0XHRpZiAodHlwZW9mIERlc2MgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gRGVzYztcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuSXNQcm9wZXJ0eURlc2NyaXB0b3IoRGVzYykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Rlc2MgbXVzdCBiZSBhIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5Jc0RhdGFEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogRGVzY1snW1tWYWx1ZV1dJ10sXG5cdFx0XHRcdHdyaXRhYmxlOiAhIURlc2NbJ1tbV3JpdGFibGVdXSddLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiAhIURlc2NbJ1tbRW51bWVyYWJsZV1dJ10sXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogISFEZXNjWydbW0NvbmZpZ3VyYWJsZV1dJ11cblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmICh0aGlzLklzQWNjZXNzb3JEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRnZXQ6IERlc2NbJ1tbR2V0XV0nXSxcblx0XHRcdFx0c2V0OiBEZXNjWydbW1NldF1dJ10sXG5cdFx0XHRcdGVudW1lcmFibGU6ICEhRGVzY1snW1tFbnVtZXJhYmxlXV0nXSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiAhIURlc2NbJ1tbQ29uZmlndXJhYmxlXV0nXVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRnJvbVByb3BlcnR5RGVzY3JpcHRvciBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVsbHkgcG9wdWxhdGVkIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC4xMC41XG5cdFRvUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBUb1Byb3BlcnR5RGVzY3JpcHRvcihPYmopIHtcblx0XHRpZiAodGhpcy5UeXBlKE9iaikgIT09ICdPYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUb1Byb3BlcnR5RGVzY3JpcHRvciByZXF1aXJlcyBhbiBvYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgZGVzYyA9IHt9O1xuXHRcdGlmIChoYXMoT2JqLCAnZW51bWVyYWJsZScpKSB7XG5cdFx0XHRkZXNjWydbW0VudW1lcmFibGVdXSddID0gdGhpcy5Ub0Jvb2xlYW4oT2JqLmVudW1lcmFibGUpO1xuXHRcdH1cblx0XHRpZiAoaGFzKE9iaiwgJ2NvbmZpZ3VyYWJsZScpKSB7XG5cdFx0XHRkZXNjWydbW0NvbmZpZ3VyYWJsZV1dJ10gPSB0aGlzLlRvQm9vbGVhbihPYmouY29uZmlndXJhYmxlKTtcblx0XHR9XG5cdFx0aWYgKGhhcyhPYmosICd2YWx1ZScpKSB7XG5cdFx0XHRkZXNjWydbW1ZhbHVlXV0nXSA9IE9iai52YWx1ZTtcblx0XHR9XG5cdFx0aWYgKGhhcyhPYmosICd3cml0YWJsZScpKSB7XG5cdFx0XHRkZXNjWydbW1dyaXRhYmxlXV0nXSA9IHRoaXMuVG9Cb29sZWFuKE9iai53cml0YWJsZSk7XG5cdFx0fVxuXHRcdGlmIChoYXMoT2JqLCAnZ2V0JykpIHtcblx0XHRcdHZhciBnZXR0ZXIgPSBPYmouZ2V0O1xuXHRcdFx0aWYgKHR5cGVvZiBnZXR0ZXIgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLklzQ2FsbGFibGUoZ2V0dGVyKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHR9XG5cdFx0XHRkZXNjWydbW0dldF1dJ10gPSBnZXR0ZXI7XG5cdFx0fVxuXHRcdGlmIChoYXMoT2JqLCAnc2V0JykpIHtcblx0XHRcdHZhciBzZXR0ZXIgPSBPYmouc2V0O1xuXHRcdFx0aWYgKHR5cGVvZiBzZXR0ZXIgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLklzQ2FsbGFibGUoc2V0dGVyKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdzZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHR9XG5cdFx0XHRkZXNjWydbW1NldF1dJ10gPSBzZXR0ZXI7XG5cdFx0fVxuXG5cdFx0aWYgKChoYXMoZGVzYywgJ1tbR2V0XV0nKSB8fCBoYXMoZGVzYywgJ1tbU2V0XV0nKSkgJiYgKGhhcyhkZXNjLCAnW1tWYWx1ZV1dJykgfHwgaGFzKGRlc2MsICdbW1dyaXRhYmxlXV0nKSkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgZGVzY3JpcHRvci4gQ2Fubm90IGJvdGggc3BlY2lmeSBhY2Nlc3NvcnMgYW5kIGEgdmFsdWUgb3Igd3JpdGFibGUgYXR0cmlidXRlJyk7XG5cdFx0fVxuXHRcdHJldHVybiBkZXNjO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVTNTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2VzMjAxNicpO1xuIiwidmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuXHRpZiAoT2JqZWN0LmFzc2lnbikge1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKTtcblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG5cdFx0aWYgKGhhcy5jYWxsKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG4iLCJ2YXIgJGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICE9PSBhOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmICEkaXNOYU4oeCkgJiYgeCAhPT0gSW5maW5pdHkgJiYgeCAhPT0gLUluZmluaXR5OyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gaXNOYU4oYSkge1xuXHRyZXR1cm4gYSAhPT0gYTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9kKG51bWJlciwgbW9kdWxvKSB7XG5cdHZhciByZW1haW4gPSBudW1iZXIgJSBtb2R1bG87XG5cdHJldHVybiBNYXRoLmZsb29yKHJlbWFpbiA+PSAwID8gcmVtYWluIDogcmVtYWluICsgbW9kdWxvKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpZ24obnVtYmVyKSB7XG5cdHJldHVybiBudW1iZXIgPj0gMCA/IDEgOiAtMTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xuXG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG5cbi8vIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDguMTJcbnZhciBFUzVpbnRlcm5hbFNsb3RzID0ge1xuXHQnW1tEZWZhdWx0VmFsdWVdXSc6IGZ1bmN0aW9uIChPLCBoaW50KSB7XG5cdFx0dmFyIGFjdHVhbEhpbnQgPSBoaW50IHx8ICh0b1N0ci5jYWxsKE8pID09PSAnW29iamVjdCBEYXRlXScgPyBTdHJpbmcgOiBOdW1iZXIpO1xuXG5cdFx0aWYgKGFjdHVhbEhpbnQgPT09IFN0cmluZyB8fCBhY3R1YWxIaW50ID09PSBOdW1iZXIpIHtcblx0XHRcdHZhciBtZXRob2RzID0gYWN0dWFsSGludCA9PT0gU3RyaW5nID8gWyd0b1N0cmluZycsICd2YWx1ZU9mJ10gOiBbJ3ZhbHVlT2YnLCAndG9TdHJpbmcnXTtcblx0XHRcdHZhciB2YWx1ZSwgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGlmIChpc0NhbGxhYmxlKE9bbWV0aG9kc1tpXV0pKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBPW21ldGhvZHNbaV1dKCk7XG5cdFx0XHRcdFx0aWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIFtbRGVmYXVsdFZhbHVlXV0gaGludCBzdXBwbGllZCcpO1xuXHR9XG59O1xuXG4vLyBodHRwczovL2VzNS5naXRodWIuaW8vI3g5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XG5cdGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblx0cmV0dXJuIEVTNWludGVybmFsU2xvdHNbJ1tbRGVmYXVsdFZhbHVlXV0nXShpbnB1dCwgUHJlZmVycmVkVHlwZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcblxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcblx0aWYgKHR5cGVvZiBPID09PSAndW5kZWZpbmVkJyB8fCBPID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyBPKTtcblx0fVxuXHRpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IChoaW50ICE9PSAnbnVtYmVyJyAmJiBoaW50ICE9PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG5cdH1cblx0dmFyIG1ldGhvZE5hbWVzID0gaGludCA9PT0gJ3N0cmluZycgPyBbJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXSA6IFsndmFsdWVPZicsICd0b1N0cmluZyddO1xuXHR2YXIgbWV0aG9kLCByZXN1bHQsIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuXHRcdG1ldGhvZCA9IE9bbWV0aG9kTmFtZXNbaV1dO1xuXHRcdGlmIChpc0NhbGxhYmxlKG1ldGhvZCkpIHtcblx0XHRcdHJlc3VsdCA9IG1ldGhvZC5jYWxsKE8pO1xuXHRcdFx0aWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xufTtcblxudmFyIEdldE1ldGhvZCA9IGZ1bmN0aW9uIEdldE1ldGhvZChPLCBQKSB7XG5cdHZhciBmdW5jID0gT1tQXTtcblx0aWYgKGZ1bmMgIT09IG51bGwgJiYgdHlwZW9mIGZ1bmMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0aWYgKCFpc0NhbGxhYmxlKGZ1bmMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bmMgKyAnIHJldHVybmVkIGZvciBwcm9wZXJ0eSAnICsgUCArICcgb2Ygb2JqZWN0ICcgKyBPICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuYztcblx0fVxufTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XG5cdGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblx0dmFyIGhpbnQgPSAnZGVmYXVsdCc7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdGlmIChQcmVmZXJyZWRUeXBlID09PSBTdHJpbmcpIHtcblx0XHRcdGhpbnQgPSAnc3RyaW5nJztcblx0XHR9IGVsc2UgaWYgKFByZWZlcnJlZFR5cGUgPT09IE51bWJlcikge1xuXHRcdFx0aGludCA9ICdudW1iZXInO1xuXHRcdH1cblx0fVxuXG5cdHZhciBleG90aWNUb1ByaW07XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0aWYgKFN5bWJvbC50b1ByaW1pdGl2ZSkge1xuXHRcdFx0ZXhvdGljVG9QcmltID0gR2V0TWV0aG9kKGlucHV0LCBTeW1ib2wudG9QcmltaXRpdmUpO1xuXHRcdH0gZWxzZSBpZiAoaXNTeW1ib2woaW5wdXQpKSB7XG5cdFx0XHRleG90aWNUb1ByaW0gPSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2Y7XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2YgZXhvdGljVG9QcmltICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgaGludCk7XG5cdFx0aWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuYWJsZSB0byBjb252ZXJ0IGV4b3RpYyBvYmplY3QgdG8gcHJpbWl0aXZlJyk7XG5cdH1cblx0aWYgKGhpbnQgPT09ICdkZWZhdWx0JyAmJiAoaXNEYXRlKGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpKSB7XG5cdFx0aGludCA9ICdzdHJpbmcnO1xuXHR9XG5cdHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSAnZGVmYXVsdCcgPyAnbnVtYmVyJyA6IGhpbnQpO1xufTtcbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJudW1lcmljXCIpLCByZXF1aXJlKFwibnVtZXJhbFwiKSwgcmVxdWlyZShcImpTdGF0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcIm51bWVyaWNcIiwgXCJudW1lcmFsXCIsIFwialN0YXRcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZm9ybXVsYWpzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibnVtZXJpY1wiKSwgcmVxdWlyZShcIm51bWVyYWxcIiksIHJlcXVpcmUoXCJqU3RhdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiZm9ybXVsYWpzXCJdID0gZmFjdG9yeShyb290W1wibnVtZXJpY1wiXSwgcm9vdFtcIm51bWVyYWxcIl0sIHJvb3RbXCJqU3RhdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBjYXRlZ29yaWVzID0gW1xuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMSksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxMiksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTQpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTcpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTEpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTgpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oNiksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxMClcblx0XTtcblxuXHRmb3IgKHZhciBjIGluIGNhdGVnb3JpZXMpIHtcblx0ICB2YXIgY2F0ZWdvcnkgPSBjYXRlZ29yaWVzW2NdO1xuXHQgIGZvciAodmFyIGYgaW4gY2F0ZWdvcnkpIHtcblx0ICAgIGV4cG9ydHNbZl0gPSBleHBvcnRzW2ZdIHx8IGNhdGVnb3J5W2ZdO1xuXHQgIH1cblx0fVxuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgbWF0aFRyaWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgc3RhdGlzdGljYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgZW5naW5lZXJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0dmFyIGRhdGVUaW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cblx0ZnVuY3Rpb24gc2V0KGZuLCByb290KSB7XG5cdCAgaWYgKHJvb3QpIHtcblx0ICAgIGZvciAodmFyIGkgaW4gcm9vdCkge1xuXHQgICAgICBmbltpXSA9IHJvb3RbaV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBmbjtcblx0fVxuXG5cdGV4cG9ydHMuQkVUQURJU1QgPSBzdGF0aXN0aWNhbC5CRVRBLkRJU1Q7XG5cdGV4cG9ydHMuQkVUQUlOViA9IHN0YXRpc3RpY2FsLkJFVEEuSU5WO1xuXHRleHBvcnRzLkJJTk9NRElTVCA9IHN0YXRpc3RpY2FsLkJJTk9NLkRJU1Q7XG5cdGV4cG9ydHMuQ0VJTElORyA9IGV4cG9ydHMuSVNPQ0VJTElORyA9IHNldChtYXRoVHJpZy5DRUlMSU5HLk1BVEgsIG1hdGhUcmlnLkNFSUxJTkcpO1xuXHRleHBvcnRzLkNFSUxJTkdNQVRIID0gbWF0aFRyaWcuQ0VJTElORy5NQVRIO1xuXHRleHBvcnRzLkNFSUxJTkdQUkVDSVNFID0gbWF0aFRyaWcuQ0VJTElORy5QUkVDSVNFO1xuXHRleHBvcnRzLkNISURJU1QgPSBzdGF0aXN0aWNhbC5DSElTUS5ESVNUO1xuXHRleHBvcnRzLkNISURJU1RSVCA9IHN0YXRpc3RpY2FsLkNISVNRLkRJU1QuUlQ7XG5cdGV4cG9ydHMuQ0hJSU5WID0gc3RhdGlzdGljYWwuQ0hJU1EuSU5WO1xuXHRleHBvcnRzLkNISUlOVlJUID0gc3RhdGlzdGljYWwuQ0hJU1EuSU5WLlJUO1xuXHRleHBvcnRzLkNISVRFU1QgPSBzdGF0aXN0aWNhbC5DSElTUS5URVNUO1xuXHRleHBvcnRzLkNPTkZJREVOQ0UgPSBzZXQoc3RhdGlzdGljYWwuQ09ORklERU5DRS5OT1JNLCBzdGF0aXN0aWNhbC5DT05GSURFTkNFKTtcblx0ZXhwb3J0cy5DT1ZBUiA9IHN0YXRpc3RpY2FsLkNPVkFSSUFOQ0UuUDtcblx0ZXhwb3J0cy5DT1ZBUklBTkNFUCA9IHN0YXRpc3RpY2FsLkNPVkFSSUFOQ0UuUDtcblx0ZXhwb3J0cy5DT1ZBUklBTkNFUyA9IHN0YXRpc3RpY2FsLkNPVkFSSUFOQ0UuUztcblx0ZXhwb3J0cy5DUklUQklOT00gPSBzdGF0aXN0aWNhbC5CSU5PTS5JTlY7XG5cdGV4cG9ydHMuRVhQT05ESVNUID0gc3RhdGlzdGljYWwuRVhQT04uRElTVDtcblx0ZXhwb3J0cy5FUkZDUFJFQ0lTRSA9IGVuZ2luZWVyaW5nLkVSRkMuUFJFQ0lTRTtcblx0ZXhwb3J0cy5FUkZQUkVDSVNFID0gZW5naW5lZXJpbmcuRVJGLlBSRUNJU0U7XG5cdGV4cG9ydHMuRkRJU1QgPSBzdGF0aXN0aWNhbC5GLkRJU1Q7XG5cdGV4cG9ydHMuRkRJU1RSVCA9IHN0YXRpc3RpY2FsLkYuRElTVC5SVDtcblx0ZXhwb3J0cy5GSU5WUlQgPSBzdGF0aXN0aWNhbC5GLklOVi5SVDtcblx0ZXhwb3J0cy5GSU5WID0gc3RhdGlzdGljYWwuRi5JTlY7XG5cdGV4cG9ydHMuRkxPT1IgPSBzZXQobWF0aFRyaWcuRkxPT1IuTUFUSCwgbWF0aFRyaWcuRkxPT1IpO1xuXHRleHBvcnRzLkZMT09STUFUSCA9IG1hdGhUcmlnLkZMT09SLk1BVEg7XG5cdGV4cG9ydHMuRkxPT1JQUkVDSVNFID0gbWF0aFRyaWcuRkxPT1IuUFJFQ0lTRTtcblx0ZXhwb3J0cy5GVEVTVCA9IHN0YXRpc3RpY2FsLkYuVEVTVDtcblx0ZXhwb3J0cy5HQU1NQURJU1QgPSBzdGF0aXN0aWNhbC5HQU1NQS5ESVNUO1xuXHRleHBvcnRzLkdBTU1BSU5WID0gc3RhdGlzdGljYWwuR0FNTUEuSU5WO1xuXHRleHBvcnRzLkdBTU1BTE5QUkVDSVNFID0gc3RhdGlzdGljYWwuR0FNTUFMTi5QUkVDSVNFO1xuXHRleHBvcnRzLkhZUEdFT01ESVNUID0gc3RhdGlzdGljYWwuSFlQR0VPTS5ESVNUO1xuXHRleHBvcnRzLkxPR0lOViA9IHN0YXRpc3RpY2FsLkxPR05PUk0uSU5WO1xuXHRleHBvcnRzLkxPR05PUk1JTlYgPSBzdGF0aXN0aWNhbC5MT0dOT1JNLklOVjtcblx0ZXhwb3J0cy5MT0dOT1JNRElTVCA9IHN0YXRpc3RpY2FsLkxPR05PUk0uRElTVDtcblx0ZXhwb3J0cy5NT0RFID0gc2V0KHN0YXRpc3RpY2FsLk1PREUuU05HTCwgc3RhdGlzdGljYWwuTU9ERSk7XG5cdGV4cG9ydHMuTU9ERU1VTFQgPSBzdGF0aXN0aWNhbC5NT0RFLk1VTFQ7XG5cdGV4cG9ydHMuTU9ERVNOR0wgPSBzdGF0aXN0aWNhbC5NT0RFLlNOR0w7XG5cdGV4cG9ydHMuTkVHQklOT01ESVNUID0gc3RhdGlzdGljYWwuTkVHQklOT00uRElTVDtcblx0ZXhwb3J0cy5ORVRXT1JLREFZU0lOVEwgPSBkYXRlVGltZS5ORVRXT1JLREFZUy5JTlRMO1xuXHRleHBvcnRzLk5PUk1ESVNUID0gc3RhdGlzdGljYWwuTk9STS5ESVNUO1xuXHRleHBvcnRzLk5PUk1JTlYgPSBzdGF0aXN0aWNhbC5OT1JNLklOVjtcblx0ZXhwb3J0cy5OT1JNU0RJU1QgPSBzdGF0aXN0aWNhbC5OT1JNLlMuRElTVDtcblx0ZXhwb3J0cy5OT1JNU0lOViA9IHN0YXRpc3RpY2FsLk5PUk0uUy5JTlY7XG5cdGV4cG9ydHMuUEVSQ0VOVElMRSA9IHNldChzdGF0aXN0aWNhbC5QRVJDRU5USUxFLkVYQywgc3RhdGlzdGljYWwuUEVSQ0VOVElMRSk7XG5cdGV4cG9ydHMuUEVSQ0VOVElMRUVYQyA9IHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUuRVhDO1xuXHRleHBvcnRzLlBFUkNFTlRJTEVJTkMgPSBzdGF0aXN0aWNhbC5QRVJDRU5USUxFLklOQztcblx0ZXhwb3J0cy5QRVJDRU5UUkFOSyA9IHNldChzdGF0aXN0aWNhbC5QRVJDRU5UUkFOSy5JTkMsIHN0YXRpc3RpY2FsLlBFUkNFTlRSQU5LKTtcblx0ZXhwb3J0cy5QRVJDRU5UUkFOS0VYQyA9IHN0YXRpc3RpY2FsLlBFUkNFTlRSQU5LLkVYQztcblx0ZXhwb3J0cy5QRVJDRU5UUkFOS0lOQyA9IHN0YXRpc3RpY2FsLlBFUkNFTlRSQU5LLklOQztcblx0ZXhwb3J0cy5QT0lTU09OID0gc2V0KHN0YXRpc3RpY2FsLlBPSVNTT04uRElTVCwgc3RhdGlzdGljYWwuUE9JU1NPTik7XG5cdGV4cG9ydHMuUE9JU1NPTkRJU1QgPSBzdGF0aXN0aWNhbC5QT0lTU09OLkRJU1Q7XG5cdGV4cG9ydHMuUVVBUlRJTEUgPSBzZXQoc3RhdGlzdGljYWwuUVVBUlRJTEUuSU5DLCBzdGF0aXN0aWNhbC5RVUFSVElMRSk7XG5cdGV4cG9ydHMuUVVBUlRJTEVFWEMgPSBzdGF0aXN0aWNhbC5RVUFSVElMRS5FWEM7XG5cdGV4cG9ydHMuUVVBUlRJTEVJTkMgPSBzdGF0aXN0aWNhbC5RVUFSVElMRS5JTkM7XG5cdGV4cG9ydHMuUkFOSyA9IHNldChzdGF0aXN0aWNhbC5SQU5LLkVRLCBzdGF0aXN0aWNhbC5SQU5LKTtcblx0ZXhwb3J0cy5SQU5LQVZHID0gc3RhdGlzdGljYWwuUkFOSy5BVkc7XG5cdGV4cG9ydHMuUkFOS0VRID0gc3RhdGlzdGljYWwuUkFOSy5FUTtcblx0ZXhwb3J0cy5TS0VXUCA9IHN0YXRpc3RpY2FsLlNLRVcuUDtcblx0ZXhwb3J0cy5TVERFViA9IHNldChzdGF0aXN0aWNhbC5TVERFVi5TLCBzdGF0aXN0aWNhbC5TVERFVik7XG5cdGV4cG9ydHMuU1RERVZQID0gc3RhdGlzdGljYWwuU1RERVYuUDtcblx0ZXhwb3J0cy5TVERFVlMgPSBzdGF0aXN0aWNhbC5TVERFVi5TO1xuXHRleHBvcnRzLlRESVNUID0gc3RhdGlzdGljYWwuVC5ESVNUO1xuXHRleHBvcnRzLlRESVNUUlQgPSBzdGF0aXN0aWNhbC5ULkRJU1QuUlQ7XG5cdGV4cG9ydHMuVElOViA9IHN0YXRpc3RpY2FsLlQuSU5WO1xuXHRleHBvcnRzLlRURVNUID0gc3RhdGlzdGljYWwuVC5URVNUO1xuXHRleHBvcnRzLlZBUiA9IHNldChzdGF0aXN0aWNhbC5WQVIuUywgc3RhdGlzdGljYWwuVkFSKTtcblx0ZXhwb3J0cy5WQVJQID0gc3RhdGlzdGljYWwuVkFSLlA7XG5cdGV4cG9ydHMuVkFSUyA9IHN0YXRpc3RpY2FsLlZBUi5TO1xuXHRleHBvcnRzLldFSUJVTEwgPSBzZXQoc3RhdGlzdGljYWwuV0VJQlVMTC5ESVNULCBzdGF0aXN0aWNhbC5XRUlCVUxMKTtcblx0ZXhwb3J0cy5XRUlCVUxMRElTVCA9IHN0YXRpc3RpY2FsLldFSUJVTEwuRElTVDtcblx0ZXhwb3J0cy5XT1JLREFZSU5UTCA9IGRhdGVUaW1lLldPUktEQVkuSU5UTDtcblx0ZXhwb3J0cy5aVEVTVCA9IHN0YXRpc3RpY2FsLlouVEVTVDtcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIG51bWVyaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgc3RhdGlzdGljYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgaW5mb3JtYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHRleHBvcnRzLkFCUyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hYnModXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5BQ09TID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFjb3MobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkFDT1NIID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIgKyBNYXRoLnNxcnQobnVtYmVyICogbnVtYmVyIC0gMSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQUNPVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hdGFuKDEgLyBudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQUNPVEggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKChudW1iZXIgKyAxKSAvIChudW1iZXIgLSAxKSk7XG5cdH07XG5cblx0Ly9UT0RPOiB1c2Ugb3B0aW9uc1xuXHRleHBvcnRzLkFHR1JFR0FURSA9IGZ1bmN0aW9uKGZ1bmN0aW9uX251bSwgb3B0aW9ucywgcmVmMSwgcmVmMikge1xuXHQgIGZ1bmN0aW9uX251bSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1bmN0aW9uX251bSk7XG5cdCAgb3B0aW9ucyA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1bmN0aW9uX251bSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZnVuY3Rpb25fbnVtLCBvcHRpb25zKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBzd2l0Y2ggKGZ1bmN0aW9uX251bSkge1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQVZFUkFHRShyZWYxKTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkNPVU5UKHJlZjEpO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlRBKHJlZjEpO1xuXHQgICAgY2FzZSA0OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUFYKHJlZjEpO1xuXHQgICAgY2FzZSA1OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUlOKHJlZjEpO1xuXHQgICAgY2FzZSA2OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QUk9EVUNUKHJlZjEpO1xuXHQgICAgY2FzZSA3OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUyhyZWYxKTtcblx0ICAgIGNhc2UgODpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNUREVWLlAocmVmMSk7XG5cdCAgICBjYXNlIDk6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlNVTShyZWYxKTtcblx0ICAgIGNhc2UgMTA6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUyhyZWYxKTtcblx0ICAgIGNhc2UgMTE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUChyZWYxKTtcblx0ICAgIGNhc2UgMTI6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NRURJQU4ocmVmMSk7XG5cdCAgICBjYXNlIDEzOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTU9ERS5TTkdMKHJlZjEpO1xuXHQgICAgY2FzZSAxNDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkxBUkdFKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxNTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNNQUxMKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxNjpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUuSU5DKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxNzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlFVQVJUSUxFLklOQyhyZWYxLCByZWYyKTtcblx0ICAgIGNhc2UgMTg6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5QRVJDRU5USUxFLkVYQyhyZWYxLCByZWYyKTtcblx0ICAgIGNhc2UgMTk6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5RVUFSVElMRS5FWEMocmVmMSwgcmVmMik7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQVJBQklDID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIC8vIENyZWRpdHM6IFJhZmE/IEt1a2F3c2tpXG5cdCAgaWYgKCEvXk0qKD86RD9DezAsM318Q1tNRF0pKD86TD9YezAsM318WFtDTF0pKD86Vj9JezAsM318SVtYVl0pJC8udGVzdCh0ZXh0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgciA9IDA7XG5cdCAgdGV4dC5yZXBsYWNlKC9bTURMVl18Q1tNRF0/fFhbQ0xdP3xJW1hWXT8vZywgZnVuY3Rpb24oaSkge1xuXHQgICAgciArPSB7XG5cdCAgICAgIE06IDEwMDAsXG5cdCAgICAgIENNOiA5MDAsXG5cdCAgICAgIEQ6IDUwMCxcblx0ICAgICAgQ0Q6IDQwMCxcblx0ICAgICAgQzogMTAwLFxuXHQgICAgICBYQzogOTAsXG5cdCAgICAgIEw6IDUwLFxuXHQgICAgICBYTDogNDAsXG5cdCAgICAgIFg6IDEwLFxuXHQgICAgICBJWDogOSxcblx0ICAgICAgVjogNSxcblx0ICAgICAgSVY6IDQsXG5cdCAgICAgIEk6IDFcblx0ICAgIH1baV07XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0ZXhwb3J0cy5BU0lOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFzaW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkFTSU5IID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIgKyBNYXRoLnNxcnQobnVtYmVyICogbnVtYmVyICsgMSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQVRBTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hdGFuKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5BVEFOMiA9IGZ1bmN0aW9uKG51bWJlcl94LCBudW1iZXJfeSkge1xuXHQgIG51bWJlcl94ID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX3gpO1xuXHQgIG51bWJlcl95ID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX3kpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcl94LCBudW1iZXJfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYXRhbjIobnVtYmVyX3gsIG51bWJlcl95KTtcblx0fTtcblxuXHRleHBvcnRzLkFUQU5IID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZygoMSArIG51bWJlcikgLyAoMSAtIG51bWJlcikpIC8gMjtcblx0fTtcblxuXHRleHBvcnRzLkJBU0UgPSBmdW5jdGlvbihudW1iZXIsIHJhZGl4LCBtaW5fbGVuZ3RoKSB7XG5cdCAgbWluX2xlbmd0aCA9IG1pbl9sZW5ndGggfHwgMDtcblxuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgcmFkaXggPSB1dGlscy5wYXJzZU51bWJlcihyYWRpeCk7XG5cdCAgbWluX2xlbmd0aCA9IHV0aWxzLnBhcnNlTnVtYmVyKG1pbl9sZW5ndGgpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgcmFkaXgsIG1pbl9sZW5ndGgpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIG1pbl9sZW5ndGggPSAobWluX2xlbmd0aCA9PT0gdW5kZWZpbmVkKSA/IDAgOiBtaW5fbGVuZ3RoO1xuXHQgIHZhciByZXN1bHQgPSBudW1iZXIudG9TdHJpbmcocmFkaXgpO1xuXHQgIHJldHVybiBuZXcgQXJyYXkoTWF0aC5tYXgobWluX2xlbmd0aCArIDEgLSByZXN1bHQubGVuZ3RoLCAwKSkuam9pbignMCcpICsgcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0VJTElORyA9IGZ1bmN0aW9uKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSB7XG5cdCAgc2lnbmlmaWNhbmNlID0gKHNpZ25pZmljYW5jZSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBNYXRoLmFicyhzaWduaWZpY2FuY2UpO1xuXHQgIG1vZGUgPSBtb2RlIHx8IDA7XG5cblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgbW9kZSA9IHV0aWxzLnBhcnNlTnVtYmVyKG1vZGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoc2lnbmlmaWNhbmNlID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cdCAgdmFyIHByZWNpc2lvbiA9IC1NYXRoLmZsb29yKE1hdGgubG9nKHNpZ25pZmljYW5jZSkgLyBNYXRoLmxvZygxMCkpO1xuXHQgIGlmIChudW1iZXIgPj0gMCkge1xuXHQgICAgcmV0dXJuIGV4cG9ydHMuUk9VTkQoTWF0aC5jZWlsKG51bWJlciAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmIChtb2RlID09PSAwKSB7XG5cdCAgICAgIHJldHVybiAtZXhwb3J0cy5ST1VORChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5DRUlMSU5HLk1BVEggPSBleHBvcnRzLkNFSUxJTkc7XG5cblx0ZXhwb3J0cy5DRUlMSU5HLlBSRUNJU0UgPSBleHBvcnRzLkNFSUxJTkc7XG5cblx0ZXhwb3J0cy5DT01CSU4gPSBmdW5jdGlvbihudW1iZXIsIG51bWJlcl9jaG9zZW4pIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIG51bWJlcl9jaG9zZW4gPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXJfY2hvc2VuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIG51bWJlcl9jaG9zZW4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBleHBvcnRzLkZBQ1QobnVtYmVyKSAvIChleHBvcnRzLkZBQ1QobnVtYmVyX2Nob3NlbikgKiBleHBvcnRzLkZBQ1QobnVtYmVyIC0gbnVtYmVyX2Nob3NlbikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09NQklOQSA9IGZ1bmN0aW9uKG51bWJlciwgbnVtYmVyX2Nob3Nlbikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgbnVtYmVyX2Nob3NlbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl9jaG9zZW4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgbnVtYmVyX2Nob3NlbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChudW1iZXIgPT09IDAgJiYgbnVtYmVyX2Nob3NlbiA9PT0gMCkgPyAxIDogZXhwb3J0cy5DT01CSU4obnVtYmVyICsgbnVtYmVyX2Nob3NlbiAtIDEsIG51bWJlciAtIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09TID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmNvcyhudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09TSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gKE1hdGguZXhwKG51bWJlcikgKyBNYXRoLmV4cCgtbnVtYmVyKSkgLyAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09UID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAxIC8gTWF0aC50YW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkNPVEggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIGUyID0gTWF0aC5leHAoMiAqIG51bWJlcik7XG5cdCAgcmV0dXJuIChlMiArIDEpIC8gKGUyIC0gMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5DU0MgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDEgLyBNYXRoLnNpbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ1NDSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gMiAvIChNYXRoLmV4cChudW1iZXIpIC0gTWF0aC5leHAoLW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREVDSU1BTCA9IGZ1bmN0aW9uKG51bWJlciwgcmFkaXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblxuXHQgIHJldHVybiBwYXJzZUludChudW1iZXIsIHJhZGl4KTtcblx0fTtcblxuXHRleHBvcnRzLkRFR1JFRVMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWJlciAqIDE4MCAvIE1hdGguUEk7XG5cdH07XG5cblx0ZXhwb3J0cy5FVkVOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBleHBvcnRzLkNFSUxJTkcobnVtYmVyLCAtMiwgLTEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVhQID0gTWF0aC5leHA7XG5cblx0dmFyIE1FTU9JWkVEX0ZBQ1QgPSBbXTtcblx0ZXhwb3J0cy5GQUNUID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHZhciBuID0gTWF0aC5mbG9vcihudW1iZXIpO1xuXHQgIGlmIChuID09PSAwIHx8IG4gPT09IDEpIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH0gZWxzZSBpZiAoTUVNT0laRURfRkFDVFtuXSA+IDApIHtcblx0ICAgIHJldHVybiBNRU1PSVpFRF9GQUNUW25dO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBNRU1PSVpFRF9GQUNUW25dID0gZXhwb3J0cy5GQUNUKG4gLSAxKSAqIG47XG5cdCAgICByZXR1cm4gTUVNT0laRURfRkFDVFtuXTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5GQUNURE9VQkxFID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHZhciBuID0gTWF0aC5mbG9vcihudW1iZXIpO1xuXHQgIGlmIChuIDw9IDApIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gbiAqIGV4cG9ydHMuRkFDVERPVUJMRShuIC0gMik7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuRkxPT1IgPSBmdW5jdGlvbihudW1iZXIsIHNpZ25pZmljYW5jZSkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgc2lnbmlmaWNhbmNlID0gdXRpbHMucGFyc2VOdW1iZXIoc2lnbmlmaWNhbmNlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHNpZ25pZmljYW5jZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHNpZ25pZmljYW5jZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgaWYgKCEobnVtYmVyID4gMCAmJiBzaWduaWZpY2FuY2UgPiAwKSAmJiAhKG51bWJlciA8IDAgJiYgc2lnbmlmaWNhbmNlIDwgMCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgc2lnbmlmaWNhbmNlID0gTWF0aC5hYnMoc2lnbmlmaWNhbmNlKTtcblx0ICB2YXIgcHJlY2lzaW9uID0gLU1hdGguZmxvb3IoTWF0aC5sb2coc2lnbmlmaWNhbmNlKSAvIE1hdGgubG9nKDEwKSk7XG5cdCAgaWYgKG51bWJlciA+PSAwKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5ST1VORChNYXRoLmZsb29yKG51bWJlciAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiAtZXhwb3J0cy5ST1VORChNYXRoLmNlaWwoTWF0aC5hYnMobnVtYmVyKSAvIHNpZ25pZmljYW5jZSksIHByZWNpc2lvbik7XG5cdCAgfVxuXHR9O1xuXG5cdC8vVE9ETzogVmVyaWZ5XG5cdGV4cG9ydHMuRkxPT1IuTUFUSCA9IGZ1bmN0aW9uKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSB7XG5cdCAgc2lnbmlmaWNhbmNlID0gKHNpZ25pZmljYW5jZSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBzaWduaWZpY2FuY2U7XG5cdCAgbW9kZSA9IChtb2RlID09PSB1bmRlZmluZWQpID8gMCA6IG1vZGU7XG5cblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgbW9kZSA9IHV0aWxzLnBhcnNlTnVtYmVyKG1vZGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoc2lnbmlmaWNhbmNlID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICBzaWduaWZpY2FuY2UgPSBzaWduaWZpY2FuY2UgPyBNYXRoLmFicyhzaWduaWZpY2FuY2UpIDogMTtcblx0ICB2YXIgcHJlY2lzaW9uID0gLU1hdGguZmxvb3IoTWF0aC5sb2coc2lnbmlmaWNhbmNlKSAvIE1hdGgubG9nKDEwKSk7XG5cdCAgaWYgKG51bWJlciA+PSAwKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5ST1VORChNYXRoLmZsb29yKG51bWJlciAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgfSBlbHNlIGlmIChtb2RlID09PSAwIHx8IG1vZGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICB9XG5cdCAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdH07XG5cblx0Ly8gRGVwcmVjYXRlZFxuXHRleHBvcnRzLkZMT09SLlBSRUNJU0UgPSBleHBvcnRzLkZMT09SLk1BVEg7XG5cblx0Ly8gYWRhcHRlZCBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvR3JlYXRlc3RfY29tbW9uX2Rpdmlzb3IjSmF2YVNjcmlwdFxuXHRleHBvcnRzLkdDRCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgcjAgPSByYW5nZVswXTtcblx0ICB2YXIgeCA9IHIwIDwgMCA/IC1yMCA6IHIwO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB2YXIgcmkgPSByYW5nZVtpXTtcblx0ICAgIHZhciB5ID0gcmkgPCAwID8gLXJpIDogcmk7XG5cdCAgICB3aGlsZSAoeCAmJiB5KSB7XG5cdCAgICAgIGlmICh4ID4geSkge1xuXHQgICAgICAgIHggJT0geTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB5ICU9IHg7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHggKz0geTtcblx0ICB9XG5cdCAgcmV0dXJuIHg7XG5cdH07XG5cblxuXHRleHBvcnRzLklOVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuXHR9O1xuXG5cdC8vVE9ETzogdmVyaWZ5XG5cdGV4cG9ydHMuSVNPID0ge1xuXHQgIENFSUxJTkc6IGV4cG9ydHMuQ0VJTElOR1xuXHR9O1xuXG5cdGV4cG9ydHMuTENNID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gQ3JlZGl0czogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhXG5cdCAgdmFyIG8gPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKG8gaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG87XG5cdCAgfVxuXHQgIGZvciAodmFyIGksIGosIG4sIGQsIHIgPSAxO1xuXHQgICAgKG4gPSBvLnBvcCgpKSAhPT0gdW5kZWZpbmVkOykge1xuXHQgICAgd2hpbGUgKG4gPiAxKSB7XG5cdCAgICAgIGlmIChuICUgMikge1xuXHQgICAgICAgIGZvciAoaSA9IDMsIGogPSBNYXRoLmZsb29yKE1hdGguc3FydChuKSk7IGkgPD0gaiAmJiBuICUgaTsgaSArPSAyKSB7XG5cdCAgICAgICAgICAvL2VtcHR5XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGQgPSAoaSA8PSBqKSA/IGkgOiBuO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGQgPSAyO1xuXHQgICAgICB9XG5cdCAgICAgIGZvciAobiAvPSBkLCByICo9IGQsIGkgPSBvLmxlbmd0aDsgaTtcblx0ICAgICAgICAob1stLWldICUgZCkgPT09IDAgJiYgKG9baV0gLz0gZCkgPT09IDEgJiYgby5zcGxpY2UoaSwgMSkpIHtcblx0ICAgICAgICAvL2VtcHR5XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0ZXhwb3J0cy5MTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2cobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkxPRyA9IGZ1bmN0aW9uKG51bWJlciwgYmFzZSkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgYmFzZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGJhc2UpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgYmFzZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgYmFzZSA9IChiYXNlID09PSB1bmRlZmluZWQpID8gMTAgOiBiYXNlO1xuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIpIC8gTWF0aC5sb2coYmFzZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5MT0cxMCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2cobnVtYmVyKSAvIE1hdGgubG9nKDEwKTtcblx0fTtcblxuXHRleHBvcnRzLk1ERVRFUk0gPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBtYXRyaXggPSB1dGlscy5wYXJzZU1hdHJpeChtYXRyaXgpO1xuXHQgIGlmIChtYXRyaXggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG1hdHJpeDtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyaWMuZGV0KG1hdHJpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU5WRVJTRSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIG1hdHJpeCA9IHV0aWxzLnBhcnNlTWF0cml4KG1hdHJpeCk7XG5cdCAgaWYgKG1hdHJpeCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbWF0cml4O1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJpYy5pbnYobWF0cml4KTtcblx0fTtcblxuXHRleHBvcnRzLk1NVUxUID0gZnVuY3Rpb24obWF0cml4MSwgbWF0cml4Mikge1xuXHQgIG1hdHJpeDEgPSB1dGlscy5wYXJzZU1hdHJpeChtYXRyaXgxKTtcblx0ICBtYXRyaXgyID0gdXRpbHMucGFyc2VNYXRyaXgobWF0cml4Mik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobWF0cml4MSwgbWF0cml4MikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyaWMuZG90KG1hdHJpeDEsIG1hdHJpeDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTU9EID0gZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcblx0ICBkaXZpZGVuZCA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpdmlkZW5kKTtcblx0ICBkaXZpc29yID0gdXRpbHMucGFyc2VOdW1iZXIoZGl2aXNvcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGl2aWRlbmQsIGRpdmlzb3IpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChkaXZpc29yID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cdCAgdmFyIG1vZHVsdXMgPSBNYXRoLmFicyhkaXZpZGVuZCAlIGRpdmlzb3IpO1xuXHQgIHJldHVybiAoZGl2aXNvciA+IDApID8gbW9kdWx1cyA6IC1tb2R1bHVzO1xuXHR9O1xuXG5cdCAgZXhwb3J0cy5NUk9VTkQgPSBmdW5jdGlvbihudW1iZXIsIG11bHRpcGxlKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBtdWx0aXBsZSA9IHV0aWxzLnBhcnNlTnVtYmVyKG11bHRpcGxlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIG11bHRpcGxlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAobnVtYmVyICogbXVsdGlwbGUgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAvIG11bHRpcGxlKSAqIG11bHRpcGxlO1xuXHR9O1xuXG5cdGV4cG9ydHMuTVVMVElOT01JQUwgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAoYXJncyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9XG5cdCAgdmFyIHN1bSA9IDA7XG5cdCAgdmFyIGRpdmlzb3IgPSAxO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgc3VtICs9IGFyZ3NbaV07XG5cdCAgICBkaXZpc29yICo9IGV4cG9ydHMuRkFDVChhcmdzW2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIGV4cG9ydHMuRkFDVChzdW0pIC8gZGl2aXNvcjtcblx0fTtcblxuXHRleHBvcnRzLk1VTklUID0gZnVuY3Rpb24oZGltZW5zaW9uKSB7XG5cdCAgZGltZW5zaW9uID0gdXRpbHMucGFyc2VOdW1iZXIoZGltZW5zaW9uKTtcblx0ICBpZiAoZGltZW5zaW9uIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBkaW1lbnNpb247XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmljLmlkZW50aXR5KGRpbWVuc2lvbik7XG5cdH07XG5cblx0ZXhwb3J0cy5PREQgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIHRlbXAgPSBNYXRoLmNlaWwoTWF0aC5hYnMobnVtYmVyKSk7XG5cdCAgdGVtcCA9ICh0ZW1wICYgMSkgPyB0ZW1wIDogdGVtcCArIDE7XG5cdCAgcmV0dXJuIChudW1iZXIgPiAwKSA/IHRlbXAgOiAtdGVtcDtcblx0fTtcblxuXHRleHBvcnRzLlBJID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIE1hdGguUEk7XG5cdH07XG5cblx0ZXhwb3J0cy5QT1dFUiA9IGZ1bmN0aW9uKG51bWJlciwgcG93ZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHBvd2VyID0gdXRpbHMucGFyc2VOdW1iZXIocG93ZXIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgcG93ZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSBNYXRoLnBvdyhudW1iZXIsIHBvd2VyKTtcblx0ICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuUFJPRFVDVCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChhcmdzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBhcmdzO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCAqPSBhcmdzW2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuUVVPVElFTlQgPSBmdW5jdGlvbihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG5cdCAgbnVtZXJhdG9yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtZXJhdG9yKTtcblx0ICBkZW5vbWluYXRvciA9IHV0aWxzLnBhcnNlTnVtYmVyKGRlbm9taW5hdG9yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gcGFyc2VJbnQobnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIDEwKTtcblx0fTtcblxuXHRleHBvcnRzLlJBRElBTlMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWJlciAqIE1hdGguUEkgLyAxODA7XG5cdH07XG5cblx0ZXhwb3J0cy5SQU5EID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SQU5EQkVUV0VFTiA9IGZ1bmN0aW9uKGJvdHRvbSwgdG9wKSB7XG5cdCAgYm90dG9tID0gdXRpbHMucGFyc2VOdW1iZXIoYm90dG9tKTtcblx0ICB0b3AgPSB1dGlscy5wYXJzZU51bWJlcih0b3ApO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGJvdHRvbSwgdG9wKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICAvLyBDcmVhdGl2ZSBDb21tb25zIEF0dHJpYnV0aW9uIDMuMCBMaWNlbnNlXG5cdCAgLy8gQ29weXJpZ2h0IChjKSAyMDEyIGVxY29kZVxuXHQgIHJldHVybiBib3R0b20gKyBNYXRoLmNlaWwoKHRvcCAtIGJvdHRvbSArIDEpICogTWF0aC5yYW5kb20oKSkgLSAxO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5ST01BTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICAvLyBUaGUgTUlUIExpY2Vuc2Vcblx0ICAvLyBDb3B5cmlnaHQgKGMpIDIwMDggU3RldmVuIExldml0aGFuXG5cdCAgdmFyIGRpZ2l0cyA9IFN0cmluZyhudW1iZXIpLnNwbGl0KCcnKTtcblx0ICB2YXIga2V5ID0gWycnLCAnQycsICdDQycsICdDQ0MnLCAnQ0QnLCAnRCcsICdEQycsICdEQ0MnLCAnRENDQycsICdDTScsICcnLCAnWCcsICdYWCcsICdYWFgnLCAnWEwnLCAnTCcsICdMWCcsICdMWFgnLCAnTFhYWCcsICdYQycsICcnLCAnSScsICdJSScsICdJSUknLCAnSVYnLCAnVicsICdWSScsICdWSUknLCAnVklJSScsICdJWCddO1xuXHQgIHZhciByb21hbiA9ICcnO1xuXHQgIHZhciBpID0gMztcblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICByb21hbiA9IChrZXlbK2RpZ2l0cy5wb3AoKSArIChpICogMTApXSB8fCAnJykgKyByb21hbjtcblx0ICB9XG5cdCAgcmV0dXJuIG5ldyBBcnJheSgrZGlnaXRzLmpvaW4oJycpICsgMSkuam9pbignTScpICsgcm9tYW47XG5cdH07XG5cblx0ZXhwb3J0cy5ST1VORCA9IGZ1bmN0aW9uKG51bWJlciwgZGlnaXRzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkaWdpdHMgPSB1dGlscy5wYXJzZU51bWJlcihkaWdpdHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGlnaXRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkgLyBNYXRoLnBvdygxMCwgZGlnaXRzKTtcblx0fTtcblxuXHRleHBvcnRzLlJPVU5ERE9XTiA9IGZ1bmN0aW9uKG51bWJlciwgZGlnaXRzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkaWdpdHMgPSB1dGlscy5wYXJzZU51bWJlcihkaWdpdHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGlnaXRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgc2lnbiA9IChudW1iZXIgPiAwKSA/IDEgOiAtMTtcblx0ICByZXR1cm4gc2lnbiAqIChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkpIC8gTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ST1VORFVQID0gZnVuY3Rpb24obnVtYmVyLCBkaWdpdHMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGRpZ2l0cyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpZ2l0cyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBkaWdpdHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBzaWduID0gKG51bWJlciA+IDApID8gMSA6IC0xO1xuXHQgIHJldHVybiBzaWduICogKE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpICogTWF0aC5wb3coMTAsIGRpZ2l0cykpKSAvIE1hdGgucG93KDEwLCBkaWdpdHMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VDID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAxIC8gTWF0aC5jb3MobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLlNFQ0ggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDIgLyAoTWF0aC5leHAobnVtYmVyKSArIE1hdGguZXhwKC1udW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLlNFUklFU1NVTSA9IGZ1bmN0aW9uKHgsIG4sIG0sIGNvZWZmaWNpZW50cykge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgbSA9IHV0aWxzLnBhcnNlTnVtYmVyKG0pO1xuXHQgIGNvZWZmaWNpZW50cyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoY29lZmZpY2llbnRzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuLCBtLCBjb2VmZmljaWVudHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSBjb2VmZmljaWVudHNbMF0gKiBNYXRoLnBvdyh4LCBuKTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGNvZWZmaWNpZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IGNvZWZmaWNpZW50c1tpXSAqIE1hdGgucG93KHgsIG4gKyBpICogbSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TSUdOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfSBlbHNlIGlmIChudW1iZXIgPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5TSU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguc2luKG51bWJlcik7XG5cdH07XG5cblx0ICBleHBvcnRzLlNJTkggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoTWF0aC5leHAobnVtYmVyKSAtIE1hdGguZXhwKC1udW1iZXIpKSAvIDI7XG5cdCAgfTtcblxuXHQgIGV4cG9ydHMuU1FSVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgICAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICAgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgfVxuXHQgICAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBNYXRoLnNxcnQobnVtYmVyKTtcblx0ICB9O1xuXG5cdCAgZXhwb3J0cy5TUVJUUEkgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBNYXRoLnNxcnQobnVtYmVyICogTWF0aC5QSSk7XG5cdCAgfTtcblxuXHRleHBvcnRzLlNVQlRPVEFMID0gZnVuY3Rpb24oZnVuY3Rpb25fY29kZSwgcmVmMSkge1xuXHQgIGZ1bmN0aW9uX2NvZGUgPSB1dGlscy5wYXJzZU51bWJlcihmdW5jdGlvbl9jb2RlKTtcblx0ICBpZiAoZnVuY3Rpb25fY29kZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb25fY29kZTtcblx0ICB9XG5cdCAgc3dpdGNoIChmdW5jdGlvbl9jb2RlKSB7XG5cdCAgICBjYXNlIDE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5BVkVSQUdFKHJlZjEpO1xuXHQgICAgY2FzZSAyOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlQocmVmMSk7XG5cdCAgICBjYXNlIDM6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVEEocmVmMSk7XG5cdCAgICBjYXNlIDQ6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NQVgocmVmMSk7XG5cdCAgICBjYXNlIDU6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NSU4ocmVmMSk7XG5cdCAgICBjYXNlIDY6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBST0RVQ1QocmVmMSk7XG5cdCAgICBjYXNlIDc6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5TKHJlZjEpO1xuXHQgICAgY2FzZSA4OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUChyZWYxKTtcblx0ICAgIGNhc2UgOTpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuU1VNKHJlZjEpO1xuXHQgICAgY2FzZSAxMDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5TKHJlZjEpO1xuXHQgICAgY2FzZSAxMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5QKHJlZjEpO1xuXHQgICAgICAvLyBubyBoaWRkZW4gdmFsdWVzIGZvciB1c1xuXHQgICAgY2FzZSAxMDE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5BVkVSQUdFKHJlZjEpO1xuXHQgICAgY2FzZSAxMDI6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVChyZWYxKTtcblx0ICAgIGNhc2UgMTAzOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlRBKHJlZjEpO1xuXHQgICAgY2FzZSAxMDQ6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NQVgocmVmMSk7XG5cdCAgICBjYXNlIDEwNTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1JTihyZWYxKTtcblx0ICAgIGNhc2UgMTA2OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QUk9EVUNUKHJlZjEpO1xuXHQgICAgY2FzZSAxMDc6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5TKHJlZjEpO1xuXHQgICAgY2FzZSAxMDg6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5QKHJlZjEpO1xuXHQgICAgY2FzZSAxMDk6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlNVTShyZWYxKTtcblx0ICAgIGNhc2UgMTEwOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuVkFSLlMocmVmMSk7XG5cdCAgICBjYXNlIDExMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5QKHJlZjEpO1xuXG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQUREID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSArIG51bTI7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU5VUyA9IGZ1bmN0aW9uIChudW0xLCBudW0yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBudW0xID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMSk7XG5cdCAgbnVtMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bTEsIG51bTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bTEgLSBudW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuRElWSURFID0gZnVuY3Rpb24gKGRpdmlkZW5kLCBkaXZpc29yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBkaXZpZGVuZCA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpdmlkZW5kKTtcblx0ICBkaXZpc29yID0gdXRpbHMucGFyc2VOdW1iZXIoZGl2aXNvcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGl2aWRlbmQsIGRpdmlzb3IpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKGRpdmlzb3IgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblxuXHQgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG5cdH07XG5cblx0ZXhwb3J0cy5NVUxUSVBMWSA9IGZ1bmN0aW9uIChmYWN0b3IxLCBmYWN0b3IyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBmYWN0b3IxID0gdXRpbHMucGFyc2VOdW1iZXIoZmFjdG9yMSk7XG5cdCAgZmFjdG9yMiA9IHV0aWxzLnBhcnNlTnVtYmVyKGZhY3RvcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGZhY3RvcjEsIGZhY3RvcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZhY3RvcjEgKiBmYWN0b3IyO1xuXHR9O1xuXG5cdGV4cG9ydHMuR1RFID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSA+PSBudW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuTFQgPSBmdW5jdGlvbiAobnVtMSwgbnVtMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgbnVtMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTEpO1xuXHQgIG51bTIgPSB1dGlscy5wYXJzZU51bWJlcihudW0yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW0xLCBudW0yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmVycm9yO1xuXHQgIH1cblxuXHQgIHJldHVybiBudW0xIDwgbnVtMjtcblx0fTtcblxuXG5cdGV4cG9ydHMuTFRFID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSA8PSBudW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVEgPSBmdW5jdGlvbiAodmFsdWUxLCB2YWx1ZTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcblx0fTtcblxuXHRleHBvcnRzLk5FID0gZnVuY3Rpb24gKHZhbHVlMSwgdmFsdWUyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsdWUxICE9PSB2YWx1ZTI7XG5cdH07XG5cblx0ZXhwb3J0cy5QT1cgPSBmdW5jdGlvbiAoYmFzZSwgZXhwb25lbnQpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGJhc2UgPSB1dGlscy5wYXJzZU51bWJlcihiYXNlKTtcblx0ICBleHBvbmVudCA9IHV0aWxzLnBhcnNlTnVtYmVyKGV4cG9uZW50KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihiYXNlLCBleHBvbmVudCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gZXhwb3J0cy5QT1dFUihiYXNlLCBleHBvbmVudCk7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU0gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgYXJnc0tleXMgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0tleXMubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciBlbHQgPSBhcmd1bWVudHNbYXJnc0tleXNbaV1dO1xuXHQgICAgaWYgKHR5cGVvZiBlbHQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJlc3VsdCArPSBlbHQ7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbHQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUZsb2F0KGVsdCk7XG5cdCAgICAgICFpc05hTihwYXJzZWQpICYmIChyZXN1bHQgKz0gcGFyc2VkKTtcblx0ICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbHQpKSB7XG5cdCAgICAgIHJlc3VsdCArPSBleHBvcnRzLlNVTS5hcHBseShudWxsLCBlbHQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNSUYgPSBmdW5jdGlvbihyYW5nZSwgY3JpdGVyaWEpIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSAoZXZhbChyYW5nZVtpXSArIGNyaXRlcmlhKSkgPyByYW5nZVtpXSA6IDA7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNSUZTID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5hcmdzVG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmdzLnNoaWZ0KCkpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgY3JpdGVyaWEgPSBhcmdzO1xuXG5cdCAgdmFyIG5fcmFuZ2VfZWxlbWVudHMgPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIG5fY3JpdGVyaWFzID0gY3JpdGVyaWEubGVuZ3RoO1xuXG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX3JhbmdlX2VsZW1lbnRzOyBpKyspIHtcblx0ICAgIHZhciBlbCA9IHJhbmdlW2ldO1xuXHQgICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuXHQgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuX2NyaXRlcmlhczsgYysrKSB7XG5cdCAgICAgIGNvbmRpdGlvbiArPSBlbCArIGNyaXRlcmlhW2NdO1xuXHQgICAgICBpZiAoYyAhPT0gbl9jcml0ZXJpYXMgLSAxKSB7XG5cdCAgICAgICAgY29uZGl0aW9uICs9ICcmJic7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChldmFsKGNvbmRpdGlvbikpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgIHJlc3VsdCArPSBlbDtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTVBST0RVQ1QgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAoIWFyZ3VtZW50cyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBhcnJheXMgPSBhcmd1bWVudHMubGVuZ3RoICsgMTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgcHJvZHVjdDtcblx0ICB2YXIgaztcblx0ICB2YXIgX2k7XG5cdCAgdmFyIF9pajtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c1swXS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKCEoYXJndW1lbnRzWzBdW2ldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICAgIHByb2R1Y3QgPSAxO1xuXHQgICAgICBmb3IgKGsgPSAxOyBrIDwgYXJyYXlzOyBrKyspIHtcblx0ICAgICAgICBfaSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFyZ3VtZW50c1trIC0gMV1baV0pO1xuXHQgICAgICAgIGlmIChfaSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICByZXR1cm4gX2k7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHByb2R1Y3QgKj0gX2k7XG5cdCAgICAgIH1cblx0ICAgICAgcmVzdWx0ICs9IHByb2R1Y3Q7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyZ3VtZW50c1swXVtpXS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgIHByb2R1Y3QgPSAxO1xuXHQgICAgICAgIGZvciAoayA9IDE7IGsgPCBhcnJheXM7IGsrKykge1xuXHQgICAgICAgICAgX2lqID0gdXRpbHMucGFyc2VOdW1iZXIoYXJndW1lbnRzW2sgLSAxXVtpXVtqXSk7XG5cdCAgICAgICAgICBpZiAoX2lqIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9pajtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHByb2R1Y3QgKj0gX2lqO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gcHJvZHVjdDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNU1EgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgbnVtYmVycyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAobnVtYmVycyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVycztcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IG51bWJlcnMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSAoaW5mb3JtYXRpb24uSVNOVU1CRVIobnVtYmVyc1tpXSkpID8gbnVtYmVyc1tpXSAqIG51bWJlcnNbaV0gOiAwO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNWDJNWTIgPSBmdW5jdGlvbihhcnJheV94LCBhcnJheV95KSB7XG5cdCAgYXJyYXlfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV94KSk7XG5cdCAgYXJyYXlfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV95KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXlfeCwgYXJyYXlfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheV94Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gYXJyYXlfeFtpXSAqIGFycmF5X3hbaV0gLSBhcnJheV95W2ldICogYXJyYXlfeVtpXTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTVgyUFkyID0gZnVuY3Rpb24oYXJyYXlfeCwgYXJyYXlfeSkge1xuXHQgIGFycmF5X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCkpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5X3gsIGFycmF5X3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGFycmF5X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCkpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSkpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlfeC5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IGFycmF5X3hbaV0gKiBhcnJheV94W2ldICsgYXJyYXlfeVtpXSAqIGFycmF5X3lbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1YTVkyID0gZnVuY3Rpb24oYXJyYXlfeCwgYXJyYXlfeSkge1xuXHQgIGFycmF5X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCkpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5X3gsIGFycmF5X3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGFycmF5X3ggPSB1dGlscy5mbGF0dGVuKGFycmF5X3gpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5mbGF0dGVuKGFycmF5X3kpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlfeC5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IE1hdGgucG93KGFycmF5X3hbaV0gLSBhcnJheV95W2ldLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlRBTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC50YW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLlRBTkggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIGUyID0gTWF0aC5leHAoMiAqIG51bWJlcik7XG5cdCAgcmV0dXJuIChlMiAtIDEpIC8gKGUyICsgMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5UUlVOQyA9IGZ1bmN0aW9uKG51bWJlciwgZGlnaXRzKSB7XG5cdCAgZGlnaXRzID0gKGRpZ2l0cyA9PT0gdW5kZWZpbmVkKSA/IDAgOiBkaWdpdHM7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkaWdpdHMgPSB1dGlscy5wYXJzZU51bWJlcihkaWdpdHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGlnaXRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgc2lnbiA9IChudW1iZXIgPiAwKSA/IDEgOiAtMTtcblx0ICByZXR1cm4gc2lnbiAqIChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkpIC8gTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXHRmdW5jdGlvbiBmbGF0dGVuU2hhbGxvdyhhcnJheSkge1xuXHQgIGlmICghYXJyYXkgfHwgIWFycmF5LnJlZHVjZSkgeyByZXR1cm4gYXJyYXk7IH1cblx0ICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHZhciBhSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG5cdCAgICB2YXIgYklzQXJyYXkgPSBBcnJheS5pc0FycmF5KGIpO1xuXHQgICAgaWYgKGFJc0FycmF5ICYmIGJJc0FycmF5ICkge1xuXHQgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG5cdCAgICB9XG5cdCAgICBpZiAoYUlzQXJyYXkpIHtcblx0ICAgICAgYS5wdXNoKGIpO1xuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH1cblx0ICAgIGlmIChiSXNBcnJheSkge1xuXHQgICAgICByZXR1cm4gW2FdLmNvbmNhdChiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBbYSwgYl07XG5cdCAgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0ZsYXQoYXJyYXkpIHtcblx0ICBpZiAoIWFycmF5KSB7IHJldHVybiBmYWxzZTsgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJlc3VsdCA9IGV4cG9ydHMuYXJnc1RvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0ICB3aGlsZSAoIWlzRmxhdChyZXN1bHQpKSB7XG5cdCAgICByZXN1bHQgPSBmbGF0dGVuU2hhbGxvdyhyZXN1bHQpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuYXJnc1RvQXJyYXkgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDApO1xuXHR9O1xuXG5cdGV4cG9ydHMubnVtYmVycyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBwb3NzaWJsZU51bWJlcnMgPSB0aGlzLmZsYXR0ZW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gcG9zc2libGVOdW1iZXJzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuXHQgICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ251bWJlcic7XG5cdCAgfSk7XG5cdH07XG5cblx0ZXhwb3J0cy5jbGVhbkZsb2F0ID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgdmFyIHBvd2VyID0gMWUxNDtcblx0ICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBwb3dlcikgLyBwb3dlcjtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlQm9vbCA9IGZ1bmN0aW9uKGJvb2wpIHtcblx0ICBpZiAodHlwZW9mIGJvb2wgPT09ICdib29sZWFuJykge1xuXHQgICAgcmV0dXJuIGJvb2w7XG5cdCAgfVxuXG5cdCAgaWYgKGJvb2wgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGJvb2w7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBib29sID09PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIGJvb2wgIT09IDA7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBib29sID09PSAnc3RyaW5nJykge1xuXHQgICAgdmFyIHVwID0gYm9vbC50b1VwcGVyQ2FzZSgpO1xuXHQgICAgaWYgKHVwID09PSAnVFJVRScpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh1cCA9PT0gJ0ZBTFNFJykge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKGJvb2wgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihib29sKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMucGFyc2VOdW1iZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQgfHwgc3RyaW5nID09PSAnJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoIWlzTmFOKHN0cmluZykpIHtcblx0ICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG5cdCAgfVxuXHQgIHJldHVybiBlcnJvci52YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlTnVtYmVyQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcblx0ICB2YXIgbGVuO1xuXHQgIGlmICghYXJyIHx8IChsZW4gPSBhcnIubGVuZ3RoKSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcGFyc2VkO1xuXHQgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgcGFyc2VkID0gZXhwb3J0cy5wYXJzZU51bWJlcihhcnJbbGVuXSk7XG5cdCAgICBpZiAocGFyc2VkID09PSBlcnJvci52YWx1ZSkge1xuXHQgICAgICByZXR1cm4gcGFyc2VkO1xuXHQgICAgfVxuXHQgICAgYXJyW2xlbl0gPSBwYXJzZWQ7XG5cdCAgfVxuXHQgIHJldHVybiBhcnI7XG5cdH07XG5cblx0ZXhwb3J0cy5wYXJzZU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIHZhciBuO1xuXHQgIGlmICghbWF0cml4IHx8IChuID0gbWF0cml4Lmxlbmd0aCkgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHBuYXJyO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0cml4Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBwbmFyciA9IGV4cG9ydHMucGFyc2VOdW1iZXJBcnJheShtYXRyaXhbaV0pO1xuXHQgICAgbWF0cml4W2ldID0gcG5hcnI7XG5cdCAgICBpZiAocG5hcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gcG5hcnI7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtYXRyaXg7XG5cdH07XG5cblx0dmFyIGQxOTAwID0gbmV3IERhdGUoMTkwMCwgMCwgMSk7XG5cdGV4cG9ydHMucGFyc2VEYXRlID0gZnVuY3Rpb24oZGF0ZSkge1xuXHQgIGlmICghaXNOYU4oZGF0ZSkpIHtcblx0ICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgZCA9IHBhcnNlSW50KGRhdGUsIDEwKTtcblx0ICAgIGlmIChkIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXHQgICAgaWYgKGQgPD0gNjApIHtcblx0ICAgICAgcmV0dXJuIG5ldyBEYXRlKGQxOTAwLmdldFRpbWUoKSArIChkIC0gMSkgKiA4NjQwMDAwMCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IERhdGUoZDE5MDAuZ2V0VGltZSgpICsgKGQgLSAyKSAqIDg2NDAwMDAwKTtcblx0ICB9XG5cdCAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuXHQgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuXHQgICAgaWYgKCFpc05hTihkYXRlKSkge1xuXHQgICAgICByZXR1cm4gZGF0ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMucGFyc2VEYXRlQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcblx0ICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0ICB2YXIgcGFyc2VkO1xuXHQgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgcGFyc2VkID0gdGhpcy5wYXJzZURhdGUoYXJyW2xlbl0pO1xuXHQgICAgaWYgKHBhcnNlZCA9PT0gZXJyb3IudmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHBhcnNlZDtcblx0ICAgIH1cblx0ICAgIGFycltsZW5dID0gcGFyc2VkO1xuXHQgIH1cblx0ICByZXR1cm4gYXJyO1xuXHR9O1xuXG5cdGV4cG9ydHMuYW55SXNFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0ICB3aGlsZSAobi0tKSB7XG5cdCAgICBpZiAoYXJndW1lbnRzW25dIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRleHBvcnRzLmFycmF5VmFsdWVzVG9OdW1iZXJzID0gZnVuY3Rpb24oYXJyKSB7XG5cdCAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuXHQgIHZhciBlbDtcblx0ICB3aGlsZSAobi0tKSB7XG5cdCAgICBlbCA9IGFycltuXTtcblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsID09PSB0cnVlKSB7XG5cdCAgICAgIGFycltuXSA9IDE7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsID09PSBmYWxzZSkge1xuXHQgICAgICBhcnJbbl0gPSAwO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHZhciBudW1iZXIgPSB0aGlzLnBhcnNlTnVtYmVyKGVsKTtcblx0ICAgICAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgYXJyW25dID0gMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBhcnJbbl0gPSBudW1iZXI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGFycjtcblx0fTtcblxuXHRleHBvcnRzLnJlc3QgPSBmdW5jdGlvbihhcnJheSwgaWR4KSB7XG5cdCAgaWR4ID0gaWR4IHx8IDE7XG5cdCAgaWYgKCFhcnJheSB8fCB0eXBlb2YgYXJyYXkuc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHJldHVybiBhcnJheTtcblx0ICB9XG5cdCAgcmV0dXJuIGFycmF5LnNsaWNlKGlkeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIGlkeCkge1xuXHQgIGlkeCA9IGlkeCB8fCAxO1xuXHQgIGlmICghYXJyYXkgfHwgdHlwZW9mIGFycmF5LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gYXJyYXk7XG5cdCAgfVxuXHQgIHJldHVybiBhcnJheS5zbGljZSgwLCBhcnJheS5sZW5ndGggLSBpZHgpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5uaWwgPSBuZXcgRXJyb3IoJyNOVUxMIScpO1xuXHRleHBvcnRzLmRpdjAgPSBuZXcgRXJyb3IoJyNESVYvMCEnKTtcblx0ZXhwb3J0cy52YWx1ZSA9IG5ldyBFcnJvcignI1ZBTFVFPycpO1xuXHRleHBvcnRzLnJlZiA9IG5ldyBFcnJvcignI1JFRiEnKTtcblx0ZXhwb3J0cy5uYW1lID0gbmV3IEVycm9yKCcjTkFNRT8nKTtcblx0ZXhwb3J0cy5udW0gPSBuZXcgRXJyb3IoJyNOVU0hJyk7XG5cdGV4cG9ydHMubmEgPSBuZXcgRXJyb3IoJyNOL0EnKTtcblx0ZXhwb3J0cy5lcnJvciA9IG5ldyBFcnJvcignI0VSUk9SIScpO1xuXHRleHBvcnRzLmRhdGEgPSBuZXcgRXJyb3IoJyNHRVRUSU5HX0RBVEEnKTtcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIG1hdGhUcmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgalN0YXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLmpTdGF0O1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgbWlzYyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG5cdHZhciBTUVJUMlBJID0gMi41MDY2MjgyNzQ2MzEwMDAyO1xuXG5cdGV4cG9ydHMuQVZFREVWID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5zdW0oalN0YXQocmFuZ2UpLnN1YnRyYWN0KGpTdGF0Lm1lYW4ocmFuZ2UpKS5hYnMoKVswXSkgLyByYW5nZS5sZW5ndGg7XG5cdH07XG5cblx0ZXhwb3J0cy5BVkVSQUdFID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzdW0gPSAwO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHN1bSArPSByYW5nZVtpXTtcblx0ICAgIGNvdW50ICs9IDE7XG5cdCAgfVxuXHQgIHJldHVybiBzdW0gLyBjb3VudDtcblx0fTtcblxuXHRleHBvcnRzLkFWRVJBR0VBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzdW0gPSAwO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciBlbCA9IHJhbmdlW2ldO1xuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgc3VtICs9IGVsO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsID09PSB0cnVlKSB7XG5cdCAgICAgIHN1bSsrO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsICE9PSBudWxsKSB7XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBzdW0gLyBjb3VudDtcblx0fTtcblxuXHRleHBvcnRzLkFWRVJBR0VJRiA9IGZ1bmN0aW9uKHJhbmdlLCBjcml0ZXJpYSwgYXZlcmFnZV9yYW5nZSkge1xuXHQgIGF2ZXJhZ2VfcmFuZ2UgPSBhdmVyYWdlX3JhbmdlIHx8IHJhbmdlO1xuXHQgIHJhbmdlID0gdXRpbHMuZmxhdHRlbihyYW5nZSk7XG5cdCAgYXZlcmFnZV9yYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhdmVyYWdlX3JhbmdlKSk7XG5cdCAgaWYgKGF2ZXJhZ2VfcmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGF2ZXJhZ2VfcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBhdmVyYWdlX2NvdW50ID0gMDtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoZXZhbChyYW5nZVtpXSArIGNyaXRlcmlhKSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgcmVzdWx0ICs9IGF2ZXJhZ2VfcmFuZ2VbaV07XG5cdCAgICAgIGF2ZXJhZ2VfY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdCAvIGF2ZXJhZ2VfY291bnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5BVkVSQUdFSUZTID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gRG9lcyBub3Qgd29yayB3aXRoIG11bHRpIGRpbWVuc2lvbmFsIHJhbmdlcyB5ZXQhXG5cdCAgLy9odHRwOi8vb2ZmaWNlLm1pY3Jvc29mdC5jb20vZW4tMDAxL2V4Y2VsLWhlbHAvYXZlcmFnZWlmcy1mdW5jdGlvbi1IQTAxMDA0NzQ5My5hc3B4XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5hcmdzVG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciBjcml0ZXJpYSA9IChhcmdzLmxlbmd0aCAtIDEpIC8gMjtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3NbMF0pO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjcml0ZXJpYTsgaisrKSB7XG5cdCAgICAgIGNvbmRpdGlvbiArPSBhcmdzWzIgKiBqICsgMV1baV0gKyBhcmdzWzIgKiBqICsgMl07XG5cdCAgICAgIGlmIChqICE9PSBjcml0ZXJpYSAtIDEpIHtcblx0ICAgICAgICBjb25kaXRpb24gKz0gJyYmJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGV2YWwoY29uZGl0aW9uKSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgcmVzdWx0ICs9IHJhbmdlW2ldO1xuXHQgICAgICBjb3VudCsrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBhdmVyYWdlID0gcmVzdWx0IC8gY291bnQ7XG5cdCAgaWYgKGlzTmFOKGF2ZXJhZ2UpKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGF2ZXJhZ2U7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQkVUQSA9IHt9O1xuXG5cdGV4cG9ydHMuQkVUQS5ESVNUID0gZnVuY3Rpb24oeCwgYWxwaGEsIGJldGEsIGN1bXVsYXRpdmUsIEEsIEIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBBID0gKEEgPT09IHVuZGVmaW5lZCkgPyAwIDogQTtcblx0ICBCID0gKEIgPT09IHVuZGVmaW5lZCkgPyAxIDogQjtcblxuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBiZXRhID0gdXRpbHMucGFyc2VOdW1iZXIoYmV0YSk7XG5cdCAgQSA9IHV0aWxzLnBhcnNlTnVtYmVyKEEpO1xuXHQgIEIgPSB1dGlscy5wYXJzZU51bWJlcihCKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBhbHBoYSwgYmV0YSwgQSwgQikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB4ID0gKHggLSBBKSAvIChCIC0gQSk7XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmJldGEuY2RmKHgsIGFscGhhLCBiZXRhKSA6IGpTdGF0LmJldGEucGRmKHgsIGFscGhhLCBiZXRhKTtcblx0fTtcblxuXHRleHBvcnRzLkJFVEEuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhLCBBLCBCKSB7XG5cdCAgQSA9IChBID09PSB1bmRlZmluZWQpID8gMCA6IEE7XG5cdCAgQiA9IChCID09PSB1bmRlZmluZWQpID8gMSA6IEI7XG5cblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBiZXRhID0gdXRpbHMucGFyc2VOdW1iZXIoYmV0YSk7XG5cdCAgQSA9IHV0aWxzLnBhcnNlTnVtYmVyKEEpO1xuXHQgIEIgPSB1dGlscy5wYXJzZU51bWJlcihCKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgYWxwaGEsIGJldGEsIEEsIEIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmJldGEuaW52KHByb2JhYmlsaXR5LCBhbHBoYSwgYmV0YSkgKiAoQiAtIEEpICsgQTtcblx0fTtcblxuXHRleHBvcnRzLkJJTk9NID0ge307XG5cblx0ZXhwb3J0cy5CSU5PTS5ESVNUID0gZnVuY3Rpb24oc3VjY2Vzc2VzLCB0cmlhbHMsIHByb2JhYmlsaXR5LCBjdW11bGF0aXZlKSB7XG5cdCAgc3VjY2Vzc2VzID0gdXRpbHMucGFyc2VOdW1iZXIoc3VjY2Vzc2VzKTtcblx0ICB0cmlhbHMgPSB1dGlscy5wYXJzZU51bWJlcih0cmlhbHMpO1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGN1bXVsYXRpdmUgPSB1dGlscy5wYXJzZU51bWJlcihjdW11bGF0aXZlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihzdWNjZXNzZXMsIHRyaWFscywgcHJvYmFiaWxpdHksIGN1bXVsYXRpdmUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5iaW5vbWlhbC5jZGYoc3VjY2Vzc2VzLCB0cmlhbHMsIHByb2JhYmlsaXR5KSA6IGpTdGF0LmJpbm9taWFsLnBkZihzdWNjZXNzZXMsIHRyaWFscywgcHJvYmFiaWxpdHkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQklOT00uRElTVC5SQU5HRSA9IGZ1bmN0aW9uKHRyaWFscywgcHJvYmFiaWxpdHksIHN1Y2Nlc3Nlcywgc3VjY2Vzc2VzMikge1xuXHQgIHN1Y2Nlc3NlczIgPSAoc3VjY2Vzc2VzMiA9PT0gdW5kZWZpbmVkKSA/IHN1Y2Nlc3NlcyA6IHN1Y2Nlc3NlczI7XG5cblx0ICB0cmlhbHMgPSB1dGlscy5wYXJzZU51bWJlcih0cmlhbHMpO1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIHN1Y2Nlc3NlcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHN1Y2Nlc3Nlcyk7XG5cdCAgc3VjY2Vzc2VzMiA9IHV0aWxzLnBhcnNlTnVtYmVyKHN1Y2Nlc3NlczIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHRyaWFscywgcHJvYmFiaWxpdHksIHN1Y2Nlc3Nlcywgc3VjY2Vzc2VzMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gc3VjY2Vzc2VzOyBpIDw9IHN1Y2Nlc3NlczI7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IG1hdGhUcmlnLkNPTUJJTih0cmlhbHMsIGkpICogTWF0aC5wb3cocHJvYmFiaWxpdHksIGkpICogTWF0aC5wb3coMSAtIHByb2JhYmlsaXR5LCB0cmlhbHMgLSBpKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkJJTk9NLklOViA9IGZ1bmN0aW9uKHRyaWFscywgcHJvYmFiaWxpdHksIGFscGhhKSB7XG5cdCAgdHJpYWxzID0gdXRpbHMucGFyc2VOdW1iZXIodHJpYWxzKTtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih0cmlhbHMsIHByb2JhYmlsaXR5LCBhbHBoYSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgeCA9IDA7XG5cdCAgd2hpbGUgKHggPD0gdHJpYWxzKSB7XG5cdCAgICBpZiAoalN0YXQuYmlub21pYWwuY2RmKHgsIHRyaWFscywgcHJvYmFiaWxpdHkpID49IGFscGhhKSB7XG5cdCAgICAgIHJldHVybiB4O1xuXHQgICAgfVxuXHQgICAgeCsrO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkNISVNRID0ge307XG5cblx0ZXhwb3J0cy5DSElTUS5ESVNUID0gZnVuY3Rpb24oeCwgaywgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgaykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuY2hpc3F1YXJlLmNkZih4LCBrKSA6IGpTdGF0LmNoaXNxdWFyZS5wZGYoeCwgayk7XG5cdH07XG5cblx0ZXhwb3J0cy5DSElTUS5ESVNULlJUID0gZnVuY3Rpb24oeCwgaykge1xuXHQgIGlmICgheCB8ICFrKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHggPCAxIHx8IGsgPiBNYXRoLnBvdygxMCwgMTApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHggIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGsgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAxIC0gIGpTdGF0LmNoaXNxdWFyZS5jZGYoeCwgayk7XG5cdH07XG5cblx0ZXhwb3J0cy5DSElTUS5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgaykge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgaykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LmNoaXNxdWFyZS5pbnYocHJvYmFiaWxpdHksIGspO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hJU1EuSU5WLlJUID0gZnVuY3Rpb24ocCwgaykge1xuXHQgIGlmICghcCB8ICFrKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHAgPCAwIHx8IHAgPiAxIHx8IGsgPCAxIHx8IGsgPiBNYXRoLnBvdygxMCwgMTApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHAgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGsgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jaGlzcXVhcmUuaW52KDEuMCAtIHAsIGspO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hJU1EuVEVTVCA9IGZ1bmN0aW9uKG9ic2VydmVkLCBleHBlY3RlZCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKCghKG9ic2VydmVkIGluc3RhbmNlb2YgQXJyYXkpKSB8fCAoIShleHBlY3RlZCBpbnN0YW5jZW9mIEFycmF5KSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAob2JzZXJ2ZWQubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAob2JzZXJ2ZWRbMF0gJiYgZXhwZWN0ZWRbMF0gJiZcblx0ICAgICAgb2JzZXJ2ZWRbMF0ubGVuZ3RoICE9PSBleHBlY3RlZFswXS5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgcm93ID0gb2JzZXJ2ZWQubGVuZ3RoO1xuXHQgIHZhciB0bXAsIGksIGo7XG5cblx0ICAvLyBDb252ZXJ0IHNpbmdsZS1kaW1lbnNpb24gYXJyYXkgaW50byB0d28tZGltZW5zaW9uIGFycmF5XG5cdCAgZm9yIChpID0gMDsgaSA8IHJvdzsgaSArKykge1xuXHQgICAgaWYgKCEob2JzZXJ2ZWRbaV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgICAgdG1wID0gb2JzZXJ2ZWRbaV07XG5cdCAgICAgIG9ic2VydmVkW2ldID0gW107XG5cdCAgICAgIG9ic2VydmVkW2ldLnB1c2godG1wKTtcblx0ICAgIH1cblx0ICAgIGlmICghKGV4cGVjdGVkW2ldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICAgIHRtcCA9IGV4cGVjdGVkW2ldO1xuXHQgICAgICBleHBlY3RlZFtpXSA9IFtdO1xuXHQgICAgICBleHBlY3RlZFtpXS5wdXNoKHRtcCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGNvbCA9IG9ic2VydmVkWzBdLmxlbmd0aDtcblx0ICB2YXIgZG9mID0gKGNvbCA9PT0gMSkgPyByb3ctMSA6IChyb3ctMSkqKGNvbC0xKTtcblx0ICB2YXIgeHNxciA9IDA7XG5cdCAgdmFyIFBpID1NYXRoLlBJO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHJvdzsgaSArKykge1xuXHQgICAgZm9yIChqID0gMDsgaiA8IGNvbDsgaiArKykge1xuXHQgICAgICB4c3FyICs9IE1hdGgucG93KChvYnNlcnZlZFtpXVtqXSAtIGV4cGVjdGVkW2ldW2pdKSwgMikgLyBleHBlY3RlZFtpXVtqXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBHZXQgaW5kZXBlbmRlbmN5IGJ5IFggc3F1YXJlIGFuZCBpdHMgZGVncmVlIG9mIGZyZWVkb21cblx0ICBmdW5jdGlvbiBDaGlTcSh4c3FyLCBkb2YpIHtcblx0ICAgIHZhciBwID0gTWF0aC5leHAoLTAuNSAqIHhzcXIpO1xuXHQgICAgaWYoKGRvZiUyKSA9PT0gMSkge1xuXHQgICAgICBwID0gcCAqIE1hdGguc3FydCgyICogeHNxci9QaSk7XG5cdCAgICB9XG5cdCAgICB2YXIgayA9IGRvZjtcblx0ICAgIHdoaWxlKGsgPj0gMikge1xuXHQgICAgICBwID0gcCAqIHhzcXIvaztcblx0ICAgICAgayA9IGsgLSAyO1xuXHQgICAgfVxuXHQgICAgdmFyIHQgPSBwO1xuXHQgICAgdmFyIGEgPSBkb2Y7XG5cdCAgICB3aGlsZSAodCA+IDAuMDAwMDAwMDAwMSpwKSB7XG5cdCAgICAgIGEgPSBhICsgMjtcblx0ICAgICAgdCA9IHQgKiB4c3FyL2E7XG5cdCAgICAgIHAgPSBwICsgdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiAxLXA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIE1hdGgucm91bmQoQ2hpU3EoeHNxciwgZG9mKSAqIDEwMDAwMDApIC8gMTAwMDAwMDtcblx0fTtcblxuXHRleHBvcnRzLkNPTFVNTiA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgQXJyYXkpIHx8ICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChtYXRyaXgubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jb2wobWF0cml4LCBpbmRleCk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT0xVTU5TID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmNvbHMobWF0cml4KTtcblx0fTtcblxuXHRleHBvcnRzLkNPTkZJREVOQ0UgPSB7fTtcblxuXHRleHBvcnRzLkNPTkZJREVOQ0UuTk9STSA9IGZ1bmN0aW9uKGFscGhhLCBzZCwgbikge1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhbHBoYSwgc2QsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5ub3JtYWxjaSgxLCBhbHBoYSwgc2QsIG4pWzFdIC0gMTtcblx0fTtcblxuXHRleHBvcnRzLkNPTkZJREVOQ0UuVCA9IGZ1bmN0aW9uKGFscGhhLCBzZCwgbikge1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhbHBoYSwgc2QsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC50Y2koMSwgYWxwaGEsIHNkLCBuKVsxXSAtIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1JSRUwgPSBmdW5jdGlvbihhcnJheTEsIGFycmF5Mikge1xuXHQgIGFycmF5MSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTEpKTtcblx0ICBhcnJheTIgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkyKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXkxLCBhcnJheTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5jb3JyY29lZmYoYXJyYXkxLCBhcnJheTIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09VTlQgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpLmxlbmd0aDtcblx0fTtcblxuXHRleHBvcnRzLkNPVU5UQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICByZXR1cm4gcmFuZ2UubGVuZ3RoIC0gZXhwb3J0cy5DT1VOVEJMQU5LKHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLkNPVU5USU4gPSBmdW5jdGlvbiAocmFuZ2UsIHZhbHVlKSB7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHJhbmdlW2ldID09PSB2YWx1ZSkge1xuXHQgICAgICByZXN1bHQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXG5cdGV4cG9ydHMuQ09VTlRCTEFOSyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgYmxhbmtzID0gMDtcblx0ICB2YXIgZWxlbWVudDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBlbGVtZW50ID0gcmFuZ2VbaV07XG5cdCAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSAnJykge1xuXHQgICAgICBibGFua3MrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGJsYW5rcztcblx0fTtcblxuXHRleHBvcnRzLkNPVU5USUYgPSBmdW5jdGlvbihyYW5nZSwgY3JpdGVyaWEpIHtcblx0ICByYW5nZSA9IHV0aWxzLmZsYXR0ZW4ocmFuZ2UpO1xuXHQgIGlmICghL1s8Pj0hXS8udGVzdChjcml0ZXJpYSkpIHtcblx0ICAgIGNyaXRlcmlhID0gJz09XCInICsgY3JpdGVyaWEgKyAnXCInO1xuXHQgIH1cblx0ICB2YXIgbWF0Y2hlcyA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHR5cGVvZiByYW5nZVtpXSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgaWYgKGV2YWwocmFuZ2VbaV0gKyBjcml0ZXJpYSkpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgICAgbWF0Y2hlcysrO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoZXZhbCgnXCInICsgcmFuZ2VbaV0gKyAnXCInICsgY3JpdGVyaWEpKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICAgIG1hdGNoZXMrKztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbWF0Y2hlcztcblx0fTtcblxuXHRleHBvcnRzLkNPVU5USUZTID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5hcmdzVG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHV0aWxzLmZsYXR0ZW4oYXJnc1swXSkubGVuZ3RoKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdHNbaV0gPSB0cnVlO1xuXHQgIH1cblx0ICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmdzW2ldKTtcblx0ICAgIHZhciBjcml0ZXJpYSA9IGFyZ3NbaSArIDFdO1xuXHQgICAgaWYgKCEvWzw+PSFdLy50ZXN0KGNyaXRlcmlhKSkge1xuXHQgICAgICBjcml0ZXJpYSA9ICc9PVwiJyArIGNyaXRlcmlhICsgJ1wiJztcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmFuZ2UubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgaWYgKHR5cGVvZiByYW5nZVtqXSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXN1bHRzW2pdID0gcmVzdWx0c1tqXSAmJiBldmFsKHJhbmdlW2pdICsgY3JpdGVyaWEpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHRzW2pdID0gcmVzdWx0c1tqXSAmJiBldmFsKCdcIicgKyByYW5nZVtqXSArICdcIicgKyBjcml0ZXJpYSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAoaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAocmVzdWx0c1tpXSkge1xuXHQgICAgICByZXN1bHQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkNPVU5UVU5JUVVFID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBtaXNjLlVOSVFVRS5hcHBseShudWxsLCB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpLmxlbmd0aDtcblx0fTtcblxuXHRleHBvcnRzLkNPVkFSSUFOQ0UgPSB7fTtcblxuXHRleHBvcnRzLkNPVkFSSUFOQ0UuUCA9IGZ1bmN0aW9uKGFycmF5MSwgYXJyYXkyKSB7XG5cdCAgYXJyYXkxID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5MSkpO1xuXHQgIGFycmF5MiA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTIpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheTEsIGFycmF5MikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4xID0galN0YXQubWVhbihhcnJheTEpO1xuXHQgIHZhciBtZWFuMiA9IGpTdGF0Lm1lYW4oYXJyYXkyKTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgbiA9IGFycmF5MS5sZW5ndGg7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSAoYXJyYXkxW2ldIC0gbWVhbjEpICogKGFycmF5MltpXSAtIG1lYW4yKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdCAvIG47XG5cdH07XG5cblx0ZXhwb3J0cy5DT1ZBUklBTkNFLlMgPSBmdW5jdGlvbihhcnJheTEsIGFycmF5Mikge1xuXHQgIGFycmF5MSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTEpKTtcblx0ICBhcnJheTIgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkyKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXkxLCBhcnJheTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5jb3ZhcmlhbmNlKGFycmF5MSwgYXJyYXkyKTtcblx0fTtcblxuXHRleHBvcnRzLkRFVlNRID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBtZWFuID0galN0YXQubWVhbihyYW5nZSk7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IE1hdGgucG93KChyYW5nZVtpXSAtIG1lYW4pLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkVYUE9OID0ge307XG5cblx0ZXhwb3J0cy5FWFBPTi5ESVNUID0gZnVuY3Rpb24oeCwgbGFtYmRhLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGxhbWJkYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGxhbWJkYSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbGFtYmRhKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuZXhwb25lbnRpYWwuY2RmKHgsIGxhbWJkYSkgOiBqU3RhdC5leHBvbmVudGlhbC5wZGYoeCwgbGFtYmRhKTtcblx0fTtcblxuXHRleHBvcnRzLkYgPSB7fTtcblxuXHRleHBvcnRzLkYuRElTVCA9IGZ1bmN0aW9uKHgsIGQxLCBkMiwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBkMSA9IHV0aWxzLnBhcnNlTnVtYmVyKGQxKTtcblx0ICBkMiA9IHV0aWxzLnBhcnNlTnVtYmVyKGQyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBkMSwgZDIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5jZW50cmFsRi5jZGYoeCwgZDEsIGQyKSA6IGpTdGF0LmNlbnRyYWxGLnBkZih4LCBkMSwgZDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRi5ESVNULlJUID0gZnVuY3Rpb24oeCwgZDEsIGQyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoeCA8IDAgfHwgZDEgPCAxIHx8IGQyIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkMSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZDIgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKHgsIGQxLCBkMik7XG5cdH07XG5cblx0ZXhwb3J0cy5GLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBkMSwgZDIpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBkMSA9IHV0aWxzLnBhcnNlTnVtYmVyKGQxKTtcblx0ICBkMiA9IHV0aWxzLnBhcnNlTnVtYmVyKGQyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgZDEsIGQyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAocHJvYmFiaWxpdHkgPD0gMC4wIHx8IHByb2JhYmlsaXR5ID4gMS4wKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jZW50cmFsRi5pbnYocHJvYmFiaWxpdHksIGQxLCBkMik7XG5cdH07XG5cblx0ZXhwb3J0cy5GLklOVi5SVCA9IGZ1bmN0aW9uKHAsIGQxLCBkMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAzKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHAgPCAwIHx8IHAgPiAxIHx8IGQxIDwgMSB8fCBkMSA+IE1hdGgucG93KDEwLCAxMCkgfHwgZDIgPCAxIHx8IGQyID4gTWF0aC5wb3coMTAsIDEwKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiBwICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkMSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZDIgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jZW50cmFsRi5pbnYoMS4wIC0gcCwgZDEsIGQyKTtcblx0fTtcblxuXHRleHBvcnRzLkYuVEVTVCA9IGZ1bmN0aW9uKGFycmF5MSwgYXJyYXkyKSB7XG5cdCAgaWYgKCFhcnJheTEgfHwgIWFycmF5Mikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICghKGFycmF5MSBpbnN0YW5jZW9mIEFycmF5KSB8fCAhKGFycmF5MiBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChhcnJheTEubGVuZ3RoIDwgMiB8fCBhcnJheTIubGVuZ3RoIDwgMikge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXG5cdCAgdmFyIHN1bU9mU3F1YXJlcyA9IGZ1bmN0aW9uKHZhbHVlcywgeDEpIHtcblx0ICAgIHZhciBzdW0gPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgc3VtICs9TWF0aC5wb3coKHZhbHVlc1tpXSAtIHgxKSwgMik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3VtO1xuXHQgIH07XG5cblx0ICB2YXIgeDEgPSBtYXRoVHJpZy5TVU0oYXJyYXkxKSAvIGFycmF5MS5sZW5ndGg7XG5cdCAgdmFyIHgyID0gbWF0aFRyaWcuU1VNKGFycmF5MikgLyBhcnJheTIubGVuZ3RoO1xuXHQgIHZhciBzdW0xID0gc3VtT2ZTcXVhcmVzKGFycmF5MSwgeDEpIC8gKGFycmF5MS5sZW5ndGggLSAxKTtcblx0ICB2YXIgc3VtMiA9IHN1bU9mU3F1YXJlcyhhcnJheTIsIHgyKSAvIChhcnJheTIubGVuZ3RoIC0gMSk7XG5cblx0ICByZXR1cm4gc3VtMSAvIHN1bTI7XG5cdH07XG5cblx0ZXhwb3J0cy5GSVNIRVIgPSBmdW5jdGlvbih4KSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGlmICh4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiB4O1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcblx0fTtcblxuXHRleHBvcnRzLkZJU0hFUklOViA9IGZ1bmN0aW9uKHkpIHtcblx0ICB5ID0gdXRpbHMucGFyc2VOdW1iZXIoeSk7XG5cdCAgaWYgKHkgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHk7XG5cdCAgfVxuXHQgIHZhciBlMnkgPSBNYXRoLmV4cCgyICogeSk7XG5cdCAgcmV0dXJuIChlMnkgLSAxKSAvIChlMnkgKyAxKTtcblx0fTtcblxuXHRleHBvcnRzLkZPUkVDQVNUID0gZnVuY3Rpb24oeCwgZGF0YV95LCBkYXRhX3gpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG51bSArPSAoZGF0YV94W2ldIC0geG1lYW4pICogKGRhdGFfeVtpXSAtIHltZWFuKTtcblx0ICAgIGRlbiArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSB4bWVhbiwgMik7XG5cdCAgfVxuXHQgIHZhciBiID0gbnVtIC8gZGVuO1xuXHQgIHZhciBhID0geW1lYW4gLSBiICogeG1lYW47XG5cdCAgcmV0dXJuIGEgKyBiICogeDtcblx0fTtcblxuXHRleHBvcnRzLkZSRVFVRU5DWSA9IGZ1bmN0aW9uKGRhdGEsIGJpbnMpIHtcblx0ICBkYXRhID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGEpKTtcblx0ICBiaW5zID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGJpbnMpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhLCBiaW5zKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgbiA9IGRhdGEubGVuZ3RoO1xuXHQgIHZhciBiID0gYmlucy5sZW5ndGg7XG5cdCAgdmFyIHIgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8PSBiOyBpKyspIHtcblx0ICAgIHJbaV0gPSAwO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcblx0ICAgICAgaWYgKGkgPT09IDApIHtcblx0ICAgICAgICBpZiAoZGF0YVtqXSA8PSBiaW5zWzBdKSB7XG5cdCAgICAgICAgICByWzBdICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKGkgPCBiKSB7XG5cdCAgICAgICAgaWYgKGRhdGFbal0gPiBiaW5zW2kgLSAxXSAmJiBkYXRhW2pdIDw9IGJpbnNbaV0pIHtcblx0ICAgICAgICAgIHJbaV0gKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoaSA9PT0gYikge1xuXHQgICAgICAgIGlmIChkYXRhW2pdID4gYmluc1tiIC0gMV0pIHtcblx0ICAgICAgICAgIHJbYl0gKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblxuXHRleHBvcnRzLkdBTU1BID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgaWYgKG51bWJlciA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAocGFyc2VJbnQobnVtYmVyLCAxMCkgPT09IG51bWJlciAmJiBudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5nYW1tYWZuKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5HQU1NQS5ESVNUID0gZnVuY3Rpb24odmFsdWUsIGFscGhhLCBiZXRhLCBjdW11bGF0aXZlKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAodmFsdWUgPCAwIHx8IGFscGhhIDw9IDAgfHwgYmV0YSA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGFscGhhICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBiZXRhICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gY3VtdWxhdGl2ZSA/IGpTdGF0LmdhbW1hLmNkZih2YWx1ZSwgYWxwaGEsIGJldGEsIHRydWUpIDogalN0YXQuZ2FtbWEucGRmKHZhbHVlLCBhbHBoYSwgYmV0YSwgZmFsc2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0FNTUEuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAocHJvYmFiaWxpdHkgPCAwIHx8IHByb2JhYmlsaXR5ID4gMSB8fCBhbHBoYSA8PSAwIHx8IGJldGEgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiBwcm9iYWJpbGl0eSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgYWxwaGEgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGJldGEgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5nYW1tYS5pbnYocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhKTtcblx0fTtcblxuXHRleHBvcnRzLkdBTU1BTE4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LmdhbW1hbG4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkdBTU1BTE4uUFJFQ0lTRSA9IGZ1bmN0aW9uKHgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh4IDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5nYW1tYWxuKHgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0FVU1MgPSBmdW5jdGlvbih6KSB7XG5cdCAgeiA9IHV0aWxzLnBhcnNlTnVtYmVyKHopO1xuXHQgIGlmICh6IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiB6O1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQubm9ybWFsLmNkZih6LCAwLCAxKSAtIDAuNTtcblx0fTtcblxuXHRleHBvcnRzLkdFT01FQU4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAoYXJncyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lmdlb21lYW4oYXJncyk7XG5cdH07XG5cblx0ZXhwb3J0cy5HUk9XVEggPSBmdW5jdGlvbihrbm93bl95LCBrbm93bl94LCBuZXdfeCwgdXNlX2NvbnN0KSB7XG5cdCAgLy8gQ3JlZGl0czogSWxtYXJpIEthcm9uZW4gKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQxNjE5OTAvaG93LXRvLWltcGxlbWVudC1ncm93dGgtZnVuY3Rpb24taW4tamF2YXNjcmlwdClcblxuXHQgIGtub3duX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KGtub3duX3kpO1xuXHQgIGlmIChrbm93bl95IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBrbm93bl95O1xuXHQgIH1cblxuXHQgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25hbCBwYXJhbWV0ZXJzOlxuXHQgIHZhciBpO1xuXHQgIGlmIChrbm93bl94ID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGtub3duX3ggPSBbXTtcblx0ICAgIGZvciAoaSA9IDE7IGkgPD0ga25vd25feS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBrbm93bl94LnB1c2goaSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmIChuZXdfeCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBuZXdfeCA9IFtdO1xuXHQgICAgZm9yIChpID0gMTsgaSA8PSBrbm93bl95Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG5ld194LnB1c2goaSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAga25vd25feCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoa25vd25feCk7XG5cdCAgbmV3X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KG5ld194KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihrbm93bl94LCBuZXdfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblxuXHQgIGlmICh1c2VfY29uc3QgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdXNlX2NvbnN0ID0gdHJ1ZTtcblx0ICB9XG5cblx0ICAvLyBDYWxjdWxhdGUgc3VtcyBvdmVyIHRoZSBkYXRhOlxuXHQgIHZhciBuID0ga25vd25feS5sZW5ndGg7XG5cdCAgdmFyIGF2Z194ID0gMDtcblx0ICB2YXIgYXZnX3kgPSAwO1xuXHQgIHZhciBhdmdfeHkgPSAwO1xuXHQgIHZhciBhdmdfeHggPSAwO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciB4ID0ga25vd25feFtpXTtcblx0ICAgIHZhciB5ID0gTWF0aC5sb2coa25vd25feVtpXSk7XG5cdCAgICBhdmdfeCArPSB4O1xuXHQgICAgYXZnX3kgKz0geTtcblx0ICAgIGF2Z194eSArPSB4ICogeTtcblx0ICAgIGF2Z194eCArPSB4ICogeDtcblx0ICB9XG5cdCAgYXZnX3ggLz0gbjtcblx0ICBhdmdfeSAvPSBuO1xuXHQgIGF2Z194eSAvPSBuO1xuXHQgIGF2Z194eCAvPSBuO1xuXG5cdCAgLy8gQ29tcHV0ZSBsaW5lYXIgcmVncmVzc2lvbiBjb2VmZmljaWVudHM6XG5cdCAgdmFyIGJldGE7XG5cdCAgdmFyIGFscGhhO1xuXHQgIGlmICh1c2VfY29uc3QpIHtcblx0ICAgIGJldGEgPSAoYXZnX3h5IC0gYXZnX3ggKiBhdmdfeSkgLyAoYXZnX3h4IC0gYXZnX3ggKiBhdmdfeCk7XG5cdCAgICBhbHBoYSA9IGF2Z195IC0gYmV0YSAqIGF2Z194O1xuXHQgIH0gZWxzZSB7XG5cdCAgICBiZXRhID0gYXZnX3h5IC8gYXZnX3h4O1xuXHQgICAgYWxwaGEgPSAwO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgYW5kIHJldHVybiByZXN1bHQgYXJyYXk6XG5cdCAgdmFyIG5ld195ID0gW107XG5cdCAgZm9yIChpID0gMDsgaSA8IG5ld194Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBuZXdfeS5wdXNoKE1hdGguZXhwKGFscGhhICsgYmV0YSAqIG5ld194W2ldKSk7XG5cdCAgfVxuXHQgIHJldHVybiBuZXdfeTtcblx0fTtcblxuXHRleHBvcnRzLkhBUk1FQU4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGRlbiArPSAxIC8gcmFuZ2VbaV07XG5cdCAgfVxuXHQgIHJldHVybiBuIC8gZGVuO1xuXHR9O1xuXG5cdGV4cG9ydHMuSFlQR0VPTSA9IHt9O1xuXG5cdGV4cG9ydHMuSFlQR0VPTS5ESVNUID0gZnVuY3Rpb24oeCwgbiwgTSwgTiwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgTSA9IHV0aWxzLnBhcnNlTnVtYmVyKE0pO1xuXHQgIE4gPSB1dGlscy5wYXJzZU51bWJlcihOKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuLCBNLCBOKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHBkZih4LCBuLCBNLCBOKSB7XG5cdCAgICByZXR1cm4gbWF0aFRyaWcuQ09NQklOKE0sIHgpICogbWF0aFRyaWcuQ09NQklOKE4gLSBNLCBuIC0geCkgLyBtYXRoVHJpZy5DT01CSU4oTiwgbik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY2RmKHgsIG4sIE0sIE4pIHtcblx0ICAgIHZhciByZXN1bHQgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0geDsgaSsrKSB7XG5cdCAgICAgIHJlc3VsdCArPSBwZGYoaSwgbiwgTSwgTik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBjZGYoeCwgbiwgTSwgTikgOiBwZGYoeCwgbiwgTSwgTik7XG5cdH07XG5cblx0ZXhwb3J0cy5JTlRFUkNFUFQgPSBmdW5jdGlvbihrbm93bl95LCBrbm93bl94KSB7XG5cdCAga25vd25feSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoa25vd25feSk7XG5cdCAga25vd25feCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoa25vd25feCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioa25vd25feSwga25vd25feCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGtub3duX3kubGVuZ3RoICE9PSBrbm93bl94Lmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwb3J0cy5GT1JFQ0FTVCgwLCBrbm93bl95LCBrbm93bl94KTtcblx0fTtcblxuXHRleHBvcnRzLktVUlQgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKHJhbmdlKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzaWdtYSArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDQpO1xuXHQgIH1cblx0ICBzaWdtYSA9IHNpZ21hIC8gTWF0aC5wb3coalN0YXQuc3RkZXYocmFuZ2UsIHRydWUpLCA0KTtcblx0ICByZXR1cm4gKChuICogKG4gKyAxKSkgLyAoKG4gLSAxKSAqIChuIC0gMikgKiAobiAtIDMpKSkgKiBzaWdtYSAtIDMgKiAobiAtIDEpICogKG4gLSAxKSAvICgobiAtIDIpICogKG4gLSAzKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5MQVJHRSA9IGZ1bmN0aW9uKHJhbmdlLCBrKSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIGspKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHJldHVybiByYW5nZS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBiIC0gYTtcblx0ICB9KVtrIC0gMV07XG5cdH07XG5cblx0ZXhwb3J0cy5MSU5FU1QgPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgeG1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeCk7XG5cdCAgdmFyIG4gPSBkYXRhX3gubGVuZ3RoO1xuXHQgIHZhciBudW0gPSAwO1xuXHQgIHZhciBkZW4gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4gKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgIH1cblx0ICB2YXIgbSA9IG51bSAvIGRlbjtcblx0ICB2YXIgYiA9IHltZWFuIC0gbSAqIHhtZWFuO1xuXHQgIHJldHVybiBbbSwgYl07XG5cdH07XG5cblx0Ly8gQWNjb3JkaW5nIHRvIE1pY3Jvc29mdDpcblx0Ly8gaHR0cDovL29mZmljZS5taWNyb3NvZnQuY29tL2VuLXVzL3N0YXJ0ZXItaGVscC9sb2dlc3QtZnVuY3Rpb24tSFAwMTAzNDI2NjUuYXNweFxuXHQvLyBMT0dFU1QgcmV0dXJucyBhcmUgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBsaW5lYXIgbW9kZWw6XG5cdC8vIGxuIHkgPSB4MSBsbiBtMSArIC4uLiArIHhuIGxuIG1uICsgbG4gYlxuXHRleHBvcnRzLkxPR0VTVCA9IGZ1bmN0aW9uKGRhdGFfeSwgZGF0YV94KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhX3kubGVuZ3RoOyBpICsrKSB7XG5cdCAgICBkYXRhX3lbaV0gPSBNYXRoLmxvZyhkYXRhX3lbaV0pO1xuXHQgIH1cblxuXHQgIHZhciByZXN1bHQgPSBleHBvcnRzLkxJTkVTVChkYXRhX3ksIGRhdGFfeCk7XG5cdCAgcmVzdWx0WzBdID0gTWF0aC5yb3VuZChNYXRoLmV4cChyZXN1bHRbMF0pKjEwMDAwMDApLzEwMDAwMDA7XG5cdCAgcmVzdWx0WzFdID0gTWF0aC5yb3VuZChNYXRoLmV4cChyZXN1bHRbMV0pKjEwMDAwMDApLzEwMDAwMDA7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkxPR05PUk0gPSB7fTtcblxuXHRleHBvcnRzLkxPR05PUk0uRElTVCA9IGZ1bmN0aW9uKHgsIG1lYW4sIHNkLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBtZWFuLCBzZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmxvZ25vcm1hbC5jZGYoeCwgbWVhbiwgc2QpIDogalN0YXQubG9nbm9ybWFsLnBkZih4LCBtZWFuLCBzZCk7XG5cdH07XG5cblx0ZXhwb3J0cy5MT0dOT1JNLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBtZWFuLCBzZCkge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgbWVhbiwgc2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5sb2dub3JtYWwuaW52KHByb2JhYmlsaXR5LCBtZWFuLCBzZCk7XG5cdH07XG5cblx0ZXhwb3J0cy5NQVggPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgcmV0dXJuIChyYW5nZS5sZW5ndGggPT09IDApID8gMCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLk1BWEEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5hcnJheVZhbHVlc1RvTnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiAocmFuZ2UubGVuZ3RoID09PSAwKSA/IDAgOiBNYXRoLm1heC5hcHBseShNYXRoLCByYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5NRURJQU4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5hcnJheVZhbHVlc1RvTnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiBqU3RhdC5tZWRpYW4ocmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlOID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiAocmFuZ2UubGVuZ3RoID09PSAwKSA/IDAgOiBNYXRoLm1pbi5hcHBseShNYXRoLCByYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU5BID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuYXJyYXlWYWx1ZXNUb051bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICByZXR1cm4gKHJhbmdlLmxlbmd0aCA9PT0gMCkgPyAwIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgcmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTU9ERSA9IHt9O1xuXG5cdGV4cG9ydHMuTU9ERS5NVUxUID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gQ3JlZGl0czogUm/Dtm5hw6RuXG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBjb3VudCA9IHt9O1xuXHQgIHZhciBtYXhJdGVtcyA9IFtdO1xuXHQgIHZhciBtYXggPSAwO1xuXHQgIHZhciBjdXJyZW50SXRlbTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBjdXJyZW50SXRlbSA9IHJhbmdlW2ldO1xuXHQgICAgY291bnRbY3VycmVudEl0ZW1dID0gY291bnRbY3VycmVudEl0ZW1dID8gY291bnRbY3VycmVudEl0ZW1dICsgMSA6IDE7XG5cdCAgICBpZiAoY291bnRbY3VycmVudEl0ZW1dID4gbWF4KSB7XG5cdCAgICAgIG1heCA9IGNvdW50W2N1cnJlbnRJdGVtXTtcblx0ICAgICAgbWF4SXRlbXMgPSBbXTtcblx0ICAgIH1cblx0ICAgIGlmIChjb3VudFtjdXJyZW50SXRlbV0gPT09IG1heCkge1xuXHQgICAgICBtYXhJdGVtc1ttYXhJdGVtcy5sZW5ndGhdID0gY3VycmVudEl0ZW07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtYXhJdGVtcztcblx0fTtcblxuXHRleHBvcnRzLk1PREUuU05HTCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwb3J0cy5NT0RFLk1VTFQocmFuZ2UpLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pWzBdO1xuXHR9O1xuXG5cdGV4cG9ydHMuTkVHQklOT00gPSB7fTtcblxuXHRleHBvcnRzLk5FR0JJTk9NLkRJU1QgPSBmdW5jdGlvbihrLCByLCBwLCBjdW11bGF0aXZlKSB7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIHIgPSB1dGlscy5wYXJzZU51bWJlcihyKTtcblx0ICBwID0gdXRpbHMucGFyc2VOdW1iZXIocCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoaywgciwgcCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0Lm5lZ2Jpbi5jZGYoaywgciwgcCkgOiBqU3RhdC5uZWdiaW4ucGRmKGssIHIsIHApO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9STSA9IHt9O1xuXG5cdGV4cG9ydHMuTk9STS5ESVNUID0gZnVuY3Rpb24oeCwgbWVhbiwgc2QsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG1lYW4sIHNkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoc2QgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbm9ybWFsIGRpc3RyaWJ1dGlvbiBjb21wdXRlZCBieSBqU3RhdCBbaHR0cDovL2pzdGF0Lm9yZ11cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQubm9ybWFsLmNkZih4LCBtZWFuLCBzZCkgOiBqU3RhdC5ub3JtYWwucGRmKHgsIG1lYW4sIHNkKTtcblx0fTtcblxuXHRleHBvcnRzLk5PUk0uSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIG1lYW4sIHNkKSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBtZWFuLCBzZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lm5vcm1hbC5pbnYocHJvYmFiaWxpdHksIG1lYW4sIHNkKTtcblx0fTtcblxuXHRleHBvcnRzLk5PUk0uUyA9IHt9O1xuXG5cdGV4cG9ydHMuTk9STS5TLkRJU1QgPSBmdW5jdGlvbih6LCBjdW11bGF0aXZlKSB7XG5cdCAgeiA9IHV0aWxzLnBhcnNlTnVtYmVyKHopO1xuXHQgIGlmICh6IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0Lm5vcm1hbC5jZGYoeiwgMCwgMSkgOiBqU3RhdC5ub3JtYWwucGRmKHosIDAsIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9STS5TLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5KSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgaWYgKHByb2JhYmlsaXR5IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lm5vcm1hbC5pbnYocHJvYmFiaWxpdHksIDAsIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVBUlNPTiA9IGZ1bmN0aW9uKGRhdGFfeCwgZGF0YV95KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbjEgPSAwO1xuXHQgIHZhciBkZW4yID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbnVtICs9IChkYXRhX3hbaV0gLSB4bWVhbikgKiAoZGF0YV95W2ldIC0geW1lYW4pO1xuXHQgICAgZGVuMSArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSB4bWVhbiwgMik7XG5cdCAgICBkZW4yICs9IE1hdGgucG93KGRhdGFfeVtpXSAtIHltZWFuLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bSAvIE1hdGguc3FydChkZW4xICogZGVuMik7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJDRU5USUxFID0ge307XG5cblx0ZXhwb3J0cy5QRVJDRU5USUxFLkVYQyA9IGZ1bmN0aW9uKGFycmF5LCBrKSB7XG5cdCAgYXJyYXkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkpKTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXksIGspKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGFycmF5ID0gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICB7XG5cdCAgICAgIHJldHVybiBhIC0gYjtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcblx0ICBpZiAoayA8IDEgLyAobiArIDEpIHx8IGsgPiAxIC0gMSAvIChuICsgMSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHQgIHZhciBsID0gayAqIChuICsgMSkgLSAxO1xuXHQgIHZhciBmbCA9IE1hdGguZmxvb3IobCk7XG5cdCAgcmV0dXJuIHV0aWxzLmNsZWFuRmxvYXQoKGwgPT09IGZsKSA/IGFycmF5W2xdIDogYXJyYXlbZmxdICsgKGwgLSBmbCkgKiAoYXJyYXlbZmwgKyAxXSAtIGFycmF5W2ZsXSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVElMRS5JTkMgPSBmdW5jdGlvbihhcnJheSwgaykge1xuXHQgIGFycmF5ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5KSk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5LCBrKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBhcnJheSA9IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pO1xuXHQgIHZhciBuID0gYXJyYXkubGVuZ3RoO1xuXHQgIHZhciBsID0gayAqIChuIC0gMSk7XG5cdCAgdmFyIGZsID0gTWF0aC5mbG9vcihsKTtcblx0ICByZXR1cm4gdXRpbHMuY2xlYW5GbG9hdCgobCA9PT0gZmwpID8gYXJyYXlbbF0gOiBhcnJheVtmbF0gKyAobCAtIGZsKSAqIChhcnJheVtmbCArIDFdIC0gYXJyYXlbZmxdKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJDRU5UUkFOSyA9IHt9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVFJBTksuRVhDID0gZnVuY3Rpb24oYXJyYXksIHgsIHNpZ25pZmljYW5jZSkge1xuXHQgIHNpZ25pZmljYW5jZSA9IChzaWduaWZpY2FuY2UgPT09IHVuZGVmaW5lZCkgPyAzIDogc2lnbmlmaWNhbmNlO1xuXHQgIGFycmF5ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5KSk7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXksIHgsIHNpZ25pZmljYW5jZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgYXJyYXkgPSBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KTtcblx0ICB2YXIgdW5pcXVlcyA9IG1pc2MuVU5JUVVFLmFwcGx5KG51bGwsIGFycmF5KTtcblx0ICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcblx0ICB2YXIgbSA9IHVuaXF1ZXMubGVuZ3RoO1xuXHQgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBzaWduaWZpY2FuY2UpO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIHZhciBtYXRjaCA9IGZhbHNlO1xuXHQgIHZhciBpID0gMDtcblx0ICB3aGlsZSAoIW1hdGNoICYmIGkgPCBtKSB7XG5cdCAgICBpZiAoeCA9PT0gdW5pcXVlc1tpXSkge1xuXHQgICAgICByZXN1bHQgPSAoYXJyYXkuaW5kZXhPZih1bmlxdWVzW2ldKSArIDEpIC8gKG4gKyAxKTtcblx0ICAgICAgbWF0Y2ggPSB0cnVlO1xuXHQgICAgfSBlbHNlIGlmICh4ID49IHVuaXF1ZXNbaV0gJiYgKHggPCB1bmlxdWVzW2kgKyAxXSB8fCBpID09PSBtIC0gMSkpIHtcblx0ICAgICAgcmVzdWx0ID0gKGFycmF5LmluZGV4T2YodW5pcXVlc1tpXSkgKyAxICsgKHggLSB1bmlxdWVzW2ldKSAvICh1bmlxdWVzW2kgKyAxXSAtIHVuaXF1ZXNbaV0pKSAvIChuICsgMSk7XG5cdCAgICAgIG1hdGNoID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGkrKztcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguZmxvb3IocmVzdWx0ICogcG93ZXIpIC8gcG93ZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJDRU5UUkFOSy5JTkMgPSBmdW5jdGlvbihhcnJheSwgeCwgc2lnbmlmaWNhbmNlKSB7XG5cdCAgc2lnbmlmaWNhbmNlID0gKHNpZ25pZmljYW5jZSA9PT0gdW5kZWZpbmVkKSA/IDMgOiBzaWduaWZpY2FuY2U7XG5cdCAgYXJyYXkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkpKTtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgc2lnbmlmaWNhbmNlID0gdXRpbHMucGFyc2VOdW1iZXIoc2lnbmlmaWNhbmNlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheSwgeCwgc2lnbmlmaWNhbmNlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBhcnJheSA9IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pO1xuXHQgIHZhciB1bmlxdWVzID0gbWlzYy5VTklRVUUuYXBwbHkobnVsbCwgYXJyYXkpO1xuXHQgIHZhciBuID0gYXJyYXkubGVuZ3RoO1xuXHQgIHZhciBtID0gdW5pcXVlcy5sZW5ndGg7XG5cdCAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIHNpZ25pZmljYW5jZSk7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIG1hdGNoID0gZmFsc2U7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHdoaWxlICghbWF0Y2ggJiYgaSA8IG0pIHtcblx0ICAgIGlmICh4ID09PSB1bmlxdWVzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCA9IGFycmF5LmluZGV4T2YodW5pcXVlc1tpXSkgLyAobiAtIDEpO1xuXHQgICAgICBtYXRjaCA9IHRydWU7XG5cdCAgICB9IGVsc2UgaWYgKHggPj0gdW5pcXVlc1tpXSAmJiAoeCA8IHVuaXF1ZXNbaSArIDFdIHx8IGkgPT09IG0gLSAxKSkge1xuXHQgICAgICByZXN1bHQgPSAoYXJyYXkuaW5kZXhPZih1bmlxdWVzW2ldKSArICh4IC0gdW5pcXVlc1tpXSkgLyAodW5pcXVlc1tpICsgMV0gLSB1bmlxdWVzW2ldKSkgLyAobiAtIDEpO1xuXHQgICAgICBtYXRjaCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpKys7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmZsb29yKHJlc3VsdCAqIHBvd2VyKSAvIHBvd2VyO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSTVVUID0gZnVuY3Rpb24obnVtYmVyLCBudW1iZXJfY2hvc2VuKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBudW1iZXJfY2hvc2VuID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX2Nob3Nlbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBudW1iZXJfY2hvc2VuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gbWF0aFRyaWcuRkFDVChudW1iZXIpIC8gbWF0aFRyaWcuRkFDVChudW1iZXIgLSBudW1iZXJfY2hvc2VuKTtcblx0fTtcblxuXHRleHBvcnRzLlBFUk1VVEFUSU9OQSA9IGZ1bmN0aW9uKG51bWJlciwgbnVtYmVyX2Nob3Nlbikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgbnVtYmVyX2Nob3NlbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl9jaG9zZW4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgbnVtYmVyX2Nob3NlbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgucG93KG51bWJlciwgbnVtYmVyX2Nob3Nlbik7XG5cdH07XG5cblx0ZXhwb3J0cy5QSEkgPSBmdW5jdGlvbih4KSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGlmICh4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiB4ICogeCkgLyBTUVJUMlBJO1xuXHR9O1xuXG5cdGV4cG9ydHMuUE9JU1NPTiA9IHt9O1xuXG5cdGV4cG9ydHMuUE9JU1NPTi5ESVNUID0gZnVuY3Rpb24oeCwgbWVhbiwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbWVhbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LnBvaXNzb24uY2RmKHgsIG1lYW4pIDogalN0YXQucG9pc3Nvbi5wZGYoeCwgbWVhbik7XG5cdH07XG5cblx0ZXhwb3J0cy5QUk9CID0gZnVuY3Rpb24ocmFuZ2UsIHByb2JhYmlsaXR5LCBsb3dlciwgdXBwZXIpIHtcblx0ICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXHQgIHVwcGVyID0gKHVwcGVyID09PSB1bmRlZmluZWQpID8gbG93ZXIgOiB1cHBlcjtcblxuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocHJvYmFiaWxpdHkpKTtcblx0ICBsb3dlciA9IHV0aWxzLnBhcnNlTnVtYmVyKGxvd2VyKTtcblx0ICB1cHBlciA9IHV0aWxzLnBhcnNlTnVtYmVyKHVwcGVyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgcHJvYmFiaWxpdHksIGxvd2VyLCB1cHBlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAobG93ZXIgPT09IHVwcGVyKSB7XG5cdCAgICByZXR1cm4gKHJhbmdlLmluZGV4T2YobG93ZXIpID49IDApID8gcHJvYmFiaWxpdHlbcmFuZ2UuaW5kZXhPZihsb3dlcildIDogMDtcblx0ICB9XG5cblx0ICB2YXIgc29ydGVkID0gcmFuZ2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSk7XG5cdCAgdmFyIG4gPSBzb3J0ZWQubGVuZ3RoO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBpZiAoc29ydGVkW2ldID49IGxvd2VyICYmIHNvcnRlZFtpXSA8PSB1cHBlcikge1xuXHQgICAgICByZXN1bHQgKz0gcHJvYmFiaWxpdHlbcmFuZ2UuaW5kZXhPZihzb3J0ZWRbaV0pXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlFVQVJUSUxFID0ge307XG5cblx0ZXhwb3J0cy5RVUFSVElMRS5FWEMgPSBmdW5jdGlvbihyYW5nZSwgcXVhcnQpIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIHF1YXJ0ID0gdXRpbHMucGFyc2VOdW1iZXIocXVhcnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBxdWFydCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgc3dpdGNoIChxdWFydCkge1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLkVYQyhyYW5nZSwgMC4yNSk7XG5cdCAgICBjYXNlIDI6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuRVhDKHJhbmdlLCAwLjUpO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLkVYQyhyYW5nZSwgMC43NSk7XG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLlFVQVJUSUxFLklOQyA9IGZ1bmN0aW9uKHJhbmdlLCBxdWFydCkge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgcXVhcnQgPSB1dGlscy5wYXJzZU51bWJlcihxdWFydCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIHF1YXJ0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBzd2l0Y2ggKHF1YXJ0KSB7XG5cdCAgICBjYXNlIDE6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuSU5DKHJhbmdlLCAwLjI1KTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUEVSQ0VOVElMRS5JTkMocmFuZ2UsIDAuNSk7XG5cdCAgICBjYXNlIDM6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuSU5DKHJhbmdlLCAwLjc1KTtcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuUkFOSyA9IHt9O1xuXG5cdGV4cG9ydHMuUkFOSy5BVkcgPSBmdW5jdGlvbihudW1iZXIsIHJhbmdlLCBvcmRlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHJhbmdlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByYW5nZSA9IHV0aWxzLmZsYXR0ZW4ocmFuZ2UpO1xuXHQgIG9yZGVyID0gb3JkZXIgfHwgZmFsc2U7XG5cdCAgdmFyIHNvcnQgPSAob3JkZXIpID8gZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0gOiBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYiAtIGE7XG5cdCAgfTtcblx0ICByYW5nZSA9IHJhbmdlLnNvcnQoc29ydCk7XG5cblx0ICB2YXIgbGVuZ3RoID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHJhbmdlW2ldID09PSBudW1iZXIpIHtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gKGNvdW50ID4gMSkgPyAoMiAqIHJhbmdlLmluZGV4T2YobnVtYmVyKSArIGNvdW50ICsgMSkgLyAyIDogcmFuZ2UuaW5kZXhPZihudW1iZXIpICsgMTtcblx0fTtcblxuXHRleHBvcnRzLlJBTksuRVEgPSBmdW5jdGlvbihudW1iZXIsIHJhbmdlLCBvcmRlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHJhbmdlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBvcmRlciA9IG9yZGVyIHx8IGZhbHNlO1xuXHQgIHZhciBzb3J0ID0gKG9yZGVyKSA/IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9IDogZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGIgLSBhO1xuXHQgIH07XG5cdCAgcmFuZ2UgPSByYW5nZS5zb3J0KHNvcnQpO1xuXHQgIHJldHVybiByYW5nZS5pbmRleE9mKG51bWJlcikgKyAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuUk9XID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBBcnJheSkgfHwgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LnJvdyhtYXRyaXgsIGluZGV4KTtcblx0fTtcblxuXHRleHBvcnRzLlJPV1MgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChtYXRyaXgubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQucm93cyhtYXRyaXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUlNRID0gZnVuY3Rpb24oZGF0YV94LCBkYXRhX3kpIHsgLy8gbm8gbmVlZCB0byBmbGF0dGVuIGhlcmUsIFBFQVJTT04gd2lsbCB0YWtlIGNhcmUgb2YgdGhhdFxuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV94LCBkYXRhX3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLnBvdyhleHBvcnRzLlBFQVJTT04oZGF0YV94LCBkYXRhX3kpLCAyKTtcblx0fTtcblxuXHRleHBvcnRzLlNLRVcgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKHJhbmdlKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzaWdtYSArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDMpO1xuXHQgIH1cblx0ICByZXR1cm4gbiAqIHNpZ21hIC8gKChuIC0gMSkgKiAobiAtIDIpICogTWF0aC5wb3coalN0YXQuc3RkZXYocmFuZ2UsIHRydWUpLCAzKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5TS0VXLlAgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKHJhbmdlKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgbTIgPSAwO1xuXHQgIHZhciBtMyA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG0zICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgMyk7XG5cdCAgICBtMiArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDIpO1xuXHQgIH1cblx0ICBtMyA9IG0zIC8gbjtcblx0ICBtMiA9IG0yIC8gbjtcblx0ICByZXR1cm4gbTMgLyBNYXRoLnBvdyhtMiwgMyAvIDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0xPUEUgPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB4bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV94KTtcblx0ICB2YXIgeW1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIG4gPSBkYXRhX3gubGVuZ3RoO1xuXHQgIHZhciBudW0gPSAwO1xuXHQgIHZhciBkZW4gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4gKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtIC8gZGVuO1xuXHR9O1xuXG5cdGV4cG9ydHMuU01BTEwgPSBmdW5jdGlvbihyYW5nZSwgaykge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBrKSkge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICByZXR1cm4gcmFuZ2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSlbayAtIDFdO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1RBTkRBUkRJWkUgPSBmdW5jdGlvbih4LCBtZWFuLCBzZCkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbWVhbiwgc2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoeCAtIG1lYW4pIC8gc2Q7XG5cdH07XG5cblx0ZXhwb3J0cy5TVERFViA9IHt9O1xuXG5cdGV4cG9ydHMuU1RERVYuUCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciB2ID0gZXhwb3J0cy5WQVIuUC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHJldHVybiBNYXRoLnNxcnQodik7XG5cdH07XG5cblx0ZXhwb3J0cy5TVERFVi5TID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHYgPSBleHBvcnRzLlZBUi5TLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIE1hdGguc3FydCh2KTtcblx0fTtcblxuXHRleHBvcnRzLlNUREVWQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciB2ID0gZXhwb3J0cy5WQVJBLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIE1hdGguc3FydCh2KTtcblx0fTtcblxuXHRleHBvcnRzLlNUREVWUEEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgdiA9IGV4cG9ydHMuVkFSUEEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gTWF0aC5zcXJ0KHYpO1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5TVEVZWCA9IGZ1bmN0aW9uKGRhdGFfeSwgZGF0YV94KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIGxmdCA9IDA7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGxmdCArPSBNYXRoLnBvdyhkYXRhX3lbaV0gLSB5bWVhbiwgMik7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4gKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5zcXJ0KChsZnQgLSBudW0gKiBudW0gLyBkZW4pIC8gKG4gLSAyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5UUkFOU1BPU0UgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBpZiAoIW1hdHJpeCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQudHJhbnNwb3NlKG1hdHJpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5UID0gdGV4dC5UO1xuXG5cdGV4cG9ydHMuVC5ESVNUID0gZnVuY3Rpb24oeCwgZGYsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgZGYgPSB1dGlscy5wYXJzZU51bWJlcihkZik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgZGYpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5zdHVkZW50dC5jZGYoeCwgZGYpIDogalN0YXQuc3R1ZGVudHQucGRmKHgsIGRmKTtcblx0fTtcblxuXHRleHBvcnRzLlQuRElTVFsnMlQnXSA9IGZ1bmN0aW9uKHgsIGRmKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoeCA8IDAgfHwgZGYgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHggIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGRmICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gKDEgLSBqU3RhdC5zdHVkZW50dC5jZGYoeCAsIGRmKSkgKiAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuVC5ESVNULlJUID0gZnVuY3Rpb24oeCwgZGYpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh4IDwgMCB8fCBkZiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZGYgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAxIC0galN0YXQuc3R1ZGVudHQuY2RmKHggLCBkZik7XG5cdH07XG5cblx0ZXhwb3J0cy5ULklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBkZikge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGRmID0gdXRpbHMucGFyc2VOdW1iZXIoZGYpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBkZikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LnN0dWRlbnR0Lmludihwcm9iYWJpbGl0eSwgZGYpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVC5JTlZbJzJUJ10gPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgZGYpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBkZiA9IHV0aWxzLnBhcnNlTnVtYmVyKGRmKTtcblx0ICBpZiAocHJvYmFiaWxpdHkgPD0gMCB8fCBwcm9iYWJpbGl0eSA+IDEgfHwgZGYgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgZGYpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFicyhqU3RhdC5zdHVkZW50dC5pbnYocHJvYmFiaWxpdHkvMiwgZGYpKTtcblx0fTtcblxuXHQvLyBUaGUgYWxnb3JpdGhtIGNhbiBiZSBmb3VuZCBoZXJlOlxuXHQvLyBodHRwOi8vd3d3LmNoZW0udW9hLmdyL2FwcGxldHMvQXBwbGV0VHRlc3QvQXBwbF9UdGVzdDIuaHRtbFxuXHRleHBvcnRzLlQuVEVTVCA9IGZ1bmN0aW9uKGRhdGFfeCwgZGF0YV95KSB7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3gsIGRhdGFfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgbWVhbl94ID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciBtZWFuX3kgPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIHNfeCA9IDA7XG5cdCAgdmFyIHNfeSA9IDA7XG5cdCAgdmFyIGk7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgZGF0YV94Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzX3ggKz0gTWF0aC5wb3coZGF0YV94W2ldIC0gbWVhbl94LCAyKTtcblx0ICB9XG5cdCAgZm9yIChpID0gMDsgaSA8IGRhdGFfeS5sZW5ndGg7IGkrKykge1xuXHQgICAgc195ICs9IE1hdGgucG93KGRhdGFfeVtpXSAtIG1lYW5feSwgMik7XG5cdCAgfVxuXG5cdCAgc194ID0gc194IC8gKGRhdGFfeC5sZW5ndGgtMSk7XG5cdCAgc195ID0gc195IC8gKGRhdGFfeS5sZW5ndGgtMSk7XG5cblx0ICB2YXIgdCA9IE1hdGguYWJzKG1lYW5feCAtIG1lYW5feSkgLyBNYXRoLnNxcnQoc194L2RhdGFfeC5sZW5ndGggKyBzX3kvZGF0YV95Lmxlbmd0aCk7XG5cblx0ICByZXR1cm4gZXhwb3J0cy5ULkRJU1RbJzJUJ10odCwgZGF0YV94Lmxlbmd0aCtkYXRhX3kubGVuZ3RoLTIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJFTkQgPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCwgbmV3X2RhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgbmV3X2RhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihuZXdfZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gsIG5ld19kYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBsaW5lc3QgPSBleHBvcnRzLkxJTkVTVChkYXRhX3ksIGRhdGFfeCk7XG5cdCAgdmFyIG0gPSBsaW5lc3RbMF07XG5cdCAgdmFyIGIgPSBsaW5lc3RbMV07XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXG5cdCAgbmV3X2RhdGFfeC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcblx0ICAgIHJlc3VsdC5wdXNoKG0gKiB4ICsgYik7XG5cdCAgfSk7XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJJTU1FQU4gPSBmdW5jdGlvbihyYW5nZSwgcGVyY2VudCkge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgcGVyY2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmNlbnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBwZXJjZW50KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgdHJpbSA9IG1hdGhUcmlnLkZMT09SKHJhbmdlLmxlbmd0aCAqIHBlcmNlbnQsIDIpIC8gMjtcblx0ICByZXR1cm4galN0YXQubWVhbih1dGlscy5pbml0aWFsKHV0aWxzLnJlc3QocmFuZ2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSksIHRyaW0pLCB0cmltKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5WQVIgPSB7fTtcblxuXHRleHBvcnRzLlZBUi5QID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgdmFyIG1lYW4gPSBleHBvcnRzLkFWRVJBR0UocmFuZ2UpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzaWdtYSArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gc2lnbWEgLyBuO1xuXHR9O1xuXG5cdGV4cG9ydHMuVkFSLlMgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICB2YXIgbWVhbiA9IGV4cG9ydHMuQVZFUkFHRShyYW5nZSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHNpZ21hICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgMik7XG5cdCAgfVxuXHQgIHJldHVybiBzaWdtYSAvIChuIC0gMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5WQVJBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgdmFyIGNvdW50ID0gMDtcblx0ICB2YXIgbWVhbiA9IGV4cG9ydHMuQVZFUkFHRUEocmFuZ2UpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB2YXIgZWwgPSByYW5nZVtpXTtcblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KGVsIC0gbWVhbiwgMik7XG5cdCAgICB9IGVsc2UgaWYgKGVsID09PSB0cnVlKSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KDEgLSBtZWFuLCAyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KDAgLSBtZWFuLCAyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGVsICE9PSBudWxsKSB7XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBzaWdtYSAvIChjb3VudCAtIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVkFSUEEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICB2YXIgY291bnQgPSAwO1xuXHQgIHZhciBtZWFuID0gZXhwb3J0cy5BVkVSQUdFQShyYW5nZSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciBlbCA9IHJhbmdlW2ldO1xuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coZWwgLSBtZWFuLCAyKTtcblx0ICAgIH0gZWxzZSBpZiAoZWwgPT09IHRydWUpIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coMSAtIG1lYW4sIDIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coMCAtIG1lYW4sIDIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZWwgIT09IG51bGwpIHtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHNpZ21hIC8gY291bnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5XRUlCVUxMID0ge307XG5cblx0ZXhwb3J0cy5XRUlCVUxMLkRJU1QgPSBmdW5jdGlvbih4LCBhbHBoYSwgYmV0YSwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBiZXRhID0gdXRpbHMucGFyc2VOdW1iZXIoYmV0YSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgYWxwaGEsIGJldGEpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyAxIC0gTWF0aC5leHAoLU1hdGgucG93KHggLyBiZXRhLCBhbHBoYSkpIDogTWF0aC5wb3coeCwgYWxwaGEgLSAxKSAqIE1hdGguZXhwKC1NYXRoLnBvdyh4IC8gYmV0YSwgYWxwaGEpKSAqIGFscGhhIC8gTWF0aC5wb3coYmV0YSwgYWxwaGEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuWiA9IHt9O1xuXG5cdGV4cG9ydHMuWi5URVNUID0gZnVuY3Rpb24ocmFuZ2UsIHgsIHNkKSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIHgpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgc2QgPSBzZCB8fCBleHBvcnRzLlNUREVWLlMocmFuZ2UpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHJldHVybiAxIC0gZXhwb3J0cy5OT1JNLlMuRElTVCgoZXhwb3J0cy5BVkVSQUdFKHJhbmdlKSAtIHgpIC8gKHNkIC8gTWF0aC5zcXJ0KG4pKSwgdHJ1ZSk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBudW1lcmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuXHQvL1RPRE9cblx0ZXhwb3J0cy5BU0MgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQVNDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vVE9ET1xuXHRleHBvcnRzLkJBSFRURVhUID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0JBSFRURVhUIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hBUiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0xFQU4gPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgdGV4dCA9IHRleHQgfHwgJyc7XG5cdCAgdmFyIHJlID0gL1tcXDAtXFx4MUZdL2c7XG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZShyZSwgXCJcIik7XG5cdH07XG5cblx0ZXhwb3J0cy5DT0RFID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIHRleHQgPSB0ZXh0IHx8ICcnO1xuXHQgIHJldHVybiB0ZXh0LmNoYXJDb2RlQXQoMCk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT05DQVRFTkFURSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXG5cdCAgdmFyIHRydWVGb3VuZCA9IDA7XG5cdCAgd2hpbGUgKCh0cnVlRm91bmQgPSBhcmdzLmluZGV4T2YodHJ1ZSkpID4gLTEpIHtcblx0ICAgIGFyZ3NbdHJ1ZUZvdW5kXSA9ICdUUlVFJztcblx0ICB9XG5cblx0ICB2YXIgZmFsc2VGb3VuZCA9IDA7XG5cdCAgd2hpbGUgKChmYWxzZUZvdW5kID0gYXJncy5pbmRleE9mKGZhbHNlKSkgPiAtMSkge1xuXHQgICAgYXJnc1tmYWxzZUZvdW5kXSA9ICdGQUxTRSc7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGFyZ3Muam9pbignJyk7XG5cdH07XG5cblx0Ly9UT0RPXG5cdGV4cG9ydHMuREJDUyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdEQkNTIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRE9MTEFSID0gZnVuY3Rpb24obnVtYmVyLCBkZWNpbWFscykge1xuXHQgIGRlY2ltYWxzID0gKGRlY2ltYWxzID09PSB1bmRlZmluZWQpID8gMiA6IGRlY2ltYWxzO1xuXG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkZWNpbWFscyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRlY2ltYWxzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRlY2ltYWxzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgZm9ybWF0ID0gJyc7XG5cdCAgaWYgKGRlY2ltYWxzIDw9IDApIHtcblx0ICAgIG51bWJlciA9IE1hdGgucm91bmQobnVtYmVyICogTWF0aC5wb3coMTAsIGRlY2ltYWxzKSkgLyBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuXHQgICAgZm9ybWF0ID0gJygkMCwwKSc7XG5cdCAgfSBlbHNlIGlmIChkZWNpbWFscyA+IDApIHtcblx0ICAgIGZvcm1hdCA9ICcoJDAsMC4nICsgbmV3IEFycmF5KGRlY2ltYWxzICsgMSkuam9pbignMCcpICsgJyknO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJhbChudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVhBQ1QgPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcblx0ICByZXR1cm4gdGV4dDEgPT09IHRleHQyO1xuXHR9O1xuXG5cdGV4cG9ydHMuRklORCA9IGZ1bmN0aW9uKGZpbmRfdGV4dCwgd2l0aGluX3RleHQsIHBvc2l0aW9uKSB7XG5cdCAgcG9zaXRpb24gPSAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkgPyAwIDogcG9zaXRpb247XG5cdCAgcmV0dXJuIHdpdGhpbl90ZXh0ID8gd2l0aGluX3RleHQuaW5kZXhPZihmaW5kX3RleHQsIHBvc2l0aW9uIC0gMSkgKyAxIDogbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLkZJWEVEID0gZnVuY3Rpb24obnVtYmVyLCBkZWNpbWFscywgbm9fY29tbWFzKSB7XG5cdCAgZGVjaW1hbHMgPSAoZGVjaW1hbHMgPT09IHVuZGVmaW5lZCkgPyAyIDogZGVjaW1hbHM7XG5cdCAgbm9fY29tbWFzID0gKG5vX2NvbW1hcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogbm9fY29tbWFzO1xuXG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkZWNpbWFscyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRlY2ltYWxzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRlY2ltYWxzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciBmb3JtYXQgPSBub19jb21tYXMgPyAnMCcgOiAnMCwwJztcblx0ICBpZiAoZGVjaW1hbHMgPD0gMCkge1xuXHQgICAgbnVtYmVyID0gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGVjaW1hbHMpKSAvIE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG5cdCAgfSBlbHNlIGlmIChkZWNpbWFscyA+IDApIHtcblx0ICAgIGZvcm1hdCArPSAnLicgKyBuZXcgQXJyYXkoZGVjaW1hbHMgKyAxKS5qb2luKCcwJyk7XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmFsKG51bWJlcikuZm9ybWF0KGZvcm1hdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5IVE1MMlRFWFQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICB2YXIgcmVzdWx0ID0gJyc7XG5cblx0ICBpZiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcblx0ICAgICAgICBpZiAocmVzdWx0ICE9PSAnJykge1xuXHQgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gKGxpbmUucmVwbGFjZSgvPCg/Oi58XFxuKSo/Pi9nbSwgJycpKTtcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKC88KD86LnxcXG4pKj8+L2dtLCAnJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkxFRlQgPSBmdW5jdGlvbih0ZXh0LCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSAobnVtYmVyID09PSB1bmRlZmluZWQpID8gMSA6IG51bWJlcjtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQgPyB0ZXh0LnN1YnN0cmluZygwLCBudW1iZXIpIDogbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLkxFTiA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLmVycm9yO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiB0ZXh0ID8gdGV4dC5sZW5ndGggOiAwO1xuXHQgIH1cblxuXHQgIGlmICh0ZXh0Lmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuXHQgIH1cblxuXHQgIHJldHVybiBlcnJvci52YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLkxPV0VSID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQgPyB0ZXh0LnRvTG93ZXJDYXNlKCkgOiB0ZXh0O1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlEID0gZnVuY3Rpb24odGV4dCwgc3RhcnQsIG51bWJlcikge1xuXHQgIHN0YXJ0ID0gdXRpbHMucGFyc2VOdW1iZXIoc3RhcnQpO1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioc3RhcnQsIG51bWJlcikgfHwgdHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIHZhciBiZWdpbiA9IHN0YXJ0IC0gMTtcblx0ICB2YXIgZW5kID0gYmVnaW4gKyBudW1iZXI7XG5cblx0ICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoYmVnaW4sIGVuZCk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk5VTUJFUlZBTFVFID0gZnVuY3Rpb24gKHRleHQsIGRlY2ltYWxfc2VwYXJhdG9yLCBncm91cF9zZXBhcmF0b3IpICB7XG5cdCAgZGVjaW1hbF9zZXBhcmF0b3IgPSAodHlwZW9mIGRlY2ltYWxfc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJykgPyAnLicgOiBkZWNpbWFsX3NlcGFyYXRvcjtcblx0ICBncm91cF9zZXBhcmF0b3IgPSAodHlwZW9mIGdyb3VwX3NlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpID8gJywnIDogZ3JvdXBfc2VwYXJhdG9yO1xuXHQgIHJldHVybiBOdW1iZXIodGV4dC5yZXBsYWNlKGRlY2ltYWxfc2VwYXJhdG9yLCAnLicpLnJlcGxhY2UoZ3JvdXBfc2VwYXJhdG9yLCAnJykpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5QUk9ORVRJQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdQUk9ORVRJQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLlBST1BFUiA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmICh0ZXh0ID09PSB0cnVlKSB7XG5cdCAgICB0ZXh0ID0gJ1RSVUUnO1xuXHQgIH1cblx0ICBpZiAodGV4dCA9PT0gZmFsc2UpIHtcblx0ICAgIHRleHQgPSAnRkFMU0UnO1xuXHQgIH1cblx0ICBpZiAoaXNOYU4odGV4dCkgJiYgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcblx0ICAgIHRleHQgPSAnJyArIHRleHQ7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFx3XFxTKi9nLCBmdW5jdGlvbih0eHQpIHtcblx0ICAgIHJldHVybiB0eHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eHQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG5cdCAgfSk7XG5cdH07XG5cblx0ZXhwb3J0cy5SRUdFWEVYVFJBQ1QgPSBmdW5jdGlvbiAodGV4dCwgcmVndWxhcl9leHByZXNzaW9uKSB7XG5cdCAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaChuZXcgUmVnRXhwKHJlZ3VsYXJfZXhwcmVzc2lvbikpO1xuXHQgIHJldHVybiBtYXRjaCA/IChtYXRjaFttYXRjaC5sZW5ndGggPiAxID8gbWF0Y2gubGVuZ3RoIC0gMSA6IDBdKSA6IG51bGw7XG5cdH07XG5cblx0ZXhwb3J0cy5SRUdFWE1BVENIID0gZnVuY3Rpb24gKHRleHQsIHJlZ3VsYXJfZXhwcmVzc2lvbiwgZnVsbCkge1xuXHQgIHZhciBtYXRjaCA9IHRleHQubWF0Y2gobmV3IFJlZ0V4cChyZWd1bGFyX2V4cHJlc3Npb24pKTtcblx0ICByZXR1cm4gZnVsbCA/IG1hdGNoIDogISFtYXRjaDtcblx0fTtcblxuXHRleHBvcnRzLlJFR0VYUkVQTEFDRSA9IGZ1bmN0aW9uICh0ZXh0LCByZWd1bGFyX2V4cHJlc3Npb24sIHJlcGxhY2VtZW50KSB7XG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZShuZXcgUmVnRXhwKHJlZ3VsYXJfZXhwcmVzc2lvbiksIHJlcGxhY2VtZW50KTtcblx0fTtcblxuXHRleHBvcnRzLlJFUExBQ0UgPSBmdW5jdGlvbih0ZXh0LCBwb3NpdGlvbiwgbGVuZ3RoLCBuZXdfdGV4dCkge1xuXHQgIHBvc2l0aW9uID0gdXRpbHMucGFyc2VOdW1iZXIocG9zaXRpb24pO1xuXHQgIGxlbmd0aCA9IHV0aWxzLnBhcnNlTnVtYmVyKGxlbmd0aCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocG9zaXRpb24sIGxlbmd0aCkgfHxcblx0ICAgIHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJyB8fFxuXHQgICAgdHlwZW9mIG5ld190ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdGV4dC5zdWJzdHIoMCwgcG9zaXRpb24gLSAxKSArIG5ld190ZXh0ICsgdGV4dC5zdWJzdHIocG9zaXRpb24gLSAxICsgbGVuZ3RoKTtcblx0fTtcblxuXHRleHBvcnRzLlJFUFQgPSBmdW5jdGlvbih0ZXh0LCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIG5ldyBBcnJheShudW1iZXIgKyAxKS5qb2luKHRleHQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUklHSFQgPSBmdW5jdGlvbih0ZXh0LCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSAobnVtYmVyID09PSB1bmRlZmluZWQpID8gMSA6IG51bWJlcjtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQgPyB0ZXh0LnN1YnN0cmluZyh0ZXh0Lmxlbmd0aCAtIG51bWJlcikgOiBudWxsO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VBUkNIID0gZnVuY3Rpb24oZmluZF90ZXh0LCB3aXRoaW5fdGV4dCwgcG9zaXRpb24pIHtcblx0ICB2YXIgZm91bmRBdDtcblx0ICBpZiAodHlwZW9mIGZpbmRfdGV4dCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHdpdGhpbl90ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBwb3NpdGlvbiA9IChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBwb3NpdGlvbjtcblx0ICBmb3VuZEF0ID0gd2l0aGluX3RleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKGZpbmRfdGV4dC50b0xvd2VyQ2FzZSgpLCBwb3NpdGlvbiAtIDEpKzE7XG5cdCAgcmV0dXJuIChmb3VuZEF0ID09PSAwKT9lcnJvci52YWx1ZTpmb3VuZEF0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1BMSVQgPSBmdW5jdGlvbiAodGV4dCwgc2VwYXJhdG9yKSB7XG5cdCAgcmV0dXJuIHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcblx0fTtcblxuXHRleHBvcnRzLlNVQlNUSVRVVEUgPSBmdW5jdGlvbih0ZXh0LCBvbGRfdGV4dCwgbmV3X3RleHQsIG9jY3VycmVuY2UpIHtcblx0ICBpZiAoIXRleHQgfHwgIW9sZF90ZXh0IHx8ICFuZXdfdGV4dCkge1xuXHQgICAgcmV0dXJuIHRleHQ7XG5cdCAgfSBlbHNlIGlmIChvY2N1cnJlbmNlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChvbGRfdGV4dCwgJ2cnKSwgbmV3X3RleHQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgdmFyIGkgPSAwO1xuXHQgICAgd2hpbGUgKHRleHQuaW5kZXhPZihvbGRfdGV4dCwgaW5kZXgpID4gMCkge1xuXHQgICAgICBpbmRleCA9IHRleHQuaW5kZXhPZihvbGRfdGV4dCwgaW5kZXggKyAxKTtcblx0ICAgICAgaSsrO1xuXHQgICAgICBpZiAoaSA9PT0gb2NjdXJyZW5jZSkge1xuXHQgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCkgKyBuZXdfdGV4dCArIHRleHQuc3Vic3RyaW5nKGluZGV4ICsgb2xkX3RleHQubGVuZ3RoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLlQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSA/IHZhbHVlIDogJyc7XG5cdH07XG5cblx0Ly8gVE9ETyBpbmNvbXBsZXRlIGltcGxlbWVudGF0aW9uXG5cdGV4cG9ydHMuVEVYVCA9IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQpIHtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtZXJhbCh2YWx1ZSkuZm9ybWF0KGZvcm1hdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5UUklNID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZSgvICsvZywgJyAnKS50cmltKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5VTklDSEFSID0gdGhpcy5DSEFSO1xuXG5cdGV4cG9ydHMuVU5JQ09ERSA9IHRoaXMuQ09ERTtcblxuXHRleHBvcnRzLlVQUEVSID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQudG9VcHBlckNhc2UoKTtcblx0fTtcblxuXHRleHBvcnRzLlZBTFVFID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyYWwoKS51bmZvcm1hdCh0ZXh0KTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXztcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV85X187XG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIHV0aWxzICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgbnVtZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0ZXhwb3J0cy5VTklRVUUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgaGFzRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgdmFyIGVsZW1lbnQgICAgPSBhcmd1bWVudHNbaV07XG5cblx0ICAgIC8vIENoZWNrIGlmIHdlJ3ZlIGFscmVhZHkgc2VlbiB0aGlzIGVsZW1lbnQuXG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlc3VsdC5sZW5ndGg7ICsraikge1xuXHQgICAgICBoYXNFbGVtZW50ID0gcmVzdWx0W2pdID09PSBlbGVtZW50O1xuXHQgICAgICBpZiAoaGFzRWxlbWVudCkgeyBicmVhazsgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBJZiB3ZSBkaWQgbm90IGZpbmQgaXQsIGFkZCBpdCB0byB0aGUgcmVzdWx0LlxuXHQgICAgaWYgKCFoYXNFbGVtZW50KSB7XG5cdCAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuRkxBVFRFTiA9IHV0aWxzLmZsYXR0ZW47XG5cblx0ZXhwb3J0cy5BUkdTMkFSUkFZID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkVGRVJFTkNFID0gZnVuY3Rpb24gKGNvbnRleHQsIHJlZmVyZW5jZSkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgcGF0aCA9IHJlZmVyZW5jZS5zcGxpdCgnLicpO1xuXHQgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQ7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgdmFyIHN0ZXAgPSBwYXRoW2ldO1xuXHQgICAgICBpZiAoc3RlcFtzdGVwLmxlbmd0aCAtIDFdID09PSAnXScpIHtcblx0ICAgICAgICB2YXIgb3BlbmluZyA9IHN0ZXAuaW5kZXhPZignWycpO1xuXHQgICAgICAgIHZhciBpbmRleCA9IHN0ZXAuc3Vic3RyaW5nKG9wZW5pbmcgKyAxLCBzdGVwLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtzdGVwLnN1YnN0cmluZygwLCBvcGVuaW5nKV1baW5kZXhdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtzdGVwXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGNhdGNoIChlcnJvcikge31cblx0fTtcblxuXHRleHBvcnRzLkpPSU4gPSBmdW5jdGlvbiAoYXJyYXksIHNlcGFyYXRvcikge1xuXHQgIHJldHVybiBhcnJheS5qb2luKHNlcGFyYXRvcik7XG5cdH07XG5cblx0ZXhwb3J0cy5OVU1CRVJTID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBwb3NzaWJsZU51bWJlcnMgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIHBvc3NpYmxlTnVtYmVycy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG5cdCAgICByZXR1cm4gdHlwZW9mIGVsID09PSAnbnVtYmVyJztcblx0ICB9KTtcblx0fTtcblxuXHRleHBvcnRzLk5VTUVSQUwgPSBmdW5jdGlvbiAobnVtYmVyLCBmb3JtYXQpIHtcblx0ICByZXR1cm4gbnVtZXJhbChudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNFTEwgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ0VMTCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkVSUk9SID0ge307XG5cdGV4cG9ydHMuRVJST1IuVFlQRSA9IGZ1bmN0aW9uKGVycm9yX3ZhbCkge1xuXHQgIHN3aXRjaCAoZXJyb3JfdmFsKSB7XG5cdCAgICBjYXNlIGVycm9yLm5pbDogcmV0dXJuIDE7XG5cdCAgICBjYXNlIGVycm9yLmRpdjA6IHJldHVybiAyO1xuXHQgICAgY2FzZSBlcnJvci52YWx1ZTogcmV0dXJuIDM7XG5cdCAgICBjYXNlIGVycm9yLnJlZjogcmV0dXJuIDQ7XG5cdCAgICBjYXNlIGVycm9yLm5hbWU6IHJldHVybiA1O1xuXHQgICAgY2FzZSBlcnJvci5udW06IHJldHVybiA2O1xuXHQgICAgY2FzZSBlcnJvci5uYTogcmV0dXJuIDc7XG5cdCAgICBjYXNlIGVycm9yLmRhdGE6IHJldHVybiA4O1xuXHQgIH1cblx0ICByZXR1cm4gZXJyb3IubmE7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLklORk8gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignSU5GTyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLklTQkxBTksgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLklTQklOQVJZID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgIHJldHVybiAoL15bMDFdezEsMTB9JC8pLnRlc3QobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLklTRVJSID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gKFtlcnJvci52YWx1ZSwgZXJyb3IucmVmLCBlcnJvci5kaXYwLCBlcnJvci5udW0sIGVycm9yLm5hbWUsIGVycm9yLm5pbF0pLmluZGV4T2YodmFsdWUpID49IDAgfHxcblx0ICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNFUlJPUiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIGV4cG9ydHMuSVNFUlIodmFsdWUpIHx8IHZhbHVlID09PSBlcnJvci5uYTtcblx0fTtcblxuXHRleHBvcnRzLklTRVZFTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIHJldHVybiAoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKSAmIDEpID8gZmFsc2UgOiB0cnVlO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5JU0ZPUk1VTEEgPSBmdW5jdGlvbigpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ0lTRk9STVVMQSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLklTTE9HSUNBTCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcblx0fTtcblxuXHRleHBvcnRzLklTTkEgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gZXJyb3IubmE7XG5cdH07XG5cblx0ZXhwb3J0cy5JU05PTlRFWFQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YodmFsdWUpICE9PSAnc3RyaW5nJztcblx0fTtcblxuXHRleHBvcnRzLklTTlVNQkVSID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JU09ERCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIHJldHVybiAoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKSAmIDEpID8gdHJ1ZSA6IGZhbHNlO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5JU1JFRiA9IGZ1bmN0aW9uKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignSVNSRUYgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5JU1RFWFQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnc3RyaW5nJztcblx0fTtcblxuXHRleHBvcnRzLk4gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIGlmICh0aGlzLklTTlVNQkVSKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdCAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuXHQgIH1cblx0ICBpZiAodmFsdWUgPT09IHRydWUpIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH1cblx0ICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cdCAgaWYgKHRoaXMuSVNFUlJPUih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIDA7XG5cdH07XG5cblx0ZXhwb3J0cy5OQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBlcnJvci5uYTtcblx0fTtcblxuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5TSEVFVCA9IGZ1bmN0aW9uKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignU0hFRVQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlNIRUVUUyA9IGZ1bmN0aW9uKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignU0hFRVRTIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVFlQRSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgaWYgKHRoaXMuSVNOVU1CRVIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdCAgaWYgKHRoaXMuSVNURVhUKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIDI7XG5cdCAgfVxuXHQgIGlmICh0aGlzLklTTE9HSUNBTCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiA0O1xuXHQgIH1cblx0ICBpZiAodGhpcy5JU0VSUk9SKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIDE2O1xuXHQgIH1cblx0ICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiA2NDtcblx0ICB9XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgalN0YXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLmpTdGF0O1xuXHR2YXIgdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBiZXNzZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuXHRmdW5jdGlvbiBpc1ZhbGlkQmluYXJ5TnVtYmVyKG51bWJlcikge1xuXHQgIHJldHVybiAoL15bMDFdezEsMTB9JC8pLnRlc3QobnVtYmVyKTtcblx0fVxuXG5cdGV4cG9ydHMuQkVTU0VMSSA9IGZ1bmN0aW9uKHgsIG4pIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBiZXNzZWwuYmVzc2VsaSh4LCBuKTtcblx0fTtcblxuXHRleHBvcnRzLkJFU1NFTEogPSBmdW5jdGlvbih4LCBuKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gYmVzc2VsLmJlc3NlbGooeCwgbik7XG5cdH07XG5cblx0ZXhwb3J0cy5CRVNTRUxLID0gZnVuY3Rpb24oeCwgbikge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGJlc3NlbC5iZXNzZWxrKHgsIG4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuQkVTU0VMWSA9IGZ1bmN0aW9uKHgsIG4pIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBiZXNzZWwuYmVzc2VseSh4LCBuKTtcblx0fTtcblxuXHRleHBvcnRzLkJJTjJERUMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBiaW5hcnkgb3IgY29udGFpbnMgbW9yZSB0aGFuIDEwIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIWlzVmFsaWRCaW5hcnlOdW1iZXIobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGJpbmFyeSBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDIpO1xuXG5cdCAgLy8gSGFuZGxlIG5lZ2F0aXZlIG51bWJlcnNcblx0ICB2YXIgc3RyaW5naWZpZWQgPSBudW1iZXIudG9TdHJpbmcoKTtcblx0ICBpZiAoc3RyaW5naWZpZWQubGVuZ3RoID09PSAxMCAmJiBzdHJpbmdpZmllZC5zdWJzdHJpbmcoMCwgMSkgPT09ICcxJykge1xuXHQgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZ2lmaWVkLnN1YnN0cmluZygxKSwgMikgLSA1MTI7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXHR9O1xuXG5cblx0ZXhwb3J0cy5CSU4ySEVYID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBiaW5hcnkgb3IgY29udGFpbnMgbW9yZSB0aGFuIDEwIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIWlzVmFsaWRCaW5hcnlOdW1iZXIobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgaGV4YWRlY2ltYWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIHZhciBzdHJpbmdpZmllZCA9IG51bWJlci50b1N0cmluZygpO1xuXHQgIGlmIChzdHJpbmdpZmllZC5sZW5ndGggPT09IDEwICYmIHN0cmluZ2lmaWVkLnN1YnN0cmluZygwLCAxKSA9PT0gJzEnKSB7XG5cdCAgICByZXR1cm4gKDEwOTk1MTE2MjcyNjQgKyBwYXJzZUludChzdHJpbmdpZmllZC5zdWJzdHJpbmcoMSksIDIpKS50b1N0cmluZygxNik7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBiaW5hcnkgbnVtYmVyIHRvIGhleGFkZWNpbWFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMikudG9TdHJpbmcoMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGhleGFkZWNpbWFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmIChwbGFjZXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQklOMk9DVCA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgYmluYXJ5IG9yIGNvbnRhaW5zIG1vcmUgdGhhbiAxMCBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCFpc1ZhbGlkQmluYXJ5TnVtYmVyKG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIG9jdGFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICB2YXIgc3RyaW5naWZpZWQgPSBudW1iZXIudG9TdHJpbmcoKTtcblx0ICBpZiAoc3RyaW5naWZpZWQubGVuZ3RoID09PSAxMCAmJiBzdHJpbmdpZmllZC5zdWJzdHJpbmcoMCwgMSkgPT09ICcxJykge1xuXHQgICAgcmV0dXJuICgxMDczNzQxMzEyICsgcGFyc2VJbnQoc3RyaW5naWZpZWQuc3Vic3RyaW5nKDEpLCAyKSkudG9TdHJpbmcoOCk7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBiaW5hcnkgbnVtYmVyIHRvIG9jdGFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMikudG9TdHJpbmcoOCk7XG5cblx0ICAvLyBSZXR1cm4gb2N0YWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRBTkQgPSBmdW5jdGlvbihudW1iZXIxLCBudW1iZXIyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgYSBub24tbnVtZXJpYyB2YWx1ZVxuXHQgIG51bWJlcjEgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIxKTtcblx0ICBudW1iZXIyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyMSwgbnVtYmVyMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIxIDwgMCB8fCBudW1iZXIyIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBhIG5vbi1pbnRlZ2VyXG5cdCAgaWYgKE1hdGguZmxvb3IobnVtYmVyMSkgIT09IG51bWJlcjEgfHwgTWF0aC5mbG9vcihudW1iZXIyKSAhPT0gbnVtYmVyMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBncmVhdGVyIHRoYW4gKDJeNDgpLTFcblx0ICBpZiAobnVtYmVyMSA+IDI4MTQ3NDk3NjcxMDY1NSB8fCBudW1iZXIyID4gMjgxNDc0OTc2NzEwNjU1KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBiaXR3aXNlIEFORCBvZiB0d28gbnVtYmVyc1xuXHQgIHJldHVybiBudW1iZXIxICYgbnVtYmVyMjtcblx0fTtcblxuXHRleHBvcnRzLkJJVExTSElGVCA9IGZ1bmN0aW9uKG51bWJlciwgc2hpZnQpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNoaWZ0ID0gdXRpbHMucGFyc2VOdW1iZXIoc2hpZnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2hpZnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcikgIT09IG51bWJlcikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBzaGlmdCBpcyBncmVhdGVyIHRoYW4gNTNcblx0ICBpZiAoTWF0aC5hYnMoc2hpZnQpID4gNTMpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBzaGlmdGVkIGJ5IHNoaWZ0IGJpdHMgdG8gdGhlIGxlZnQgb3IgdG8gdGhlIHJpZ2h0IGlmIHNoaWZ0IGlzIG5lZ2F0aXZlXG5cdCAgcmV0dXJuIChzaGlmdCA+PSAwKSA/IG51bWJlciA8PCBzaGlmdCA6IG51bWJlciA+PiAtc2hpZnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRPUiA9IGZ1bmN0aW9uKG51bWJlcjEsIG51bWJlcjIpIHtcblx0ICBudW1iZXIxID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMSk7XG5cdCAgbnVtYmVyMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcjEsIG51bWJlcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgbGVzcyB0aGFuIDBcblx0ICBpZiAobnVtYmVyMSA8IDAgfHwgbnVtYmVyMiA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcjEpICE9PSBudW1iZXIxIHx8IE1hdGguZmxvb3IobnVtYmVyMikgIT09IG51bWJlcjIpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgZ3JlYXRlciB0aGFuICgyXjQ4KS0xXG5cdCAgaWYgKG51bWJlcjEgPiAyODE0NzQ5NzY3MTA2NTUgfHwgbnVtYmVyMiA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYml0d2lzZSBPUiBvZiB0d28gbnVtYmVyc1xuXHQgIHJldHVybiBudW1iZXIxIHwgbnVtYmVyMjtcblx0fTtcblxuXHRleHBvcnRzLkJJVFJTSElGVCA9IGZ1bmN0aW9uKG51bWJlciwgc2hpZnQpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNoaWZ0ID0gdXRpbHMucGFyc2VOdW1iZXIoc2hpZnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2hpZnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcikgIT09IG51bWJlcikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBzaGlmdCBpcyBncmVhdGVyIHRoYW4gNTNcblx0ICBpZiAoTWF0aC5hYnMoc2hpZnQpID4gNTMpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBzaGlmdGVkIGJ5IHNoaWZ0IGJpdHMgdG8gdGhlIHJpZ2h0IG9yIHRvIHRoZSBsZWZ0IGlmIHNoaWZ0IGlzIG5lZ2F0aXZlXG5cdCAgcmV0dXJuIChzaGlmdCA+PSAwKSA/IG51bWJlciA+PiBzaGlmdCA6IG51bWJlciA8PCAtc2hpZnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRYT1IgPSBmdW5jdGlvbihudW1iZXIxLCBudW1iZXIyKSB7XG5cdCAgbnVtYmVyMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjEpO1xuXHQgIG51bWJlcjIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIxLCBudW1iZXIyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGxlc3MgdGhhbiAwXG5cdCAgaWYgKG51bWJlcjEgPCAwIHx8IG51bWJlcjIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGEgbm9uLWludGVnZXJcblx0ICBpZiAoTWF0aC5mbG9vcihudW1iZXIxKSAhPT0gbnVtYmVyMSB8fCBNYXRoLmZsb29yKG51bWJlcjIpICE9PSBudW1iZXIyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIxID4gMjgxNDc0OTc2NzEwNjU1IHx8IG51bWJlcjIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGJpdHdpc2UgWE9SIG9mIHR3byBudW1iZXJzXG5cdCAgcmV0dXJuIG51bWJlcjEgXiBudW1iZXIyO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09NUExFWCA9IGZ1bmN0aW9uKHJlYWwsIGltYWdpbmFyeSwgc3VmZml4KSB7XG5cdCAgcmVhbCA9IHV0aWxzLnBhcnNlTnVtYmVyKHJlYWwpO1xuXHQgIGltYWdpbmFyeSA9IHV0aWxzLnBhcnNlTnVtYmVyKGltYWdpbmFyeSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmVhbCwgaW1hZ2luYXJ5KSkge1xuXHQgICAgcmV0dXJuIHJlYWw7XG5cdCAgfVxuXG5cdCAgLy8gU2V0IHN1ZmZpeFxuXHQgIHN1ZmZpeCA9IChzdWZmaXggPT09IHVuZGVmaW5lZCkgPyAnaScgOiBzdWZmaXg7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc3VmZml4IGlzIG5laXRoZXIgXCJpXCIgbm9yIFwialwiXG5cdCAgaWYgKHN1ZmZpeCAhPT0gJ2knICYmIHN1ZmZpeCAhPT0gJ2onKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGNvbXBsZXggbnVtYmVyXG5cdCAgaWYgKHJlYWwgPT09IDAgJiYgaW1hZ2luYXJ5ID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2UgaWYgKHJlYWwgPT09IDApIHtcblx0ICAgIHJldHVybiAoaW1hZ2luYXJ5ID09PSAxKSA/IHN1ZmZpeCA6IGltYWdpbmFyeS50b1N0cmluZygpICsgc3VmZml4O1xuXHQgIH0gZWxzZSBpZiAoaW1hZ2luYXJ5ID09PSAwKSB7XG5cdCAgICByZXR1cm4gcmVhbC50b1N0cmluZygpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgc2lnbiA9IChpbWFnaW5hcnkgPiAwKSA/ICcrJyA6ICcnO1xuXHQgICAgcmV0dXJuIHJlYWwudG9TdHJpbmcoKSArIHNpZ24gKyAoKGltYWdpbmFyeSA9PT0gMSkgPyBzdWZmaXggOiBpbWFnaW5hcnkudG9TdHJpbmcoKSArIHN1ZmZpeCk7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQ09OVkVSVCA9IGZ1bmN0aW9uKG51bWJlciwgZnJvbV91bml0LCB0b191bml0KSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgLy8gTGlzdCBvZiB1bml0cyBzdXBwb3J0ZWQgYnkgQ09OVkVSVCBhbmQgdW5pdHMgZGVmaW5lZCBieSB0aGUgSW50ZXJuYXRpb25hbCBTeXN0ZW0gb2YgVW5pdHNcblx0ICAvLyBbTmFtZSwgU3ltYm9sLCBBbHRlcm5hdGUgc3ltYm9scywgUXVhbnRpdHksIElTVSwgQ09OVkVSVCwgQ29udmVyc2lvbiByYXRpb11cblx0ICB2YXIgdW5pdHMgPSBbXG5cdCAgICBbXCJhLnUuIG9mIGFjdGlvblwiLCBcIj9cIiwgbnVsbCwgXCJhY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCAxLjA1NDU3MTY4MTgxODE4ZS0zNF0sXG5cdCAgICBbXCJhLnUuIG9mIGNoYXJnZVwiLCBcImVcIiwgbnVsbCwgXCJlbGVjdHJpY19jaGFyZ2VcIiwgZmFsc2UsIGZhbHNlLCAxLjYwMjE3NjUzMTQxNDE0ZS0xOV0sXG5cdCAgICBbXCJhLnUuIG9mIGVuZXJneVwiLCBcIkVoXCIsIG51bGwsIFwiZW5lcmd5XCIsIGZhbHNlLCBmYWxzZSwgNC4zNTk3NDQxNzc1NzU3NmUtMThdLFxuXHQgICAgW1wiYS51LiBvZiBsZW5ndGhcIiwgXCJhP1wiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgZmFsc2UsIDUuMjkxNzcyMTA4MTgxODJlLTExXSxcblx0ICAgIFtcImEudS4gb2YgbWFzc1wiLCBcIm0/XCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgZmFsc2UsIDkuMTA5MzgyNjE2MTYxNjJlLTMxXSxcblx0ICAgIFtcImEudS4gb2YgdGltZVwiLCBcIj8vRWhcIiwgbnVsbCwgXCJ0aW1lXCIsIGZhbHNlLCBmYWxzZSwgMi40MTg4ODQzMjY1MDUxNmUtMTddLFxuXHQgICAgW1wiYWRtaXJhbHR5IGtub3RcIiwgXCJhZG1rblwiLCBudWxsLCBcInNwZWVkXCIsIGZhbHNlLCB0cnVlLCAwLjUxNDc3MzMzM10sXG5cdCAgICBbXCJhbXBlcmVcIiwgXCJBXCIsIG51bGwsIFwiZWxlY3RyaWNfY3VycmVudFwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJhbXBlcmUgcGVyIG1ldGVyXCIsIFwiQS9tXCIsIG51bGwsIFwibWFnbmV0aWNfZmllbGRfaW50ZW5zaXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcIsOlbmdzdHLDtm1cIiwgXCLDhVwiLCBbXCJhbmdcIl0sIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAxZS0xMF0sXG5cdCAgICBbXCJhcmVcIiwgXCJhclwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDEwMF0sXG5cdCAgICBbXCJhc3Ryb25vbWljYWwgdW5pdFwiLCBcInVhXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCBmYWxzZSwgMS40OTU5Nzg3MDY5MTY2N2UtMTFdLFxuXHQgICAgW1wiYmFyXCIsIFwiYmFyXCIsIG51bGwsIFwicHJlc3N1cmVcIiwgZmFsc2UsIGZhbHNlLCAxMDAwMDBdLFxuXHQgICAgW1wiYmFyblwiLCBcImJcIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCBmYWxzZSwgMWUtMjhdLFxuXHQgICAgW1wiYmVjcXVlcmVsXCIsIFwiQnFcIiwgbnVsbCwgXCJyYWRpb2FjdGl2aXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImJpdFwiLCBcImJpdFwiLCBbXCJiXCJdLCBcImluZm9ybWF0aW9uXCIsIGZhbHNlLCB0cnVlLCAxXSxcblx0ICAgIFtcImJ0dVwiLCBcIkJUVVwiLCBbXCJidHVcIl0sIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAxMDU1LjA1NTg1MjYyXSxcblx0ICAgIFtcImJ5dGVcIiwgXCJieXRlXCIsIG51bGwsIFwiaW5mb3JtYXRpb25cIiwgZmFsc2UsIHRydWUsIDhdLFxuXHQgICAgW1wiY2FuZGVsYVwiLCBcImNkXCIsIG51bGwsIFwibHVtaW5vdXNfaW50ZW5zaXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImNhbmRlbGEgcGVyIHNxdWFyZSBtZXRyZVwiLCBcImNkL20/XCIsIG51bGwsIFwibHVtaW5hbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImNvdWxvbWJcIiwgXCJDXCIsIG51bGwsIFwiZWxlY3RyaWNfY2hhcmdlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImN1YmljIMOlbmdzdHLDtm1cIiwgXCJhbmczXCIsIFtcImFuZ14zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMWUtMzBdLFxuXHQgICAgW1wiY3ViaWMgZm9vdFwiLCBcImZ0M1wiLCBbXCJmdF4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMjgzMTY4NDY1OTJdLFxuXHQgICAgW1wiY3ViaWMgaW5jaFwiLCBcImluM1wiLCBbXCJpbl4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMTYzODcwNjRdLFxuXHQgICAgW1wiY3ViaWMgbGlnaHQteWVhclwiLCBcImx5M1wiLCBbXCJseV4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgOC40Njc4NjY2NDYyMzcxNWUtNDddLFxuXHQgICAgW1wiY3ViaWMgbWV0cmVcIiwgXCJtP1wiLCBudWxsLCBcInZvbHVtZVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcImN1YmljIG1pbGVcIiwgXCJtaTNcIiwgW1wibWleM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDQxNjgxODE4MjUuNDQwNThdLFxuXHQgICAgW1wiY3ViaWMgbmF1dGljYWwgbWlsZVwiLCBcIk5taTNcIiwgW1wiTm1pXjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCA2MzUyMTgyMjA4XSxcblx0ICAgIFtcImN1YmljIFBpY2FcIiwgXCJQaWNhM1wiLCBbXCJQaWNhcHQzXCIsIFwiUGljYV4zXCIsIFwiUGljYXB0XjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCA3LjU4NjYwMzcwMzcwMzY5ZS04XSxcblx0ICAgIFtcImN1YmljIHlhcmRcIiwgXCJ5ZDNcIiwgW1wieWReM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuNzY0NTU0ODU3OTg0XSxcblx0ICAgIFtcImN1cFwiLCBcImN1cFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAyMzY1ODgyMzY1XSxcblx0ICAgIFtcImRhbHRvblwiLCBcIkRhXCIsIFtcInVcIl0sIFwibWFzc1wiLCBmYWxzZSwgZmFsc2UsIDEuNjYwNTM4ODYyODI4MjhlLTI3XSxcblx0ICAgIFtcImRheVwiLCBcImRcIiwgW1wiZGF5XCJdLCBcInRpbWVcIiwgZmFsc2UsIHRydWUsIDg2NDAwXSxcblx0ICAgIFtcImRlZ3JlZVwiLCBcIsKwXCIsIG51bGwsIFwiYW5nbGVcIiwgZmFsc2UsIGZhbHNlLCAwLjAxNzQ1MzI5MjUxOTk0MzNdLFxuXHQgICAgW1wiZGVncmVlcyBSYW5raW5lXCIsIFwiUmFua1wiLCBudWxsLCBcInRlbXBlcmF0dXJlXCIsIGZhbHNlLCB0cnVlLCAwLjU1NTU1NTU1NTU1NTU1Nl0sXG5cdCAgICBbXCJkeW5lXCIsIFwiZHluXCIsIFtcImR5XCJdLCBcImZvcmNlXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAxXSxcblx0ICAgIFtcImVsZWN0cm9udm9sdFwiLCBcImVWXCIsIFtcImV2XCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMS42MDIxNzY1NjUxNDE0MV0sXG5cdCAgICBbXCJlbGxcIiwgXCJlbGxcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDEuMTQzXSxcblx0ICAgIFtcImVyZ1wiLCBcImVyZ1wiLCBbXCJlXCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMWUtN10sXG5cdCAgICBbXCJmYXJhZFwiLCBcIkZcIiwgbnVsbCwgXCJlbGVjdHJpY19jYXBhY2l0YW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJmbHVpZCBvdW5jZVwiLCBcIm96XCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAyOTU3MzUyOTU2MjVdLFxuXHQgICAgW1wiZm9vdFwiLCBcImZ0XCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAwLjMwNDhdLFxuXHQgICAgW1wiZm9vdC1wb3VuZFwiLCBcImZsYlwiLCBudWxsLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMS4zNTU4MTc5NDgzMzE0XSxcblx0ICAgIFtcImdhbFwiLCBcIkdhbFwiLCBudWxsLCBcImFjY2VsZXJhdGlvblwiLCBmYWxzZSwgZmFsc2UsIDAuMDFdLFxuXHQgICAgW1wiZ2FsbG9uXCIsIFwiZ2FsXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMzc4NTQxMTc4NF0sXG5cdCAgICBbXCJnYXVzc1wiLCBcIkdcIiwgW1wiZ2FcIl0sIFwibWFnbmV0aWNfZmx1eF9kZW5zaXR5XCIsIGZhbHNlLCB0cnVlLCAxXSxcblx0ICAgIFtcImdyYWluXCIsIFwiZ3JhaW5cIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDA2NDc5ODldLFxuXHQgICAgW1wiZ3JhbVwiLCBcImdcIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAwLjAwMV0sXG5cdCAgICBbXCJncmF5XCIsIFwiR3lcIiwgbnVsbCwgXCJhYnNvcmJlZF9kb3NlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImdyb3NzIHJlZ2lzdGVyZWQgdG9uXCIsIFwiR1JUXCIsIFtcInJlZ3RvblwiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDIuODMxNjg0NjU5Ml0sXG5cdCAgICBbXCJoZWN0YXJlXCIsIFwiaGFcIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAxMDAwMF0sXG5cdCAgICBbXCJoZW5yeVwiLCBcIkhcIiwgbnVsbCwgXCJpbmR1Y3RhbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImhlcnR6XCIsIFwiSHpcIiwgbnVsbCwgXCJmcmVxdWVuY3lcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiaG9yc2Vwb3dlclwiLCBcIkhQXCIsIFtcImhcIl0sIFwicG93ZXJcIiwgZmFsc2UsIHRydWUsIDc0NS42OTk4NzE1ODIyN10sXG5cdCAgICBbXCJob3JzZXBvd2VyLWhvdXJcIiwgXCJIUGhcIiwgW1wiaGhcIiwgXCJocGhcIl0sIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAyNjg0NTE5LjUzOF0sXG5cdCAgICBbXCJob3VyXCIsIFwiaFwiLCBbXCJoclwiXSwgXCJ0aW1lXCIsIGZhbHNlLCB0cnVlLCAzNjAwXSxcblx0ICAgIFtcImltcGVyaWFsIGdhbGxvbiAoVS5LLilcIiwgXCJ1a19nYWxcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDA0NTQ2MDldLFxuXHQgICAgW1wiaW1wZXJpYWwgaHVuZHJlZHdlaWdodFwiLCBcImxjd3RcIiwgW1widWtfY3d0XCIsIFwiaHdlaWdodFwiXSwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCA1MC44MDIzNDVdLFxuXHQgICAgW1wiaW1wZXJpYWwgcXVhcnQgKFUuSylcIiwgXCJ1a19xdFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDExMzY1MjI1XSxcblx0ICAgIFtcImltcGVyaWFsIHRvblwiLCBcImJydG9uXCIsIFtcInVrX3RvblwiLCBcIkxUT05cIl0sIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMTAxNi4wNDY5MDldLFxuXHQgICAgW1wiaW5jaFwiLCBcImluXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAwLjAyNTRdLFxuXHQgICAgW1wiaW50ZXJuYXRpb25hbCBhY3JlXCIsIFwidWtfYWNyZVwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDQwNDYuODU2NDIyNF0sXG5cdCAgICBbXCJJVCBjYWxvcmllXCIsIFwiY2FsXCIsIG51bGwsIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCA0LjE4NjhdLFxuXHQgICAgW1wiam91bGVcIiwgXCJKXCIsIG51bGwsIFwiZW5lcmd5XCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wia2F0YWxcIiwgXCJrYXRcIiwgbnVsbCwgXCJjYXRhbHl0aWNfYWN0aXZpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wia2VsdmluXCIsIFwiS1wiLCBbXCJrZWxcIl0sIFwidGVtcGVyYXR1cmVcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJraWxvZ3JhbVwiLCBcImtnXCIsIG51bGwsIFwibWFzc1wiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcImtub3RcIiwgXCJrblwiLCBudWxsLCBcInNwZWVkXCIsIGZhbHNlLCB0cnVlLCAwLjUxNDQ0NDQ0NDQ0NDQ0NF0sXG5cdCAgICBbXCJsaWdodC15ZWFyXCIsIFwibHlcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDk0NjA3MzA0NzI1ODA4MDBdLFxuXHQgICAgW1wibGl0cmVcIiwgXCJMXCIsIFtcImxcIiwgXCJsdFwiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAxXSxcblx0ICAgIFtcImx1bWVuXCIsIFwibG1cIiwgbnVsbCwgXCJsdW1pbm91c19mbHV4XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImx1eFwiLCBcImx4XCIsIG51bGwsIFwiaWxsdW1pbmFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wibWF4d2VsbFwiLCBcIk14XCIsIG51bGwsIFwibWFnbmV0aWNfZmx1eFwiLCBmYWxzZSwgZmFsc2UsIDFlLTE4XSxcblx0ICAgIFtcIm1lYXN1cmVtZW50IHRvblwiLCBcIk1UT05cIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDEuMTMyNjczODYzNjhdLFxuXHQgICAgW1wibWV0ZXIgcGVyIGhvdXJcIiwgXCJtL2hcIiwgW1wibS9oclwiXSwgXCJzcGVlZFwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAyNzc3Nzc3Nzc3Nzc3OF0sXG5cdCAgICBbXCJtZXRlciBwZXIgc2Vjb25kXCIsIFwibS9zXCIsIFtcIm0vc2VjXCJdLCBcInNwZWVkXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wibWV0ZXIgcGVyIHNlY29uZCBzcXVhcmVkXCIsIFwibT9zPz9cIiwgbnVsbCwgXCJhY2NlbGVyYXRpb25cIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wicGFyc2VjXCIsIFwicGNcIiwgW1wicGFyc2VjXCJdLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMzA4NTY3NzU4MTQ2NzE5MDBdLFxuXHQgICAgW1wibWV0ZXIgc3F1YXJlZCBwZXIgc2Vjb25kXCIsIFwibT8vc1wiLCBudWxsLCBcImtpbmVtYXRpY192aXNjb3NpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wibWV0cmVcIiwgXCJtXCIsIG51bGwsIFwibGVuZ3RoXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wibWlsZXMgcGVyIGhvdXJcIiwgXCJtcGhcIiwgbnVsbCwgXCJzcGVlZFwiLCBmYWxzZSwgdHJ1ZSwgMC40NDcwNF0sXG5cdCAgICBbXCJtaWxsaW1ldHJlIG9mIG1lcmN1cnlcIiwgXCJtbUhnXCIsIG51bGwsIFwicHJlc3N1cmVcIiwgZmFsc2UsIGZhbHNlLCAxMzMuMzIyXSxcblx0ICAgIFtcIm1pbnV0ZVwiLCBcIj9cIiwgbnVsbCwgXCJhbmdsZVwiLCBmYWxzZSwgZmFsc2UsIDAuMDAwMjkwODg4MjA4NjY1NzIyXSxcblx0ICAgIFtcIm1pbnV0ZVwiLCBcIm1pblwiLCBbXCJtblwiXSwgXCJ0aW1lXCIsIGZhbHNlLCB0cnVlLCA2MF0sXG5cdCAgICBbXCJtb2Rlcm4gdGVhc3Bvb25cIiwgXCJ0c3BtXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAwNV0sXG5cdCAgICBbXCJtb2xlXCIsIFwibW9sXCIsIG51bGwsIFwiYW1vdW50X29mX3N1YnN0YW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJtb3JnZW5cIiwgXCJNb3JnZW5cIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAyNTAwXSxcblx0ICAgIFtcIm4udS4gb2YgYWN0aW9uXCIsIFwiP1wiLCBudWxsLCBcImFjdGlvblwiLCBmYWxzZSwgZmFsc2UsIDEuMDU0NTcxNjgxODE4MThlLTM0XSxcblx0ICAgIFtcIm4udS4gb2YgbWFzc1wiLCBcIm0/XCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgZmFsc2UsIDkuMTA5MzgyNjE2MTYxNjJlLTMxXSxcblx0ICAgIFtcIm4udS4gb2Ygc3BlZWRcIiwgXCJjP1wiLCBudWxsLCBcInNwZWVkXCIsIGZhbHNlLCBmYWxzZSwgMjk5NzkyNDU4XSxcblx0ICAgIFtcIm4udS4gb2YgdGltZVwiLCBcIj8vKG1lP2M/PylcIiwgbnVsbCwgXCJ0aW1lXCIsIGZhbHNlLCBmYWxzZSwgMS4yODgwODg2Njc3ODY4N2UtMjFdLFxuXHQgICAgW1wibmF1dGljYWwgbWlsZVwiLCBcIk1cIiwgW1wiTm1pXCJdLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMTg1Ml0sXG5cdCAgICBbXCJuZXd0b25cIiwgXCJOXCIsIG51bGwsIFwiZm9yY2VcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCLFk3JzdGVkXCIsIFwiT2UgXCIsIG51bGwsIFwibWFnbmV0aWNfZmllbGRfaW50ZW5zaXR5XCIsIGZhbHNlLCBmYWxzZSwgNzkuNTc3NDcxNTQ1OTQ3N10sXG5cdCAgICBbXCJvaG1cIiwgXCLOqVwiLCBudWxsLCBcImVsZWN0cmljX3Jlc2lzdGFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wib3VuY2UgbWFzc1wiLCBcIm96bVwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDAuMDI4MzQ5NTIzMTI1XSxcblx0ICAgIFtcInBhc2NhbFwiLCBcIlBhXCIsIG51bGwsIFwicHJlc3N1cmVcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wicGFzY2FsIHNlY29uZFwiLCBcIlBhP3NcIiwgbnVsbCwgXCJkeW5hbWljX3Zpc2Nvc2l0eVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJwZmVyZGVzdMOkcmtlXCIsIFwiUFNcIiwgbnVsbCwgXCJwb3dlclwiLCBmYWxzZSwgdHJ1ZSwgNzM1LjQ5ODc1XSxcblx0ICAgIFtcInBob3RcIiwgXCJwaFwiLCBudWxsLCBcImlsbHVtaW5hbmNlXCIsIGZhbHNlLCBmYWxzZSwgMC4wMDAxXSxcblx0ICAgIFtcInBpY2EgKDEvNiBpbmNoKVwiLCBcInBpY2FcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDAuMDAwMzUyNzc3Nzc3Nzc3NzhdLFxuXHQgICAgW1wicGljYSAoMS83MiBpbmNoKVwiLCBcIlBpY2FcIiwgW1wiUGljYXB0XCJdLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDQyMzMzMzMzMzMzMzMzM10sXG5cdCAgICBbXCJwb2lzZVwiLCBcIlBcIiwgbnVsbCwgXCJkeW5hbWljX3Zpc2Nvc2l0eVwiLCBmYWxzZSwgZmFsc2UsIDAuMV0sXG5cdCAgICBbXCJwb25kXCIsIFwicG9uZFwiLCBudWxsLCBcImZvcmNlXCIsIGZhbHNlLCB0cnVlLCAwLjAwOTgwNjY1XSxcblx0ICAgIFtcInBvdW5kIGZvcmNlXCIsIFwibGJmXCIsIG51bGwsIFwiZm9yY2VcIiwgZmFsc2UsIHRydWUsIDQuNDQ4MjIxNjE1MjYwNV0sXG5cdCAgICBbXCJwb3VuZCBtYXNzXCIsIFwibGJtXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMC40NTM1OTIzN10sXG5cdCAgICBbXCJxdWFydFwiLCBcInF0XCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDk0NjM1Mjk0Nl0sXG5cdCAgICBbXCJyYWRpYW5cIiwgXCJyYWRcIiwgbnVsbCwgXCJhbmdsZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJzZWNvbmRcIiwgXCI/XCIsIG51bGwsIFwiYW5nbGVcIiwgZmFsc2UsIGZhbHNlLCAwLjAwMDAwNDg0ODEzNjgxMTA5NTM2XSxcblx0ICAgIFtcInNlY29uZFwiLCBcInNcIiwgW1wic2VjXCJdLCBcInRpbWVcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJzaG9ydCBodW5kcmVkd2VpZ2h0XCIsIFwiY3d0XCIsIFtcInNod2VpZ2h0XCJdLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDQ1LjM1OTIzN10sXG5cdCAgICBbXCJzaWVtZW5zXCIsIFwiU1wiLCBudWxsLCBcImVsZWN0cmljYWxfY29uZHVjdGFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wic2lldmVydFwiLCBcIlN2XCIsIG51bGwsIFwiZXF1aXZhbGVudF9kb3NlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInNsdWdcIiwgXCJzZ1wiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDE0LjU5MzkwMjk0XSxcblx0ICAgIFtcInNxdWFyZSDDpW5nc3Ryw7ZtXCIsIFwiYW5nMlwiLCBbXCJhbmdeMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAxZS0yMF0sXG5cdCAgICBbXCJzcXVhcmUgZm9vdFwiLCBcImZ0MlwiLCBbXCJmdF4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDAuMDkyOTAzMDRdLFxuXHQgICAgW1wic3F1YXJlIGluY2hcIiwgXCJpbjJcIiwgW1wiaW5eMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDY0NTE2XSxcblx0ICAgIFtcInNxdWFyZSBsaWdodC15ZWFyXCIsIFwibHkyXCIsIFtcImx5XjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgOC45NTA1NDIxMDc0ODE4OWUrMzFdLFxuXHQgICAgW1wic3F1YXJlIG1ldGVyXCIsIFwibT9cIiwgbnVsbCwgXCJhcmVhXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wic3F1YXJlIG1pbGVcIiwgXCJtaTJcIiwgW1wibWleMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAyNTg5OTg4LjExMDMzNl0sXG5cdCAgICBbXCJzcXVhcmUgbmF1dGljYWwgbWlsZVwiLCBcIk5taTJcIiwgW1wiTm1pXjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMzQyOTkwNF0sXG5cdCAgICBbXCJzcXVhcmUgUGljYVwiLCBcIlBpY2EyXCIsIFtcIlBpY2FwdDJcIiwgXCJQaWNhXjJcIiwgXCJQaWNhcHReMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAxNzkyMTExMTExMTExXSxcblx0ICAgIFtcInNxdWFyZSB5YXJkXCIsIFwieWQyXCIsIFtcInlkXjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMC44MzYxMjczNl0sXG5cdCAgICBbXCJzdGF0dXRlIG1pbGVcIiwgXCJtaVwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMTYwOS4zNDRdLFxuXHQgICAgW1wic3RlcmFkaWFuXCIsIFwic3JcIiwgbnVsbCwgXCJzb2xpZF9hbmdsZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJzdGlsYlwiLCBcInNiXCIsIG51bGwsIFwibHVtaW5hbmNlXCIsIGZhbHNlLCBmYWxzZSwgMC4wMDAxXSxcblx0ICAgIFtcInN0b2tlc1wiLCBcIlN0XCIsIG51bGwsIFwia2luZW1hdGljX3Zpc2Nvc2l0eVwiLCBmYWxzZSwgZmFsc2UsIDAuMDAwMV0sXG5cdCAgICBbXCJzdG9uZVwiLCBcInN0b25lXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgNi4zNTAyOTMxOF0sXG5cdCAgICBbXCJ0YWJsZXNwb29uXCIsIFwidGJzXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAxNDc4NjhdLFxuXHQgICAgW1widGVhc3Bvb25cIiwgXCJ0c3BcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDA0OTI4OTJdLFxuXHQgICAgW1widGVzbGFcIiwgXCJUXCIsIG51bGwsIFwibWFnbmV0aWNfZmx1eF9kZW5zaXR5XCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1widGhlcm1vZHluYW1pYyBjYWxvcmllXCIsIFwiY1wiLCBudWxsLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgNC4xODRdLFxuXHQgICAgW1widG9uXCIsIFwidG9uXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgOTA3LjE4NDc0XSxcblx0ICAgIFtcInRvbm5lXCIsIFwidFwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIGZhbHNlLCAxMDAwXSxcblx0ICAgIFtcIlUuSy4gcGludFwiLCBcInVrX3B0XCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDU2ODI2MTI1XSxcblx0ICAgIFtcIlUuUy4gYnVzaGVsXCIsIFwiYnVzaGVsXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAzNTIzOTA3XSxcblx0ICAgIFtcIlUuUy4gb2lsIGJhcnJlbFwiLCBcImJhcnJlbFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4xNTg5ODcyOTVdLFxuXHQgICAgW1wiVS5TLiBwaW50XCIsIFwicHRcIiwgW1widXNfcHRcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDQ3MzE3NjQ3M10sXG5cdCAgICBbXCJVLlMuIHN1cnZleSBtaWxlXCIsIFwic3VydmV5X21pXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAxNjA5LjM0NzIxOV0sXG5cdCAgICBbXCJVLlMuIHN1cnZleS9zdGF0dXRlIGFjcmVcIiwgXCJ1c19hY3JlXCIsIG51bGwsIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgNDA0Ni44NzI2MV0sXG5cdCAgICBbXCJ2b2x0XCIsIFwiVlwiLCBudWxsLCBcInZvbHRhZ2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wid2F0dFwiLCBcIldcIiwgbnVsbCwgXCJwb3dlclwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcIndhdHQtaG91clwiLCBcIldoXCIsIFtcIndoXCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMzYwMF0sXG5cdCAgICBbXCJ3ZWJlclwiLCBcIldiXCIsIG51bGwsIFwibWFnbmV0aWNfZmx1eFwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJ5YXJkXCIsIFwieWRcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDAuOTE0NF0sXG5cdCAgICBbXCJ5ZWFyXCIsIFwieXJcIiwgbnVsbCwgXCJ0aW1lXCIsIGZhbHNlLCB0cnVlLCAzMTU1NzYwMF1cblx0ICBdO1xuXG5cdCAgLy8gQmluYXJ5IHByZWZpeGVzXG5cdCAgLy8gW05hbWUsIFByZWZpeCBwb3dlciBvZiAyIHZhbHVlLCBQcmV2aXggdmFsdWUsIEFiYnJldmlhdGlvbiwgRGVyaXZlZCBmcm9tXVxuXHQgIHZhciBiaW5hcnlfcHJlZml4ZXMgPSB7XG5cdCAgICBZaTogW1wieW9iaVwiLCA4MCwgMTIwODkyNTgxOTYxNDYyOTE3NDcwNjE3NiwgXCJZaVwiLCBcInlvdHRhXCJdLFxuXHQgICAgWmk6IFtcInplYmlcIiwgNzAsIDExODA1OTE2MjA3MTc0MTEzMDM0MjQsIFwiWmlcIiwgXCJ6ZXR0YVwiXSxcblx0ICAgIEVpOiBbXCJleGJpXCIsIDYwLCAxMTUyOTIxNTA0NjA2ODQ2OTc2LCBcIkVpXCIsIFwiZXhhXCJdLFxuXHQgICAgUGk6IFtcInBlYmlcIiwgNTAsIDExMjU4OTk5MDY4NDI2MjQsIFwiUGlcIiwgXCJwZXRhXCJdLFxuXHQgICAgVGk6IFtcInRlYmlcIiwgNDAsIDEwOTk1MTE2Mjc3NzYsIFwiVGlcIiwgXCJ0ZXJhXCJdLFxuXHQgICAgR2k6IFtcImdpYmlcIiwgMzAsIDEwNzM3NDE4MjQsIFwiR2lcIiwgXCJnaWdhXCJdLFxuXHQgICAgTWk6IFtcIm1lYmlcIiwgMjAsIDEwNDg1NzYsIFwiTWlcIiwgXCJtZWdhXCJdLFxuXHQgICAga2k6IFtcImtpYmlcIiwgMTAsIDEwMjQsIFwia2lcIiwgXCJraWxvXCJdXG5cdCAgfTtcblxuXHQgIC8vIFVuaXQgcHJlZml4ZXNcblx0ICAvLyBbTmFtZSwgTXVsdGlwbGllciwgQWJicmV2aWF0aW9uXVxuXHQgIHZhciB1bml0X3ByZWZpeGVzID0ge1xuXHQgICAgWTogW1wieW90dGFcIiwgMWUrMjQsIFwiWVwiXSxcblx0ICAgIFo6IFtcInpldHRhXCIsIDFlKzIxLCBcIlpcIl0sXG5cdCAgICBFOiBbXCJleGFcIiwgMWUrMTgsIFwiRVwiXSxcblx0ICAgIFA6IFtcInBldGFcIiwgMWUrMTUsIFwiUFwiXSxcblx0ICAgIFQ6IFtcInRlcmFcIiwgMWUrMTIsIFwiVFwiXSxcblx0ICAgIEc6IFtcImdpZ2FcIiwgMWUrMDksIFwiR1wiXSxcblx0ICAgIE06IFtcIm1lZ2FcIiwgMWUrMDYsIFwiTVwiXSxcblx0ICAgIGs6IFtcImtpbG9cIiwgMWUrMDMsIFwia1wiXSxcblx0ICAgIGg6IFtcImhlY3RvXCIsIDFlKzAyLCBcImhcIl0sXG5cdCAgICBlOiBbXCJkZWthb1wiLCAxZSswMSwgXCJlXCJdLFxuXHQgICAgZDogW1wiZGVjaVwiLCAxZS0wMSwgXCJkXCJdLFxuXHQgICAgYzogW1wiY2VudGlcIiwgMWUtMDIsIFwiY1wiXSxcblx0ICAgIG06IFtcIm1pbGxpXCIsIDFlLTAzLCBcIm1cIl0sXG5cdCAgICB1OiBbXCJtaWNyb1wiLCAxZS0wNiwgXCJ1XCJdLFxuXHQgICAgbjogW1wibmFub1wiLCAxZS0wOSwgXCJuXCJdLFxuXHQgICAgcDogW1wicGljb1wiLCAxZS0xMiwgXCJwXCJdLFxuXHQgICAgZjogW1wiZmVtdG9cIiwgMWUtMTUsIFwiZlwiXSxcblx0ICAgIGE6IFtcImF0dG9cIiwgMWUtMTgsIFwiYVwiXSxcblx0ICAgIHo6IFtcInplcHRvXCIsIDFlLTIxLCBcInpcIl0sXG5cdCAgICB5OiBbXCJ5b2N0b1wiLCAxZS0yNCwgXCJ5XCJdXG5cdCAgfTtcblxuXHQgIC8vIEluaXRpYWxpemUgdW5pdHMgYW5kIG11bHRpcGxpZXJzXG5cdCAgdmFyIGZyb20gPSBudWxsO1xuXHQgIHZhciB0byA9IG51bGw7XG5cdCAgdmFyIGJhc2VfZnJvbV91bml0ID0gZnJvbV91bml0O1xuXHQgIHZhciBiYXNlX3RvX3VuaXQgPSB0b191bml0O1xuXHQgIHZhciBmcm9tX211bHRpcGxpZXIgPSAxO1xuXHQgIHZhciB0b19tdWx0aXBsaWVyID0gMTtcblx0ICB2YXIgYWx0O1xuXG5cdCAgLy8gTG9va3VwIGZyb20gYW5kIHRvIHVuaXRzXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgYWx0ID0gKHVuaXRzW2ldWzJdID09PSBudWxsKSA/IFtdIDogdW5pdHNbaV1bMl07XG5cdCAgICBpZiAodW5pdHNbaV1bMV0gPT09IGJhc2VfZnJvbV91bml0IHx8IGFsdC5pbmRleE9mKGJhc2VfZnJvbV91bml0KSA+PSAwKSB7XG5cdCAgICAgIGZyb20gPSB1bml0c1tpXTtcblx0ICAgIH1cblx0ICAgIGlmICh1bml0c1tpXVsxXSA9PT0gYmFzZV90b191bml0IHx8IGFsdC5pbmRleE9mKGJhc2VfdG9fdW5pdCkgPj0gMCkge1xuXHQgICAgICB0byA9IHVuaXRzW2ldO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBmcm9tIHByZWZpeFxuXHQgIGlmIChmcm9tID09PSBudWxsKSB7XG5cdCAgICB2YXIgZnJvbV9iaW5hcnlfcHJlZml4ID0gYmluYXJ5X3ByZWZpeGVzW2Zyb21fdW5pdC5zdWJzdHJpbmcoMCwgMildO1xuXHQgICAgdmFyIGZyb21fdW5pdF9wcmVmaXggPSB1bml0X3ByZWZpeGVzW2Zyb21fdW5pdC5zdWJzdHJpbmcoMCwgMSldO1xuXG5cdCAgICAvLyBIYW5kbGUgZGVrYW8gdW5pdCBwcmVmaXggKG9ubHkgdW5pdCBwcmVmaXggd2l0aCB0d28gY2hhcmFjdGVycylcblx0ICAgIGlmIChmcm9tX3VuaXQuc3Vic3RyaW5nKDAsIDIpID09PSAnZGEnKSB7XG5cdCAgICAgIGZyb21fdW5pdF9wcmVmaXggPSBbXCJkZWthb1wiLCAxZSswMSwgXCJkYVwiXTtcblx0ICAgIH1cblxuXHQgICAgLy8gSGFuZGxlIGJpbmFyeSBwcmVmaXhlcyBmaXJzdCAoc28gdGhhdCAnWWknIGlzIHByb2Nlc3NlZCBiZWZvcmUgJ1knKVxuXHQgICAgaWYgKGZyb21fYmluYXJ5X3ByZWZpeCkge1xuXHQgICAgICBmcm9tX211bHRpcGxpZXIgPSBmcm9tX2JpbmFyeV9wcmVmaXhbMl07XG5cdCAgICAgIGJhc2VfZnJvbV91bml0ID0gZnJvbV91bml0LnN1YnN0cmluZygyKTtcblx0ICAgIH0gZWxzZSBpZiAoZnJvbV91bml0X3ByZWZpeCkge1xuXHQgICAgICBmcm9tX211bHRpcGxpZXIgPSBmcm9tX3VuaXRfcHJlZml4WzFdO1xuXHQgICAgICBiYXNlX2Zyb21fdW5pdCA9IGZyb21fdW5pdC5zdWJzdHJpbmcoZnJvbV91bml0X3ByZWZpeFsyXS5sZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMb29rdXAgZnJvbSB1bml0XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaXRzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIGFsdCA9ICh1bml0c1tqXVsyXSA9PT0gbnVsbCkgPyBbXSA6IHVuaXRzW2pdWzJdO1xuXHQgICAgICBpZiAodW5pdHNbal1bMV0gPT09IGJhc2VfZnJvbV91bml0IHx8IGFsdC5pbmRleE9mKGJhc2VfZnJvbV91bml0KSA+PSAwKSB7XG5cdCAgICAgICAgZnJvbSA9IHVuaXRzW2pdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHRvIHByZWZpeFxuXHQgIGlmICh0byA9PT0gbnVsbCkge1xuXHQgICAgdmFyIHRvX2JpbmFyeV9wcmVmaXggPSBiaW5hcnlfcHJlZml4ZXNbdG9fdW5pdC5zdWJzdHJpbmcoMCwgMildO1xuXHQgICAgdmFyIHRvX3VuaXRfcHJlZml4ID0gdW5pdF9wcmVmaXhlc1t0b191bml0LnN1YnN0cmluZygwLCAxKV07XG5cblx0ICAgIC8vIEhhbmRsZSBkZWthbyB1bml0IHByZWZpeCAob25seSB1bml0IHByZWZpeCB3aXRoIHR3byBjaGFyYWN0ZXJzKVxuXHQgICAgaWYgKHRvX3VuaXQuc3Vic3RyaW5nKDAsIDIpID09PSAnZGEnKSB7XG5cdCAgICAgIHRvX3VuaXRfcHJlZml4ID0gW1wiZGVrYW9cIiwgMWUrMDEsIFwiZGFcIl07XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSBiaW5hcnkgcHJlZml4ZXMgZmlyc3QgKHNvIHRoYXQgJ1lpJyBpcyBwcm9jZXNzZWQgYmVmb3JlICdZJylcblx0ICAgIGlmICh0b19iaW5hcnlfcHJlZml4KSB7XG5cdCAgICAgIHRvX211bHRpcGxpZXIgPSB0b19iaW5hcnlfcHJlZml4WzJdO1xuXHQgICAgICBiYXNlX3RvX3VuaXQgPSB0b191bml0LnN1YnN0cmluZygyKTtcblx0ICAgIH0gZWxzZSBpZiAodG9fdW5pdF9wcmVmaXgpIHtcblx0ICAgICAgdG9fbXVsdGlwbGllciA9IHRvX3VuaXRfcHJlZml4WzFdO1xuXHQgICAgICBiYXNlX3RvX3VuaXQgPSB0b191bml0LnN1YnN0cmluZyh0b191bml0X3ByZWZpeFsyXS5sZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMb29rdXAgdG8gdW5pdFxuXHQgICAgZm9yICh2YXIgayA9IDA7IGsgPCB1bml0cy5sZW5ndGg7IGsrKykge1xuXHQgICAgICBhbHQgPSAodW5pdHNba11bMl0gPT09IG51bGwpID8gW10gOiB1bml0c1trXVsyXTtcblx0ICAgICAgaWYgKHVuaXRzW2tdWzFdID09PSBiYXNlX3RvX3VuaXQgfHwgYWx0LmluZGV4T2YoYmFzZV90b191bml0KSA+PSAwKSB7XG5cdCAgICAgICAgdG8gPSB1bml0c1trXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBhIHVuaXQgZG9lcyBub3QgZXhpc3Rcblx0ICBpZiAoZnJvbSA9PT0gbnVsbCB8fCB0byA9PT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB1bml0cyByZXByZXNlbnQgZGlmZmVyZW50IHF1YW50aXRpZXNcblx0ICBpZiAoZnJvbVszXSAhPT0gdG9bM10pIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gY29udmVydGVkIG51bWJlclxuXHQgIHJldHVybiBudW1iZXIgKiBmcm9tWzZdICogZnJvbV9tdWx0aXBsaWVyIC8gKHRvWzZdICogdG9fbXVsdGlwbGllcik7XG5cdH07XG5cblx0ZXhwb3J0cy5ERUMyQklOID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBkZWNpbWFsLCBpcyBsb3dlciB0aGFuIC01MTIsIG9yIGlzIGdyZWF0ZXIgdGhhbiA1MTFcblx0ICBpZiAoIS9eLT9bMC05XXsxLDN9JC8udGVzdChudW1iZXIpIHx8IG51bWJlciA8IC01MTIgfHwgbnVtYmVyID4gNTExKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBiaW5hcnkgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gJzEnICsgdGV4dC5SRVBUKCcwJywgOSAtICg1MTIgKyBudW1iZXIpLnRvU3RyaW5nKDIpLmxlbmd0aCkgKyAoNTEyICsgbnVtYmVyKS50b1N0cmluZygyKTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGJpbmFyeVxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDEwKS50b1N0cmluZygyKTtcblxuXHQgIC8vIFJldHVybiBiaW5hcnkgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHR5cGVvZiBwbGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5ERUMySEVYID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBkZWNpbWFsLCBpcyBsb3dlciB0aGFuIC01NDk3NTU4MTM4ODgsIG9yIGlzIGdyZWF0ZXIgdGhhbiA1NDk3NTU4MTM4ODdcblx0ICBpZiAoIS9eLT9bMC05XXsxLDEyfSQvLnRlc3QobnVtYmVyKSB8fCBudW1iZXIgPCAtNTQ5NzU1ODEzODg4IHx8IG51bWJlciA+IDU0OTc1NTgxMzg4Nykge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgaGV4YWRlY2ltYWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gKDEwOTk1MTE2Mjc3NzYgKyBudW1iZXIpLnRvU3RyaW5nKDE2KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGhleGFkZWNpbWFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMTApLnRvU3RyaW5nKDE2KTtcblxuXHQgIC8vIFJldHVybiBoZXhhZGVjaW1hbCBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAodHlwZW9mIHBsYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkRFQzJPQ1QgPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGRlY2ltYWwsIGlzIGxvd2VyIHRoYW4gLTU0OTc1NTgxMzg4OCwgb3IgaXMgZ3JlYXRlciB0aGFuIDU0OTc1NTgxMzg4N1xuXHQgIGlmICghL14tP1swLTldezEsOX0kLy50ZXN0KG51bWJlcikgfHwgbnVtYmVyIDwgLTUzNjg3MDkxMiB8fCBudW1iZXIgPiA1MzY4NzA5MTEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIG9jdGFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuICgxMDczNzQxODI0ICsgbnVtYmVyKS50b1N0cmluZyg4KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIG9jdGFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMTApLnRvU3RyaW5nKDgpO1xuXG5cdCAgLy8gUmV0dXJuIG9jdGFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmICh0eXBlb2YgcGxhY2VzID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuREVMVEEgPSBmdW5jdGlvbihudW1iZXIxLCBudW1iZXIyKSB7XG5cdCAgLy8gU2V0IG51bWJlcjIgdG8gemVybyBpZiB1bmRlZmluZWRcblx0ICBudW1iZXIyID0gKG51bWJlcjIgPT09IHVuZGVmaW5lZCkgPyAwIDogbnVtYmVyMjtcblx0ICBudW1iZXIxID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMSk7XG5cdCAgbnVtYmVyMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcjEsIG51bWJlcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGRlbHRhXG5cdCAgcmV0dXJuIChudW1iZXIxID09PSBudW1iZXIyKSA/IDEgOiAwO1xuXHR9O1xuXG5cdC8vIFRPRE86IHdoeSBpcyB1cHBlcl9ib3VuZCBub3QgdXNlZCA/IFRoZSBleGNlbCBkb2N1bWVudGF0aW9uIGhhcyBubyBleGFtcGxlcyB3aXRoIHVwcGVyX2JvdW5kXG5cdGV4cG9ydHMuRVJGID0gZnVuY3Rpb24obG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSB7XG5cdCAgLy8gU2V0IG51bWJlcjIgdG8gemVybyBpZiB1bmRlZmluZWRcblx0ICB1cHBlcl9ib3VuZCA9ICh1cHBlcl9ib3VuZCA9PT0gdW5kZWZpbmVkKSA/IDAgOiB1cHBlcl9ib3VuZDtcblxuXHQgIGxvd2VyX2JvdW5kID0gdXRpbHMucGFyc2VOdW1iZXIobG93ZXJfYm91bmQpO1xuXHQgIHVwcGVyX2JvdW5kID0gdXRpbHMucGFyc2VOdW1iZXIodXBwZXJfYm91bmQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuZXJmKGxvd2VyX2JvdW5kKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuRVJGLlBSRUNJU0UgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignRVJGLlBSRUNJU0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5FUkZDID0gZnVuY3Rpb24oeCkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiB4IGlzIG5vdCBhIG51bWJlclxuXHQgIGlmIChpc05hTih4KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5lcmZjKHgpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5FUkZDLlBSRUNJU0UgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignRVJGQy5QUkVDSVNFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0VTVEVQID0gZnVuY3Rpb24obnVtYmVyLCBzdGVwKSB7XG5cdCAgc3RlcCA9IHN0ZXAgfHwgMDtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHN0ZXAsIG51bWJlcikpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGRlbHRhXG5cdCAgcmV0dXJuIChudW1iZXIgPj0gc3RlcCkgPyAxIDogMDtcblx0fTtcblxuXHRleHBvcnRzLkhFWDJCSU4gPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGhleGFkZWNpbWFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC05QS1GYS1mXXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDaGVjayBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICB2YXIgbmVnYXRpdmUgPSAobnVtYmVyLmxlbmd0aCA9PT0gMTAgJiYgbnVtYmVyLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpID09PSAnZicpID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdCAgLy8gQ29udmVydCBoZXhhZGVjaW1hbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gKG5lZ2F0aXZlKSA/IHBhcnNlSW50KG51bWJlciwgMTYpIC0gMTA5OTUxMTYyNzc3NiA6IHBhcnNlSW50KG51bWJlciwgMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBsb3dlciB0aGFuIC01MTIgb3IgZ3JlYXRlciB0aGFuIDUxMVxuXHQgIGlmIChkZWNpbWFsIDwgLTUxMiB8fCBkZWNpbWFsID4gNTExKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBiaW5hcnkgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgcmV0dXJuICcxJyArIHRleHQuUkVQVCgnMCcsIDkgLSAoNTEyICsgZGVjaW1hbCkudG9TdHJpbmcoMikubGVuZ3RoKSArICg1MTIgKyBkZWNpbWFsKS50b1N0cmluZygyKTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGJpbmFyeVxuXHQgIHZhciByZXN1bHQgPSBkZWNpbWFsLnRvU3RyaW5nKDIpO1xuXG5cdCAgLy8gUmV0dXJuIGJpbmFyeSBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAocGxhY2VzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkhFWDJERUMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBoZXhhZGVjaW1hbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtOUEtRmEtZl17MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBoZXhhZGVjaW1hbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gcGFyc2VJbnQobnVtYmVyLCAxNik7XG5cblx0ICAvLyBSZXR1cm4gZGVjaW1hbCBudW1iZXJcblx0ICByZXR1cm4gKGRlY2ltYWwgPj0gNTQ5NzU1ODEzODg4KSA/IGRlY2ltYWwgLSAxMDk5NTExNjI3Nzc2IDogZGVjaW1hbDtcblx0fTtcblxuXHRleHBvcnRzLkhFWDJPQ1QgPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGhleGFkZWNpbWFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC05QS1GYS1mXXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGhleGFkZWNpbWFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSBwYXJzZUludChudW1iZXIsIDE2KTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgcG9zaXRpdmUgYW5kIGdyZWF0ZXIgdGhhbiAweDFmZmZmZmZmICg1MzY4NzA5MTEpXG5cdCAgaWYgKGRlY2ltYWwgPiA1MzY4NzA5MTEgJiYgZGVjaW1hbCA8IDEwOTg5NzQ3NTY4NjQpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIG9jdGFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAoZGVjaW1hbCA+PSAxMDk4OTc0NzU2ODY0KSB7XG5cdCAgICByZXR1cm4gKGRlY2ltYWwgLSAxMDk4NDM3ODg1OTUyKS50b1N0cmluZyg4KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIG9jdGFsXG5cdCAgdmFyIHJlc3VsdCA9IGRlY2ltYWwudG9TdHJpbmcoOCk7XG5cblx0ICAvLyBSZXR1cm4gb2N0YWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5JTUFCUyA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIGNvZWZmaWNpZW50IGlzIG5vdCBhIG51bWJlclxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGFic29sdXRlIHZhbHVlIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNQUdJTkFSWSA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICBpZiAoaW51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGludW1iZXIgPT09IHRydWUgfHwgaW51bWJlciA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gMCBpZiBpbnVtYmVyIGlzIGVxdWFsIHRvIDBcblx0ICBpZiAoaW51bWJlciA9PT0gMCB8fCBpbnVtYmVyID09PSAnMCcpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzXG5cdCAgaWYgKFsnaScsICdqJ10uaW5kZXhPZihpbnVtYmVyKSA+PSAwKSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cblx0ICAvLyBOb3JtYWxpemUgaW1hZ2luYXJ5IGNvZWZmaWNpZW50XG5cdCAgaW51bWJlciA9IGludW1iZXIucmVwbGFjZSgnK2knLCAnKzFpJykucmVwbGFjZSgnLWknLCAnLTFpJykucmVwbGFjZSgnK2onLCAnKzFqJykucmVwbGFjZSgnLWonLCAnLTFqJyk7XG5cblx0ICAvLyBMb29rdXAgc2lnblxuXHQgIHZhciBwbHVzID0gaW51bWJlci5pbmRleE9mKCcrJyk7XG5cdCAgdmFyIG1pbnVzID0gaW51bWJlci5pbmRleE9mKCctJyk7XG5cdCAgaWYgKHBsdXMgPT09IDApIHtcblx0ICAgIHBsdXMgPSBpbnVtYmVyLmluZGV4T2YoJysnLCAxKTtcblx0ICB9XG5cblx0ICBpZiAobWludXMgPT09IDApIHtcblx0ICAgIG1pbnVzID0gaW51bWJlci5pbmRleE9mKCctJywgMSk7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIGxhc3QgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEsIGludW1iZXIubGVuZ3RoKTtcblx0ICB2YXIgdW5pdCA9IChsYXN0ID09PSAnaScgfHwgbGFzdCA9PT0gJ2onKTtcblxuXHQgIGlmIChwbHVzID49IDAgfHwgbWludXMgPj0gMCkge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIGltYWdpbmFyeSB1bml0IGlzIG5laXRoZXIgaSBub3IgalxuXHQgICAgaWYgKCF1bml0KSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBpbWFnaW5hcnkgY29lZmZpY2llbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICAgIGlmIChwbHVzID49IDApIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBwbHVzKSkgfHwgaXNOYU4oaW51bWJlci5zdWJzdHJpbmcocGx1cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpKSA/XG5cdCAgICAgICAgZXJyb3IubnVtIDpcblx0ICAgICAgICBOdW1iZXIoaW51bWJlci5zdWJzdHJpbmcocGx1cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBtaW51cykpIHx8IGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKG1pbnVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSkpID9cblx0ICAgICAgICBlcnJvci5udW0gOlxuXHQgICAgICAgIC1OdW1iZXIoaW51bWJlci5zdWJzdHJpbmcobWludXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHVuaXQpIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgPyBlcnJvci5udW0gOiBpbnVtYmVyLnN1YnN0cmluZygwLCBpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyKSkgPyBlcnJvci5udW0gOiAwO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLklNQVJHVU1FTlQgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgZXhwb3J0cy5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBjb2VmZmljaWVudCBpcyBub3QgYSBudW1iZXJcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyIGlzIGVxdWFsIHRvIHplcm9cblx0ICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gUEkvMiBpZiB4IGlzIGVxdWFsIHRvIHplcm8gYW5kIHkgaXMgcG9zaXRpdmVcblx0ICBpZiAoeCA9PT0gMCAmJiB5ID4gMCkge1xuXHQgICAgcmV0dXJuIE1hdGguUEkgLyAyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAtUEkvMiBpZiB4IGlzIGVxdWFsIHRvIHplcm8gYW5kIHkgaXMgbmVnYXRpdmVcblx0ICBpZiAoeCA9PT0gMCAmJiB5IDwgMCkge1xuXHQgICAgcmV0dXJuIC1NYXRoLlBJIC8gMjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gemVybyBpZiB4IGlzIG5lZ2F0aXZlIGFuZCB5IGlzIGVxdWFsIHRvIHplcm9cblx0ICBpZiAoeSA9PT0gMCAmJiB4ID4gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHplcm8gaWYgeCBpcyBuZWdhdGl2ZSBhbmQgeSBpcyBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHkgPT09IDAgJiYgeCA8IDApIHtcblx0ICAgIHJldHVybiAtTWF0aC5QSTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYXJndW1lbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICBpZiAoeCA+IDApIHtcblx0ICAgIHJldHVybiBNYXRoLmF0YW4oeSAvIHgpO1xuXHQgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+PSAwKSB7XG5cdCAgICByZXR1cm4gTWF0aC5hdGFuKHkgLyB4KSArIE1hdGguUEk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBNYXRoLmF0YW4oeSAvIHgpIC0gTWF0aC5QSTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNPTkpVR0FURSA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBjb25qdWdhdGUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gKHkgIT09IDApID8gZXhwb3J0cy5DT01QTEVYKHgsIC15LCB1bml0KSA6IGludW1iZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNPUyA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBjb3NpbmUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGguY29zKHgpICogKE1hdGguZXhwKHkpICsgTWF0aC5leHAoLXkpKSAvIDIsIC1NYXRoLnNpbih4KSAqIChNYXRoLmV4cCh5KSAtIE1hdGguZXhwKC15KSkgLyAyLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNQ09TSCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBoeXBlcmJvbGljIGNvc2luZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5jb3MoeSkgKiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMiwgTWF0aC5zaW4oeSkgKiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMiwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNPVCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBjb3RhbmdlbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVihleHBvcnRzLklNQ09TKGludW1iZXIpLCBleHBvcnRzLklNU0lOKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNRElWID0gZnVuY3Rpb24oaW51bWJlcjEsIGludW1iZXIyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIGEgPSBleHBvcnRzLklNUkVBTChpbnVtYmVyMSk7XG5cdCAgdmFyIGIgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyMSk7XG5cdCAgdmFyIGMgPSBleHBvcnRzLklNUkVBTChpbnVtYmVyMik7XG5cdCAgdmFyIGQgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyMik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhLCBiLCBjLCBkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0MSA9IGludW1iZXIxLnN1YnN0cmluZyhpbnVtYmVyMS5sZW5ndGggLSAxKTtcblx0ICB2YXIgdW5pdDIgPSBpbnVtYmVyMi5zdWJzdHJpbmcoaW51bWJlcjIubGVuZ3RoIC0gMSk7XG5cdCAgdmFyIHVuaXQgPSAnaSc7XG5cdCAgaWYgKHVuaXQxID09PSAnaicpIHtcblx0ICAgIHVuaXQgPSAnaic7XG5cdCAgfSBlbHNlIGlmICh1bml0MiA9PT0gJ2onKSB7XG5cdCAgICB1bml0ID0gJ2onO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyMiBpcyBudWxsXG5cdCAgaWYgKGMgPT09IDAgJiYgZCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICB2YXIgZGVuID0gYyAqIGMgKyBkICogZDtcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKChhICogYyArIGIgKiBkKSAvIGRlbiwgKGIgKiBjIC0gYSAqIGQpIC8gZGVuLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNRVhQID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgdmFyIGUgPSBNYXRoLmV4cCh4KTtcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKGUgKiBNYXRoLmNvcyh5KSwgZSAqIE1hdGguc2luKHkpLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNTE4gPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGgubG9nKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSksIE1hdGguYXRhbih5IC8geCksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1MT0cxMCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5sb2coTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKSAvIE1hdGgubG9nKDEwKSwgTWF0aC5hdGFuKHkgLyB4KSAvIE1hdGgubG9nKDEwKSwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUxPRzIgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGgubG9nKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSkgLyBNYXRoLmxvZygyKSwgTWF0aC5hdGFuKHkgLyB4KSAvIE1hdGgubG9nKDIpLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNUE9XRVIgPSBmdW5jdGlvbihpbnVtYmVyLCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIHBvd2VyIG9mIG1vZHVsdXNcblx0ICB2YXIgcCA9IE1hdGgucG93KGV4cG9ydHMuSU1BQlMoaW51bWJlciksIG51bWJlcik7XG5cblx0ICAvLyBDYWxjdWxhdGUgYXJndW1lbnRcblx0ICB2YXIgdCA9IGV4cG9ydHMuSU1BUkdVTUVOVChpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgocCAqIE1hdGguY29zKG51bWJlciAqIHQpLCBwICogTWF0aC5zaW4obnVtYmVyICogdCksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1QUk9EVUNUID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gSW5pdGlhbGl6ZSByZXN1bHRcblx0ICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzWzBdO1xuXG5cdCAgLy8gTG9vcCBvbiBhbGwgbnVtYmVyc1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAvLyBMb29rdXAgY29lZmZpY2llbnRzIG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICAgIHZhciBhID0gZXhwb3J0cy5JTVJFQUwocmVzdWx0KTtcblx0ICAgIHZhciBiID0gZXhwb3J0cy5JTUFHSU5BUlkocmVzdWx0KTtcblx0ICAgIHZhciBjID0gZXhwb3J0cy5JTVJFQUwoYXJndW1lbnRzW2ldKTtcblx0ICAgIHZhciBkID0gZXhwb3J0cy5JTUFHSU5BUlkoYXJndW1lbnRzW2ldKTtcblxuXHQgICAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYSwgYiwgYywgZCkpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb21wbHV0ZSBwcm9kdWN0IG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICAgIHJlc3VsdCA9IGV4cG9ydHMuQ09NUExFWChhICogYyAtIGIgKiBkLCBhICogZCArIGIgKiBjKTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gcHJvZHVjdCBvZiBjb21wbGV4IG51bWJlcnNcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1SRUFMID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIGlmIChpbnVtYmVyID09PSB1bmRlZmluZWQgfHwgaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAwIGlmIGludW1iZXIgaXMgZXF1YWwgdG8gMFxuXHQgIGlmIChpbnVtYmVyID09PSAwIHx8IGludW1iZXIgPT09ICcwJykge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcblx0ICBpZiAoWydpJywgJytpJywgJzFpJywgJysxaScsICctaScsICctMWknLCAnaicsICcraicsICcxaicsICcrMWonLCAnLWonLCAnLTFqJ10uaW5kZXhPZihpbnVtYmVyKSA+PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgc2lnblxuXHQgIHZhciBwbHVzID0gaW51bWJlci5pbmRleE9mKCcrJyk7XG5cdCAgdmFyIG1pbnVzID0gaW51bWJlci5pbmRleE9mKCctJyk7XG5cdCAgaWYgKHBsdXMgPT09IDApIHtcblx0ICAgIHBsdXMgPSBpbnVtYmVyLmluZGV4T2YoJysnLCAxKTtcblx0ICB9XG5cdCAgaWYgKG1pbnVzID09PSAwKSB7XG5cdCAgICBtaW51cyA9IGludW1iZXIuaW5kZXhPZignLScsIDEpO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciBsYXN0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxLCBpbnVtYmVyLmxlbmd0aCk7XG5cdCAgdmFyIHVuaXQgPSAobGFzdCA9PT0gJ2knIHx8IGxhc3QgPT09ICdqJyk7XG5cblx0ICBpZiAocGx1cyA+PSAwIHx8IG1pbnVzID49IDApIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBpbWFnaW5hcnkgdW5pdCBpcyBuZWl0aGVyIGkgbm9yIGpcblx0ICAgIGlmICghdW5pdCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gcmVhbCBjb2VmZmljaWVudCBvZiBjb21wbGV4IG51bWJlclxuXHQgICAgaWYgKHBsdXMgPj0gMCkge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIHBsdXMpKSB8fCBpc05hTihpbnVtYmVyLnN1YnN0cmluZyhwbHVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSkpID9cblx0ICAgICAgICBlcnJvci5udW0gOlxuXHQgICAgICAgIE51bWJlcihpbnVtYmVyLnN1YnN0cmluZygwLCBwbHVzKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIG1pbnVzKSkgfHwgaXNOYU4oaW51bWJlci5zdWJzdHJpbmcobWludXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgP1xuXHQgICAgICAgIGVycm9yLm51bSA6XG5cdCAgICAgICAgTnVtYmVyKGludW1iZXIuc3Vic3RyaW5nKDAsIG1pbnVzKSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICh1bml0KSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlci5zdWJzdHJpbmcoMCwgaW51bWJlci5sZW5ndGggLSAxKSkpID8gZXJyb3IubnVtIDogMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlcikpID8gZXJyb3IubnVtIDogaW51bWJlcjtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNFQyA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBhIGxvZ2ljYWwgdmFsdWVcblx0ICBpZiAoaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHNlY2FudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLklNRElWKCcxJywgZXhwb3J0cy5JTUNPUyhpbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNFQ0ggPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gaHlwZXJib2xpYyBzZWNhbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVignMScsIGV4cG9ydHMuSU1DT1NIKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNU0lOID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIHNpbmUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGguc2luKHgpICogKE1hdGguZXhwKHkpICsgTWF0aC5leHAoLXkpKSAvIDIsIE1hdGguY29zKHgpICogKE1hdGguZXhwKHkpIC0gTWF0aC5leHAoLXkpKSAvIDIsIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1TSU5IID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGh5cGVyYm9saWMgc2luZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5jb3MoeSkgKiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMiwgTWF0aC5zaW4oeSkgKiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMiwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNRUlQgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBDYWxjdWxhdGUgcG93ZXIgb2YgbW9kdWx1c1xuXHQgIHZhciBzID0gTWF0aC5zcXJ0KGV4cG9ydHMuSU1BQlMoaW51bWJlcikpO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIGFyZ3VtZW50XG5cdCAgdmFyIHQgPSBleHBvcnRzLklNQVJHVU1FTlQoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKHMgKiBNYXRoLmNvcyh0IC8gMiksIHMgKiBNYXRoLnNpbih0IC8gMiksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1DU0MgPSBmdW5jdGlvbiAoaW51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyIGlzIGEgbG9naWNhbCB2YWx1ZVxuXHQgIGlmIChpbnVtYmVyID09PSB0cnVlIHx8IGludW1iZXIgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBjb2VmZmljaWVudCBpcyBub3QgYSBudW1iZXJcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gY29zZWNhbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVignMScsIGV4cG9ydHMuSU1TSU4oaW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1DU0NIID0gZnVuY3Rpb24gKGludW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBhIGxvZ2ljYWwgdmFsdWVcblx0ICBpZiAoaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgY29lZmZpY2llbnQgaXMgbm90IGEgbnVtYmVyXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGh5cGVyYm9saWMgY29zZWNhbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVignMScsIGV4cG9ydHMuSU1TSU5IKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNU1VCID0gZnVuY3Rpb24oaW51bWJlcjEsIGludW1iZXIyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIGEgPSB0aGlzLklNUkVBTChpbnVtYmVyMSk7XG5cdCAgdmFyIGIgPSB0aGlzLklNQUdJTkFSWShpbnVtYmVyMSk7XG5cdCAgdmFyIGMgPSB0aGlzLklNUkVBTChpbnVtYmVyMik7XG5cdCAgdmFyIGQgPSB0aGlzLklNQUdJTkFSWShpbnVtYmVyMik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhLCBiLCBjLCBkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0MSA9IGludW1iZXIxLnN1YnN0cmluZyhpbnVtYmVyMS5sZW5ndGggLSAxKTtcblx0ICB2YXIgdW5pdDIgPSBpbnVtYmVyMi5zdWJzdHJpbmcoaW51bWJlcjIubGVuZ3RoIC0gMSk7XG5cdCAgdmFyIHVuaXQgPSAnaSc7XG5cdCAgaWYgKHVuaXQxID09PSAnaicpIHtcblx0ICAgIHVuaXQgPSAnaic7XG5cdCAgfSBlbHNlIGlmICh1bml0MiA9PT0gJ2onKSB7XG5cdCAgICB1bml0ID0gJ2onO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBfIG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICByZXR1cm4gdGhpcy5DT01QTEVYKGEgLSBjLCBiIC0gZCwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNVTSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXG5cdCAgLy8gSW5pdGlhbGl6ZSByZXN1bHRcblx0ICB2YXIgcmVzdWx0ID0gYXJnc1swXTtcblxuXHQgIC8vIExvb3Agb24gYWxsIG51bWJlcnNcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIC8vIExvb2t1cCBjb2VmZmljaWVudHMgb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuXHQgICAgdmFyIGEgPSB0aGlzLklNUkVBTChyZXN1bHQpO1xuXHQgICAgdmFyIGIgPSB0aGlzLklNQUdJTkFSWShyZXN1bHQpO1xuXHQgICAgdmFyIGMgPSB0aGlzLklNUkVBTChhcmdzW2ldKTtcblx0ICAgIHZhciBkID0gdGhpcy5JTUFHSU5BUlkoYXJnc1tpXSk7XG5cblx0ICAgIGlmICh1dGlscy5hbnlJc0Vycm9yKGEsIGIsIGMsIGQpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29tcGx1dGUgcHJvZHVjdCBvZiB0d28gY29tcGxleCBudW1iZXJzXG5cdCAgICByZXN1bHQgPSB0aGlzLkNPTVBMRVgoYSArIGMsIGIgKyBkKTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gc3VtIG9mIGNvbXBsZXggbnVtYmVyc1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVRBTiA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBhIGxvZ2ljYWwgdmFsdWVcblx0ICBpZiAoaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHRhbmdlbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gdGhpcy5JTURJVih0aGlzLklNU0lOKGludW1iZXIpLCB0aGlzLklNQ09TKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLk9DVDJCSU4gPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGhleGFkZWNpbWFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC03XXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDaGVjayBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICB2YXIgbmVnYXRpdmUgPSAobnVtYmVyLmxlbmd0aCA9PT0gMTAgJiYgbnVtYmVyLnN1YnN0cmluZygwLCAxKSA9PT0gJzcnKSA/IHRydWUgOiBmYWxzZTtcblxuXHQgIC8vIENvbnZlcnQgb2N0YWwgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgZGVjaW1hbCA9IChuZWdhdGl2ZSkgPyBwYXJzZUludChudW1iZXIsIDgpIC0gMTA3Mzc0MTgyNCA6IHBhcnNlSW50KG51bWJlciwgOCk7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGxvd2VyIHRoYW4gLTUxMiBvciBncmVhdGVyIHRoYW4gNTExXG5cdCAgaWYgKGRlY2ltYWwgPCAtNTEyIHx8IGRlY2ltYWwgPiA1MTEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIGJpbmFyeSBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICByZXR1cm4gJzEnICsgdGV4dC5SRVBUKCcwJywgOSAtICg1MTIgKyBkZWNpbWFsKS50b1N0cmluZygyKS5sZW5ndGgpICsgKDUxMiArIGRlY2ltYWwpLnRvU3RyaW5nKDIpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gYmluYXJ5XG5cdCAgdmFyIHJlc3VsdCA9IGRlY2ltYWwudG9TdHJpbmcoMik7XG5cblx0ICAvLyBSZXR1cm4gYmluYXJ5IG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmICh0eXBlb2YgcGxhY2VzID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuT0NUMkRFQyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IG9jdGFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC03XXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IG9jdGFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSBwYXJzZUludChudW1iZXIsIDgpO1xuXG5cdCAgLy8gUmV0dXJuIGRlY2ltYWwgbnVtYmVyXG5cdCAgcmV0dXJuIChkZWNpbWFsID49IDUzNjg3MDkxMikgPyBkZWNpbWFsIC0gMTA3Mzc0MTgyNCA6IGRlY2ltYWw7XG5cdH07XG5cblx0ZXhwb3J0cy5PQ1QySEVYID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBvY3RhbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtN117MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBvY3RhbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gcGFyc2VJbnQobnVtYmVyLCA4KTtcblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBvY3RhbCBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKGRlY2ltYWwgPj0gNTM2ODcwOTEyKSB7XG5cdCAgICByZXR1cm4gJ2ZmJyArIChkZWNpbWFsICsgMzIyMTIyNTQ3MikudG9TdHJpbmcoMTYpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gaGV4YWRlY2ltYWxcblx0ICB2YXIgcmVzdWx0ID0gZGVjaW1hbC50b1N0cmluZygxNik7XG5cblx0ICAvLyBSZXR1cm4gaGV4YWRlY2ltYWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIE0gPSBNYXRoO1xuXHRmdW5jdGlvbiBfaG9ybmVyKGFyciwgdikgeyByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbih6LHcpe3JldHVybiB2ICogeiArIHc7fSwwKTsgfTtcblx0ZnVuY3Rpb24gX2Jlc3NlbF9pdGVyKHgsIG4sIGYwLCBmMSwgc2lnbikge1xuXHQgIGlmKCFzaWduKSBzaWduID0gLTE7XG5cdCAgdmFyIHRkeCA9IDIgLyB4LCBmMjtcblx0ICBpZihuID09PSAwKSByZXR1cm4gZjA7XG5cdCAgaWYobiA9PT0gMSkgcmV0dXJuIGYxO1xuXHQgIGZvcih2YXIgbyA9IDE7IG8gIT0gbjsgKytvKSB7XG5cdCAgICBmMiA9IGYxICogbyAqIHRkeCArIHNpZ24gKiBmMDtcblx0ICAgIGYwID0gZjE7IGYxID0gZjI7XG5cdCAgfVxuXHQgIHJldHVybiBmMTtcblx0fVxuXHRmdW5jdGlvbiBfYmVzc2VsX3dyYXAoYmVzc2VsMCwgYmVzc2VsMSwgbmFtZSwgbm9uemVybywgc2lnbikge1xuXHQgIHJldHVybiBmdW5jdGlvbiBiZXNzZWwoeCxuKSB7XG5cdCAgICBpZihuID09PSAwKSByZXR1cm4gYmVzc2VsMCh4KTtcblx0ICAgIGlmKG4gPT09IDEpIHJldHVybiBiZXNzZWwxKHgpO1xuXHQgICAgaWYobiA8IDApIHRocm93IG5hbWUgKyAnOiBPcmRlciAoJyArIG4gKyAnKSBtdXN0IGJlIG5vbm5lZ2F0aXZlJztcblx0ICAgIGlmKG5vbnplcm8gPT0gMSAmJiB4ID09PSAwKSB0aHJvdyBuYW1lICsgJzogVW5kZWZpbmVkIHdoZW4geCA9PSAwJztcblx0ICAgIGlmKG5vbnplcm8gPT0gMiAmJiB4IDw9IDApIHRocm93IG5hbWUgKyAnOiBVbmRlZmluZWQgd2hlbiB4IDw9IDAnO1xuXHQgICAgdmFyIGIwID0gYmVzc2VsMCh4KSwgYjEgPSBiZXNzZWwxKHgpO1xuXHQgICAgcmV0dXJuIF9iZXNzZWxfaXRlcih4LCBuLCBiMCwgYjEsIHNpZ24pO1xuXHQgIH07XG5cdH1cblx0dmFyIGJlc3NlbGogPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGIwX2ExYSA9IFs1NzU2ODQ5MDU3NC4wLC0xMzM2MjU5MDM1NC4wLDY1MTYxOTY0MC43LC0xMTIxNDQyNC4xOCw3NzM5Mi4zMzAxNywtMTg0LjkwNTI0NTZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYTJhID0gWzU3NTY4NDkwNDExLjAsMTAyOTUzMjk4NS4wLDk0OTQ2ODAuNzE4LDU5MjcyLjY0ODUzLDI2Ny44NTMyNzEyLDEuMF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMWIgPSBbMS4wLCAtMC4xMDk4NjI4NjI3ZS0yLCAwLjI3MzQ1MTA0MDdlLTQsIC0wLjIwNzMzNzA2MzllLTUsIDAuMjA5Mzg4NzIxMWUtNl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMmIgPSBbLTAuMTU2MjQ5OTk5NWUtMSwgMC4xNDMwNDg4NzY1ZS0zLCAtMC42OTExMTQ3NjUxZS01LCAwLjc2MjEwOTUxNjFlLTYsIC0wLjkzNDkzNTE1MmUtN10ucmV2ZXJzZSgpO1xuXHQgIHZhciBXID0gMC42MzY2MTk3NzI7IC8vIDIgLyBNYXRoLlBJXG5cblx0ICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcblx0ICAgIHZhciBhLCBhMSwgYTIsIHkgPSB4ICogeCwgeHggPSBNLmFicyh4KSAtIDAuNzg1Mzk4MTY0O1xuXHQgICAgaWYoTS5hYnMoeCkgPCA4KSB7XG5cdCAgICAgIGExID0gX2hvcm5lcihiMF9hMWEsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjBfYTJhLCB5KTtcblx0ICAgICAgYSA9IGExL2EyO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHkgPSA2NCAvIHk7XG5cdCAgICAgIGExID0gX2hvcm5lcihiMF9hMWIsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjBfYTJiLCB5KTtcblx0ICAgICAgYSA9IE0uc3FydChXL00uYWJzKHgpKSooTS5jb3MoeHgpKmExLU0uc2luKHh4KSphMio4L00uYWJzKHgpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhO1xuXHQgIH1cblx0ICB2YXIgYjFfYTFhID0gWzcyMzYyNjE0MjMyLjAsLTc4OTUwNTkyMzUuMCwyNDIzOTY4NTMuMSwtMjk3MjYxMS40MzksIDE1NzA0LjQ4MjYwLCAtMzAuMTYwMzY2MDZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTJhID0gWzE0NDcyNTIyODQ0Mi4wLCAyMzAwNTM1MTc4LjAsIDE4NTgzMzA0Ljc0LCA5OTQ0Ny40MzM5NCwgMzc2Ljk5OTEzOTcsIDEuMF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9hMWIgPSBbMS4wLCAwLjE4MzEwNWUtMiwgLTAuMzUxNjM5NjQ5NmUtNCwgMC4yNDU3NTIwMTc0ZS01LCAtMC4yNDAzMzcwMTllLTZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTJiID0gWzAuMDQ2ODc0OTk5OTUsIC0wLjIwMDI2OTA4NzNlLTMsIDAuODQ0OTE5OTA5NmUtNSwgLTAuODgyMjg5ODdlLTYsIDAuMTA1Nzg3NDEyZS02XS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG5cdCAgICB2YXIgYSwgYTEsIGEyLCB5ID0geCp4LCB4eCA9IE0uYWJzKHgpIC0gMi4zNTYxOTQ0OTE7XG5cdCAgICBpZihNYXRoLmFicyh4KTwgOCkge1xuXHQgICAgICBhMSA9IHgqX2hvcm5lcihiMV9hMWEsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjFfYTJhLCB5KTtcblx0ICAgICAgYSA9IGExIC8gYTI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB5ID0gNjQgLyB5O1xuXHQgICAgICBhMT1faG9ybmVyKGIxX2ExYiwgeSk7XG5cdCAgICAgIGEyPV9ob3JuZXIoYjFfYTJiLCB5KTtcblx0ICAgICAgYT1NLnNxcnQoVy9NLmFicyh4KSkqKE0uY29zKHh4KSphMS1NLnNpbih4eCkqYTIqOC9NLmFicyh4KSk7XG5cdCAgICAgIGlmKHggPCAwKSBhID0gLWE7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYTtcblx0ICB9XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIGJlc3NlbGooeCwgbikge1xuXHQgICAgbiA9IE1hdGgucm91bmQobik7XG5cdCAgICBpZihuID09PSAwKSByZXR1cm4gYmVzc2VsMChNLmFicyh4KSk7XG5cdCAgICBpZihuID09PSAxKSByZXR1cm4gYmVzc2VsMShNLmFicyh4KSk7XG5cdCAgICBpZihuIDwgMCkgdGhyb3cgJ0JFU1NFTEo6IE9yZGVyICgnICsgbiArICcpIG11c3QgYmUgbm9ubmVnYXRpdmUnO1xuXHQgICAgaWYoTS5hYnMoeCkgPT09IDApIHJldHVybiAwO1xuXG5cdCAgICB2YXIgcmV0LCBqLCB0b3ggPSAyIC8gTS5hYnMoeCksIG0sIGpzdW0sIHN1bSwgYmpwLCBiaiwgYmptO1xuXHQgICAgaWYoTS5hYnMoeCkgPiBuKSB7XG5cdCAgICAgIHJldCA9IF9iZXNzZWxfaXRlcih4LCBuLCBiZXNzZWwwKE0uYWJzKHgpKSwgYmVzc2VsMShNLmFicyh4KSksLTEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbT0yKk0uZmxvb3IoKG4rTS5mbG9vcihNLnNxcnQoNDAqbikpKS8yKTtcblx0ICAgICAganN1bT0wO1xuXHQgICAgICBianA9cmV0PXN1bT0wLjA7XG5cdCAgICAgIGJqPTEuMDtcblx0ICAgICAgZm9yIChqPW07aj4wO2otLSkge1xuXHQgICAgICAgIGJqbT1qKnRveCpiai1ianA7XG5cdCAgICAgICAgYmpwPWJqO1xuXHQgICAgICAgIGJqPWJqbTtcblx0ICAgICAgICBpZiAoTS5hYnMoYmopID4gMUUxMCkge1xuXHQgICAgICAgICAgYmogKj0gMUUtMTA7XG5cdCAgICAgICAgICBianAgKj0gMUUtMTA7XG5cdCAgICAgICAgICByZXQgKj0gMUUtMTA7XG5cdCAgICAgICAgICBzdW0gKj0gMUUtMTA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChqc3VtKSBzdW0gKz0gYmo7XG5cdCAgICAgICAganN1bT0hanN1bTtcblx0ICAgICAgICBpZiAoaiA9PSBuKSByZXQ9YmpwO1xuXHQgICAgICB9XG5cdCAgICAgIHN1bT0yLjAqc3VtLWJqO1xuXHQgICAgICByZXQgLz0gc3VtO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHggPCAwICYmIChuJTIpID8gLXJldCA6IHJldDtcblx0ICB9O1xuXHR9KSgpO1xuXHR2YXIgYmVzc2VseSA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgYjBfYTFhID0gWy0yOTU3ODIxMzg5LjAsIDcwNjI4MzQwNjUuMCwgLTUxMjM1OTgwMy42LCAxMDg3OTg4MS4yOSwgLTg2MzI3LjkyNzU3LCAyMjguNDYyMjczM10ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMmEgPSBbNDAwNzY1NDQyNjkuMCwgNzQ1MjQ5OTY0LjgsIDcxODk0NjYuNDM4LCA0NzQ0Ny4yNjQ3MCwgMjI2LjEwMzAyNDQsIDEuMF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMWIgPSBbMS4wLCAtMC4xMDk4NjI4NjI3ZS0yLCAwLjI3MzQ1MTA0MDdlLTQsIC0wLjIwNzMzNzA2MzllLTUsIDAuMjA5Mzg4NzIxMWUtNl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMmIgPSBbLTAuMTU2MjQ5OTk5NWUtMSwgMC4xNDMwNDg4NzY1ZS0zLCAtMC42OTExMTQ3NjUxZS01LCAwLjc2MjEwOTUxNjFlLTYsIC0wLjkzNDk0NTE1MmUtN10ucmV2ZXJzZSgpO1xuXG5cdCAgdmFyIFcgPSAwLjYzNjYxOTc3Mjtcblx0ICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcblx0ICAgIHZhciBhLCBhMSwgYTIsIHkgPSB4ICogeCwgeHggPSB4IC0gMC43ODUzOTgxNjQ7XG5cdCAgICBpZih4IDwgOCkge1xuXHQgICAgICBhMSA9IF9ob3JuZXIoYjBfYTFhLCB5KTtcblx0ICAgICAgYTIgPSBfaG9ybmVyKGIwX2EyYSwgeSk7XG5cdCAgICAgIGEgPSBhMS9hMiArIFcgKiBiZXNzZWxqKHgsMCkgKiBNLmxvZyh4KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHkgPSA2NCAvIHk7XG5cdCAgICAgIGExID0gX2hvcm5lcihiMF9hMWIsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjBfYTJiLCB5KTtcblx0ICAgICAgYSA9IE0uc3FydChXL3gpKihNLnNpbih4eCkqYTErTS5jb3MoeHgpKmEyKjgveCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYTtcblx0ICB9XG5cblx0ICB2YXIgYjFfYTFhID0gWy0wLjQ5MDA2MDQ5NDNlMTMsIDAuMTI3NTI3NDM5MGUxMywgLTAuNTE1MzQzODEzOWUxMSwgMC43MzQ5MjY0NTUxZTksIC0wLjQyMzc5MjI3MjZlNywgMC44NTExOTM3OTM1ZTRdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTJhID0gWzAuMjQ5OTU4MDU3MGUxNCwgMC40MjQ0NDE5NjY0ZTEyLCAwLjM3MzM2NTAzNjdlMTAsIDAuMjI0NTkwNDAwMmU4LCAwLjEwMjA0MjYwNTBlNiwgMC4zNTQ5NjMyODg1ZTMsIDFdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTFiID0gWzEuMCwgMC4xODMxMDVlLTIsIC0wLjM1MTYzOTY0OTZlLTQsIDAuMjQ1NzUyMDE3NGUtNSwgLTAuMjQwMzM3MDE5ZS02XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2EyYiA9IFswLjA0Njg3NDk5OTk1LCAtMC4yMDAyNjkwODczZS0zLCAwLjg0NDkxOTkwOTZlLTUsIC0wLjg4MjI4OTg3ZS02LCAwLjEwNTc4NzQxMmUtNl0ucmV2ZXJzZSgpO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDEoeCkge1xuXHQgICAgdmFyIGEsIGExLCBhMiwgeSA9IHgqeCwgeHggPSB4IC0gMi4zNTYxOTQ0OTE7XG5cdCAgICBpZih4IDwgOCkge1xuXHQgICAgICBhMSA9IHgqX2hvcm5lcihiMV9hMWEsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjFfYTJhLCB5KTtcblx0ICAgICAgYSA9IGExL2EyICsgVyAqIChiZXNzZWxqKHgsMSkgKiBNLmxvZyh4KSAtIDEgLyB4KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHkgPSA2NCAvIHk7XG5cdCAgICAgIGExPV9ob3JuZXIoYjFfYTFiLCB5KTtcblx0ICAgICAgYTI9X2hvcm5lcihiMV9hMmIsIHkpO1xuXHQgICAgICBhPU0uc3FydChXL3gpKihNLnNpbih4eCkqYTErTS5jb3MoeHgpKmEyKjgveCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYTtcblx0ICB9XG5cblx0ICByZXR1cm4gX2Jlc3NlbF93cmFwKGJlc3NlbDAsIGJlc3NlbDEsICdCRVNTRUxZJywgMSwgLTEpO1xuXHR9KSgpO1xuXHR2YXIgYmVzc2VsaSA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgYjBfYSA9IFsxLjAsIDMuNTE1NjIyOSwgMy4wODk5NDI0LCAxLjIwNjc0OTIsIDAuMjY1OTczMiwgMC4zNjA3NjhlLTEsIDAuNDU4MTNlLTJdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYiA9IFswLjM5ODk0MjI4LCAwLjEzMjg1OTJlLTEsIDAuMjI1MzE5ZS0yLCAtMC4xNTc1NjVlLTIsIDAuOTE2MjgxZS0yLCAtMC4yMDU3NzA2ZS0xLCAwLjI2MzU1MzdlLTEsIC0wLjE2NDc2MzNlLTEsIDAuMzkyMzc3ZS0yXS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMCh4KSB7XG5cdCAgICBpZih4IDw9IDMuNzUpIHJldHVybiBfaG9ybmVyKGIwX2EsIHgqeC8oMy43NSozLjc1KSk7XG5cdCAgICByZXR1cm4gTS5leHAoTS5hYnMoeCkpL00uc3FydChNLmFicyh4KSkqX2hvcm5lcihiMF9iLCAzLjc1L00uYWJzKHgpKTtcblx0ICB9XG5cblx0ICB2YXIgYjFfYSA9IFswLjUsIDAuODc4OTA1OTQsIDAuNTE0OTg4NjksIDAuMTUwODQ5MzQsIDAuMjY1ODczM2UtMSwgMC4zMDE1MzJlLTIsIDAuMzI0MTFlLTNdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYiA9IFswLjM5ODk0MjI4LCAtMC4zOTg4MDI0ZS0xLCAtMC4zNjIwMThlLTIsIDAuMTYzODAxZS0yLCAtMC4xMDMxNTU1ZS0xLCAwLjIyODI5NjdlLTEsIC0wLjI4OTUzMTJlLTEsIDAuMTc4NzY1NGUtMSwgLTAuNDIwMDU5ZS0yXS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG5cdCAgICBpZih4IDwgMy43NSkgcmV0dXJuIHggKiBfaG9ybmVyKGIxX2EsIHgqeC8oMy43NSozLjc1KSk7XG5cdCAgICByZXR1cm4gKHggPCAwID8gLTEgOiAxKSAqIE0uZXhwKE0uYWJzKHgpKS9NLnNxcnQoTS5hYnMoeCkpKl9ob3JuZXIoYjFfYiwgMy43NS9NLmFicyh4KSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIGJlc3NlbGkoeCwgbikge1xuXHQgICAgbiA9IE1hdGgucm91bmQobik7XG5cdCAgICBpZihuID09PSAwKSByZXR1cm4gYmVzc2VsMCh4KTtcblx0ICAgIGlmKG4gPT0gMSkgcmV0dXJuIGJlc3NlbDEoeCk7XG5cdCAgICBpZihuIDwgMCkgdGhyb3cgJ0JFU1NFTEkgT3JkZXIgKCcgKyBuICsgJykgbXVzdCBiZSBub25uZWdhdGl2ZSc7XG5cdCAgICBpZihNLmFicyh4KSA9PT0gMCkgcmV0dXJuIDA7XG5cblx0ICAgIHZhciByZXQsIGosIHRveCA9IDIgLyBNLmFicyh4KSwgbSwgYmlwLCBiaSwgYmltO1xuXHQgICAgbT0yKk0ucm91bmQoKG4rTS5yb3VuZChNLnNxcnQoNDAqbikpKS8yKTtcblx0ICAgIGJpcD1yZXQ9MC4wO1xuXHQgICAgYmk9MS4wO1xuXHQgICAgZm9yIChqPW07aj4wO2otLSkge1xuXHQgICAgICBiaW09aip0b3gqYmkgKyBiaXA7XG5cdCAgICAgIGJpcD1iaTsgYmk9YmltO1xuXHQgICAgICBpZiAoTS5hYnMoYmkpID4gMUUxMCkge1xuXHQgICAgICAgIGJpICo9IDFFLTEwO1xuXHQgICAgICAgIGJpcCAqPSAxRS0xMDtcblx0ICAgICAgICByZXQgKj0gMUUtMTA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYoaiA9PSBuKSByZXQgPSBiaXA7XG5cdCAgICB9XG5cdCAgICByZXQgKj0gYmVzc2VsaSh4LCAwKSAvIGJpO1xuXHQgICAgcmV0dXJuIHggPCAwICYmIChuJTIpID8gLXJldCA6IHJldDtcblx0ICB9O1xuXG5cdH0pKCk7XG5cblx0dmFyIGJlc3NlbGsgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGIwX2EgPSBbLTAuNTc3MjE1NjYsIDAuNDIyNzg0MjAsIDAuMjMwNjk3NTYsIDAuMzQ4ODU5MGUtMSwgMC4yNjI2OThlLTIsIDAuMTA3NTBlLTMsIDAuNzRlLTVdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYiA9IFsxLjI1MzMxNDE0LCAtMC43ODMyMzU4ZS0xLCAwLjIxODk1NjhlLTEsIC0wLjEwNjI0NDZlLTEsIDAuNTg3ODcyZS0yLCAtMC4yNTE1NDBlLTIsIDAuNTMyMDhlLTNdLnJldmVyc2UoKTtcblx0ICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcblx0ICAgIGlmKHggPD0gMikgcmV0dXJuIC1NLmxvZyh4LzIpKmJlc3NlbGkoeCwwKSArIF9ob3JuZXIoYjBfYSwgeCp4LzQpO1xuXHQgICAgcmV0dXJuIE0uZXhwKC14KS9NLnNxcnQoeCkqX2hvcm5lcihiMF9iLCAyL3gpO1xuXHQgIH1cblxuXHQgIHZhciBiMV9hID0gWzEuMCwgMC4xNTQ0MzE0NCwgLTAuNjcyNzg1NzksIC0wLjE4MTU2ODk3LCAtMC4xOTE5NDAyZS0xLCAtMC4xMTA0MDRlLTIsIC0wLjQ2ODZlLTRdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYiA9IFsxLjI1MzMxNDE0LCAwLjIzNDk4NjE5LCAtMC4zNjU1NjIwZS0xLCAwLjE1MDQyNjhlLTEsIC0wLjc4MDM1M2UtMiwgMC4zMjU2MTRlLTIsIC0wLjY4MjQ1ZS0zXS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG5cdCAgICBpZih4IDw9IDIpIHJldHVybiBNLmxvZyh4LzIpKmJlc3NlbGkoeCwxKSArICgxL3gpKl9ob3JuZXIoYjFfYSwgeCp4LzQpO1xuXHQgICAgcmV0dXJuIE0uZXhwKC14KS9NLnNxcnQoeCkqX2hvcm5lcihiMV9iLCAyL3gpO1xuXHQgIH1cblxuXHQgIHJldHVybiBfYmVzc2VsX3dyYXAoYmVzc2VsMCwgYmVzc2VsMSwgJ0JFU1NFTEsnLCAyLCAxKTtcblx0fSkoKTtcblx0aWYodHJ1ZSkge1xuXHQgIGV4cG9ydHMuYmVzc2VsaiA9IGJlc3NlbGo7XG5cdCAgZXhwb3J0cy5iZXNzZWx5ID0gYmVzc2VseTtcblx0ICBleHBvcnRzLmJlc3NlbGkgPSBiZXNzZWxpO1xuXHQgIGV4cG9ydHMuYmVzc2VsayA9IGJlc3NlbGs7XG5cdH1cblxuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHR2YXIgZDE5MDAgPSBuZXcgRGF0ZSgxOTAwLCAwLCAxKTtcblx0dmFyIFdFRUtfU1RBUlRTID0gW1xuXHQgIHVuZGVmaW5lZCxcblx0ICAwLFxuXHQgIDEsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgMSxcblx0ICAyLFxuXHQgIDMsXG5cdCAgNCxcblx0ICA1LFxuXHQgIDYsXG5cdCAgMFxuXHRdO1xuXHR2YXIgV0VFS19UWVBFUyA9IFtcblx0ICBbXSxcblx0ICBbMSwgMiwgMywgNCwgNSwgNiwgN10sXG5cdCAgWzcsIDEsIDIsIDMsIDQsIDUsIDZdLFxuXHQgIFs2LCAwLCAxLCAyLCAzLCA0LCA1XSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbNywgMSwgMiwgMywgNCwgNSwgNl0sXG5cdCAgWzYsIDcsIDEsIDIsIDMsIDQsIDVdLFxuXHQgIFs1LCA2LCA3LCAxLCAyLCAzLCA0XSxcblx0ICBbNCwgNSwgNiwgNywgMSwgMiwgM10sXG5cdCAgWzMsIDQsIDUsIDYsIDcsIDEsIDJdLFxuXHQgIFsyLCAzLCA0LCA1LCA2LCA3LCAxXSxcblx0ICBbMSwgMiwgMywgNCwgNSwgNiwgN11cblx0XTtcblx0dmFyIFdFRUtFTkRfVFlQRVMgPSBbXG5cdCAgW10sXG5cdCAgWzYsIDBdLFxuXHQgIFswLCAxXSxcblx0ICBbMSwgMl0sXG5cdCAgWzIsIDNdLFxuXHQgIFszLCA0XSxcblx0ICBbNCwgNV0sXG5cdCAgWzUsIDZdLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLCBbMCwgMF0sXG5cdCAgWzEsIDFdLFxuXHQgIFsyLCAyXSxcblx0ICBbMywgM10sXG5cdCAgWzQsIDRdLFxuXHQgIFs1LCA1XSxcblx0ICBbNiwgNl1cblx0XTtcblxuXHRleHBvcnRzLkRBVEUgPSBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdCAgeWVhciA9IHV0aWxzLnBhcnNlTnVtYmVyKHllYXIpO1xuXHQgIG1vbnRoID0gdXRpbHMucGFyc2VOdW1iZXIobW9udGgpO1xuXHQgIGRheSA9IHV0aWxzLnBhcnNlTnVtYmVyKGRheSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeWVhciwgbW9udGgsIGRheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHllYXIgPCAwIHx8IG1vbnRoIDwgMCB8fCBkYXkgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0ICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcblx0ICByZXR1cm4gZGF0ZTtcblx0fTtcblxuXHRleHBvcnRzLkRBVEVWQUxVRSA9IGZ1bmN0aW9uKGRhdGVfdGV4dCkge1xuXHQgIGlmICh0eXBlb2YgZGF0ZV90ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgZGF0ZSA9IERhdGUucGFyc2UoZGF0ZV90ZXh0KTtcblx0ICBpZiAoaXNOYU4oZGF0ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGRhdGUgPD0gLTIyMDM4OTEyMDAwMDApIHtcblx0ICAgIHJldHVybiAoZGF0ZSAtIGQxOTAwKSAvIDg2NDAwMDAwICsgMTtcblx0ICB9XG5cdCAgcmV0dXJuIChkYXRlIC0gZDE5MDApIC8gODY0MDAwMDAgKyAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuREFZID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHZhciBkYXRlID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChkYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBkYXRlO1xuXHQgIH1cblx0ICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5EQVlTID0gZnVuY3Rpb24oZW5kX2RhdGUsIHN0YXJ0X2RhdGUpIHtcblx0ICBlbmRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShlbmRfZGF0ZSk7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoZW5kX2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVuZF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHNlcmlhbChlbmRfZGF0ZSkgLSBzZXJpYWwoc3RhcnRfZGF0ZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5EQVlTMzYwID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZW5kX2RhdGUsIG1ldGhvZCkge1xuXHQgIG1ldGhvZCA9IHV0aWxzLnBhcnNlQm9vbChtZXRob2QpO1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgZW5kX2RhdGUgPSB1dGlscy5wYXJzZURhdGUoZW5kX2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoZW5kX2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVuZF9kYXRlO1xuXHQgIH1cblx0ICBpZiAobWV0aG9kIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBtZXRob2Q7XG5cdCAgfVxuXHQgIHZhciBzbSA9IHN0YXJ0X2RhdGUuZ2V0TW9udGgoKTtcblx0ICB2YXIgZW0gPSBlbmRfZGF0ZS5nZXRNb250aCgpO1xuXHQgIHZhciBzZCwgZWQ7XG5cdCAgaWYgKG1ldGhvZCkge1xuXHQgICAgc2QgPSBzdGFydF9kYXRlLmdldERhdGUoKSA9PT0gMzEgPyAzMCA6IHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpO1xuXHQgICAgZWQgPSBlbmRfZGF0ZS5nZXREYXRlKCkgPT09IDMxID8gMzAgOiBlbmRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBzbWQgPSBuZXcgRGF0ZShzdGFydF9kYXRlLmdldEZ1bGxZZWFyKCksIHNtICsgMSwgMCkuZ2V0RGF0ZSgpO1xuXHQgICAgdmFyIGVtZCA9IG5ldyBEYXRlKGVuZF9kYXRlLmdldEZ1bGxZZWFyKCksIGVtICsgMSwgMCkuZ2V0RGF0ZSgpO1xuXHQgICAgc2QgPSBzdGFydF9kYXRlLmdldERhdGUoKSA9PT0gc21kID8gMzAgOiBzdGFydF9kYXRlLmdldERhdGUoKTtcblx0ICAgIGlmIChlbmRfZGF0ZS5nZXREYXRlKCkgPT09IGVtZCkge1xuXHQgICAgICBpZiAoc2QgPCAzMCkge1xuXHQgICAgICAgIGVtKys7XG5cdCAgICAgICAgZWQgPSAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVkID0gMzA7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVkID0gZW5kX2RhdGUuZ2V0RGF0ZSgpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gMzYwICogKGVuZF9kYXRlLmdldEZ1bGxZZWFyKCkgLSBzdGFydF9kYXRlLmdldEZ1bGxZZWFyKCkpICtcblx0ICAgIDMwICogKGVtIC0gc20pICsgKGVkIC0gc2QpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRURBVEUgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBtb250aHMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoaXNOYU4obW9udGhzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBtb250aHMgPSBwYXJzZUludChtb250aHMsIDEwKTtcblx0ICBzdGFydF9kYXRlLnNldE1vbnRoKHN0YXJ0X2RhdGUuZ2V0TW9udGgoKSArIG1vbnRocyk7XG5cdCAgcmV0dXJuIHNlcmlhbChzdGFydF9kYXRlKTtcblx0fTtcblxuXHRleHBvcnRzLkVPTU9OVEggPSBmdW5jdGlvbihzdGFydF9kYXRlLCBtb250aHMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoaXNOYU4obW9udGhzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBtb250aHMgPSBwYXJzZUludChtb250aHMsIDEwKTtcblx0ICByZXR1cm4gc2VyaWFsKG5ldyBEYXRlKHN0YXJ0X2RhdGUuZ2V0RnVsbFllYXIoKSwgc3RhcnRfZGF0ZS5nZXRNb250aCgpICsgbW9udGhzICsgMSwgMCkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSE9VUiA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsX251bWJlci5nZXRIb3VycygpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU5URVJWQUwgPSBmdW5jdGlvbiAoc2Vjb25kKSB7XG5cdCAgaWYgKHR5cGVvZiBzZWNvbmQgIT09ICdudW1iZXInICYmIHR5cGVvZiBzZWNvbmQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHNlY29uZCA9IHBhcnNlSW50KHNlY29uZCwgMTApO1xuXHQgIH1cblxuXHQgIHZhciB5ZWFyICA9IE1hdGguZmxvb3Ioc2Vjb25kLzk0NjA4MDAwMCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTk0NjA4MDAwMDtcblx0ICB2YXIgbW9udGggPSBNYXRoLmZsb29yKHNlY29uZC8yNTkyMDAwKTtcblx0ICBzZWNvbmQgICAgPSBzZWNvbmQlMjU5MjAwMDtcblx0ICB2YXIgZGF5ICAgPSBNYXRoLmZsb29yKHNlY29uZC84NjQwMCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTg2NDAwO1xuXG5cdCAgdmFyIGhvdXIgID0gTWF0aC5mbG9vcihzZWNvbmQvMzYwMCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTM2MDA7XG5cdCAgdmFyIG1pbiAgID0gTWF0aC5mbG9vcihzZWNvbmQvNjApO1xuXHQgIHNlY29uZCAgICA9IHNlY29uZCU2MDtcblx0ICB2YXIgc2VjICAgPSBzZWNvbmQ7XG5cblx0ICB5ZWFyICA9ICh5ZWFyICA+IDApID8geWVhciAgKyAnWScgOiAnJztcblx0ICBtb250aCA9IChtb250aCA+IDApID8gbW9udGggKyAnTScgOiAnJztcblx0ICBkYXkgICA9IChkYXkgICA+IDApID8gZGF5ICAgKyAnRCcgOiAnJztcblx0ICBob3VyICA9IChob3VyICA+IDApID8gaG91ciAgKyAnSCcgOiAnJztcblx0ICBtaW4gICA9IChtaW4gICA+IDApID8gbWluICAgKyAnTScgOiAnJztcblx0ICBzZWMgICA9IChzZWMgICA+IDApID8gc2VjICAgKyAnUycgOiAnJztcblxuXHQgIHJldHVybiAnUCcgKyB5ZWFyICsgbW9udGggKyBkYXkgK1xuXHQgICdUJyArIGhvdXIgKyBtaW4gKyBzZWM7XG5cdH07XG5cblx0ZXhwb3J0cy5JU09XRUVLTlVNID0gZnVuY3Rpb24oZGF0ZSkge1xuXHQgIGRhdGUgPSB1dGlscy5wYXJzZURhdGUoZGF0ZSk7XG5cdCAgaWYgKGRhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGRhdGU7XG5cdCAgfVxuXG5cdCAgZGF0ZS5zZXRIb3VycygwLCAwLCAwKTtcblx0ICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyA0IC0gKGRhdGUuZ2V0RGF5KCkgfHwgNykpO1xuXHQgIHZhciB5ZWFyU3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuXHQgIHJldHVybiBNYXRoLmNlaWwoKCgoZGF0ZSAtIHllYXJTdGFydCkgLyA4NjQwMDAwMCkgKyAxKSAvIDcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlOVVRFID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldE1pbnV0ZXMoKTtcblx0fTtcblxuXHRleHBvcnRzLk1PTlRIID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldE1vbnRoKCkgKyAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuTkVUV09SS0RBWVMgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBlbmRfZGF0ZSwgaG9saWRheXMpIHtcblx0ICByZXR1cm4gdGhpcy5ORVRXT1JLREFZUy5JTlRMKHN0YXJ0X2RhdGUsIGVuZF9kYXRlLCAxLCBob2xpZGF5cyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ORVRXT1JLREFZUy5JTlRMID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZW5kX2RhdGUsIHdlZWtlbmQsIGhvbGlkYXlzKSB7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgZW5kX2RhdGUgPSB1dGlscy5wYXJzZURhdGUoZW5kX2RhdGUpO1xuXHQgIGlmIChlbmRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZW5kX2RhdGU7XG5cdCAgfVxuXHQgIGlmICh3ZWVrZW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHdlZWtlbmQgPSBXRUVLRU5EX1RZUEVTWzFdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB3ZWVrZW5kID0gV0VFS0VORF9UWVBFU1t3ZWVrZW5kXTtcblx0ICB9XG5cdCAgaWYgKCEod2Vla2VuZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaG9saWRheXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgaG9saWRheXMgPSBbXTtcblx0ICB9IGVsc2UgaWYgKCEoaG9saWRheXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIGhvbGlkYXlzID0gW2hvbGlkYXlzXTtcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xpZGF5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGggPSB1dGlscy5wYXJzZURhdGUoaG9saWRheXNbaV0pO1xuXHQgICAgaWYgKGggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gaDtcblx0ICAgIH1cblx0ICAgIGhvbGlkYXlzW2ldID0gaDtcblx0ICB9XG5cdCAgdmFyIGRheXMgPSAoZW5kX2RhdGUgLSBzdGFydF9kYXRlKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSArIDE7XG5cdCAgdmFyIHRvdGFsID0gZGF5cztcblx0ICB2YXIgZGF5ID0gc3RhcnRfZGF0ZTtcblx0ICBmb3IgKGkgPSAwOyBpIDwgZGF5czsgaSsrKSB7XG5cdCAgICB2YXIgZCA9IChuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgPiAwKSA/IGRheS5nZXRVVENEYXkoKSA6IGRheS5nZXREYXkoKTtcblx0ICAgIHZhciBkZWMgPSBmYWxzZTtcblx0ICAgIGlmIChkID09PSB3ZWVrZW5kWzBdIHx8IGQgPT09IHdlZWtlbmRbMV0pIHtcblx0ICAgICAgZGVjID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgaG9saWRheXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgdmFyIGhvbGlkYXkgPSBob2xpZGF5c1tqXTtcblx0ICAgICAgaWYgKGhvbGlkYXkuZ2V0RGF0ZSgpID09PSBkYXkuZ2V0RGF0ZSgpICYmXG5cdCAgICAgICAgaG9saWRheS5nZXRNb250aCgpID09PSBkYXkuZ2V0TW9udGgoKSAmJlxuXHQgICAgICAgIGhvbGlkYXkuZ2V0RnVsbFllYXIoKSA9PT0gZGF5LmdldEZ1bGxZZWFyKCkpIHtcblx0ICAgICAgICBkZWMgPSB0cnVlO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZGVjKSB7XG5cdCAgICAgIHRvdGFsLS07XG5cdCAgICB9XG5cdCAgICBkYXkuc2V0RGF0ZShkYXkuZ2V0RGF0ZSgpICsgMSk7XG5cdCAgfVxuXHQgIHJldHVybiB0b3RhbDtcblx0fTtcblxuXHRleHBvcnRzLk5PVyA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBuZXcgRGF0ZSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VDT05EID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldFNlY29uZHMoKTtcblx0fTtcblxuXHRleHBvcnRzLlRJTUUgPSBmdW5jdGlvbihob3VyLCBtaW51dGUsIHNlY29uZCkge1xuXHQgIGhvdXIgPSB1dGlscy5wYXJzZU51bWJlcihob3VyKTtcblx0ICBtaW51dGUgPSB1dGlscy5wYXJzZU51bWJlcihtaW51dGUpO1xuXHQgIHNlY29uZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNlY29uZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoaG91ciwgbWludXRlLCBzZWNvbmQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChob3VyIDwgMCB8fCBtaW51dGUgPCAwIHx8IHNlY29uZCA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHQgIHJldHVybiAoMzYwMCAqIGhvdXIgKyA2MCAqIG1pbnV0ZSArIHNlY29uZCkgLyA4NjQwMDtcblx0fTtcblxuXHRleHBvcnRzLlRJTUVWQUxVRSA9IGZ1bmN0aW9uKHRpbWVfdGV4dCkge1xuXHQgIHRpbWVfdGV4dCA9IHV0aWxzLnBhcnNlRGF0ZSh0aW1lX3RleHQpO1xuXHQgIGlmICh0aW1lX3RleHQgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHRpbWVfdGV4dDtcblx0ICB9XG5cdCAgcmV0dXJuICgzNjAwICogdGltZV90ZXh0LmdldEhvdXJzKCkgK1xuXHQgICAgNjAgKiB0aW1lX3RleHQuZ2V0TWludXRlcygpICtcblx0ICAgIHRpbWVfdGV4dC5nZXRTZWNvbmRzKCkpIC8gODY0MDA7XG5cdH07XG5cblx0ZXhwb3J0cy5UT0RBWSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBuZXcgRGF0ZSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuV0VFS0RBWSA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIsIHJldHVybl90eXBlKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgaWYgKHJldHVybl90eXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybl90eXBlID0gMTtcblx0ICB9XG5cdCAgdmFyIGRheSA9IHNlcmlhbF9udW1iZXIuZ2V0RGF5KCk7XG5cdCAgcmV0dXJuIFdFRUtfVFlQRVNbcmV0dXJuX3R5cGVdW2RheV07XG5cdH07XG5cblx0ZXhwb3J0cy5XRUVLTlVNID0gZnVuY3Rpb24oc2VyaWFsX251bWJlciwgcmV0dXJuX3R5cGUpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICBpZiAocmV0dXJuX3R5cGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuX3R5cGUgPSAxO1xuXHQgIH1cblx0ICBpZiAocmV0dXJuX3R5cGUgPT09IDIxKSB7XG5cdCAgICByZXR1cm4gdGhpcy5JU09XRUVLTlVNKHNlcmlhbF9udW1iZXIpO1xuXHQgIH1cblx0ICB2YXIgd2Vla19zdGFydCA9IFdFRUtfU1RBUlRTW3JldHVybl90eXBlXTtcblx0ICB2YXIgamFuID0gbmV3IERhdGUoc2VyaWFsX251bWJlci5nZXRGdWxsWWVhcigpLCAwLCAxKTtcblx0ICB2YXIgaW5jID0gamFuLmdldERheSgpIDwgd2Vla19zdGFydCA/IDEgOiAwO1xuXHQgIGphbiAtPSBNYXRoLmFicyhqYW4uZ2V0RGF5KCkgLSB3ZWVrX3N0YXJ0KSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cdCAgcmV0dXJuIE1hdGguZmxvb3IoKChzZXJpYWxfbnVtYmVyIC0gamFuKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkgLyA3ICsgMSkgKyBpbmM7XG5cdH07XG5cblx0ZXhwb3J0cy5XT1JLREFZID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZGF5cywgaG9saWRheXMpIHtcblx0ICByZXR1cm4gdGhpcy5XT1JLREFZLklOVEwoc3RhcnRfZGF0ZSwgZGF5cywgMSwgaG9saWRheXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuV09SS0RBWS5JTlRMID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZGF5cywgd2Vla2VuZCwgaG9saWRheXMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBkYXlzID0gdXRpbHMucGFyc2VOdW1iZXIoZGF5cyk7XG5cdCAgaWYgKGRheXMgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGRheXM7XG5cdCAgfVxuXHQgIGlmIChkYXlzIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdCAgaWYgKHdlZWtlbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgd2Vla2VuZCA9IFdFRUtFTkRfVFlQRVNbMV07XG5cdCAgfSBlbHNlIHtcblx0ICAgIHdlZWtlbmQgPSBXRUVLRU5EX1RZUEVTW3dlZWtlbmRdO1xuXHQgIH1cblx0ICBpZiAoISh3ZWVrZW5kIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChob2xpZGF5cyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBob2xpZGF5cyA9IFtdO1xuXHQgIH0gZWxzZSBpZiAoIShob2xpZGF5cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgaG9saWRheXMgPSBbaG9saWRheXNdO1xuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGhvbGlkYXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgaCA9IHV0aWxzLnBhcnNlRGF0ZShob2xpZGF5c1tpXSk7XG5cdCAgICBpZiAoaCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiBoO1xuXHQgICAgfVxuXHQgICAgaG9saWRheXNbaV0gPSBoO1xuXHQgIH1cblx0ICB2YXIgZCA9IDA7XG5cdCAgd2hpbGUgKGQgPCBkYXlzKSB7XG5cdCAgICBzdGFydF9kYXRlLnNldERhdGUoc3RhcnRfZGF0ZS5nZXREYXRlKCkgKyAxKTtcblx0ICAgIHZhciBkYXkgPSBzdGFydF9kYXRlLmdldERheSgpO1xuXHQgICAgaWYgKGRheSA9PT0gd2Vla2VuZFswXSB8fCBkYXkgPT09IHdlZWtlbmRbMV0pIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhvbGlkYXlzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIHZhciBob2xpZGF5ID0gaG9saWRheXNbal07XG5cdCAgICAgIGlmIChob2xpZGF5LmdldERhdGUoKSA9PT0gc3RhcnRfZGF0ZS5nZXREYXRlKCkgJiZcblx0ICAgICAgICBob2xpZGF5LmdldE1vbnRoKCkgPT09IHN0YXJ0X2RhdGUuZ2V0TW9udGgoKSAmJlxuXHQgICAgICAgIGhvbGlkYXkuZ2V0RnVsbFllYXIoKSA9PT0gc3RhcnRfZGF0ZS5nZXRGdWxsWWVhcigpKSB7XG5cdCAgICAgICAgZC0tO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBkKys7XG5cdCAgfVxuXHQgIHJldHVybiBzdGFydF9kYXRlO1xuXHR9O1xuXG5cdGV4cG9ydHMuWUVBUiA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsX251bWJlci5nZXRGdWxsWWVhcigpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuXHQgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCAxLCAyOSkuZ2V0TW9udGgoKSA9PT0gMTtcblx0fVxuXG5cdC8vIFRPRE8gOiBVc2UgREFZUyA/XG5cdGZ1bmN0aW9uIGRheXNCZXR3ZWVuKHN0YXJ0X2RhdGUsIGVuZF9kYXRlKSB7XG5cdCAgcmV0dXJuIE1hdGguY2VpbCgoZW5kX2RhdGUgLSBzdGFydF9kYXRlKSAvIDEwMDAgLyA2MCAvIDYwIC8gMjQpO1xuXHR9XG5cblx0ZXhwb3J0cy5ZRUFSRlJBQyA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIGVuZF9kYXRlLCBiYXNpcykge1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIGVuZF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKGVuZF9kYXRlKTtcblx0ICBpZiAoZW5kX2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVuZF9kYXRlO1xuXHQgIH1cblxuXHQgIGJhc2lzID0gYmFzaXMgfHwgMDtcblx0ICB2YXIgc2QgPSBzdGFydF9kYXRlLmdldERhdGUoKTtcblx0ICB2YXIgc20gPSBzdGFydF9kYXRlLmdldE1vbnRoKCkgKyAxO1xuXHQgIHZhciBzeSA9IHN0YXJ0X2RhdGUuZ2V0RnVsbFllYXIoKTtcblx0ICB2YXIgZWQgPSBlbmRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgdmFyIGVtID0gZW5kX2RhdGUuZ2V0TW9udGgoKSArIDE7XG5cdCAgdmFyIGV5ID0gZW5kX2RhdGUuZ2V0RnVsbFllYXIoKTtcblxuXHQgIHN3aXRjaCAoYmFzaXMpIHtcblx0ICAgIGNhc2UgMDpcblx0ICAgICAgLy8gVVMgKE5BU0QpIDMwLzM2MFxuXHQgICAgICBpZiAoc2QgPT09IDMxICYmIGVkID09PSAzMSkge1xuXHQgICAgICAgIHNkID0gMzA7XG5cdCAgICAgICAgZWQgPSAzMDtcblx0ICAgICAgfSBlbHNlIGlmIChzZCA9PT0gMzEpIHtcblx0ICAgICAgICBzZCA9IDMwO1xuXHQgICAgICB9IGVsc2UgaWYgKHNkID09PSAzMCAmJiBlZCA9PT0gMzEpIHtcblx0ICAgICAgICBlZCA9IDMwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAoKGVkICsgZW0gKiAzMCArIGV5ICogMzYwKSAtIChzZCArIHNtICogMzAgKyBzeSAqIDM2MCkpIC8gMzYwO1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICAvLyBBY3R1YWwvYWN0dWFsXG5cdCAgICAgIHZhciBmZWIyOUJldHdlZW4gPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcblx0ICAgICAgICB2YXIgeWVhcjEgPSBkYXRlMS5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgIHZhciBtYXIxeWVhcjEgPSBuZXcgRGF0ZSh5ZWFyMSwgMiwgMSk7XG5cdCAgICAgICAgaWYgKGlzTGVhcFllYXIoeWVhcjEpICYmIGRhdGUxIDwgbWFyMXllYXIxICYmIGRhdGUyID49IG1hcjF5ZWFyMSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB5ZWFyMiA9IGRhdGUyLmdldEZ1bGxZZWFyKCk7XG5cdCAgICAgICAgdmFyIG1hcjF5ZWFyMiA9IG5ldyBEYXRlKHllYXIyLCAyLCAxKTtcblx0ICAgICAgICByZXR1cm4gKGlzTGVhcFllYXIoeWVhcjIpICYmIGRhdGUyID49IG1hcjF5ZWFyMiAmJiBkYXRlMSA8IG1hcjF5ZWFyMik7XG5cdCAgICAgIH07XG5cdCAgICAgIHZhciB5bGVuZ3RoID0gMzY1O1xuXHQgICAgICBpZiAoc3kgPT09IGV5IHx8ICgoc3kgKyAxKSA9PT0gZXkpICYmICgoc20gPiBlbSkgfHwgKChzbSA9PT0gZW0pICYmIChzZCA+PSBlZCkpKSkge1xuXHQgICAgICAgIGlmICgoc3kgPT09IGV5ICYmIGlzTGVhcFllYXIoc3kpKSB8fFxuXHQgICAgICAgICAgICBmZWIyOUJldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIHx8XG5cdCAgICAgICAgICAgIChlbSA9PT0gMSAmJiBlZCA9PT0gMjkpKSB7XG5cdCAgICAgICAgICB5bGVuZ3RoID0gMzY2O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIC8geWxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgeWVhcnMgPSAoZXkgLSBzeSkgKyAxO1xuXHQgICAgICB2YXIgZGF5cyA9IChuZXcgRGF0ZShleSArIDEsIDAsIDEpIC0gbmV3IERhdGUoc3ksIDAsIDEpKSAvIDEwMDAgLyA2MCAvIDYwIC8gMjQ7XG5cdCAgICAgIHZhciBhdmVyYWdlID0gZGF5cyAvIHllYXJzO1xuXHQgICAgICByZXR1cm4gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIC8gYXZlcmFnZTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgLy8gQWN0dWFsLzM2MFxuXHQgICAgICByZXR1cm4gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIC8gMzYwO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICAvLyBBY3R1YWwvMzY1XG5cdCAgICAgIHJldHVybiBkYXlzQmV0d2VlbihzdGFydF9kYXRlLCBlbmRfZGF0ZSkgLyAzNjU7XG5cdCAgICBjYXNlIDQ6XG5cdCAgICAgIC8vIEV1cm9wZWFuIDMwLzM2MFxuXHQgICAgICByZXR1cm4gKChlZCArIGVtICogMzAgKyBleSAqIDM2MCkgLSAoc2QgKyBzbSAqIDMwICsgc3kgKiAzNjApKSAvIDM2MDtcblx0ICB9XG5cdH07XG5cblx0ZnVuY3Rpb24gc2VyaWFsKGRhdGUpIHtcblx0ICB2YXIgYWRkT24gPSAoZGF0ZSA+IC0yMjAzODkxMjAwMDAwKT8yOjE7XG5cdCAgcmV0dXJuIChkYXRlIC0gZDE5MDApIC8gODY0MDAwMDAgKyBhZGRPbjtcblx0fVxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBzdGF0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBtYXRocyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0ZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuXHQgIGlmICghYXJyYXkpIHsgcmV0dXJuIGFycmF5OyB9XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmICghYXJyYXlbaV0pIHsgY29udGludWU7IH1cblx0ICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGV4cG9ydHMuRklOREZJRUxEID0gZnVuY3Rpb24oZGF0YWJhc2UsIHRpdGxlKSB7XG5cdCAgdmFyIGluZGV4ID0gbnVsbDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFiYXNlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoZGF0YWJhc2VbaV1bMF0gPT09IHRpdGxlKSB7XG5cdCAgICAgIGluZGV4ID0gaTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHRoZSBpbnB1dCBmaWVsZCB0aXRsZSBpcyBpbmNvcnJlY3Rcblx0ICBpZiAoaW5kZXggPT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0ZnVuY3Rpb24gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYXMpIHtcblx0ICB2YXIgbWF0Y2hlcyA9IHt9O1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgZGF0YWJhc2VbMF0ubGVuZ3RoOyArK2kpIHtcblx0ICAgIG1hdGNoZXNbaV0gPSB0cnVlO1xuXHQgIH1cblx0ICB2YXIgbWF4Q3JpdGVyaWFMZW5ndGggPSBjcml0ZXJpYXNbMF0ubGVuZ3RoO1xuXHQgIGZvciAoaSA9IDE7IGkgPCBjcml0ZXJpYXMubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmIChjcml0ZXJpYXNbaV0ubGVuZ3RoID4gbWF4Q3JpdGVyaWFMZW5ndGgpIHtcblx0ICAgICAgbWF4Q3JpdGVyaWFMZW5ndGggPSBjcml0ZXJpYXNbaV0ubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZvciAodmFyIGsgPSAxOyBrIDwgZGF0YWJhc2UubGVuZ3RoOyArK2spIHtcblx0ICAgIGZvciAodmFyIGwgPSAxOyBsIDwgZGF0YWJhc2Vba10ubGVuZ3RoOyArK2wpIHtcblx0ICAgICAgdmFyIGN1cnJlbnRDcml0ZXJpYVJlc3VsdCA9IGZhbHNlO1xuXHQgICAgICB2YXIgaGFzTWF0Y2hpbmdDcml0ZXJpYSAgID0gZmFsc2U7XG5cdCAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3JpdGVyaWFzLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgdmFyIGNyaXRlcmlhID0gY3JpdGVyaWFzW2pdO1xuXHQgICAgICAgIGlmIChjcml0ZXJpYS5sZW5ndGggPCBtYXhDcml0ZXJpYUxlbmd0aCkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNyaXRlcmlhRmllbGQgPSBjcml0ZXJpYVswXTtcblx0ICAgICAgICBpZiAoZGF0YWJhc2Vba11bMF0gIT09IGNyaXRlcmlhRmllbGQpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBoYXNNYXRjaGluZ0NyaXRlcmlhID0gdHJ1ZTtcblx0ICAgICAgICBmb3IgKHZhciBwID0gMTsgcCA8IGNyaXRlcmlhLmxlbmd0aDsgKytwKSB7XG5cdCAgICAgICAgICBjdXJyZW50Q3JpdGVyaWFSZXN1bHQgPSBjdXJyZW50Q3JpdGVyaWFSZXN1bHQgfHwgZXZhbChkYXRhYmFzZVtrXVtsXSArIGNyaXRlcmlhW3BdKTsgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoaGFzTWF0Y2hpbmdDcml0ZXJpYSkge1xuXHQgICAgICAgIG1hdGNoZXNbbF0gPSBtYXRjaGVzW2xdICYmIGN1cnJlbnRDcml0ZXJpYVJlc3VsdDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICBmb3IgKHZhciBuID0gMDsgbiA8IGRhdGFiYXNlWzBdLmxlbmd0aDsgKytuKSB7XG5cdCAgICBpZiAobWF0Y2hlc1tuXSkge1xuXHQgICAgICByZXN1bHQucHVzaChuIC0gMSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvLyBEYXRhYmFzZSBmdW5jdGlvbnNcblx0ZXhwb3J0cy5EQVZFUkFHRSA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHN1bSA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzdW0gKz0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0SW5kZXhlcy5sZW5ndGggPT09IDAgPyBlcnJvci5kaXYwIDogc3VtIC8gcmVzdWx0SW5kZXhlcy5sZW5ndGg7XG5cdH07XG5cblx0ZXhwb3J0cy5EQ09VTlQgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0YXRzLkNPVU5UKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EQ09VTlRBID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBzdGF0cy5DT1VOVEEodGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXHRleHBvcnRzLkRHRVQgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBubyByZWNvcmQgbWVldHMgdGhlIGNyaXRlcmlhXG5cdCAgaWYgKHJlc3VsdEluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIC8vIFJldHVybnMgdGhlICNOVU0hIGVycm9yIHZhbHVlIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSByZWNvcmQgbWVldHMgdGhlXG5cdCAgLy8gY3JpdGVyaWFcblx0ICBpZiAocmVzdWx0SW5kZXhlcy5sZW5ndGggPiAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1swXV07XG5cdH07XG5cblx0ZXhwb3J0cy5ETUFYID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgbWF4VmFsdWUgPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1swXV07XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAobWF4VmFsdWUgPCB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV0pIHtcblx0ICAgICAgbWF4VmFsdWUgPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtYXhWYWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLkRNSU4gPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciBtaW5WYWx1ZSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzWzBdXTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChtaW5WYWx1ZSA+IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXSkge1xuXHQgICAgICBtaW5WYWx1ZSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG1pblZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFBST0RVQ1QgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgdGFyZ2V0VmFsdWVzID0gY29tcGFjdCh0YXJnZXRWYWx1ZXMpO1xuXHQgIHZhciByZXN1bHQgPSAxO1xuXHQgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCAqPSB0YXJnZXRWYWx1ZXNbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5EU1RERVYgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgdGFyZ2V0VmFsdWVzID0gY29tcGFjdCh0YXJnZXRWYWx1ZXMpO1xuXHQgIHJldHVybiBzdGF0cy5TVERFVi5TKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EU1RERVZQID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHRhcmdldFZhbHVlcyA9IGNvbXBhY3QodGFyZ2V0VmFsdWVzKTtcblx0ICByZXR1cm4gc3RhdHMuU1RERVYuUCh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFNVTSA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gbWF0aHMuU1VNKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EVkFSID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBzdGF0cy5WQVIuUyh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFZBUlAgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0YXRzLlZBUi5QKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgaW5mb3JtYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHRleHBvcnRzLkFORCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciByZXN1bHQgPSB0cnVlO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKCFhcmdzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hPT1NFID0gZnVuY3Rpb24oKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgdmFyIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuXHQgIGlmIChpbmRleCA8IDEgfHwgaW5kZXggPiAyNTQpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IGluZGV4ICsgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBhcmd1bWVudHNbaW5kZXhdO1xuXHR9O1xuXG5cdGV4cG9ydHMuRkFMU0UgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0ZXhwb3J0cy5JRiA9IGZ1bmN0aW9uKHRlc3QsIHRoZW5fdmFsdWUsIG90aGVyd2lzZV92YWx1ZSkge1xuXHQgIHJldHVybiB0ZXN0ID8gdGhlbl92YWx1ZSA6IG90aGVyd2lzZV92YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLklGRVJST1IgPSBmdW5jdGlvbih2YWx1ZSwgdmFsdWVJZkVycm9yKSB7XG5cdCAgaWYgKGluZm9ybWF0aW9uLklTRVJST1IodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWVJZkVycm9yO1xuXHQgIH1cblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5JRk5BID0gZnVuY3Rpb24odmFsdWUsIHZhbHVlX2lmX25hKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSBlcnJvci5uYSA/IHZhbHVlX2lmX25hIDogdmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5OT1QgPSBmdW5jdGlvbihsb2dpY2FsKSB7XG5cdCAgcmV0dXJuICFsb2dpY2FsO1xuXHR9O1xuXG5cdGV4cG9ydHMuT1IgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoYXJnc1tpXSkge1xuXHQgICAgICByZXN1bHQgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJVRSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuWE9SID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoYXJnc1tpXSkge1xuXHQgICAgICByZXN1bHQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIChNYXRoLmZsb29yKE1hdGguYWJzKHJlc3VsdCkpICYgMSkgPyB0cnVlIDogZmFsc2U7XG5cdH07XG5cblx0ZXhwb3J0cy5TV0lUQ0ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApICB7XG5cdCAgICB2YXIgdGFyZ2V0VmFsdWUgPSBhcmd1bWVudHNbMF07XG5cdCAgICB2YXIgYXJnYyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXHQgICAgdmFyIHN3aXRjaENvdW50ID0gTWF0aC5mbG9vcihhcmdjIC8gMik7XG5cdCAgICB2YXIgc3dpdGNoU2F0aXNmaWVkID0gZmFsc2U7XG5cdCAgICB2YXIgZGVmYXVsdENsYXVzZSA9IGFyZ2MgJSAyID09PSAwID8gbnVsbCA6IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cblx0ICAgIGlmIChzd2l0Y2hDb3VudCkge1xuXHQgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3dpdGNoQ291bnQ7IGluZGV4KyspIHtcblx0ICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPT09IGFyZ3VtZW50c1tpbmRleCAqIDIgKyAxXSkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2luZGV4ICogMiArIDJdO1xuXHQgICAgICAgICAgc3dpdGNoU2F0aXNmaWVkID0gdHJ1ZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIXN3aXRjaFNhdGlzZmllZCAmJiBkZWZhdWx0Q2xhdXNlKSB7XG5cdCAgICAgIHJlc3VsdCA9IGRlZmF1bHRDbGF1c2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBkYXRlVGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdGZ1bmN0aW9uIHZhbGlkRGF0ZShkKSB7XG5cdCAgcmV0dXJuIGQgJiYgZC5nZXRUaW1lICYmICFpc05hTihkLmdldFRpbWUoKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbnN1cmVEYXRlKGQpIHtcblx0ICByZXR1cm4gKGQgaW5zdGFuY2VvZiBEYXRlKT9kOm5ldyBEYXRlKGQpO1xuXHR9XG5cblx0ZXhwb3J0cy5BQ0NSSU5UID0gZnVuY3Rpb24oaXNzdWUsIGZpcnN0LCBzZXR0bGVtZW50LCByYXRlLCBwYXIsIGZyZXF1ZW5jeSwgYmFzaXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIGRhdGUgaXMgaW52YWxpZFxuXHQgIGlzc3VlICAgICAgPSBlbnN1cmVEYXRlKGlzc3VlKTtcblx0ICBmaXJzdCAgICAgID0gZW5zdXJlRGF0ZShmaXJzdCk7XG5cdCAgc2V0dGxlbWVudCA9IGVuc3VyZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgaWYgKCF2YWxpZERhdGUoaXNzdWUpIHx8ICF2YWxpZERhdGUoZmlyc3QpIHx8ICF2YWxpZERhdGUoc2V0dGxlbWVudCkpIHtcblx0ICAgIHJldHVybiAnI1ZBTFVFISc7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciByYXRlIG9yIHBhciBhcmUgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwYXIgPD0gMCkge1xuXHQgICAgcmV0dXJuICcjTlVNISc7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZyZXF1ZW5jeSBpcyBuZWl0aGVyIDEsIDIsIG9yIDRcblx0ICBpZiAoWzEsIDIsIDRdLmluZGV4T2YoZnJlcXVlbmN5KSA9PT0gLTEpIHtcblx0ICAgIHJldHVybiAnI05VTSEnO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBiYXNpcyBpcyBuZWl0aGVyIDAsIDEsIDIsIDMsIG9yIDRcblx0ICBpZiAoWzAsIDEsIDIsIDMsIDRdLmluZGV4T2YoYmFzaXMpID09PSAtMSkge1xuXHQgICAgcmV0dXJuICcjTlVNISc7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgYmVmb3JlIG9yIGVxdWFsIHRvIGlzc3VlXG5cdCAgaWYgKHNldHRsZW1lbnQgPD0gaXNzdWUpIHtcblx0ICAgIHJldHVybiAnI05VTSEnO1xuXHQgIH1cblxuXHQgIC8vIFNldCBkZWZhdWx0IHZhbHVlc1xuXHQgIHBhciAgID0gcGFyICAgfHwgMDtcblx0ICBiYXNpcyA9IGJhc2lzIHx8IDA7XG5cblx0ICAvLyBDb21wdXRlIGFjY3J1ZWQgaW50ZXJlc3Rcblx0ICByZXR1cm4gcGFyICogcmF0ZSAqIGRhdGVUaW1lLllFQVJGUkFDKGlzc3VlLCBzZXR0bGVtZW50LCBiYXNpcyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkFDQ1JJTlRNID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0FDQ1JJTlRNIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5BTU9SREVHUkMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQU1PUkRFR1JDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5BTU9STElOQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdBTU9STElOQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUERBWUJTID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBEQVlCUyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUERBWVMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUERBWVMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBEQVlTTkMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUERBWVNOQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUE5DRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDT1VQTkNEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DT1VQTlVNID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBOVU0gaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBQQ0QgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUFBDRCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkNVTUlQTVQgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzLCB2YWx1ZSwgc3RhcnQsIGVuZCwgdHlwZSkge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXHQgIC8vIENyZWRpdHM6IEhhbm5lcyBTdGllYml0emhvZmVyIGZvciB0aGUgdHJhbnNsYXRpb25zIG9mIGZ1bmN0aW9uIGFuZCB2YXJpYWJsZSBuYW1lc1xuXHQgIC8vIFJlcXVpcmVzIGV4cG9ydHMuRlYoKSBhbmQgZXhwb3J0cy5QTVQoKSBmcm9tIGV4cG9ydHMuanMgW2h0dHA6Ly9zdG9pYy5jb20vZXhwb3J0cy9dXG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHZhbHVlID0gdXRpbHMucGFyc2VOdW1iZXIodmFsdWUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgcmF0ZSwgcGVyaW9kcywgb3IgdmFsdWUgYXJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuXHQgIGlmIChyYXRlIDw9IDAgfHwgcGVyaW9kcyA8PSAwIHx8IHZhbHVlIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHN0YXJ0IDwgMSwgZW5kIDwgMSwgb3Igc3RhcnQgPiBlbmRcblx0ICBpZiAoc3RhcnQgPCAxIHx8IGVuZCA8IDEgfHwgc3RhcnQgPiBlbmQpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHR5cGUgaXMgbmVpdGhlciAwIG5vciAxXG5cdCAgaWYgKHR5cGUgIT09IDAgJiYgdHlwZSAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb21wdXRlIGN1bXVsYXRpdmUgaW50ZXJlc3Rcblx0ICB2YXIgcGF5bWVudCA9IGV4cG9ydHMuUE1UKHJhdGUsIHBlcmlvZHMsIHZhbHVlLCAwLCB0eXBlKTtcblx0ICB2YXIgaW50ZXJlc3QgPSAwO1xuXG5cdCAgaWYgKHN0YXJ0ID09PSAxKSB7XG5cdCAgICBpZiAodHlwZSA9PT0gMCkge1xuXHQgICAgICBpbnRlcmVzdCA9IC12YWx1ZTtcblx0ICAgICAgc3RhcnQrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIGludGVyZXN0ICs9IGV4cG9ydHMuRlYocmF0ZSwgaSAtIDIsIHBheW1lbnQsIHZhbHVlLCAxKSAtIHBheW1lbnQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbnRlcmVzdCArPSBleHBvcnRzLkZWKHJhdGUsIGkgLSAxLCBwYXltZW50LCB2YWx1ZSwgMCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGludGVyZXN0ICo9IHJhdGU7XG5cblx0ICAvLyBSZXR1cm4gY3VtdWxhdGl2ZSBpbnRlcmVzdFxuXHQgIHJldHVybiBpbnRlcmVzdDtcblx0fTtcblxuXHRleHBvcnRzLkNVTVBSSU5DID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgdmFsdWUsIHN0YXJ0LCBlbmQsIHR5cGUpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2Vcblx0ICAvLyBDcmVkaXRzOiBIYW5uZXMgU3RpZWJpdHpob2ZlciBmb3IgdGhlIHRyYW5zbGF0aW9ucyBvZiBmdW5jdGlvbiBhbmQgdmFyaWFibGUgbmFtZXNcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgdmFsdWUgPSB1dGlscy5wYXJzZU51bWJlcih2YWx1ZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgdmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciByYXRlLCBwZXJpb2RzLCBvciB2YWx1ZSBhcmUgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwZXJpb2RzIDw9IDAgfHwgdmFsdWUgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc3RhcnQgPCAxLCBlbmQgPCAxLCBvciBzdGFydCA+IGVuZFxuXHQgIGlmIChzdGFydCA8IDEgfHwgZW5kIDwgMSB8fCBzdGFydCA+IGVuZCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdHlwZSBpcyBuZWl0aGVyIDAgbm9yIDFcblx0ICBpZiAodHlwZSAhPT0gMCAmJiB0eXBlICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgY3VtdWxhdGl2ZSBwcmluY2lwYWxcblx0ICB2YXIgcGF5bWVudCA9IGV4cG9ydHMuUE1UKHJhdGUsIHBlcmlvZHMsIHZhbHVlLCAwLCB0eXBlKTtcblx0ICB2YXIgcHJpbmNpcGFsID0gMDtcblx0ICBpZiAoc3RhcnQgPT09IDEpIHtcblx0ICAgIGlmICh0eXBlID09PSAwKSB7XG5cdCAgICAgIHByaW5jaXBhbCA9IHBheW1lbnQgKyB2YWx1ZSAqIHJhdGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwcmluY2lwYWwgPSBwYXltZW50O1xuXHQgICAgfVxuXHQgICAgc3RhcnQrKztcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG5cdCAgICBpZiAodHlwZSA+IDApIHtcblx0ICAgICAgcHJpbmNpcGFsICs9IHBheW1lbnQgLSAoZXhwb3J0cy5GVihyYXRlLCBpIC0gMiwgcGF5bWVudCwgdmFsdWUsIDEpIC0gcGF5bWVudCkgKiByYXRlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcHJpbmNpcGFsICs9IHBheW1lbnQgLSBleHBvcnRzLkZWKHJhdGUsIGkgLSAxLCBwYXltZW50LCB2YWx1ZSwgMCkgKiByYXRlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBjdW11bGF0aXZlIHByaW5jaXBhbFxuXHQgIHJldHVybiBwcmluY2lwYWw7XG5cdH07XG5cblx0ZXhwb3J0cy5EQiA9IGZ1bmN0aW9uKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCwgbW9udGgpIHtcblx0ICAvLyBJbml0aWFsaXplIG1vbnRoXG5cdCAgbW9udGggPSAobW9udGggPT09IHVuZGVmaW5lZCkgPyAxMiA6IG1vbnRoO1xuXG5cdCAgY29zdCA9IHV0aWxzLnBhcnNlTnVtYmVyKGNvc3QpO1xuXHQgIHNhbHZhZ2UgPSB1dGlscy5wYXJzZU51bWJlcihzYWx2YWdlKTtcblx0ICBsaWZlID0gdXRpbHMucGFyc2VOdW1iZXIobGlmZSk7XG5cdCAgcGVyaW9kID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kKTtcblx0ICBtb250aCA9IHV0aWxzLnBhcnNlTnVtYmVyKG1vbnRoKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QsIG1vbnRoKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgaXMgbmVnYXRpdmVcblx0ICBpZiAoY29zdCA8IDAgfHwgc2FsdmFnZSA8IDAgfHwgbGlmZSA8IDAgfHwgcGVyaW9kIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbW9udGggaXMgbm90IGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCAxMlxuXHQgIGlmIChbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl0uaW5kZXhPZihtb250aCkgPT09IC0xKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBwZXJpb2QgaXMgZ3JlYXRlciB0aGFuIGxpZmVcblx0ICBpZiAocGVyaW9kID4gbGlmZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gMCAoemVybykgaWYgc2FsdmFnZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gY29zdFxuXHQgIGlmIChzYWx2YWdlID49IGNvc3QpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIFJhdGUgaXMgcm91bmRlZCB0byB0aHJlZSBkZWNpbWFscyBwbGFjZXNcblx0ICB2YXIgcmF0ZSA9ICgxIC0gTWF0aC5wb3coc2FsdmFnZSAvIGNvc3QsIDEgLyBsaWZlKSkudG9GaXhlZCgzKTtcblxuXHQgIC8vIENvbXB1dGUgaW5pdGlhbCBkZXByZWNpYXRpb25cblx0ICB2YXIgaW5pdGlhbCA9IGNvc3QgKiByYXRlICogbW9udGggLyAxMjtcblxuXHQgIC8vIENvbXB1dGUgdG90YWwgZGVwcmVjaWF0aW9uXG5cdCAgdmFyIHRvdGFsID0gaW5pdGlhbDtcblx0ICB2YXIgY3VycmVudCA9IDA7XG5cdCAgdmFyIGNlaWxpbmcgPSAocGVyaW9kID09PSBsaWZlKSA/IGxpZmUgLSAxIDogcGVyaW9kO1xuXHQgIGZvciAodmFyIGkgPSAyOyBpIDw9IGNlaWxpbmc7IGkrKykge1xuXHQgICAgY3VycmVudCA9IChjb3N0IC0gdG90YWwpICogcmF0ZTtcblx0ICAgIHRvdGFsICs9IGN1cnJlbnQ7XG5cdCAgfVxuXG5cdCAgLy8gRGVwcmVjaWF0aW9uIGZvciB0aGUgZmlyc3QgYW5kIGxhc3QgcGVyaW9kcyBhcmUgc3BlY2lhbCBjYXNlc1xuXHQgIGlmIChwZXJpb2QgPT09IDEpIHtcblx0ICAgIC8vIEZpcnN0IHBlcmlvZFxuXHQgICAgcmV0dXJuIGluaXRpYWw7XG5cdCAgfSBlbHNlIGlmIChwZXJpb2QgPT09IGxpZmUpIHtcblx0ICAgIC8vIExhc3QgcGVyaW9kXG5cdCAgICByZXR1cm4gKGNvc3QgLSB0b3RhbCkgKiByYXRlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gY3VycmVudDtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5EREIgPSBmdW5jdGlvbihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QsIGZhY3Rvcikge1xuXHQgIC8vIEluaXRpYWxpemUgZmFjdG9yXG5cdCAgZmFjdG9yID0gKGZhY3RvciA9PT0gdW5kZWZpbmVkKSA/IDIgOiBmYWN0b3I7XG5cblx0ICBjb3N0ID0gdXRpbHMucGFyc2VOdW1iZXIoY29zdCk7XG5cdCAgc2FsdmFnZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNhbHZhZ2UpO1xuXHQgIGxpZmUgPSB1dGlscy5wYXJzZU51bWJlcihsaWZlKTtcblx0ICBwZXJpb2QgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2QpO1xuXHQgIGZhY3RvciA9IHV0aWxzLnBhcnNlTnVtYmVyKGZhY3Rvcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kLCBmYWN0b3IpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBpcyBuZWdhdGl2ZSBvciBpZiBmYWN0b3IgaXMgbnVsbFxuXHQgIGlmIChjb3N0IDwgMCB8fCBzYWx2YWdlIDwgMCB8fCBsaWZlIDwgMCB8fCBwZXJpb2QgPCAwIHx8IGZhY3RvciA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBwZXJpb2QgaXMgZ3JlYXRlciB0aGFuIGxpZmVcblx0ICBpZiAocGVyaW9kID4gbGlmZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gMCAoemVybykgaWYgc2FsdmFnZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gY29zdFxuXHQgIGlmIChzYWx2YWdlID49IGNvc3QpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgZGVwcmVjaWF0aW9uXG5cdCAgdmFyIHRvdGFsID0gMDtcblx0ICB2YXIgY3VycmVudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPD0gcGVyaW9kOyBpKyspIHtcblx0ICAgIGN1cnJlbnQgPSBNYXRoLm1pbigoY29zdCAtIHRvdGFsKSAqIChmYWN0b3IgLyBsaWZlKSwgKGNvc3QgLSBzYWx2YWdlIC0gdG90YWwpKTtcblx0ICAgIHRvdGFsICs9IGN1cnJlbnQ7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGRlcHJlY2lhdGlvblxuXHQgIHJldHVybiBjdXJyZW50O1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5ESVNDID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0RJU0MgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ET0xMQVJERSA9IGZ1bmN0aW9uKGRvbGxhciwgZnJhY3Rpb24pIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIGRvbGxhciA9IHV0aWxzLnBhcnNlTnVtYmVyKGRvbGxhcik7XG5cdCAgZnJhY3Rpb24gPSB1dGlscy5wYXJzZU51bWJlcihmcmFjdGlvbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZG9sbGFyLCBmcmFjdGlvbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZnJhY3Rpb24gaXMgbmVnYXRpdmVcblx0ICBpZiAoZnJhY3Rpb24gPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmcmFjdGlvbiBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzcyB0aGFuIDFcblx0ICBpZiAoZnJhY3Rpb24gPj0gMCAmJiBmcmFjdGlvbiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblxuXHQgIC8vIFRydW5jYXRlIGZyYWN0aW9uIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgZnJhY3Rpb24gPSBwYXJzZUludChmcmFjdGlvbiwgMTApO1xuXG5cdCAgLy8gQ29tcHV0ZSBpbnRlZ2VyIHBhcnRcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQoZG9sbGFyLCAxMCk7XG5cblx0ICAvLyBBZGQgZGVjaW1hbCBwYXJ0XG5cdCAgcmVzdWx0ICs9IChkb2xsYXIgJSAxKSAqIE1hdGgucG93KDEwLCBNYXRoLmNlaWwoTWF0aC5sb2coZnJhY3Rpb24pIC8gTWF0aC5MTjEwKSkgLyBmcmFjdGlvbjtcblxuXHQgIC8vIFJvdW5kIHJlc3VsdFxuXHQgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBNYXRoLmNlaWwoTWF0aC5sb2coZnJhY3Rpb24pIC8gTWF0aC5MTjIpICsgMSk7XG5cdCAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQgKiBwb3dlcikgLyBwb3dlcjtcblxuXHQgIC8vIFJldHVybiBjb252ZXJ0ZWQgZG9sbGFyIHByaWNlXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkRPTExBUkZSID0gZnVuY3Rpb24oZG9sbGFyLCBmcmFjdGlvbikge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgZG9sbGFyID0gdXRpbHMucGFyc2VOdW1iZXIoZG9sbGFyKTtcblx0ICBmcmFjdGlvbiA9IHV0aWxzLnBhcnNlTnVtYmVyKGZyYWN0aW9uKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkb2xsYXIsIGZyYWN0aW9uKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmcmFjdGlvbiBpcyBuZWdhdGl2ZVxuXHQgIGlmIChmcmFjdGlvbiA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZyYWN0aW9uIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIGFuZCBsZXNzIHRoYW4gMVxuXHQgIGlmIChmcmFjdGlvbiA+PSAwICYmIGZyYWN0aW9uIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgZnJhY3Rpb24gaWYgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICBmcmFjdGlvbiA9IHBhcnNlSW50KGZyYWN0aW9uLCAxMCk7XG5cblx0ICAvLyBDb21wdXRlIGludGVnZXIgcGFydFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChkb2xsYXIsIDEwKTtcblxuXHQgIC8vIEFkZCBkZWNpbWFsIHBhcnRcblx0ICByZXN1bHQgKz0gKGRvbGxhciAlIDEpICogTWF0aC5wb3coMTAsIC1NYXRoLmNlaWwoTWF0aC5sb2coZnJhY3Rpb24pIC8gTWF0aC5MTjEwKSkgKiBmcmFjdGlvbjtcblxuXHQgIC8vIFJldHVybiBjb252ZXJ0ZWQgZG9sbGFyIHByaWNlXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuRFVSQVRJT04gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignRFVSQVRJT04gaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5FRkZFQ1QgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzKSB7XG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiByYXRlIDw9MCBvciBwZXJpb2RzIDwgMVxuXHQgIGlmIChyYXRlIDw9IDAgfHwgcGVyaW9kcyA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgcGVyaW9kcyBpZiBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgIHBlcmlvZHMgPSBwYXJzZUludChwZXJpb2RzLCAxMCk7XG5cblx0ICAvLyBSZXR1cm4gZWZmZWN0aXZlIGFubnVhbCBpbnRlcmVzdCByYXRlXG5cdCAgcmV0dXJuIE1hdGgucG93KDEgKyByYXRlIC8gcGVyaW9kcywgcGVyaW9kcykgLSAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuRlYgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzLCBwYXltZW50LCB2YWx1ZSwgdHlwZSkge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgdmFsdWUgPSB2YWx1ZSB8fCAwO1xuXHQgIHR5cGUgPSB0eXBlIHx8IDA7XG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHBheW1lbnQgPSB1dGlscy5wYXJzZU51bWJlcihwYXltZW50KTtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgcGF5bWVudCwgdmFsdWUsIHR5cGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGZ1dHVyZSB2YWx1ZVxuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKHJhdGUgPT09IDApIHtcblx0ICAgIHJlc3VsdCA9IHZhbHVlICsgcGF5bWVudCAqIHBlcmlvZHM7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciB0ZXJtID0gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpO1xuXHQgICAgaWYgKHR5cGUgPT09IDEpIHtcblx0ICAgICAgcmVzdWx0ID0gdmFsdWUgKiB0ZXJtICsgcGF5bWVudCAqICgxICsgcmF0ZSkgKiAodGVybSAtIDEpIC8gcmF0ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc3VsdCA9IHZhbHVlICogdGVybSArIHBheW1lbnQgKiAodGVybSAtIDEpIC8gcmF0ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIC1yZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5GVlNDSEVEVUxFID0gZnVuY3Rpb24ocHJpbmNpcGFsLCBzY2hlZHVsZSkge1xuXHQgIHByaW5jaXBhbCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByaW5jaXBhbCk7XG5cdCAgc2NoZWR1bGUgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oc2NoZWR1bGUpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcmluY2lwYWwsIHNjaGVkdWxlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciBuID0gc2NoZWR1bGUubGVuZ3RoO1xuXHQgIHZhciBmdXR1cmUgPSBwcmluY2lwYWw7XG5cblx0ICAvLyBBcHBseSBhbGwgaW50ZXJlc3RzIGluIHNjaGVkdWxlXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIC8vIEFwcGx5IHNjaGVkdWxlZCBpbnRlcmVzdFxuXHQgICAgZnV0dXJlICo9IDEgKyBzY2hlZHVsZVtpXTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZnV0dXJlIHZhbHVlXG5cdCAgcmV0dXJuIGZ1dHVyZTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuSU5UUkFURSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdJTlRSQVRFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVBNVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICBmdXR1cmUgPSBmdXR1cmUgfHwgMDtcblx0ICB0eXBlID0gdHlwZSB8fCAwO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZCk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBDb21wdXRlIHBheW1lbnRcblx0ICB2YXIgcGF5bWVudCA9IGV4cG9ydHMuUE1UKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSk7XG5cblx0ICAvLyBDb21wdXRlIGludGVyZXN0XG5cdCAgdmFyIGludGVyZXN0O1xuXHQgIGlmIChwZXJpb2QgPT09IDEpIHtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIGludGVyZXN0ID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGludGVyZXN0ID0gLXByZXNlbnQ7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIGludGVyZXN0ID0gZXhwb3J0cy5GVihyYXRlLCBwZXJpb2QgLSAyLCBwYXltZW50LCBwcmVzZW50LCAxKSAtIHBheW1lbnQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbnRlcmVzdCA9IGV4cG9ydHMuRlYocmF0ZSwgcGVyaW9kIC0gMSwgcGF5bWVudCwgcHJlc2VudCwgMCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGludGVyZXN0XG5cdCAgcmV0dXJuIGludGVyZXN0ICogcmF0ZTtcblx0fTtcblxuXHRleHBvcnRzLklSUiA9IGZ1bmN0aW9uKHZhbHVlcywgZ3Vlc3MpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIGd1ZXNzID0gZ3Vlc3MgfHwgMDtcblxuXHQgIHZhbHVlcyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbih2YWx1ZXMpKTtcblx0ICBndWVzcyA9IHV0aWxzLnBhcnNlTnVtYmVyKGd1ZXNzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih2YWx1ZXMsIGd1ZXNzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIENhbGN1bGF0ZXMgdGhlIHJlc3VsdGluZyBhbW91bnRcblx0ICB2YXIgaXJyUmVzdWx0ID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgcmF0ZSkge1xuXHQgICAgdmFyIHIgPSByYXRlICsgMTtcblx0ICAgIHZhciByZXN1bHQgPSB2YWx1ZXNbMF07XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICByZXN1bHQgKz0gdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgKGRhdGVzW2ldIC0gZGF0ZXNbMF0pIC8gMzY1KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgIC8vIENhbGN1bGF0ZXMgdGhlIGZpcnN0IGRlcml2YXRpb25cblx0ICB2YXIgaXJyUmVzdWx0RGVyaXYgPSBmdW5jdGlvbih2YWx1ZXMsIGRhdGVzLCByYXRlKSB7XG5cdCAgICB2YXIgciA9IHJhdGUgKyAxO1xuXHQgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgZnJhYyA9IChkYXRlc1tpXSAtIGRhdGVzWzBdKSAvIDM2NTtcblx0ICAgICAgcmVzdWx0IC09IGZyYWMgKiB2YWx1ZXNbaV0gLyBNYXRoLnBvdyhyLCBmcmFjICsgMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBJbml0aWFsaXplIGRhdGVzIGFuZCBjaGVjayB0aGF0IHZhbHVlcyBjb250YWlucyBhdCBsZWFzdCBvbmUgcG9zaXRpdmUgdmFsdWUgYW5kIG9uZSBuZWdhdGl2ZSB2YWx1ZVxuXHQgIHZhciBkYXRlcyA9IFtdO1xuXHQgIHZhciBwb3NpdGl2ZSA9IGZhbHNlO1xuXHQgIHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBkYXRlc1tpXSA9IChpID09PSAwKSA/IDAgOiBkYXRlc1tpIC0gMV0gKyAzNjU7XG5cdCAgICBpZiAodmFsdWVzW2ldID4gMCkge1xuXHQgICAgICBwb3NpdGl2ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWVzW2ldIDwgMCkge1xuXHQgICAgICBuZWdhdGl2ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHZhbHVlcyBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSBwb3NpdGl2ZSB2YWx1ZSBhbmQgb25lIG5lZ2F0aXZlIHZhbHVlXG5cdCAgaWYgKCFwb3NpdGl2ZSB8fCAhbmVnYXRpdmUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSW5pdGlhbGl6ZSBndWVzcyBhbmQgcmVzdWx0UmF0ZVxuXHQgIGd1ZXNzID0gKGd1ZXNzID09PSB1bmRlZmluZWQpID8gMC4xIDogZ3Vlc3M7XG5cdCAgdmFyIHJlc3VsdFJhdGUgPSBndWVzcztcblxuXHQgIC8vIFNldCBtYXhpbXVtIGVwc2lsb24gZm9yIGVuZCBvZiBpdGVyYXRpb25cblx0ICB2YXIgZXBzTWF4ID0gMWUtMTA7XG5cblx0ICAvLyBJbXBsZW1lbnQgTmV3dG9uJ3MgbWV0aG9kXG5cdCAgdmFyIG5ld1JhdGUsIGVwc1JhdGUsIHJlc3VsdFZhbHVlO1xuXHQgIHZhciBjb250TG9vcCA9IHRydWU7XG5cdCAgZG8ge1xuXHQgICAgcmVzdWx0VmFsdWUgPSBpcnJSZXN1bHQodmFsdWVzLCBkYXRlcywgcmVzdWx0UmF0ZSk7XG5cdCAgICBuZXdSYXRlID0gcmVzdWx0UmF0ZSAtIHJlc3VsdFZhbHVlIC8gaXJyUmVzdWx0RGVyaXYodmFsdWVzLCBkYXRlcywgcmVzdWx0UmF0ZSk7XG5cdCAgICBlcHNSYXRlID0gTWF0aC5hYnMobmV3UmF0ZSAtIHJlc3VsdFJhdGUpO1xuXHQgICAgcmVzdWx0UmF0ZSA9IG5ld1JhdGU7XG5cdCAgICBjb250TG9vcCA9IChlcHNSYXRlID4gZXBzTWF4KSAmJiAoTWF0aC5hYnMocmVzdWx0VmFsdWUpID4gZXBzTWF4KTtcblx0ICB9IHdoaWxlIChjb250TG9vcCk7XG5cblx0ICAvLyBSZXR1cm4gaW50ZXJuYWwgcmF0ZSBvZiByZXR1cm5cblx0ICByZXR1cm4gcmVzdWx0UmF0ZTtcblx0fTtcblxuXHRleHBvcnRzLklTUE1UID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kLCBwZXJpb2RzLCB2YWx1ZSkge1xuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2QgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2QpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBpbnRlcmVzdFxuXHQgIHJldHVybiB2YWx1ZSAqIHJhdGUgKiAocGVyaW9kIC8gcGVyaW9kcyAtIDEpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5NRFVSQVRJT04gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignTURVUkFUSU9OIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlSUiA9IGZ1bmN0aW9uKHZhbHVlcywgZmluYW5jZV9yYXRlLCByZWludmVzdF9yYXRlKSB7XG5cdCAgdmFsdWVzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHZhbHVlcykpO1xuXHQgIGZpbmFuY2VfcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZpbmFuY2VfcmF0ZSk7XG5cdCAgcmVpbnZlc3RfcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJlaW52ZXN0X3JhdGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHZhbHVlcywgZmluYW5jZV9yYXRlLCByZWludmVzdF9yYXRlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIEluaXRpYWxpemUgbnVtYmVyIG9mIHZhbHVlc1xuXHQgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcblxuXHQgIC8vIExvb2t1cCBwYXltZW50cyAobmVnYXRpdmUgdmFsdWVzKSBhbmQgaW5jb21lcyAocG9zaXRpdmUgdmFsdWVzKVxuXHQgIHZhciBwYXltZW50cyA9IFtdO1xuXHQgIHZhciBpbmNvbWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGlmICh2YWx1ZXNbaV0gPCAwKSB7XG5cdCAgICAgIHBheW1lbnRzLnB1c2godmFsdWVzW2ldKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGluY29tZXMucHVzaCh2YWx1ZXNbaV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBtb2RpZmllZCBpbnRlcm5hbCByYXRlIG9mIHJldHVyblxuXHQgIHZhciBudW0gPSAtZXhwb3J0cy5OUFYocmVpbnZlc3RfcmF0ZSwgaW5jb21lcykgKiBNYXRoLnBvdygxICsgcmVpbnZlc3RfcmF0ZSwgbiAtIDEpO1xuXHQgIHZhciBkZW4gPSBleHBvcnRzLk5QVihmaW5hbmNlX3JhdGUsIHBheW1lbnRzKSAqICgxICsgZmluYW5jZV9yYXRlKTtcblx0ICByZXR1cm4gTWF0aC5wb3cobnVtIC8gZGVuLCAxIC8gKG4gLSAxKSkgLSAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9NSU5BTCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHJhdGUgPD0wIG9yIHBlcmlvZHMgPCAxXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwZXJpb2RzIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBUcnVuY2F0ZSBwZXJpb2RzIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgcGVyaW9kcyA9IHBhcnNlSW50KHBlcmlvZHMsIDEwKTtcblxuXHQgIC8vIFJldHVybiBub21pbmFsIGFubnVhbCBpbnRlcmVzdCByYXRlXG5cdCAgcmV0dXJuIChNYXRoLnBvdyhyYXRlICsgMSwgMSAvIHBlcmlvZHMpIC0gMSkgKiBwZXJpb2RzO1xuXHR9O1xuXG5cdGV4cG9ydHMuTlBFUiA9IGZ1bmN0aW9uKHJhdGUsIHBheW1lbnQsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkge1xuXHQgIHR5cGUgPSAodHlwZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiB0eXBlO1xuXHQgIGZ1dHVyZSA9IChmdXR1cmUgPT09IHVuZGVmaW5lZCkgPyAwIDogZnV0dXJlO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBheW1lbnQgPSB1dGlscy5wYXJzZU51bWJlcihwYXltZW50KTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGF5bWVudCwgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBudW1iZXIgb2YgcGVyaW9kc1xuXHQgIHZhciBudW0gPSBwYXltZW50ICogKDEgKyByYXRlICogdHlwZSkgLSBmdXR1cmUgKiByYXRlO1xuXHQgIHZhciBkZW4gPSAocHJlc2VudCAqIHJhdGUgKyBwYXltZW50ICogKDEgKyByYXRlICogdHlwZSkpO1xuXHQgIHJldHVybiBNYXRoLmxvZyhudW0gLyBkZW4pIC8gTWF0aC5sb2coMSArIHJhdGUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTlBWID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGFyZ3M7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHJhdGVcblx0ICB2YXIgcmF0ZSA9IGFyZ3NbMF07XG5cblx0ICAvLyBJbml0aWFsaXplIG5ldCBwcmVzZW50IHZhbHVlXG5cdCAgdmFyIHZhbHVlID0gMDtcblxuXHQgIC8vIExvb3Agb24gYWxsIHZhbHVlc1xuXHQgIGZvciAodmFyIGogPSAxOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuXHQgICAgdmFsdWUgKz0gYXJnc1tqXSAvIE1hdGgucG93KDEgKyByYXRlLCBqKTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbmV0IHByZXNlbnQgdmFsdWVcblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9EREZQUklDRSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERGUFJJQ0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9EREZZSUVMRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERGWUlFTEQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9ERExQUklDRSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERMUFJJQ0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9ERExZSUVMRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERMWUlFTEQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5QRFVSQVRJT04gPSBmdW5jdGlvbihyYXRlLCBwcmVzZW50LCBmdXR1cmUpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcHJlc2VudCwgZnV0dXJlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiByYXRlIDw9MFxuXHQgIGlmIChyYXRlIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBvZiBwZXJpb2RzXG5cdCAgcmV0dXJuIChNYXRoLmxvZyhmdXR1cmUpIC0gTWF0aC5sb2cocHJlc2VudCkpIC8gTWF0aC5sb2coMSArIHJhdGUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUE1UID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICBmdXR1cmUgPSBmdXR1cmUgfHwgMDtcblx0ICB0eXBlID0gdHlwZSB8fCAwO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBwYXltZW50XG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAocmF0ZSA9PT0gMCkge1xuXHQgICAgcmVzdWx0ID0gKHByZXNlbnQgKyBmdXR1cmUpIC8gcGVyaW9kcztcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHRlcm0gPSBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyk7XG5cdCAgICBpZiAodHlwZSA9PT0gMSkge1xuXHQgICAgICByZXN1bHQgPSAoZnV0dXJlICogcmF0ZSAvICh0ZXJtIC0gMSkgKyBwcmVzZW50ICogcmF0ZSAvICgxIC0gMSAvIHRlcm0pKSAvICgxICsgcmF0ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXN1bHQgPSBmdXR1cmUgKiByYXRlIC8gKHRlcm0gLSAxKSArIHByZXNlbnQgKiByYXRlIC8gKDEgLSAxIC8gdGVybSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAtcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuUFBNVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgZnV0dXJlID0gZnV0dXJlIHx8IDA7XG5cdCAgdHlwZSA9IHR5cGUgfHwgMDtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gZXhwb3J0cy5QTVQocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSAtIGV4cG9ydHMuSVBNVChyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlBSSUNFID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1BSSUNFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5QUklDRURJU0MgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignUFJJQ0VESVNDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5QUklDRU1BVCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdQUklDRU1BVCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLlBWID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgcGF5bWVudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgZnV0dXJlID0gZnV0dXJlIHx8IDA7XG5cdCAgdHlwZSA9IHR5cGUgfHwgMDtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcGF5bWVudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBheW1lbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHBheW1lbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gcHJlc2VudCB2YWx1ZVxuXHQgIGlmIChyYXRlID09PSAwKSB7XG5cdCAgICByZXR1cm4gLXBheW1lbnQgKiBwZXJpb2RzIC0gZnV0dXJlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gKCgoMSAtIE1hdGgucG93KDEgKyByYXRlLCBwZXJpb2RzKSkgLyByYXRlKSAqIHBheW1lbnQgKiAoMSArIHJhdGUgKiB0eXBlKSAtIGZ1dHVyZSkgLyBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyk7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuUkFURSA9IGZ1bmN0aW9uKHBlcmlvZHMsIHBheW1lbnQsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSwgZ3Vlc3MpIHtcblx0ICAvLyBDcmVkaXRzOiByYWJ1Z2VudG9cblxuXHQgIGd1ZXNzID0gKGd1ZXNzID09PSB1bmRlZmluZWQpID8gMC4wMSA6IGd1ZXNzO1xuXHQgIGZ1dHVyZSA9IChmdXR1cmUgPT09IHVuZGVmaW5lZCkgPyAwIDogZnV0dXJlO1xuXHQgIHR5cGUgPSAodHlwZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiB0eXBlO1xuXG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHBheW1lbnQgPSB1dGlscy5wYXJzZU51bWJlcihwYXltZW50KTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgZ3Vlc3MgPSB1dGlscy5wYXJzZU51bWJlcihndWVzcyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocGVyaW9kcywgcGF5bWVudCwgcHJlc2VudCwgZnV0dXJlLCB0eXBlLCBndWVzcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBTZXQgbWF4aW11bSBlcHNpbG9uIGZvciBlbmQgb2YgaXRlcmF0aW9uXG5cdCAgdmFyIGVwc01heCA9IDFlLTY7XG5cblx0ICAvLyBTZXQgbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uc1xuXHQgIHZhciBpdGVyTWF4ID0gMTAwO1xuXHQgIHZhciBpdGVyID0gMDtcblx0ICB2YXIgY2xvc2UgPSBmYWxzZTtcblx0ICB2YXIgcmF0ZSA9IGd1ZXNzO1xuXG5cdCAgd2hpbGUgKGl0ZXIgPCBpdGVyTWF4ICYmICFjbG9zZSkge1xuXHQgICAgdmFyIHQxID0gTWF0aC5wb3cocmF0ZSArIDEsIHBlcmlvZHMpO1xuXHQgICAgdmFyIHQyID0gTWF0aC5wb3cocmF0ZSArIDEsIHBlcmlvZHMgLSAxKTtcblxuXHQgICAgdmFyIGYxID0gZnV0dXJlICsgdDEgKiBwcmVzZW50ICsgcGF5bWVudCAqICh0MSAtIDEpICogKHJhdGUgKiB0eXBlICsgMSkgLyByYXRlO1xuXHQgICAgdmFyIGYyID0gcGVyaW9kcyAqIHQyICogcHJlc2VudCAtIHBheW1lbnQgKiAodDEgLSAxKSAqKHJhdGUgKiB0eXBlICsgMSkgLyBNYXRoLnBvdyhyYXRlLDIpO1xuXHQgICAgdmFyIGYzID0gcGVyaW9kcyAqIHBheW1lbnQgKiB0MiAqIChyYXRlICogdHlwZSArIDEpIC8gcmF0ZSArIHBheW1lbnQgKiAodDEgLSAxKSAqIHR5cGUgLyByYXRlO1xuXG5cdCAgICB2YXIgbmV3UmF0ZSA9IHJhdGUgLSBmMSAvIChmMiArIGYzKTtcblxuXHQgICAgaWYgKE1hdGguYWJzKG5ld1JhdGUgLSByYXRlKSA8IGVwc01heCkgY2xvc2UgPSB0cnVlO1xuXHQgICAgaXRlcisrXG5cdCAgICByYXRlID0gbmV3UmF0ZTtcblx0ICB9XG5cblx0ICBpZiAoIWNsb3NlKSByZXR1cm4gTnVtYmVyLk5hTiArIHJhdGU7XG5cdCAgcmV0dXJuIHJhdGU7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlJFQ0VJVkVEID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1JFQ0VJVkVEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUlJJID0gZnVuY3Rpb24ocGVyaW9kcywgcHJlc2VudCwgZnV0dXJlKSB7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcGVyaW9kcyBvciBwcmVzZW50IGlzIGVxdWFsIHRvIDAgKHplcm8pXG5cdCAgaWYgKHBlcmlvZHMgPT09IDAgfHwgcHJlc2VudCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXF1aXZhbGVudCBpbnRlcmVzdCByYXRlXG5cdCAgcmV0dXJuIE1hdGgucG93KGZ1dHVyZSAvIHByZXNlbnQsIDEgLyBwZXJpb2RzKSAtIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5TTE4gPSBmdW5jdGlvbihjb3N0LCBzYWx2YWdlLCBsaWZlKSB7XG5cdCAgY29zdCA9IHV0aWxzLnBhcnNlTnVtYmVyKGNvc3QpO1xuXHQgIHNhbHZhZ2UgPSB1dGlscy5wYXJzZU51bWJlcihzYWx2YWdlKTtcblx0ICBsaWZlID0gdXRpbHMucGFyc2VOdW1iZXIobGlmZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoY29zdCwgc2FsdmFnZSwgbGlmZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbGlmZSBlcXVhbCB0byAwICh6ZXJvKVxuXHQgIGlmIChsaWZlID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBzdHJhaWdodC1saW5lIGRlcHJlY2lhdGlvblxuXHQgIHJldHVybiAoY29zdCAtIHNhbHZhZ2UpIC8gbGlmZTtcblx0fTtcblxuXHRleHBvcnRzLlNZRCA9IGZ1bmN0aW9uKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgaXMgbm90IGEgbnVtYmVyXG5cdCAgY29zdCA9IHV0aWxzLnBhcnNlTnVtYmVyKGNvc3QpO1xuXHQgIHNhbHZhZ2UgPSB1dGlscy5wYXJzZU51bWJlcihzYWx2YWdlKTtcblx0ICBsaWZlID0gdXRpbHMucGFyc2VOdW1iZXIobGlmZSk7XG5cdCAgcGVyaW9kID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGxpZmUgZXF1YWwgdG8gMCAoemVybylcblx0ICBpZiAobGlmZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcGVyaW9kIGlzIGxvd2VyIHRoYW4gMSBvciBncmVhdGVyIHRoYW4gbGlmZVxuXHQgIGlmIChwZXJpb2QgPCAxIHx8IHBlcmlvZCA+IGxpZmUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgcGVyaW9kIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgcGVyaW9kID0gcGFyc2VJbnQocGVyaW9kLCAxMCk7XG5cblx0ICAvLyBSZXR1cm4gc3RyYWlnaHQtbGluZSBkZXByZWNpYXRpb25cblx0ICByZXR1cm4gKChjb3N0IC0gc2FsdmFnZSkgKiAobGlmZSAtIHBlcmlvZCArIDEpICogMikgLyAobGlmZSAqIChsaWZlICsgMSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVEJJTExFUSA9IGZ1bmN0aW9uKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkge1xuXHQgIHNldHRsZW1lbnQgPSB1dGlscy5wYXJzZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgbWF0dXJpdHkgPSB1dGlscy5wYXJzZURhdGUobWF0dXJpdHkpO1xuXHQgIGRpc2NvdW50ID0gdXRpbHMucGFyc2VOdW1iZXIoZGlzY291bnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZGlzY291bnQgaXMgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKGRpc2NvdW50IDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgZ3JlYXRlciB0aGFuIG1hdHVyaXR5XG5cdCAgaWYgKHNldHRsZW1lbnQgPiBtYXR1cml0eSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbWF0dXJpdHkgaXMgbW9yZSB0aGFuIG9uZSB5ZWFyIGFmdGVyIHNldHRsZW1lbnRcblx0ICBpZiAobWF0dXJpdHkgLSBzZXR0bGVtZW50ID4gMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYm9uZC1lcXVpdmFsZW50IHlpZWxkXG5cdCAgcmV0dXJuICgzNjUgKiBkaXNjb3VudCkgLyAoMzYwIC0gZGlzY291bnQgKiBkYXRlVGltZS5EQVlTMzYwKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBmYWxzZSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVEJJTExQUklDRSA9IGZ1bmN0aW9uKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkge1xuXHQgIHNldHRsZW1lbnQgPSB1dGlscy5wYXJzZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgbWF0dXJpdHkgPSB1dGlscy5wYXJzZURhdGUobWF0dXJpdHkpO1xuXHQgIGRpc2NvdW50ID0gdXRpbHMucGFyc2VOdW1iZXIoZGlzY291bnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZGlzY291bnQgaXMgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKGRpc2NvdW50IDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgZ3JlYXRlciB0aGFuIG1hdHVyaXR5XG5cdCAgaWYgKHNldHRsZW1lbnQgPiBtYXR1cml0eSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbWF0dXJpdHkgaXMgbW9yZSB0aGFuIG9uZSB5ZWFyIGFmdGVyIHNldHRsZW1lbnRcblx0ICBpZiAobWF0dXJpdHkgLSBzZXR0bGVtZW50ID4gMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYm9uZC1lcXVpdmFsZW50IHlpZWxkXG5cdCAgcmV0dXJuIDEwMCAqICgxIC0gZGlzY291bnQgKiBkYXRlVGltZS5EQVlTMzYwKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBmYWxzZSkgLyAzNjApO1xuXHR9O1xuXG5cdGV4cG9ydHMuVEJJTExZSUVMRCA9IGZ1bmN0aW9uKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBwcmljZSkge1xuXHQgIHNldHRsZW1lbnQgPSB1dGlscy5wYXJzZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgbWF0dXJpdHkgPSB1dGlscy5wYXJzZURhdGUobWF0dXJpdHkpO1xuXHQgIHByaWNlID0gdXRpbHMucGFyc2VOdW1iZXIocHJpY2UpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBwcmljZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcHJpY2UgaXMgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHByaWNlIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgZ3JlYXRlciB0aGFuIG1hdHVyaXR5XG5cdCAgaWYgKHNldHRsZW1lbnQgPiBtYXR1cml0eSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbWF0dXJpdHkgaXMgbW9yZSB0aGFuIG9uZSB5ZWFyIGFmdGVyIHNldHRsZW1lbnRcblx0ICBpZiAobWF0dXJpdHkgLSBzZXR0bGVtZW50ID4gMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYm9uZC1lcXVpdmFsZW50IHlpZWxkXG5cdCAgcmV0dXJuICgxMDAgLSBwcmljZSkgKiAzNjAgLyAocHJpY2UgKiBkYXRlVGltZS5EQVlTMzYwKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBmYWxzZSkpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5WREIgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignVkRCIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5YSVJSID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgZ3Vlc3MpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIHZhbHVlcyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbih2YWx1ZXMpKTtcblx0ICBkYXRlcyA9IHV0aWxzLnBhcnNlRGF0ZUFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0ZXMpKTtcblx0ICBndWVzcyA9IHV0aWxzLnBhcnNlTnVtYmVyKGd1ZXNzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih2YWx1ZXMsIGRhdGVzLCBndWVzcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBDYWxjdWxhdGVzIHRoZSByZXN1bHRpbmcgYW1vdW50XG5cdCAgdmFyIGlyclJlc3VsdCA9IGZ1bmN0aW9uKHZhbHVlcywgZGF0ZXMsIHJhdGUpIHtcblx0ICAgIHZhciByID0gcmF0ZSArIDE7XG5cdCAgICB2YXIgcmVzdWx0ID0gdmFsdWVzWzBdO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcmVzdWx0ICs9IHZhbHVlc1tpXSAvIE1hdGgucG93KHIsIGRhdGVUaW1lLkRBWVMoZGF0ZXNbaV0sIGRhdGVzWzBdKSAvIDM2NSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBDYWxjdWxhdGVzIHRoZSBmaXJzdCBkZXJpdmF0aW9uXG5cdCAgdmFyIGlyclJlc3VsdERlcml2ID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgcmF0ZSkge1xuXHQgICAgdmFyIHIgPSByYXRlICsgMTtcblx0ICAgIHZhciByZXN1bHQgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGZyYWMgPSBkYXRlVGltZS5EQVlTKGRhdGVzW2ldLCBkYXRlc1swXSkgLyAzNjU7XG5cdCAgICAgIHJlc3VsdCAtPSBmcmFjICogdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgZnJhYyArIDEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gQ2hlY2sgdGhhdCB2YWx1ZXMgY29udGFpbnMgYXQgbGVhc3Qgb25lIHBvc2l0aXZlIHZhbHVlIGFuZCBvbmUgbmVnYXRpdmUgdmFsdWVcblx0ICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcblx0ICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHZhbHVlc1tpXSA+IDApIHtcblx0ICAgICAgcG9zaXRpdmUgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlc1tpXSA8IDApIHtcblx0ICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB2YWx1ZXMgZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcG9zaXRpdmUgdmFsdWUgYW5kIG9uZSBuZWdhdGl2ZSB2YWx1ZVxuXHQgIGlmICghcG9zaXRpdmUgfHwgIW5lZ2F0aXZlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIEluaXRpYWxpemUgZ3Vlc3MgYW5kIHJlc3VsdFJhdGVcblx0ICBndWVzcyA9IGd1ZXNzIHx8IDAuMTtcblx0ICB2YXIgcmVzdWx0UmF0ZSA9IGd1ZXNzO1xuXG5cdCAgLy8gU2V0IG1heGltdW0gZXBzaWxvbiBmb3IgZW5kIG9mIGl0ZXJhdGlvblxuXHQgIHZhciBlcHNNYXggPSAxZS0xMDtcblxuXHQgIC8vIEltcGxlbWVudCBOZXd0b24ncyBtZXRob2Rcblx0ICB2YXIgbmV3UmF0ZSwgZXBzUmF0ZSwgcmVzdWx0VmFsdWU7XG5cdCAgdmFyIGNvbnRMb29wID0gdHJ1ZTtcblx0ICBkbyB7XG5cdCAgICByZXN1bHRWYWx1ZSA9IGlyclJlc3VsdCh2YWx1ZXMsIGRhdGVzLCByZXN1bHRSYXRlKTtcblx0ICAgIG5ld1JhdGUgPSByZXN1bHRSYXRlIC0gcmVzdWx0VmFsdWUgLyBpcnJSZXN1bHREZXJpdih2YWx1ZXMsIGRhdGVzLCByZXN1bHRSYXRlKTtcblx0ICAgIGVwc1JhdGUgPSBNYXRoLmFicyhuZXdSYXRlIC0gcmVzdWx0UmF0ZSk7XG5cdCAgICByZXN1bHRSYXRlID0gbmV3UmF0ZTtcblx0ICAgIGNvbnRMb29wID0gKGVwc1JhdGUgPiBlcHNNYXgpICYmIChNYXRoLmFicyhyZXN1bHRWYWx1ZSkgPiBlcHNNYXgpO1xuXHQgIH0gd2hpbGUgKGNvbnRMb29wKTtcblxuXHQgIC8vIFJldHVybiBpbnRlcm5hbCByYXRlIG9mIHJldHVyblxuXHQgIHJldHVybiByZXN1bHRSYXRlO1xuXHR9O1xuXG5cdGV4cG9ydHMuWE5QViA9IGZ1bmN0aW9uKHJhdGUsIHZhbHVlcywgZGF0ZXMpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgdmFsdWVzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHZhbHVlcykpO1xuXHQgIGRhdGVzID0gdXRpbHMucGFyc2VEYXRlQXJyYXkodXRpbHMuZmxhdHRlbihkYXRlcykpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHZhbHVlcywgZGF0ZXMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSB2YWx1ZXNbaV0gLyBNYXRoLnBvdygxICsgcmF0ZSwgZGF0ZVRpbWUuREFZUyhkYXRlc1tpXSwgZGF0ZXNbMF0pIC8gMzY1KTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuWUlFTEQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignWUlFTEQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLllJRUxERElTQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdZSUVMRERJU0MgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLllJRUxETUFUID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1lJRUxETUFUIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0ZXhwb3J0cy5NQVRDSCA9IGZ1bmN0aW9uKGxvb2t1cFZhbHVlLCBsb29rdXBBcnJheSwgbWF0Y2hUeXBlKSB7XG5cdCAgaWYgKCFsb29rdXBWYWx1ZSAmJiAhbG9va3VwQXJyYXkpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgbWF0Y2hUeXBlID0gMTtcblx0ICB9XG5cdCAgaWYgKCEobG9va3VwQXJyYXkgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAobWF0Y2hUeXBlICE9PSAtMSAmJiBtYXRjaFR5cGUgIT09IDAgJiYgbWF0Y2hUeXBlICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXHQgIHZhciBpbmRleDtcblx0ICB2YXIgaW5kZXhWYWx1ZTtcblx0ICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBBcnJheS5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICBpZiAobWF0Y2hUeXBlID09PSAxKSB7XG5cdCAgICAgIGlmIChsb29rdXBBcnJheVtpZHhdID09PSBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBpZHggKyAxO1xuXHQgICAgICB9IGVsc2UgaWYgKGxvb2t1cEFycmF5W2lkeF0gPCBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgIGlmICghaW5kZXhWYWx1ZSkge1xuXHQgICAgICAgICAgaW5kZXggPSBpZHggKyAxO1xuXHQgICAgICAgICAgaW5kZXhWYWx1ZSA9IGxvb2t1cEFycmF5W2lkeF07XG5cdCAgICAgICAgfSBlbHNlIGlmIChsb29rdXBBcnJheVtpZHhdID4gaW5kZXhWYWx1ZSkge1xuXHQgICAgICAgICAgaW5kZXggPSBpZHggKyAxO1xuXHQgICAgICAgICAgaW5kZXhWYWx1ZSA9IGxvb2t1cEFycmF5W2lkeF07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG1hdGNoVHlwZSA9PT0gMCkge1xuXHQgICAgICBpZiAodHlwZW9mIGxvb2t1cFZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIGxvb2t1cFZhbHVlID0gbG9va3VwVmFsdWUucmVwbGFjZSgvXFw/L2csICcuJyk7XG5cdCAgICAgICAgaWYgKGxvb2t1cEFycmF5W2lkeF0udG9Mb3dlckNhc2UoKS5tYXRjaChsb29rdXBWYWx1ZS50b0xvd2VyQ2FzZSgpKSkge1xuXHQgICAgICAgICAgcmV0dXJuIGlkeCArIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChsb29rdXBBcnJheVtpZHhdID09PSBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGlkeCArIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG1hdGNoVHlwZSA9PT0gLTEpIHtcblx0ICAgICAgaWYgKGxvb2t1cEFycmF5W2lkeF0gPT09IGxvb2t1cFZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGlkeCArIDE7XG5cdCAgICAgIH0gZWxzZSBpZiAobG9va3VwQXJyYXlbaWR4XSA+IGxvb2t1cFZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFpbmRleFZhbHVlKSB7XG5cdCAgICAgICAgICBpbmRleCA9IGlkeCArIDE7XG5cdCAgICAgICAgICBpbmRleFZhbHVlID0gbG9va3VwQXJyYXlbaWR4XTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGxvb2t1cEFycmF5W2lkeF0gPCBpbmRleFZhbHVlKSB7XG5cdCAgICAgICAgICBpbmRleCA9IGlkeCArIDE7XG5cdCAgICAgICAgICBpbmRleFZhbHVlID0gbG9va3VwQXJyYXlbaWR4XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gaW5kZXggPyBpbmRleCA6IGVycm9yLm5hO1xuXHR9O1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47IiwiZXhwb3J0cy5uaWwgPSBuZXcgRXJyb3IoJyNOVUxMIScpO1xuZXhwb3J0cy5kaXYwID0gbmV3IEVycm9yKCcjRElWLzAhJyk7XG5leHBvcnRzLnZhbHVlID0gbmV3IEVycm9yKCcjVkFMVUU/Jyk7XG5leHBvcnRzLnJlZiA9IG5ldyBFcnJvcignI1JFRiEnKTtcbmV4cG9ydHMubmFtZSA9IG5ldyBFcnJvcignI05BTUU/Jyk7XG5leHBvcnRzLm51bSA9IG5ldyBFcnJvcignI05VTSEnKTtcbmV4cG9ydHMubmEgPSBuZXcgRXJyb3IoJyNOL0EnKTtcbmV4cG9ydHMuZXJyb3IgPSBuZXcgRXJyb3IoJyNFUlJPUiEnKTtcbmV4cG9ydHMuZGF0YSA9IG5ldyBFcnJvcignI0dFVFRJTkdfREFUQScpO1xuIiwidmFyIGVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuXG5mdW5jdGlvbiBmbGF0dGVuU2hhbGxvdyhhcnJheSkge1xuICBpZiAoIWFycmF5IHx8ICFhcnJheS5yZWR1Y2UpIHsgcmV0dXJuIGFycmF5OyB9XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBhSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgdmFyIGJJc0FycmF5ID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICBpZiAoYUlzQXJyYXkgJiYgYklzQXJyYXkgKSB7XG4gICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgfVxuICAgIGlmIChhSXNBcnJheSkge1xuICAgICAgYS5wdXNoKGIpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiSXNBcnJheSkge1xuICAgICAgcmV0dXJuIFthXS5jb25jYXQoYik7XG4gICAgfVxuICAgIHJldHVybiBbYSwgYl07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0ZsYXQoYXJyYXkpIHtcbiAgaWYgKCFhcnJheSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSBleHBvcnRzLmFyZ3NUb0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHdoaWxlICghaXNGbGF0KHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBmbGF0dGVuU2hhbGxvdyhyZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLmFyZ3NUb0FycmF5ID0gZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMCk7XG59O1xuXG5leHBvcnRzLm51bWJlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBvc3NpYmxlTnVtYmVycyA9IHRoaXMuZmxhdHRlbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gcG9zc2libGVOdW1iZXJzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdudW1iZXInO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuY2xlYW5GbG9hdCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICB2YXIgcG93ZXIgPSAxZTE0O1xuICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBwb3dlcikgLyBwb3dlcjtcbn07XG5cbmV4cG9ydHMucGFyc2VCb29sID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBib29sO1xuICB9XG5cbiAgaWYgKGJvb2wgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBib29sO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBib29sID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBib29sICE9PSAwO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBib29sID09PSAnc3RyaW5nJykge1xuICAgIHZhciB1cCA9IGJvb2wudG9VcHBlckNhc2UoKTtcbiAgICBpZiAodXAgPT09ICdUUlVFJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHVwID09PSAnRkFMU0UnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJvb2wgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihib29sKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yLnZhbHVlO1xufTtcblxuZXhwb3J0cy5wYXJzZU51bWJlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQgfHwgc3RyaW5nID09PSAnJykge1xuICAgIHJldHVybiBlcnJvci52YWx1ZTtcbiAgfVxuICBpZiAoIWlzTmFOKHN0cmluZykpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHJpbmcpO1xuICB9XG4gIHJldHVybiBlcnJvci52YWx1ZTtcbn07XG5cbmV4cG9ydHMucGFyc2VOdW1iZXJBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICB2YXIgbGVuO1xuICBpZiAoIWFyciB8fCAobGVuID0gYXJyLmxlbmd0aCkgPT09IDApIHtcbiAgICByZXR1cm4gZXJyb3IudmFsdWU7XG4gIH1cbiAgdmFyIHBhcnNlZDtcbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgcGFyc2VkID0gZXhwb3J0cy5wYXJzZU51bWJlcihhcnJbbGVuXSk7XG4gICAgaWYgKHBhcnNlZCA9PT0gZXJyb3IudmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGFycltsZW5dID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5leHBvcnRzLnBhcnNlTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG4gIHZhciBuO1xuICBpZiAoIW1hdHJpeCB8fCAobiA9IG1hdHJpeC5sZW5ndGgpID09PSAwKSB7XG4gICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuICB9XG4gIHZhciBwbmFycjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspIHtcbiAgICBwbmFyciA9IGV4cG9ydHMucGFyc2VOdW1iZXJBcnJheShtYXRyaXhbaV0pO1xuICAgIG1hdHJpeFtpXSA9IHBuYXJyO1xuICAgIGlmIChwbmFyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gcG5hcnI7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRyaXg7XG59O1xuXG52YXIgZDE5MDAgPSBuZXcgRGF0ZSgxOTAwLCAwLCAxKTtcbmV4cG9ydHMucGFyc2VEYXRlID0gZnVuY3Rpb24oZGF0ZSkge1xuICBpZiAoIWlzTmFOKGRhdGUpKSB7XG4gICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgfVxuICAgIHZhciBkID0gcGFyc2VJbnQoZGF0ZSwgMTApO1xuICAgIGlmIChkIDwgMCkge1xuICAgICAgcmV0dXJuIGVycm9yLm51bTtcbiAgICB9XG4gICAgaWYgKGQgPD0gNjApIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkMTkwMC5nZXRUaW1lKCkgKyAoZCAtIDEpICogODY0MDAwMDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZDE5MDAuZ2V0VGltZSgpICsgKGQgLSAyKSAqIDg2NDAwMDAwKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIGlmICghaXNOYU4oZGF0ZSkpIHtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyb3IudmFsdWU7XG59O1xuXG5leHBvcnRzLnBhcnNlRGF0ZUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgcGFyc2VkO1xuICB3aGlsZSAobGVuLS0pIHtcbiAgICBwYXJzZWQgPSB0aGlzLnBhcnNlRGF0ZShhcnJbbGVuXSk7XG4gICAgaWYgKHBhcnNlZCA9PT0gZXJyb3IudmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGFycltsZW5dID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5leHBvcnRzLmFueUlzRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAobi0tKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tuXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0cy5hcnJheVZhbHVlc1RvTnVtYmVycyA9IGZ1bmN0aW9uKGFycikge1xuICB2YXIgbiA9IGFyci5sZW5ndGg7XG4gIHZhciBlbDtcbiAgd2hpbGUgKG4tLSkge1xuICAgIGVsID0gYXJyW25dO1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGVsID09PSB0cnVlKSB7XG4gICAgICBhcnJbbl0gPSAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbCA9PT0gZmFsc2UpIHtcbiAgICAgIGFycltuXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBudW1iZXIgPSB0aGlzLnBhcnNlTnVtYmVyKGVsKTtcbiAgICAgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBhcnJbbl0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyW25dID0gbnVtYmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuZXhwb3J0cy5yZXN0ID0gZnVuY3Rpb24oYXJyYXksIGlkeCkge1xuICBpZHggPSBpZHggfHwgMTtcbiAgaWYgKCFhcnJheSB8fCB0eXBlb2YgYXJyYXkuc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LnNsaWNlKGlkeCk7XG59O1xuXG5leHBvcnRzLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgaWR4KSB7XG4gIGlkeCA9IGlkeCB8fCAxO1xuICBpZiAoIWFycmF5IHx8IHR5cGVvZiBhcnJheS5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgYXJyYXkubGVuZ3RoIC0gaWR4KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCJ2YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzIC87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0ZuKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHR2YXIgc2luZ2xlU3RyaXBwZWQgPSBmblN0ci5yZXBsYWNlKC9cXC9cXC8uKlxcbi9nLCAnJyk7XG5cdFx0dmFyIG11bHRpU3RyaXBwZWQgPSBzaW5nbGVTdHJpcHBlZC5yZXBsYWNlKC9cXC9cXCpbLlxcc1xcU10qXFwqXFwvL2csICcnKTtcblx0XHR2YXIgc3BhY2VTdHJpcHBlZCA9IG11bHRpU3RyaXBwZWQucmVwbGFjZSgvXFxuL21nLCAnICcpLnJlcGxhY2UoLyB7Mn0vZywgJyAnKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KHNwYWNlU3RyaXBwZWQpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXREYXkgPSBEYXRlLnByb3RvdHlwZS5nZXREYXk7XG52YXIgdHJ5RGF0ZU9iamVjdCA9IGZ1bmN0aW9uIHRyeURhdGVPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRnZXREYXkuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RhdGVPYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeURhdGVPYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IGRhdGVDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcbnZhciByZWdleEV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciB0cnlSZWdleEV4ZWNDYWxsID0gZnVuY3Rpb24gdHJ5UmVnZXhFeGVjKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGxhc3RJbmRleCA9IHZhbHVlLmxhc3RJbmRleDtcblx0XHR2YWx1ZS5sYXN0SW5kZXggPSAwO1xuXG5cdFx0cmVnZXhFeGVjLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdHZhbHVlLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIHRvU3RyLmNhbGwodmFsdWUpID09PSByZWdleENsYXNzO1xuXHR9XG5cblx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHZhbHVlLCAnbGFzdEluZGV4Jyk7XG5cdHZhciBoYXNMYXN0SW5kZXhEYXRhUHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGhhcyhkZXNjcmlwdG9yLCAndmFsdWUnKTtcblx0aWYgKCFoYXNMYXN0SW5kZXhEYXRhUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ5UmVnZXhFeGVjQ2FsbCh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woKSA9PT0gJ3N5bWJvbCc7XG5cbmlmIChoYXNTeW1ib2xzKSB7XG5cdHZhciBzeW1Ub1N0ciA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBzeW1TdHJpbmdSZWdleCA9IC9eU3ltYm9sXFwoLipcXCkkLztcblx0dmFyIGlzU3ltYm9sT2JqZWN0ID0gZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YoKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0cmV0dXJuIHN5bVN0cmluZ1JlZ2V4LnRlc3Qoc3ltVG9TdHIuY2FsbCh2YWx1ZSkpO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAodG9TdHIuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gaXNTeW1ib2xPYmplY3QodmFsdWUpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG5cdFx0Ly8gdGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFN5bWJvbHMuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuIiwidGhpcy5qJCA9IHRoaXMualN0YXQgPSAoZnVuY3Rpb24oTWF0aCwgdW5kZWZpbmVkKSB7XG5cbi8vIEZvciBxdWljayByZWZlcmVuY2UuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIENhbGN1bGF0ZSBjb3JyZWN0aW9uIGZvciBJRUVFIGVycm9yXG4vLyBUT0RPOiBUaGlzIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXByb3ZlZC5cbmZ1bmN0aW9uIGNhbGNSZHgobiwgbSkge1xuICB2YXIgdmFsID0gbiA+IG0gPyBuIDogbTtcbiAgcmV0dXJuIE1hdGgucG93KDEwLFxuICAgICAgICAgICAgICAgICAgMTcgLSB+fihNYXRoLmxvZygoKHZhbCA+IDApID8gdmFsIDogLXZhbCkpICogTWF0aC5MT0cxMEUpKTtcbn1cblxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInICYmIGFyZyA9PT0gYXJnO1xufVxuXG5cbi8vIENvbnZlcnRzIHRoZSBqU3RhdCBtYXRyaXggdG8gdmVjdG9yLlxuZnVuY3Rpb24gdG9WZWN0b3IoYXJyKSB7XG4gIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGFycik7XG59XG5cblxuLy8gVGhlIG9uZSBhbmQgb25seSBqU3RhdCBjb25zdHJ1Y3Rvci5cbmZ1bmN0aW9uIGpTdGF0KCkge1xuICByZXR1cm4gbmV3IGpTdGF0Ll9pbml0KGFyZ3VtZW50cyk7XG59XG5cblxuLy8gVE9ETzogUmVtb3ZlIGFmdGVyIGFsbCByZWZlcmVuY2VzIGluIHNyYyBmaWxlcyBoYXZlIGJlZW4gcmVtb3ZlZC5cbmpTdGF0LmZuID0galN0YXQucHJvdG90eXBlO1xuXG5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGluaXRpYWxpemVyIGZyb20gdGhlIGNvbnN0cnVjdG9yIGl0J3MgZWFzaWVyIHRvIGhhbmRsZVxuLy8gYWx3YXlzIHJldHVybmluZyBhIG5ldyBpbnN0YW5jZSB3aGV0aGVyIFwibmV3XCIgd2FzIHVzZWQgb3Igbm90LlxualN0YXQuX2luaXQgPSBmdW5jdGlvbiBfaW5pdChhcmdzKSB7XG4gIHZhciBpO1xuXG4gIC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5LCBtdXN0IGJlIHZlY3RvciBvciBtYXRyaXguXG4gIGlmIChpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgLy8gQ2hlY2sgaWYgbWF0cml4LlxuICAgIGlmIChpc0FycmF5KGFyZ3NbMF1bMF0pKSB7XG4gICAgICAvLyBTZWUgaWYgYSBtYXBwaW5nIGZ1bmN0aW9uIHdhcyBhbHNvIHBhc3NlZC5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbMV0pKVxuICAgICAgICBhcmdzWzBdID0galN0YXQubWFwKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggaXMgZmFzdGVyIHRoYW4gdGhpcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3NbMF0uXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnc1swXS5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpc1tpXSA9IGFyZ3NbMF1baV07XG4gICAgICB0aGlzLmxlbmd0aCA9IGFyZ3NbMF0ubGVuZ3RoO1xuXG4gICAgLy8gT3RoZXJ3aXNlIG11c3QgYmUgYSB2ZWN0b3IuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbMF0gPSBpc0Z1bmN0aW9uKGFyZ3NbMV0pID8galN0YXQubWFwKGFyZ3NbMF0sIGFyZ3NbMV0pIDogYXJnc1swXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgLy8gSWYgZmlyc3QgYXJndW1lbnQgaXMgbnVtYmVyLCBhc3N1bWUgY3JlYXRpb24gb2Ygc2VxdWVuY2UuXG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoYXJnc1swXSkpIHtcbiAgICB0aGlzWzBdID0galN0YXQuc2VxLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAvLyBIYW5kbGUgY2FzZSB3aGVuIGpTdGF0IG9iamVjdCBpcyBwYXNzZWQgdG8galN0YXQuXG4gIH0gZWxzZSBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIGpTdGF0KSB7XG4gICAgLy8gRHVwbGljYXRlIHRoZSBvYmplY3QgYW5kIHBhc3MgaXQgYmFjay5cbiAgICByZXR1cm4galN0YXQoYXJnc1swXS50b0FycmF5KCkpO1xuXG4gIC8vIFVuZXhwZWN0ZWQgYXJndW1lbnQgdmFsdWUsIHJldHVybiBlbXB0eSBqU3RhdCBvYmplY3QuXG4gIC8vIFRPRE86IFRoaXMgaXMgc3RyYW5nZSBiZWhhdmlvci4gU2hvdWxkbid0IHRoaXMgdGhyb3cgb3Igc29tZSBzdWNoIHRvIGxldFxuICAvLyB0aGUgdXNlciBrbm93IHRoZXkgaGFkIGJhZCBhcmd1bWVudHM/XG4gIH0gZWxzZSB7XG4gICAgdGhpc1swXSA9IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbmpTdGF0Ll9pbml0LnByb3RvdHlwZSA9IGpTdGF0LnByb3RvdHlwZTtcbmpTdGF0Ll9pbml0LmNvbnN0cnVjdG9yID0galN0YXQ7XG5cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMuXG4vLyBUT0RPOiBmb3IgaW50ZXJuYWwgdXNlIG9ubHk/XG5qU3RhdC51dGlscyA9IHtcbiAgY2FsY1JkeDogY2FsY1JkeCxcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICB0b1ZlY3RvcjogdG9WZWN0b3Jcbn07XG5cblxuLy8gRWFzaWx5IGV4dGVuZCB0aGUgalN0YXQgb2JqZWN0LlxuLy8gVE9ETzogaXMgdGhpcyBzZXJpb3VzbHkgbmVjZXNzYXJ5P1xualN0YXQuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICB2YXIgaSwgajtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZvciAoaiBpbiBvYmopXG4gICAgICBqU3RhdFtqXSA9IG9ialtqXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGogaW4gYXJndW1lbnRzW2ldKVxuICAgICAgb2JqW2pdID0gYXJndW1lbnRzW2ldW2pdO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeC5cbmpTdGF0LnJvd3MgPSBmdW5jdGlvbiByb3dzKGFycikge1xuICByZXR1cm4gYXJyLmxlbmd0aCB8fCAxO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4LlxualN0YXQuY29scyA9IGZ1bmN0aW9uIGNvbHMoYXJyKSB7XG4gIHJldHVybiBhcnJbMF0ubGVuZ3RoIHx8IDE7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB7IHJvd3M6IGksIGNvbHM6IGogfVxualN0YXQuZGltZW5zaW9ucyA9IGZ1bmN0aW9uIGRpbWVuc2lvbnMoYXJyKSB7XG4gIHJldHVybiB7XG4gICAgcm93czogalN0YXQucm93cyhhcnIpLFxuICAgIGNvbHM6IGpTdGF0LmNvbHMoYXJyKVxuICB9O1xufTtcblxuXG4vLyBSZXR1cm5zIGEgc3BlY2lmaWVkIHJvdyBhcyBhIHZlY3RvclxualN0YXQucm93ID0gZnVuY3Rpb24gcm93KGFyciwgaW5kZXgpIHtcbiAgcmV0dXJuIGFycltpbmRleF07XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIHNwZWNpZmllZCBjb2x1bW4gYXMgYSB2ZWN0b3JcbmpTdGF0LmNvbCA9IGZ1bmN0aW9uIGNvbHMoYXJyLCBpbmRleCkge1xuICB2YXIgY29sdW1uID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICBjb2x1bW5baV0gPSBbYXJyW2ldW2luZGV4XV07XG4gIHJldHVybiBjb2x1bW47XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGRpYWdvbmFsIG9mIHRoZSBtYXRyaXhcbmpTdGF0LmRpYWcgPSBmdW5jdGlvbiBkaWFnKGFycikge1xuICB2YXIgbnJvdyA9IGpTdGF0LnJvd3MoYXJyKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShucm93KTtcbiAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbnJvdzsgcm93KyspXG4gICAgcmVzW3Jvd10gPSBbYXJyW3Jvd11bcm93XV07XG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGFudGktZGlhZ29uYWwgb2YgdGhlIG1hdHJpeFxualN0YXQuYW50aWRpYWcgPSBmdW5jdGlvbiBhbnRpZGlhZyhhcnIpIHtcbiAgdmFyIG5yb3cgPSBqU3RhdC5yb3dzKGFycikgLSAxO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG5yb3cpO1xuICBmb3IgKHZhciBpID0gMDsgbnJvdyA+PSAwOyBucm93LS0sIGkrKylcbiAgICByZXNbaV0gPSBbYXJyW2ldW25yb3ddXTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFRyYW5zcG9zZSBhIG1hdHJpeCBvciBhcnJheS5cbmpTdGF0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZShhcnIpIHtcbiAgdmFyIG9iaiA9IFtdO1xuICB2YXIgb2JqQXJyLCByb3dzLCBjb2xzLCBqLCBpO1xuXG4gIC8vIE1ha2Ugc3VyZSBhcnIgaXMgaW4gbWF0cml4IGZvcm1hdC5cbiAgaWYgKCFpc0FycmF5KGFyclswXSkpXG4gICAgYXJyID0gW2Fycl07XG5cbiAgcm93cyA9IGFyci5sZW5ndGg7XG4gIGNvbHMgPSBhcnJbMF0ubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcbiAgICBvYmpBcnIgPSBuZXcgQXJyYXkocm93cyk7XG4gICAgZm9yIChqID0gMDsgaiA8IHJvd3M7IGorKylcbiAgICAgIG9iakFycltqXSA9IGFycltqXVtpXTtcbiAgICBvYmoucHVzaChvYmpBcnIpO1xuICB9XG5cbiAgLy8gSWYgb2JqIGlzIHZlY3RvciwgcmV0dXJuIG9ubHkgc2luZ2xlIGFycmF5LlxuICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMSA/IG9ialswXSA6IG9iajtcbn07XG5cblxuLy8gTWFwIGEgZnVuY3Rpb24gdG8gYW4gYXJyYXkgb3IgYXJyYXkgb2YgYXJyYXlzLlxuLy8gXCJ0b0FsdGVyXCIgaXMgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG5qU3RhdC5tYXAgPSBmdW5jdGlvbiBtYXAoYXJyLCBmdW5jLCB0b0FsdGVyKSB7XG4gIHZhciByb3csIG5yb3csIG5jb2wsIHJlcywgY29sO1xuXG4gIGlmICghaXNBcnJheShhcnJbMF0pKVxuICAgIGFyciA9IFthcnJdO1xuXG4gIG5yb3cgPSBhcnIubGVuZ3RoO1xuICBuY29sID0gYXJyWzBdLmxlbmd0aDtcbiAgcmVzID0gdG9BbHRlciA/IGFyciA6IG5ldyBBcnJheShucm93KTtcblxuICBmb3IgKHJvdyA9IDA7IHJvdyA8IG5yb3c7IHJvdysrKSB7XG4gICAgLy8gaWYgdGhlIHJvdyBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICBpZiAoIXJlc1tyb3ddKVxuICAgICAgcmVzW3Jvd10gPSBuZXcgQXJyYXkobmNvbCk7XG4gICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgIHJlc1tyb3ddW2NvbF0gPSBmdW5jKGFycltyb3ddW2NvbF0sIHJvdywgY29sKTtcbiAgfVxuXG4gIHJldHVybiByZXMubGVuZ3RoID09PSAxID8gcmVzWzBdIDogcmVzO1xufTtcblxuXG4vLyBEZXN0cnVjdGl2ZWx5IGFsdGVyIGFuIGFycmF5LlxualN0YXQuYWx0ZXIgPSBmdW5jdGlvbiBhbHRlcihhcnIsIGZ1bmMpIHtcbiAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmMsIHRydWUpO1xufTtcblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBhY2NvcmRpbmcgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxualN0YXQuY3JlYXRlID0gZnVuY3Rpb24gIGNyZWF0ZShyb3dzLCBjb2xzLCBmdW5jKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkocm93cyk7XG4gIHZhciBpLCBqO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGNvbHMpKSB7XG4gICAgZnVuYyA9IGNvbHM7XG4gICAgY29scyA9IHJvd3M7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgcmVzW2ldID0gbmV3IEFycmF5KGNvbHMpO1xuICAgIGZvciAoaiA9IDA7IGogPCBjb2xzOyBqKyspXG4gICAgICByZXNbaV1bal0gPSBmdW5jKGksIGopO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuZnVuY3Rpb24gcmV0WmVybygpIHsgcmV0dXJuIDA7IH1cblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBvZiB6ZXJvcy5cbmpTdGF0Lnplcm9zID0gZnVuY3Rpb24gemVyb3Mocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldFplcm8pO1xufTtcblxuXG5mdW5jdGlvbiByZXRPbmUoKSB7IHJldHVybiAxOyB9XG5cblxuLy8gR2VuZXJhdGUgYSByb3dzIHggY29scyBtYXRyaXggb2Ygb25lcy5cbmpTdGF0Lm9uZXMgPSBmdW5jdGlvbiBvbmVzKHJvd3MsIGNvbHMpIHtcbiAgaWYgKCFpc051bWJlcihjb2xzKSlcbiAgICBjb2xzID0gcm93cztcbiAgcmV0dXJuIGpTdGF0LmNyZWF0ZShyb3dzLCBjb2xzLCByZXRPbmUpO1xufTtcblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBvZiB1bmlmb3JtbHkgcmFuZG9tIG51bWJlcnMuXG5qU3RhdC5yYW5kID0gZnVuY3Rpb24gcmFuZChyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgTWF0aC5yYW5kb20pO1xufTtcblxuXG5mdW5jdGlvbiByZXRJZGVudChpLCBqKSB7IHJldHVybiBpID09PSBqID8gMSA6IDA7IH1cblxuXG4vLyBHZW5lcmF0ZSBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSByb3cgeCBjb2xzLlxualN0YXQuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgcmV0SWRlbnQpO1xufTtcblxuXG4vLyBUZXN0cyB3aGV0aGVyIGEgbWF0cml4IGlzIHN5bW1ldHJpY1xualN0YXQuc3ltbWV0cmljID0gZnVuY3Rpb24gc3ltbWV0cmljKGFycikge1xuICB2YXIgaXNzeW1tZXRyaWMgPSB0cnVlO1xuICB2YXIgc2l6ZSA9IGFyci5sZW5ndGg7XG4gIHZhciByb3csIGNvbDtcblxuICBpZiAoYXJyLmxlbmd0aCAhPT0gYXJyWzBdLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChyb3cgPSAwOyByb3cgPCBzaXplOyByb3crKykge1xuICAgIGZvciAoY29sID0gMDsgY29sIDwgc2l6ZTsgY29sKyspXG4gICAgICBpZiAoYXJyW2NvbF1bcm93XSAhPT0gYXJyW3Jvd11bY29sXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFNldCBhbGwgdmFsdWVzIHRvIHplcm8uXG5qU3RhdC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKGFycikge1xuICByZXR1cm4galN0YXQuYWx0ZXIoYXJyLCByZXRaZXJvKTtcbn07XG5cblxuLy8gR2VuZXJhdGUgc2VxdWVuY2UuXG5qU3RhdC5zZXEgPSBmdW5jdGlvbiBzZXEobWluLCBtYXgsIGxlbmd0aCwgZnVuYykge1xuICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpXG4gICAgZnVuYyA9IGZhbHNlO1xuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhpdmFsID0gY2FsY1JkeChtaW4sIG1heCk7XG4gIHZhciBzdGVwID0gKG1heCAqIGhpdmFsIC0gbWluICogaGl2YWwpIC8gKChsZW5ndGggLSAxKSAqIGhpdmFsKTtcbiAgdmFyIGN1cnJlbnQgPSBtaW47XG4gIHZhciBjbnQ7XG5cbiAgLy8gQ3VycmVudCBpcyBhc3NpZ25lZCB1c2luZyBhIHRlY2huaXF1ZSB0byBjb21wZW5zYXRlIGZvciBJRUVFIGVycm9yLlxuICAvLyBUT0RPOiBOZWVkcyBiZXR0ZXIgaW1wbGVtZW50YXRpb24uXG4gIGZvciAoY250ID0gMDtcbiAgICAgICBjdXJyZW50IDw9IG1heDtcbiAgICAgICBjbnQrKywgY3VycmVudCA9IChtaW4gKiBoaXZhbCArIHN0ZXAgKiBoaXZhbCAqIGNudCkgLyBoaXZhbCkge1xuICAgIGFyci5wdXNoKChmdW5jID8gZnVuYyhjdXJyZW50LCBjbnQpIDogY3VycmVudCkpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuLy8gVE9ETzogR28gb3ZlciB0aGlzIGVudGlyZSBpbXBsZW1lbnRhdGlvbi4gU2VlbXMgYSB0cmFnaWMgd2FzdGUgb2YgcmVzb3VyY2VzXG4vLyBkb2luZyBhbGwgdGhpcyB3b3JrLiBJbnN0ZWFkLCBhbmQgd2hpbGUgdWdseSwgdXNlIG5ldyBGdW5jdGlvbigpIHRvIGdlbmVyYXRlXG4vLyBhIGN1c3RvbSBmdW5jdGlvbiBmb3IgZWFjaCBzdGF0aWMgbWV0aG9kLlxuXG4vLyBRdWljayByZWZlcmVuY2UuXG52YXIgalByb3RvID0galN0YXQucHJvdG90eXBlO1xuXG4vLyBEZWZhdWx0IGxlbmd0aC5cbmpQcm90by5sZW5ndGggPSAwO1xuXG4vLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4vLyBUT0RPOiBDaGVjayBpZiB0aGV5J3JlIGFjdHVhbGx5IHVzZWQsIGFuZCBpZiB0aGV5IGFyZSB0aGVuIHJlbmFtZSB0aGVtXG4vLyB0byBfKlxualByb3RvLnB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmpQcm90by5zb3J0ID0gQXJyYXkucHJvdG90eXBlLnNvcnQ7XG5qUHJvdG8uc3BsaWNlID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcbmpQcm90by5zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuXG4vLyBSZXR1cm4gYSBjbGVhbiBhcnJheS5cbmpQcm90by50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwodGhpcykgOiBzbGljZS5jYWxsKHRoaXMpWzBdO1xufTtcblxuXG4vLyBNYXAgYSBmdW5jdGlvbiB0byBhIG1hdHJpeCBvciB2ZWN0b3IuXG5qUHJvdG8ubWFwID0gZnVuY3Rpb24gbWFwKGZ1bmMsIHRvQWx0ZXIpIHtcbiAgcmV0dXJuIGpTdGF0KGpTdGF0Lm1hcCh0aGlzLCBmdW5jLCB0b0FsdGVyKSk7XG59O1xuXG5cbi8vIERlc3RydWN0aXZlbHkgYWx0ZXIgYW4gYXJyYXkuXG5qUHJvdG8uYWx0ZXIgPSBmdW5jdGlvbiBhbHRlcihmdW5jKSB7XG4gIGpTdGF0LmFsdGVyKHRoaXMsIGZ1bmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gRXh0ZW5kIHByb3RvdHlwZSB3aXRoIG1ldGhvZHMgdGhhdCBoYXZlIG5vIGFyZ3VtZW50LlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICByZXN1bHRzO1xuICAgICAgLy8gQ2hlY2sgZm9yIGNhbGxiYWNrLlxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwoc2VsZiwgalByb3RvW3Bhc3NmdW5jXS5jYWxsKHNlbGYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyA9IGpTdGF0W3Bhc3NmdW5jXSh0aGlzKTtcbiAgICAgIHJldHVybiBpc0FycmF5KHJlc3VsdHMpID8galN0YXQocmVzdWx0cykgOiByZXN1bHRzO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCd0cmFuc3Bvc2UgY2xlYXIgc3ltbWV0cmljIHJvd3MgY29scyBkaW1lbnNpb25zIGRpYWcgYW50aWRpYWcnLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBwcm90b3R5cGUgd2l0aCBtZXRob2RzIHRoYXQgaGF2ZSBvbmUgYXJndW1lbnQuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKGluZGV4LCBmdW5jKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvLyBjaGVjayBmb3IgY2FsbGJhY2tcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHNlbGYsIGpQcm90b1twYXNzZnVuY10uY2FsbChzZWxmLCBpbmRleCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4galN0YXQoalN0YXRbcGFzc2Z1bmNdKHRoaXMsIGluZGV4KSk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3JvdyBjb2wnLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBwcm90b3R5cGUgd2l0aCBzaW1wbGUgc2hvcnRjdXQgbWV0aG9kcy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gbmV3IEZ1bmN0aW9uKFxuICAgICAgICAncmV0dXJuIGpTdGF0KGpTdGF0LicgKyBwYXNzZnVuYyArICcuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7Jyk7XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdjcmVhdGUgemVyb3Mgb25lcyByYW5kIGlkZW50aXR5Jy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHBvc2luZyBqU3RhdC5cbnJldHVybiBqU3RhdDtcblxufShNYXRoKSk7XG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxudmFyIGlzRnVuY3Rpb24gPSBqU3RhdC51dGlscy5pc0Z1bmN0aW9uO1xuXG4vLyBBc2NlbmRpbmcgZnVuY3Rpb25zIGZvciBzb3J0XG5mdW5jdGlvbiBhc2NOdW0oYSwgYikgeyByZXR1cm4gYSAtIGI7IH1cblxuZnVuY3Rpb24gY2xpcChhcmcsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKGFyZywgbWF4KSk7XG59XG5cblxuLy8gc3VtIG9mIGFuIGFycmF5XG5qU3RhdC5zdW0gPSBmdW5jdGlvbiBzdW0oYXJyKSB7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHZhciB0bXA7XG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBzdW0gKz0gYXJyW2ldO1xuICByZXR1cm4gc3VtO1xufTtcblxuXG4vLyBzdW0gc3F1YXJlZFxualN0YXQuc3Vtc3FyZCA9IGZ1bmN0aW9uIHN1bXNxcmQoYXJyKSB7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBzdW0gKz0gYXJyW2ldICogYXJyW2ldO1xuICByZXR1cm4gc3VtO1xufTtcblxuXG4vLyBzdW0gb2Ygc3F1YXJlZCBlcnJvcnMgb2YgcHJlZGljdGlvbiAoU1NFKVxualN0YXQuc3Vtc3FlcnIgPSBmdW5jdGlvbiBzdW1zcWVycihhcnIpIHtcbiAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKGFycik7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHZhciB0bXA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIHRtcCA9IGFycltpXSAtIG1lYW47XG4gICAgc3VtICs9IHRtcCAqIHRtcDtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuXG4vLyBwcm9kdWN0IG9mIGFuIGFycmF5XG5qU3RhdC5wcm9kdWN0ID0gZnVuY3Rpb24gcHJvZHVjdChhcnIpIHtcbiAgdmFyIHByb2QgPSAxO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBwcm9kICo9IGFycltpXTtcbiAgcmV0dXJuIHByb2Q7XG59O1xuXG5cbi8vIG1pbmltdW0gdmFsdWUgb2YgYW4gYXJyYXlcbmpTdGF0Lm1pbiA9IGZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgdmFyIGxvdyA9IGFyclswXTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYXJyLmxlbmd0aClcbiAgICBpZiAoYXJyW2ldIDwgbG93KVxuICAgICAgbG93ID0gYXJyW2ldO1xuICByZXR1cm4gbG93O1xufTtcblxuXG4vLyBtYXhpbXVtIHZhbHVlIG9mIGFuIGFycmF5XG5qU3RhdC5tYXggPSBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gIHZhciBoaWdoID0gYXJyWzBdO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBhcnIubGVuZ3RoKVxuICAgIGlmIChhcnJbaV0gPiBoaWdoKVxuICAgICAgaGlnaCA9IGFycltpXTtcbiAgcmV0dXJuIGhpZ2g7XG59O1xuXG5cbi8vIG1lYW4gdmFsdWUgb2YgYW4gYXJyYXlcbmpTdGF0Lm1lYW4gPSBmdW5jdGlvbiBtZWFuKGFycikge1xuICByZXR1cm4galN0YXQuc3VtKGFycikgLyBhcnIubGVuZ3RoO1xufTtcblxuXG4vLyBtZWFuIHNxdWFyZWQgZXJyb3IgKE1TRSlcbmpTdGF0Lm1lYW5zcWVyciA9IGZ1bmN0aW9uIG1lYW5zcWVycihhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LnN1bXNxZXJyKGFycikgLyBhcnIubGVuZ3RoO1xufTtcblxuXG4vLyBnZW9tZXRyaWMgbWVhbiBvZiBhbiBhcnJheVxualN0YXQuZ2VvbWVhbiA9IGZ1bmN0aW9uIGdlb21lYW4oYXJyKSB7XG4gIHJldHVybiBNYXRoLnBvdyhqU3RhdC5wcm9kdWN0KGFyciksIDEgLyBhcnIubGVuZ3RoKTtcbn07XG5cblxuLy8gbWVkaWFuIG9mIGFuIGFycmF5XG5qU3RhdC5tZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oYXJyKSB7XG4gIHZhciBhcnJsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgLy8gY2hlY2sgaWYgYXJyYXkgaXMgZXZlbiBvciBvZGQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZVxuICByZXR1cm4gIShhcnJsZW4gJiAxKVxuICAgID8gKF9hcnJbKGFycmxlbiAvIDIpIC0gMSBdICsgX2FyclsoYXJybGVuIC8gMildKSAvIDJcbiAgICA6IF9hcnJbKGFycmxlbiAvIDIpIHwgMCBdO1xufTtcblxuXG4vLyBjdW11bGF0aXZlIHN1bSBvZiBhbiBhcnJheVxualN0YXQuY3Vtc3VtID0gZnVuY3Rpb24gY3Vtc3VtKGFycikge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHN1bXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIGk7XG4gIHN1bXNbMF0gPSBhcnJbMF07XG4gIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICBzdW1zW2ldID0gc3Vtc1tpIC0gMV0gKyBhcnJbaV07XG4gIHJldHVybiBzdW1zO1xufTtcblxuXG4vLyBzdWNjZXNzaXZlIGRpZmZlcmVuY2VzIG9mIGEgc2VxdWVuY2VcbmpTdGF0LmRpZmYgPSBmdW5jdGlvbiBkaWZmKGFycikge1xuICB2YXIgZGlmZnMgPSBbXTtcbiAgdmFyIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAxOyBpIDwgYXJyTGVuOyBpKyspXG4gICAgZGlmZnMucHVzaChhcnJbaV0gLSBhcnJbaSAtIDFdKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vLyBtb2RlIG9mIGFuIGFycmF5XG4vLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbW9kZXMgb2YgYW4gYXJyYXksIHJldHVybiBhbGwgb2YgdGhlbVxuLy8gaXMgdGhpcyB0aGUgYXBwcm9wcmlhdGUgd2F5IG9mIGhhbmRsaW5nIGl0P1xualN0YXQubW9kZSA9IGZ1bmN0aW9uIG1vZGUoYXJyKSB7XG4gIHZhciBhcnJMZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdmFyIG1heENvdW50ID0gMDtcbiAgdmFyIG51bU1heENvdW50ID0gMDtcbiAgdmFyIG1vZGVfYXJyID0gW107XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47IGkrKykge1xuICAgIGlmIChfYXJyW2ldID09PSBfYXJyW2kgKyAxXSkge1xuICAgICAgY291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvdW50ID4gbWF4Q291bnQpIHtcbiAgICAgICAgbW9kZV9hcnIgPSBbX2FycltpXV07XG4gICAgICAgIG1heENvdW50ID0gY291bnQ7XG4gICAgICAgIG51bU1heENvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIGFyZSB0aGVyZSBtdWx0aXBsZSBtYXggY291bnRzXG4gICAgICBlbHNlIGlmIChjb3VudCA9PT0gbWF4Q291bnQpIHtcbiAgICAgICAgbW9kZV9hcnIucHVzaChfYXJyW2ldKTtcbiAgICAgICAgbnVtTWF4Q291bnQrKztcbiAgICAgIH1cbiAgICAgIC8vIHJlc2V0dGluZyBjb3VudCBmb3IgbmV3IHZhbHVlIGluIGFycmF5XG4gICAgICBjb3VudCA9IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bU1heENvdW50ID09PSAwID8gbW9kZV9hcnJbMF0gOiBtb2RlX2Fycjtcbn07XG5cblxuLy8gcmFuZ2Ugb2YgYW4gYXJyYXlcbmpTdGF0LnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5tYXgoYXJyKSAtIGpTdGF0Lm1pbihhcnIpO1xufTtcblxuLy8gdmFyaWFuY2Ugb2YgYW4gYXJyYXlcbi8vIGZsYWcgaW5kaWNhdGVzIHBvcHVsYXRpb24gdnMgc2FtcGxlXG5qU3RhdC52YXJpYW5jZSA9IGZ1bmN0aW9uIHZhcmlhbmNlKGFyciwgZmxhZykge1xuICByZXR1cm4galN0YXQuc3Vtc3FlcnIoYXJyKSAvIChhcnIubGVuZ3RoIC0gKGZsYWcgPyAxIDogMCkpO1xufTtcblxuXG4vLyBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXlcbi8vIGZsYWcgaW5kaWNhdGVzIHBvcHVsYXRpb24gdnMgc2FtcGxlXG5qU3RhdC5zdGRldiA9IGZ1bmN0aW9uIHN0ZGV2KGFyciwgZmxhZykge1xuICByZXR1cm4gTWF0aC5zcXJ0KGpTdGF0LnZhcmlhbmNlKGFyciwgZmxhZykpO1xufTtcblxuXG4vLyBtZWFuIGRldmlhdGlvbiAobWVhbiBhYnNvbHV0ZSBkZXZpYXRpb24pIG9mIGFuIGFycmF5XG5qU3RhdC5tZWFuZGV2ID0gZnVuY3Rpb24gbWVhbmRldihhcnIpIHtcbiAgdmFyIGRldlN1bSA9IDA7XG4gIHZhciBtZWFuID0galN0YXQubWVhbihhcnIpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIGRldlN1bSArPSBNYXRoLmFicyhhcnJbaV0gLSBtZWFuKTtcbiAgcmV0dXJuIGRldlN1bSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIG1lZGlhbiBkZXZpYXRpb24gKG1lZGlhbiBhYnNvbHV0ZSBkZXZpYXRpb24pIG9mIGFuIGFycmF5XG5qU3RhdC5tZWRkZXYgPSBmdW5jdGlvbiBtZWRkZXYoYXJyKSB7XG4gIHZhciBkZXZTdW0gPSAwO1xuICB2YXIgbWVkaWFuID0galN0YXQubWVkaWFuKGFycik7XG4gIHZhciBpO1xuICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgZGV2U3VtICs9IE1hdGguYWJzKGFycltpXSAtIG1lZGlhbik7XG4gIHJldHVybiBkZXZTdW0gLyBhcnIubGVuZ3RoO1xufTtcblxuXG4vLyBjb2VmZmljaWVudCBvZiB2YXJpYXRpb25cbmpTdGF0LmNvZWZmdmFyID0gZnVuY3Rpb24gY29lZmZ2YXIoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5zdGRldihhcnIpIC8galN0YXQubWVhbihhcnIpO1xufTtcblxuXG4vLyBxdWFydGlsZXMgb2YgYW4gYXJyYXlcbmpTdGF0LnF1YXJ0aWxlcyA9IGZ1bmN0aW9uIHF1YXJ0aWxlcyhhcnIpIHtcbiAgdmFyIGFycmxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBfYXJyID0gYXJyLnNsaWNlKCkuc29ydChhc2NOdW0pO1xuICByZXR1cm4gW1xuICAgIF9hcnJbIE1hdGgucm91bmQoKGFycmxlbikgLyA0KSAtIDEgXSxcbiAgICBfYXJyWyBNYXRoLnJvdW5kKChhcnJsZW4pIC8gMikgLSAxIF0sXG4gICAgX2FyclsgTWF0aC5yb3VuZCgoYXJybGVuKSAqIDMgLyA0KSAtIDEgXVxuICBdO1xufTtcblxuXG4vLyBBcmJpdGFyeSBxdWFudGlsZXMgb2YgYW4gYXJyYXkuIERpcmVjdCBwb3J0IG9mIHRoZSBzY2lweS5zdGF0c1xuLy8gaW1wbGVtZW50YXRpb24gYnkgUGllcnJlIEdGIEdlcmFyZC1NYXJjaGFudC5cbmpTdGF0LnF1YW50aWxlcyA9IGZ1bmN0aW9uIHF1YW50aWxlcyhhcnIsIHF1YW50aWxlc0FycmF5LCBhbHBoYXAsIGJldGFwKSB7XG4gIHZhciBzb3J0ZWRBcnJheSA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgdmFyIHF1YW50aWxlVmFscyA9IFtxdWFudGlsZXNBcnJheS5sZW5ndGhdO1xuICB2YXIgbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpLCBwLCBtLCBhbGVwaCwgaywgZ2FtbWE7XG5cbiAgaWYgKHR5cGVvZiBhbHBoYXAgPT09ICd1bmRlZmluZWQnKVxuICAgIGFscGhhcCA9IDMgLyA4O1xuICBpZiAodHlwZW9mIGJldGFwID09PSAndW5kZWZpbmVkJylcbiAgICBiZXRhcCA9IDMgLyA4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBxdWFudGlsZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHAgPSBxdWFudGlsZXNBcnJheVtpXTtcbiAgICBtID0gYWxwaGFwICsgcCAqICgxIC0gYWxwaGFwIC0gYmV0YXApO1xuICAgIGFsZXBoID0gbiAqIHAgKyBtO1xuICAgIGsgPSBNYXRoLmZsb29yKGNsaXAoYWxlcGgsIDEsIG4gLSAxKSk7XG4gICAgZ2FtbWEgPSBjbGlwKGFsZXBoIC0gaywgMCwgMSk7XG4gICAgcXVhbnRpbGVWYWxzW2ldID0gKDEgLSBnYW1tYSkgKiBzb3J0ZWRBcnJheVtrIC0gMV0gKyBnYW1tYSAqIHNvcnRlZEFycmF5W2tdO1xuICB9XG5cbiAgcmV0dXJuIHF1YW50aWxlVmFscztcbn07XG5cbi8vIFRoZSBwZXJjZW50aWxlIHJhbmsgb2Ygc2NvcmUgaW4gYSBnaXZlbiBhcnJheS4gUmV0dXJucyB0aGUgcGVyY2VudGFnZVxuLy8gb2YgYWxsIHZhbHVlcyBpbiB0aGUgaW5wdXQgYXJyYXkgdGhhdCBhcmUgbGVzcyB0aGFuIChraW5kPSdzdHJpY3QnKSBvclxuLy8gbGVzcyBvciBlcXVhbCB0aGFuIChraW5kPSd3ZWFrJykgc2NvcmUuIERlZmF1bHQgaXMgd2Vhay5cbmpTdGF0LnBlcmNlbnRpbGVPZlNjb3JlID0gZnVuY3Rpb24gcGVyY2VudGlsZU9mU2NvcmUoYXJyLCBzY29yZSwga2luZCkge1xuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgc3RyaWN0ID0gZmFsc2U7XG4gIHZhciB2YWx1ZSwgaTtcblxuICBpZiAoa2luZCA9PT0gJ3N0cmljdCcpXG4gICAgc3RyaWN0ID0gdHJ1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycltpXTtcbiAgICBpZiAoKHN0cmljdCAmJiB2YWx1ZSA8IHNjb3JlKSB8fFxuICAgICAgICAoIXN0cmljdCAmJiB2YWx1ZSA8PSBzY29yZSkpIHtcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnRlciAvIGxlbjtcbn07XG5cbi8vIGNvdmFyaWFuY2Ugb2YgdHdvIGFycmF5c1xualN0YXQuY292YXJpYW5jZSA9IGZ1bmN0aW9uIGNvdmFyaWFuY2UoYXJyMSwgYXJyMikge1xuICB2YXIgdSA9IGpTdGF0Lm1lYW4oYXJyMSk7XG4gIHZhciB2ID0galN0YXQubWVhbihhcnIyKTtcbiAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcbiAgdmFyIHNxX2RldiA9IG5ldyBBcnJheShhcnIxTGVuKTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGFycjFMZW47IGkrKylcbiAgICBzcV9kZXZbaV0gPSAoYXJyMVtpXSAtIHUpICogKGFycjJbaV0gLSB2KTtcblxuICByZXR1cm4galN0YXQuc3VtKHNxX2RldikgLyAoYXJyMUxlbiAtIDEpO1xufTtcblxuXG4vLyAocGVhcnNvbidzKSBwb3B1bGF0aW9uIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50LCByaG9cbmpTdGF0LmNvcnJjb2VmZiA9IGZ1bmN0aW9uIGNvcnJjb2VmZihhcnIxLCBhcnIyKSB7XG4gIHJldHVybiBqU3RhdC5jb3ZhcmlhbmNlKGFycjEsIGFycjIpIC9cbiAgICAgIGpTdGF0LnN0ZGV2KGFycjEsIDEpIC9cbiAgICAgIGpTdGF0LnN0ZGV2KGFycjIsIDEpO1xufTtcblxuXG52YXIgalByb3RvID0galN0YXQucHJvdG90eXBlO1xuXG5cbi8vIEV4dGVuZCBqUHJvdG8gd2l0aCBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIGN1bXVsYXRpdmUgc3VtcywgYXMgaXQgZG9lcyBub3Rcbi8vIHJ1biBhZ2FpbiBpbiBjYXNlIG9mIHRydWUuXG4vLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvbiB0aGVcbi8vIGNvbHVtbnMuXG5qUHJvdG8uY3Vtc3VtID0gZnVuY3Rpb24oZnVsbGJvb2wsIGZ1bmMpIHtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciB0bXB0aGlzID0gdGhpcztcblxuICAvLyBBc3NpZ25tZW50IHJlYXNzaWduYXRpb24gZGVwZW5kaW5nIG9uIGhvdyBwYXJhbWV0ZXJzIHdlcmUgcGFzc2VkIGluLlxuICBpZiAoaXNGdW5jdGlvbihmdWxsYm9vbCkpIHtcbiAgICBmdW5jID0gZnVsbGJvb2w7XG4gICAgZnVsbGJvb2wgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGEgY2FsbGJhY2sgd2FzIHBhc3NlZCB3aXRoIHRoZSBmdW5jdGlvbi5cbiAgaWYgKGZ1bmMpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZnVuYy5jYWxsKHRtcHRoaXMsIGpQcm90by5jdW1zdW0uY2FsbCh0bXB0aGlzLCBmdWxsYm9vbCkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgbWF0cml4IGFuZCBydW4gY2FsY3VsYXRpb25zLlxuICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgdG1wdGhpcyA9IGZ1bGxib29sID09PSB0cnVlID8gdGhpcyA6IHRoaXMudHJhbnNwb3NlKCk7XG4gICAgZm9yICg7IGkgPCB0bXB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgYXJyW2ldID0galN0YXQuY3Vtc3VtKHRtcHRoaXNbaV0pO1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICByZXR1cm4galN0YXQuY3Vtc3VtKHRoaXNbMF0sIGZ1bGxib29sKTtcbn07XG5cblxuLy8gRXh0ZW5kIGpQcm90byB3aXRoIG1ldGhvZHMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBhcmd1bWVudHMgYW5kIHdvcmsgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICAvLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvblxuICAgIC8vIHRoZSBjb2x1bW5zLlxuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihmdWxsYm9vbCwgZnVuYykge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHRtcHRoaXMgPSB0aGlzO1xuICAgICAgLy8gQXNzaWdubWVudCByZWFzc2lnbmF0aW9uIGRlcGVuZGluZyBvbiBob3cgcGFyYW1ldGVycyB3ZXJlIHBhc3NlZCBpbi5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bGxib29sKSkge1xuICAgICAgICBmdW5jID0gZnVsbGJvb2w7XG4gICAgICAgIGZ1bGxib29sID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBhIGNhbGxiYWNrIHdhcyBwYXNzZWQgd2l0aCB0aGUgZnVuY3Rpb24uXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbCh0bXB0aGlzLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwodG1wdGhpcywgZnVsbGJvb2wpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgbWF0cml4IGFuZCBydW4gY2FsY3VsYXRpb25zLlxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0bXB0aGlzID0gZnVsbGJvb2wgPT09IHRydWUgPyB0aGlzIDogdGhpcy50cmFuc3Bvc2UoKTtcbiAgICAgICAgZm9yICg7IGkgPCB0bXB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIGFycltpXSA9IGpTdGF0W3Bhc3NmdW5jXSh0bXB0aGlzW2ldKTtcbiAgICAgICAgcmV0dXJuIGZ1bGxib29sID09PSB0cnVlXG4gICAgICAgICAgICA/IGpTdGF0W3Bhc3NmdW5jXShqU3RhdC51dGlscy50b1ZlY3RvcihhcnIpKVxuICAgICAgICAgICAgOiBhcnI7XG4gICAgICB9XG4gICAgICAvLyBQYXNzIGZ1bGxib29sIGlmIG9ubHkgdmVjdG9yLCBub3QgYSBtYXRyaXguIGZvciB2YXJpYW5jZSBhbmQgc3RkZXYuXG4gICAgICByZXR1cm4galN0YXRbcGFzc2Z1bmNdKHRoaXNbMF0sIGZ1bGxib29sKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgoJ3N1bSBzdW1zcXJkIHN1bXNxZXJyIHByb2R1Y3QgbWluIG1heCBtZWFuIG1lYW5zcWVyciBnZW9tZWFuIG1lZGlhbiBkaWZmICcgK1xuICAgICdtb2RlIHJhbmdlIHZhcmlhbmNlIHN0ZGV2IG1lYW5kZXYgbWVkZGV2IGNvZWZmdmFyIHF1YXJ0aWxlcycpLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBqUHJvdG8gd2l0aCBmdW5jdGlvbnMgdGhhdCB0YWtlIGFyZ3VtZW50cy4gT3BlcmF0aW9ucyBvbiBtYXRyaWNlcyBhcmVcbi8vIGRvbmUgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgdG1wdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIElmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIHdlIGFzc3VtZSBpdCdzIGEgY2FsbGJhY2s7IHdlXG4gICAgICAvLyBzdHJpcCB0aGUgY2FsbGJhY2sgb3V0IGFuZCBjYWxsIHRoZSBmdW5jdGlvbiBhZ2Fpbi5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrRnVuY3Rpb24gPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBhcmdzVG9QYXNzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2tGdW5jdGlvbi5jYWxsKHRtcHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpQcm90b1twYXNzZnVuY10uYXBwbHkodG1wdGhpcywgYXJnc1RvUGFzcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBjdXJyeSB0aGUgZnVuY3Rpb24gYXJncyBhbmQgY2FsbCBub3JtYWxseS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjYWxsYmFja0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY3VycmllZEZ1bmN0aW9uID0gZnVuY3Rpb24gY3VycmllZEZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10uYXBwbHkodG1wdGhpcywgW3ZlY3Rvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgbWF0cml4LCBydW4gY29sdW1uLWJ5LWNvbHVtbi5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG1wdGhpcyA9IHRtcHRoaXMudHJhbnNwb3NlKCk7XG4gICAgICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnJbaV0gPSBjdXJyaWVkRnVuY3Rpb24odG1wdGhpc1tpXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSBydW4gb24gdGhlIHZlY3Rvci5cbiAgICAgIHJldHVybiBjdXJyaWVkRnVuY3Rpb24odGhpc1swXSk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3F1YW50aWxlcyBwZXJjZW50aWxlT2ZTY29yZScuc3BsaXQoJyAnKSk7XG5cbn0odGhpcy5qU3RhdCwgTWF0aCkpO1xuLy8gU3BlY2lhbCBmdW5jdGlvbnMgLy9cbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG4vLyBMb2ctZ2FtbWEgZnVuY3Rpb25cbmpTdGF0LmdhbW1hbG4gPSBmdW5jdGlvbiBnYW1tYWxuKHgpIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgY29mID0gW1xuICAgIDc2LjE4MDA5MTcyOTQ3MTQ2LCAtODYuNTA1MzIwMzI5NDE2NzcsIDI0LjAxNDA5ODI0MDgzMDkxLFxuICAgIC0xLjIzMTczOTU3MjQ1MDE1NSwgMC4xMjA4NjUwOTczODY2MTc5ZS0yLCAtMC41Mzk1MjM5Mzg0OTUzZS01XG4gIF07XG4gIHZhciBzZXIgPSAxLjAwMDAwMDAwMDE5MDAxNTtcbiAgdmFyIHh4LCB5LCB0bXA7XG4gIHRtcCA9ICh5ID0geHggPSB4KSArIDUuNTtcbiAgdG1wIC09ICh4eCArIDAuNSkgKiBNYXRoLmxvZyh0bXApO1xuICBmb3IgKDsgaiA8IDY7IGorKylcbiAgICBzZXIgKz0gY29mW2pdIC8gKyt5O1xuICByZXR1cm4gTWF0aC5sb2coMi41MDY2MjgyNzQ2MzEwMDA1ICogc2VyIC8geHgpIC0gdG1wO1xufTtcblxuXG4vLyBnYW1tYSBvZiB4XG5qU3RhdC5nYW1tYWZuID0gZnVuY3Rpb24gZ2FtbWFmbih4KSB7XG4gIHZhciBwID0gWy0xLjcxNjE4NTEzODg2NTQ5NSwgMjQuNzY1NjUwODA1NTc1OTIsIC0zNzkuODA0MjU2NDcwOTQ1NjMsXG4gICAgICAgICAgIDYyOS4zMzExNTUzMTI4MTg0LCA4NjYuOTY2MjAyNzkwNDEzMywgLTMxNDUxLjI3Mjk2ODg0ODM2NyxcbiAgICAgICAgICAgLTM2MTQ0LjQxMzQxODY5MTE3NiwgNjY0NTYuMTQzODIwMjQwNTRcbiAgXTtcbiAgdmFyIHEgPSBbLTMwLjg0MDIzMDAxMTk3MzksIDMxNS4zNTA2MjY5Nzk2MDQxNiwgLTEwMTUuMTU2MzY3NDkwMjE5MixcbiAgICAgICAgICAgLTMxMDcuNzcxNjcxNTcyMzExLCAyMjUzOC4xMTg0MjA5ODAxNTEsIDQ3NTUuODQ2Mjc3NTI3ODgxMSxcbiAgICAgICAgICAgLTEzNDY1OS45NTk4NjQ5NjkzLCAtMTE1MTMyLjI1OTY3NTU1MzVdO1xuICB2YXIgZmFjdCA9IGZhbHNlO1xuICB2YXIgbiA9IDA7XG4gIHZhciB4ZGVuID0gMDtcbiAgdmFyIHhudW0gPSAwO1xuICB2YXIgeSA9IHg7XG4gIHZhciBpLCB6LCB5aSwgcmVzLCBzdW0sIHlzcTtcbiAgaWYgKHkgPD0gMCkge1xuICAgIHJlcyA9IHkgJSAxICsgMy42ZS0xNjtcbiAgICBpZiAocmVzKSB7XG4gICAgICBmYWN0ID0gKCEoeSAmIDEpID8gMSA6IC0xKSAqIE1hdGguUEkgLyBNYXRoLnNpbihNYXRoLlBJICogcmVzKTtcbiAgICAgIHkgPSAxIC0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfVxuICB5aSA9IHk7XG4gIGlmICh5IDwgMSkge1xuICAgIHogPSB5Kys7XG4gIH0gZWxzZSB7XG4gICAgeiA9ICh5IC09IG4gPSAoeSB8IDApIC0gMSkgLSAxO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICB4bnVtID0gKHhudW0gKyBwW2ldKSAqIHo7XG4gICAgeGRlbiA9IHhkZW4gKiB6ICsgcVtpXTtcbiAgfVxuICByZXMgPSB4bnVtIC8geGRlbiArIDE7XG4gIGlmICh5aSA8IHkpIHtcbiAgICByZXMgLz0geWk7XG4gIH0gZWxzZSBpZiAoeWkgPiB5KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmVzICo9IHk7XG4gICAgICB5Kys7XG4gICAgfVxuICB9XG4gIGlmIChmYWN0KSB7XG4gICAgcmVzID0gZmFjdCAvIHJlcztcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBsb3dlciBpbmNvbXBsZXRlIGdhbW1hIGZ1bmN0aW9uIFAoYSx4KVxualN0YXQuZ2FtbWFwID0gZnVuY3Rpb24gZ2FtbWFwKGEsIHgpIHtcbiAgdmFyIGFsbiA9IGpTdGF0LmdhbW1hbG4oYSk7XG4gIHZhciBhcCA9IGE7XG4gIHZhciBzdW0gPSAxIC8gYTtcbiAgdmFyIGRlbCA9IHN1bTtcbiAgdmFyIGIgPSB4ICsgMSAtIGE7XG4gIHZhciBjID0gMSAvIDEuMGUtMzA7XG4gIHZhciBkID0gMSAvIGI7XG4gIHZhciBoID0gZDtcbiAgdmFyIGkgPSAxO1xuICAvLyBjYWxjdWxhdGUgbWF4aW11bSBudW1iZXIgb2YgaXR0ZXJhdGlvbnMgcmVxdWlyZWQgZm9yIGFcbiAgdmFyIElUTUFYID0gLX4oTWF0aC5sb2coKGEgPj0gMSkgPyBhIDogMSAvIGEpICogOC41ICsgYSAqIDAuNCArIDE3KTtcbiAgdmFyIGFuLCBlbmR2YWw7XG5cbiAgaWYgKHggPCAwIHx8IGEgPD0gMCkge1xuICAgIHJldHVybiBOYU47XG4gIH0gZWxzZSBpZiAoeCA8IGEgKyAxKSB7XG4gICAgZm9yICg7IGkgPD0gSVRNQVg7IGkrKykge1xuICAgICAgc3VtICs9IGRlbCAqPSB4IC8gKythcDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSAqIE1hdGguZXhwKC14ICsgYSAqIE1hdGgubG9nKHgpIC0gKGFsbikpO1xuICB9XG5cbiAgZm9yICg7IGkgPD0gSVRNQVg7IGkrKykge1xuICAgIGFuID0gLWkgKiAoaSAtIGEpO1xuICAgIGIgKz0gMjtcbiAgICBkID0gYW4gKiBkICsgYjtcbiAgICBjID0gYiArIGFuIC8gYztcbiAgICBkID0gMSAvIGQ7XG4gICAgaCAqPSBkICogYztcbiAgfVxuXG4gIHJldHVybiAxIC0gaCAqIE1hdGguZXhwKC14ICsgYSAqIE1hdGgubG9nKHgpIC0gKGFsbikpO1xufTtcblxuXG4vLyBuYXR1cmFsIGxvZyBmYWN0b3JpYWwgb2YgblxualN0YXQuZmFjdG9yaWFsbG4gPSBmdW5jdGlvbiBmYWN0b3JpYWxsbihuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hbG4obiArIDEpO1xufTtcblxuLy8gZmFjdG9yaWFsIG9mIG5cbmpTdGF0LmZhY3RvcmlhbCA9IGZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hZm4obiArIDEpO1xufTtcblxuLy8gY29tYmluYXRpb25zIG9mIG4sIG1cbmpTdGF0LmNvbWJpbmF0aW9uID0gZnVuY3Rpb24gY29tYmluYXRpb24obiwgbSkge1xuICAvLyBtYWtlIHN1cmUgbiBvciBtIGRvbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKG4gPiAxNzAgfHwgbSA+IDE3MClcbiAgICAgID8gTWF0aC5leHAoalN0YXQuY29tYmluYXRpb25sbihuLCBtKSlcbiAgICAgIDogKGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChtKSkgLyBqU3RhdC5mYWN0b3JpYWwobiAtIG0pO1xufTtcblxuXG5qU3RhdC5jb21iaW5hdGlvbmxuID0gZnVuY3Rpb24gY29tYmluYXRpb25sbihuLCBtKXtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbGxuKG4pIC0galN0YXQuZmFjdG9yaWFsbG4obSkgLSBqU3RhdC5mYWN0b3JpYWxsbihuIC0gbSk7XG59O1xuXG5cbi8vIHBlcm11dGF0aW9ucyBvZiBuLCBtXG5qU3RhdC5wZXJtdXRhdGlvbiA9IGZ1bmN0aW9uIHBlcm11dGF0aW9uKG4sIG0pIHtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChuIC0gbSk7XG59O1xuXG5cbi8vIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFmbiA9IGZ1bmN0aW9uIGJldGFmbih4LCB5KSB7XG4gIC8vIGVuc3VyZSBhcmd1bWVudHMgYXJlIHBvc2l0aXZlXG4gIGlmICh4IDw9IDAgfHwgeSA8PSAwKVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIC8vIG1ha2Ugc3VyZSB4ICsgeSBkb2Vzbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKHggKyB5ID4gMTcwKVxuICAgICAgPyBNYXRoLmV4cChqU3RhdC5iZXRhbG4oeCwgeSkpXG4gICAgICA6IGpTdGF0LmdhbW1hZm4oeCkgKiBqU3RhdC5nYW1tYWZuKHkpIC8galN0YXQuZ2FtbWFmbih4ICsgeSk7XG59O1xuXG5cbi8vIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFsbiA9IGZ1bmN0aW9uIGJldGFsbih4LCB5KSB7XG4gIHJldHVybiBqU3RhdC5nYW1tYWxuKHgpICsgalN0YXQuZ2FtbWFsbih5KSAtIGpTdGF0LmdhbW1hbG4oeCArIHkpO1xufTtcblxuXG4vLyBFdmFsdWF0ZXMgdGhlIGNvbnRpbnVlZCBmcmFjdGlvbiBmb3IgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIGJ5IG1vZGlmaWVkXG4vLyBMZW50eidzIG1ldGhvZC5cbmpTdGF0LmJldGFjZiA9IGZ1bmN0aW9uIGJldGFjZih4LCBhLCBiKSB7XG4gIHZhciBmcG1pbiA9IDFlLTMwO1xuICB2YXIgbSA9IDE7XG4gIHZhciBxYWIgPSBhICsgYjtcbiAgdmFyIHFhcCA9IGEgKyAxO1xuICB2YXIgcWFtID0gYSAtIDE7XG4gIHZhciBjID0gMTtcbiAgdmFyIGQgPSAxIC0gcWFiICogeCAvIHFhcDtcbiAgdmFyIG0yLCBhYSwgZGVsLCBoO1xuXG4gIC8vIFRoZXNlIHEncyB3aWxsIGJlIHVzZWQgaW4gZmFjdG9ycyB0aGF0IG9jY3VyIGluIHRoZSBjb2VmZmljaWVudHNcbiAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgZCA9IGZwbWluO1xuICBkID0gMSAvIGQ7XG4gIGggPSBkO1xuXG4gIGZvciAoOyBtIDw9IDEwMDsgbSsrKSB7XG4gICAgbTIgPSAyICogbTtcbiAgICBhYSA9IG0gKiAoYiAtIG0pICogeCAvICgocWFtICsgbTIpICogKGEgKyBtMikpO1xuICAgIC8vIE9uZSBzdGVwICh0aGUgZXZlbiBvbmUpIG9mIHRoZSByZWN1cnJlbmNlXG4gICAgZCA9IDEgKyBhYSAqIGQ7XG4gICAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgICBkID0gZnBtaW47XG4gICAgYyA9IDEgKyBhYSAvIGM7XG4gICAgaWYgKE1hdGguYWJzKGMpIDwgZnBtaW4pXG4gICAgICBjID0gZnBtaW47XG4gICAgZCA9IDEgLyBkO1xuICAgIGggKj0gZCAqIGM7XG4gICAgYWEgPSAtKGEgKyBtKSAqIChxYWIgKyBtKSAqIHggLyAoKGEgKyBtMikgKiAocWFwICsgbTIpKTtcbiAgICAvLyBOZXh0IHN0ZXAgb2YgdGhlIHJlY3VycmVuY2UgKHRoZSBvZGQgb25lKVxuICAgIGQgPSAxICsgYWEgKiBkO1xuICAgIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKVxuICAgICAgZCA9IGZwbWluO1xuICAgIGMgPSAxICsgYWEgLyBjO1xuICAgIGlmIChNYXRoLmFicyhjKSA8IGZwbWluKVxuICAgICAgYyA9IGZwbWluO1xuICAgIGQgPSAxIC8gZDtcbiAgICBkZWwgPSBkICogYztcbiAgICBoICo9IGRlbDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsIC0gMS4wKSA8IDNlLTcpXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBoO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIGluY29tcGx0ZSBnYW1tYSBmdW5jdGlvblxualN0YXQuZ2FtbWFwaW52ID0gZnVuY3Rpb24gZ2FtbWFwaW52KHAsIGEpIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgYTEgPSBhIC0gMTtcbiAgdmFyIEVQUyA9IDFlLTg7XG4gIHZhciBnbG4gPSBqU3RhdC5nYW1tYWxuKGEpO1xuICB2YXIgeCwgZXJyLCB0LCB1LCBwcCwgbG5hMSwgYWZhYztcblxuICBpZiAocCA+PSAxKVxuICAgIHJldHVybiBNYXRoLm1heCgxMDAsIGEgKyAxMDAgKiBNYXRoLnNxcnQoYSkpO1xuICBpZiAocCA8PSAwKVxuICAgIHJldHVybiAwO1xuICBpZiAoYSA+IDEpIHtcbiAgICBsbmExID0gTWF0aC5sb2coYTEpO1xuICAgIGFmYWMgPSBNYXRoLmV4cChhMSAqIChsbmExIC0gMSkgLSBnbG4pO1xuICAgIHBwID0gKHAgPCAwLjUpID8gcCA6IDEgLSBwO1xuICAgIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCkpO1xuICAgIHggPSAoMi4zMDc1MyArIHQgKiAwLjI3MDYxKSAvICgxICsgdCAqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQ7XG4gICAgaWYgKHAgPCAwLjUpXG4gICAgICB4ID0gLXg7XG4gICAgeCA9IE1hdGgubWF4KDFlLTMsXG4gICAgICAgICAgICAgICAgIGEgKiBNYXRoLnBvdygxIC0gMSAvICg5ICogYSkgLSB4IC8gKDMgKiBNYXRoLnNxcnQoYSkpLCAzKSk7XG4gIH0gZWxzZSB7XG4gICAgdCA9IDEgLSBhICogKDAuMjUzICsgYSAqIDAuMTIpO1xuICAgIGlmIChwIDwgdClcbiAgICAgIHggPSBNYXRoLnBvdyhwIC8gdCwgMSAvIGEpO1xuICAgIGVsc2VcbiAgICAgIHggPSAxIC0gTWF0aC5sb2coMSAtIChwIC0gdCkgLyAoMSAtIHQpKTtcbiAgfVxuXG4gIGZvcig7IGogPCAxMjsgaisrKSB7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIGVyciA9IGpTdGF0LmdhbW1hcChhLCB4KSAtIHA7XG4gICAgaWYgKGEgPiAxKVxuICAgICAgdCA9IGFmYWMgKiBNYXRoLmV4cCgtKHggLSBhMSkgKyBhMSAqIChNYXRoLmxvZyh4KSAtIGxuYTEpKTtcbiAgICBlbHNlXG4gICAgICB0ID0gTWF0aC5leHAoLXggKyBhMSAqIE1hdGgubG9nKHgpIC0gZ2xuKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqICgoYSAtIDEpIC8geCAtIDEpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFMgKiB4KVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgZXJyb3IgZnVuY3Rpb24gZXJmKHgpXG5qU3RhdC5lcmYgPSBmdW5jdGlvbiBlcmYoeCkge1xuICB2YXIgY29mID0gWy0xLjMwMjY1MzcxOTc4MTcwOTQsIDYuNDE5Njk3OTIzNTY0OTAyNmUtMSwgMS45NDc2NDczMjA0MTg1ODM2ZS0yLFxuICAgICAgICAgICAgIC05LjU2MTUxNDc4NjgwODYzMWUtMywgLTkuNDY1OTUzNDQ0ODIwMzZlLTQsIDMuNjY4Mzk0OTc4NTI3NjFlLTQsXG4gICAgICAgICAgICAgNC4yNTIzMzI0ODA2OTA3ZS01LCAtMi4wMjc4NTc4MTEyNTM0ZS01LCAtMS42MjQyOTAwMDQ2NDdlLTYsXG4gICAgICAgICAgICAgMS4zMDM2NTU4MzU1ODBlLTYsIDEuNTYyNjQ0MTcyMmUtOCwgLTguNTIzODA5NTkxNWUtOCxcbiAgICAgICAgICAgICA2LjUyOTA1NDQzOWUtOSwgNS4wNTkzNDM0OTVlLTksIC05LjkxMzY0MTU2ZS0xMCxcbiAgICAgICAgICAgICAtMi4yNzM2NTEyMmUtMTAsIDkuNjQ2NzkxMWUtMTEsIDIuMzk0MDM4ZS0xMixcbiAgICAgICAgICAgICAtNi44ODYwMjdlLTEyLCA4Ljk0NDg3ZS0xMywgMy4xMzA5MmUtMTMsXG4gICAgICAgICAgICAgLTEuMTI3MDhlLTEzLCAzLjgxZS0xNiwgNy4xMDZlLTE1LFxuICAgICAgICAgICAgIC0xLjUyM2UtMTUsIC05LjRlLTE3LCAxLjIxZS0xNixcbiAgICAgICAgICAgICAtMi44ZS0xN107XG4gIHZhciBqID0gY29mLmxlbmd0aCAtIDE7XG4gIHZhciBpc25lZyA9IGZhbHNlO1xuICB2YXIgZCA9IDA7XG4gIHZhciBkZCA9IDA7XG4gIHZhciB0LCB0eSwgdG1wLCByZXM7XG5cbiAgaWYgKHggPCAwKSB7XG4gICAgeCA9IC14O1xuICAgIGlzbmVnID0gdHJ1ZTtcbiAgfVxuXG4gIHQgPSAyIC8gKDIgKyB4KTtcbiAgdHkgPSA0ICogdCAtIDI7XG5cbiAgZm9yKDsgaiA+IDA7IGotLSkge1xuICAgIHRtcCA9IGQ7XG4gICAgZCA9IHR5ICogZCAtIGRkICsgY29mW2pdO1xuICAgIGRkID0gdG1wO1xuICB9XG5cbiAgcmVzID0gdCAqIE1hdGguZXhwKC14ICogeCArIDAuNSAqIChjb2ZbMF0gKyB0eSAqIGQpIC0gZGQpO1xuICByZXR1cm4gaXNuZWcgPyByZXMgLSAxIDogMSAtIHJlcztcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgY29tcGxtZW50YXJ5IGVycm9yIGZ1bmN0aW9uIGVyZmMoeClcbmpTdGF0LmVyZmMgPSBmdW5jdGlvbiBlcmZjKHgpIHtcbiAgcmV0dXJuIDEgLSBqU3RhdC5lcmYoeCk7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBsZW1lbnRhcnkgZXJyb3IgZnVuY3Rpb25cbmpTdGF0LmVyZmNpbnYgPSBmdW5jdGlvbiBlcmZjaW52KHApIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgeCwgZXJyLCB0LCBwcDtcbiAgaWYgKHAgPj0gMilcbiAgICByZXR1cm4gLTEwMDtcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMTAwO1xuICBwcCA9IChwIDwgMSkgPyBwIDogMiAtIHA7XG4gIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCAvIDIpKTtcbiAgeCA9IC0wLjcwNzExICogKCgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC9cbiAgICAgICAgICAgICAgICAgICgxICsgdCAqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQpO1xuICBmb3IgKDsgaiA8IDI7IGorKykge1xuICAgIGVyciA9IGpTdGF0LmVyZmMoeCkgLSBwcDtcbiAgICB4ICs9IGVyciAvICgxLjEyODM3OTE2NzA5NTUxMjU3ICogTWF0aC5leHAoLXggKiB4KSAtIHggKiBlcnIpO1xuICB9XG4gIHJldHVybiAocCA8IDEpID8geCA6IC14O1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBpbmNvbXBsZXRlIGJldGEgZnVuY3Rpb25cbmpTdGF0LmliZXRhaW52ID0gZnVuY3Rpb24gaWJldGFpbnYocCwgYSwgYikge1xuICB2YXIgRVBTID0gMWUtODtcbiAgdmFyIGExID0gYSAtIDE7XG4gIHZhciBiMSA9IGIgLSAxO1xuICB2YXIgaiA9IDA7XG4gIHZhciBsbmEsIGxuYiwgcHAsIHQsIHUsIGVyciwgeCwgYWwsIGgsIHcsIGFmYWM7XG4gIGlmIChwIDw9IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmIChwID49IDEpXG4gICAgcmV0dXJuIDE7XG4gIGlmIChhID49IDEgJiYgYiA+PSAxKSB7XG4gICAgcHAgPSAocCA8IDAuNSkgPyBwIDogMSAtIHA7XG4gICAgdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHBwKSk7XG4gICAgeCA9ICgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC8gKDEgKyB0KiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KVxuICAgICAgeCA9IC14O1xuICAgIGFsID0gKHggKiB4IC0gMykgLyA2O1xuICAgIGggPSAyIC8gKDEgLyAoMiAqIGEgLSAxKSAgKyAxIC8gKDIgKiBiIC0gMSkpO1xuICAgIHcgPSAoeCAqIE1hdGguc3FydChhbCArIGgpIC8gaCkgLSAoMSAvICgyICogYiAtIDEpIC0gMSAvICgyICogYSAtIDEpKSAqXG4gICAgICAgIChhbCArIDUgLyA2IC0gMiAvICgzICogaCkpO1xuICAgIHggPSBhIC8gKGEgKyBiICogTWF0aC5leHAoMiAqIHcpKTtcbiAgfSBlbHNlIHtcbiAgICBsbmEgPSBNYXRoLmxvZyhhIC8gKGEgKyBiKSk7XG4gICAgbG5iID0gTWF0aC5sb2coYiAvIChhICsgYikpO1xuICAgIHQgPSBNYXRoLmV4cChhICogbG5hKSAvIGE7XG4gICAgdSA9IE1hdGguZXhwKGIgKiBsbmIpIC8gYjtcbiAgICB3ID0gdCArIHU7XG4gICAgaWYgKHAgPCB0IC8gdylcbiAgICAgIHggPSBNYXRoLnBvdyhhICogdyAqIHAsIDEgLyBhKTtcbiAgICBlbHNlXG4gICAgICB4ID0gMSAtIE1hdGgucG93KGIgKiB3ICogKDEgLSBwKSwgMSAvIGIpO1xuICB9XG4gIGFmYWMgPSAtalN0YXQuZ2FtbWFsbihhKSAtIGpTdGF0LmdhbW1hbG4oYikgKyBqU3RhdC5nYW1tYWxuKGEgKyBiKTtcbiAgZm9yKDsgaiA8IDEwOyBqKyspIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKVxuICAgICAgcmV0dXJuIHg7XG4gICAgZXJyID0galN0YXQuaWJldGEoeCwgYSwgYikgLSBwO1xuICAgIHQgPSBNYXRoLmV4cChhMSAqIE1hdGgubG9nKHgpICsgYjEgKiBNYXRoLmxvZygxIC0geCkgKyBhZmFjKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqIChhMSAvIHggLSBiMSAvICgxIC0geCkpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoeCA+PSAxKVxuICAgICAgeCA9IDAuNSAqICh4ICsgdCArIDEpO1xuICAgIGlmIChNYXRoLmFicyh0KSA8IEVQUyAqIHggJiYgaiA+IDApXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIElfeChhLGIpXG5qU3RhdC5pYmV0YSA9IGZ1bmN0aW9uIGliZXRhKHgsIGEsIGIpIHtcbiAgLy8gRmFjdG9ycyBpbiBmcm9udCBvZiB0aGUgY29udGludWVkIGZyYWN0aW9uLlxuICB2YXIgYnQgPSAoeCA9PT0gMCB8fCB4ID09PSAxKSA/ICAwIDpcbiAgICBNYXRoLmV4cChqU3RhdC5nYW1tYWxuKGEgKyBiKSAtIGpTdGF0LmdhbW1hbG4oYSkgLVxuICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oYikgKyBhICogTWF0aC5sb2coeCkgKyBiICpcbiAgICAgICAgICAgICBNYXRoLmxvZygxIC0geCkpO1xuICBpZiAoeCA8IDAgfHwgeCA+IDEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoeCA8IChhICsgMSkgLyAoYSArIGIgKyAyKSlcbiAgICAvLyBVc2UgY29udGludWVkIGZyYWN0aW9uIGRpcmVjdGx5LlxuICAgIHJldHVybiBidCAqIGpTdGF0LmJldGFjZih4LCBhLCBiKSAvIGE7XG4gIC8vIGVsc2UgdXNlIGNvbnRpbnVlZCBmcmFjdGlvbiBhZnRlciBtYWtpbmcgdGhlIHN5bW1ldHJ5IHRyYW5zZm9ybWF0aW9uLlxuICByZXR1cm4gMSAtIGJ0ICogalN0YXQuYmV0YWNmKDEgLSB4LCBiLCBhKSAvIGI7XG59O1xuXG5cbi8vIFJldHVybnMgYSBub3JtYWwgZGV2aWF0ZSAobXU9MCwgc2lnbWE9MSkuXG4vLyBJZiBuIGFuZCBtIGFyZSBzcGVjaWZpZWQgaXQgcmV0dXJucyBhIG9iamVjdCBvZiBub3JtYWwgZGV2aWF0ZXMuXG5qU3RhdC5yYW5kbiA9IGZ1bmN0aW9uIHJhbmRuKG4sIG0pIHtcbiAgdmFyIHUsIHYsIHgsIHksIHEsIG1hdDtcbiAgaWYgKCFtKVxuICAgIG0gPSBuO1xuICBpZiAobilcbiAgICByZXR1cm4galN0YXQuY3JlYXRlKG4sIG0sIGZ1bmN0aW9uKCkgeyByZXR1cm4galN0YXQucmFuZG4oKTsgfSk7XG4gIGRvIHtcbiAgICB1ID0gTWF0aC5yYW5kb20oKTtcbiAgICB2ID0gMS43MTU2ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgIHggPSB1IC0gMC40NDk4NzE7XG4gICAgeSA9IE1hdGguYWJzKHYpICsgMC4zODY1OTU7XG4gICAgcSA9IHggKiB4ICsgeSAqICgwLjE5NjAwICogeSAtIDAuMjU0NzIgKiB4KTtcbiAgfSB3aGlsZSAocSA+IDAuMjc1OTcgJiYgKHEgPiAwLjI3ODQ2IHx8IHYgKiB2ID4gLTQgKiBNYXRoLmxvZyh1KSAqIHUgKiB1KSk7XG4gIHJldHVybiB2IC8gdTtcbn07XG5cblxuLy8gUmV0dXJucyBhIGdhbW1hIGRldmlhdGUgYnkgdGhlIG1ldGhvZCBvZiBNYXJzYWdsaWEgYW5kIFRzYW5nLlxualN0YXQucmFuZGcgPSBmdW5jdGlvbiByYW5kZyhzaGFwZSwgbiwgbSkge1xuICB2YXIgb2FscGggPSBzaGFwZTtcbiAgdmFyIGExLCBhMiwgdSwgdiwgeCwgbWF0O1xuICBpZiAoIW0pXG4gICAgbSA9IG47XG4gIGlmICghc2hhcGUpXG4gICAgc2hhcGUgPSAxO1xuICBpZiAobikge1xuICAgIG1hdCA9IGpTdGF0Lnplcm9zKG4sbSk7XG4gICAgbWF0LmFsdGVyKGZ1bmN0aW9uKCkgeyByZXR1cm4galN0YXQucmFuZGcoc2hhcGUpOyB9KTtcbiAgICByZXR1cm4gbWF0O1xuICB9XG4gIGlmIChzaGFwZSA8IDEpXG4gICAgc2hhcGUgKz0gMTtcbiAgYTEgPSBzaGFwZSAtIDEgLyAzO1xuICBhMiA9IDEgLyBNYXRoLnNxcnQoOSAqIGExKTtcbiAgZG8ge1xuICAgIGRvIHtcbiAgICAgIHggPSBqU3RhdC5yYW5kbigpO1xuICAgICAgdiA9IDEgKyBhMiAqIHg7XG4gICAgfSB3aGlsZSh2IDw9IDApO1xuICAgIHYgPSB2ICogdiAqIHY7XG4gICAgdSA9IE1hdGgucmFuZG9tKCk7XG4gIH0gd2hpbGUodSA+IDEgLSAwLjMzMSAqIE1hdGgucG93KHgsIDQpICYmXG4gICAgICAgICAgTWF0aC5sb2codSkgPiAwLjUgKiB4KnggKyBhMSAqICgxIC0gdiArIE1hdGgubG9nKHYpKSk7XG4gIC8vIGFscGhhID4gMVxuICBpZiAoc2hhcGUgPT0gb2FscGgpXG4gICAgcmV0dXJuIGExICogdjtcbiAgLy8gYWxwaGEgPCAxXG4gIGRvIHtcbiAgICB1ID0gTWF0aC5yYW5kb20oKTtcbiAgfSB3aGlsZSh1ID09PSAwKTtcbiAgcmV0dXJuIE1hdGgucG93KHUsIDEgLyBvYWxwaCkgKiBhMSAqIHY7XG59O1xuXG5cbi8vIG1ha2luZyB1c2Ugb2Ygc3RhdGljIG1ldGhvZHMgb24gdGhlIGluc3RhbmNlXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalN0YXQuZm5bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4galN0YXQoXG4gICAgICAgICAgalN0YXQubWFwKHRoaXMsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBqU3RhdFtwYXNzZnVuY10odmFsdWUpOyB9KSk7XG4gICAgfVxuICB9KShmdW5jc1tpXSk7XG59KSgnZ2FtbWFsbiBnYW1tYWZuIGZhY3RvcmlhbCBmYWN0b3JpYWxsbicuc3BsaXQoJyAnKSk7XG5cblxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpTdGF0LmZuW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgncmFuZG4nLnNwbGl0KCcgJykpO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG4vLyBnZW5lcmF0ZSBhbGwgZGlzdHJpYnV0aW9uIGluc3RhbmNlIG1ldGhvZHNcbihmdW5jdGlvbihsaXN0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBkaXN0cmlidXRpb24gaW5zdGFuY2UgbWV0aG9kXG4gICAgalN0YXRbZnVuY10gPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYXJndW1lbnRzLmNhbGxlZSkpXG4gICAgICAgIHJldHVybiBuZXcgYXJndW1lbnRzLmNhbGxlZShhLCBiLCBjKTtcbiAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gZGlzdHJpYnV0aW9uIG1ldGhvZCB0byBiZSB1c2VkIG9uIGEgalN0YXQgaW5zdGFuY2VcbiAgICBqU3RhdC5mbltmdW5jXSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHZhciBuZXd0aGlzID0galN0YXRbZnVuY10oYSwgYiwgYyk7XG4gICAgICBuZXd0aGlzLmRhdGEgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ld3RoaXM7XG4gICAgfTtcbiAgICAvLyBzYW1wbGUgaW5zdGFuY2UgbWV0aG9kXG4gICAgalN0YXRbZnVuY10ucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hO1xuICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgdmFyIGMgPSB0aGlzLl9jO1xuICAgICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGpTdGF0LmFsdGVyKGFyciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdLnNhbXBsZShhLCBiLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBqU3RhdFtmdW5jXS5zYW1wbGUoYSwgYiwgYyk7XG4gICAgfTtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgcGRmLCBjZGYgYW5kIGludiBpbnN0YW5jZSBtZXRob2RzXG4gICAgKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKGZuZnVuYykge1xuICAgICAgICBqU3RhdFtmdW5jXS5wcm90b3R5cGVbZm5mdW5jXSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuX2E7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgICAgIHZhciBjID0gdGhpcy5fYztcbiAgICAgICAgICBpZiAoIXggJiYgeCAhPT0gMClcbiAgICAgICAgICAgIHggPSB0aGlzLmRhdGE7XG4gICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGpTdGF0LmZuLm1hcC5jYWxsKHgsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgncGRmIGNkZiBpbnYnLnNwbGl0KCcgJykpO1xuICAgIC8vIGdlbmVyYXRlIHRoZSBtZWFuLCBtZWRpYW4sIG1vZGUgYW5kIHZhcmlhbmNlIGluc3RhbmNlIG1ldGhvZHNcbiAgICAoZnVuY3Rpb24odmFscykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24oZm5mdW5jKSB7XG4gICAgICAgIGpTdGF0W2Z1bmNdLnByb3RvdHlwZVtmbmZ1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10odGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgnbWVhbiBtZWRpYW4gbW9kZSB2YXJpYW5jZScuc3BsaXQoJyAnKSk7XG4gIH0pKGxpc3RbaV0pO1xufSkoKFxuICAnYmV0YSBjZW50cmFsRiBjYXVjaHkgY2hpc3F1YXJlIGV4cG9uZW50aWFsIGdhbW1hIGludmdhbW1hIGt1bWFyYXN3YW15ICcgK1xuICAnbG9nbm9ybWFsIG5vcm1hbCBwYXJldG8gc3R1ZGVudHQgd2VpYnVsbCB1bmlmb3JtICBiaW5vbWlhbCBuZWdiaW4gaHlwZ2VvbSAnICtcbiAgJ3BvaXNzb24gdHJpYW5ndWxhcidcbikuc3BsaXQoJyAnKSk7XG5cblxuXG4vLyBleHRlbmQgYmV0YSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuYmV0YSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIC8vIFBERiBpcyB6ZXJvIG91dHNpZGUgdGhlIHN1cHBvcnRcbiAgICBpZiAoeCA+IDEgfHwgeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICAvLyBQREYgaXMgb25lIGZvciB0aGUgdW5pZm9ybSBjYXNlXG4gICAgaWYgKGFscGhhID09IDEgJiYgYmV0YSA9PSAxKVxuICAgICAgcmV0dXJuIDE7XG5cbiAgICBpZiAoYWxwaGEgPCA1MTIgfHwgYmV0YSA8IDUxMikge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdyh4LCBhbHBoYSAtIDEpICogTWF0aC5wb3coMSAtIHgsIGJldGEgLSAxKSkgL1xuICAgICAgICAgIGpTdGF0LmJldGFmbihhbHBoYSwgYmV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmV4cCgoYWxwaGEgLSAxKSAqIE1hdGgubG9nKHgpICtcbiAgICAgICAgICAgICAgICAgICAgICAoYmV0YSAtIDEpICogTWF0aC5sb2coMSAtIHgpIC1cbiAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5iZXRhbG4oYWxwaGEsIGJldGEpKTtcbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKHggPiAxIHx8IHggPCAwKSA/ICh4ID4gMSkgKiAxIDogalN0YXQuaWJldGEoeCwgYWxwaGEsIGJldGEpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGpTdGF0LmliZXRhaW52KHgsIGFscGhhLCBiZXRhKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGFscGhhIC8gKGFscGhhICsgYmV0YSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oYWxwaGEsIGJldGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lZGlhbiBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYWxwaGEgKiBiZXRhKSAvIChNYXRoLnBvdyhhbHBoYSArIGJldGEsIDIpICogKGFscGhhICsgYmV0YSArIDEpKTtcbiAgfSxcblxuICAvLyByZXR1cm4gYSByYW5kb20gc2FtcGxlXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGFscGhhLCBiZXRhKSB7XG4gICAgdmFyIHUgPSBqU3RhdC5yYW5kZyhhbHBoYSk7XG4gICAgcmV0dXJuIHUgLyAodSArIGpTdGF0LnJhbmRnKGJldGEpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKGFscGhhICogYmV0YSkgLyAoTWF0aC5wb3coYWxwaGEgKyBiZXRhLCAyKSAqIChhbHBoYSArIGJldGEgKyAxKSk7XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgRiBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuY2VudHJhbEYsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZGYxLCBkZjIpIHtcbiAgICBpZiAoeCA8IDApXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBNYXRoLnNxcnQoKE1hdGgucG93KGRmMSAqIHgsIGRmMSkgKiBNYXRoLnBvdyhkZjIsIGRmMikpIC9cbiAgICAgICAgICAgICAgICAgICAgIChNYXRoLnBvdyhkZjEgKiB4ICsgZGYyLCBkZjEgKyBkZjIpKSkgL1xuICAgICAgICAgICAgICAgICAgICAgKHggKiBqU3RhdC5iZXRhZm4oZGYxLzIsIGRmMi8yKSk7XG5cbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkZjEsIGRmMikge1xuICAgIHJldHVybiBqU3RhdC5pYmV0YSgoZGYxICogeCkgLyAoZGYxICogeCArIGRmMiksIGRmMSAvIDIsIGRmMiAvIDIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIGRmMiAvIChkZjEgKiAoMSAvIGpTdGF0LmliZXRhaW52KHgsIGRmMSAvIDIsIGRmMiAvIDIpIC0gMSkpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMiA+IDIpID8gZGYyIC8gKGRmMiAtIDIpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMSA+IDIpID8gKGRmMiAqIChkZjEgLSAyKSkgLyAoZGYxICogKGRmMiArIDIpKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvLyByZXR1cm4gYSByYW5kb20gc2FtcGxlXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGRmMSwgZGYyKSB7XG4gICAgdmFyIHgxID0galN0YXQucmFuZGcoZGYxIC8gMikgKiAyO1xuICAgIHZhciB4MiA9IGpTdGF0LnJhbmRnKGRmMiAvIDIpICogMjtcbiAgICByZXR1cm4gKHgxIC8gZGYxKSAvICh4MiAvIGRmMik7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRmMSwgZGYyKSB7XG4gICAgaWYgKGRmMiA8PSA0KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gMiAqIGRmMiAqIGRmMiAqIChkZjEgKyBkZjIgLSAyKSAvXG4gICAgICAgIChkZjEgKiAoZGYyIC0gMikgKiAoZGYyIC0gMikgKiAoZGYyIC0gNCkpO1xuICB9XG59KTtcblxuXG4vLyBleHRlbmQgY2F1Y2h5IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jYXVjaHksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIChzY2FsZSAvIChNYXRoLnBvdyh4IC0gbG9jYWwsIDIpICsgTWF0aC5wb3coc2NhbGUsIDIpKSkgLyBNYXRoLlBJO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4oKHggLSBsb2NhbCkgLyBzY2FsZSkgLyBNYXRoLlBJICsgMC41O1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsICsgc2NhbGUgKiBNYXRoLnRhbihNYXRoLlBJICogKHAgLSAwLjUpKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWw7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWw7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRuKCkgKlxuICAgICAgICBNYXRoLnNxcnQoMSAvICgyICogalN0YXQucmFuZGcoMC41KSkpICogc2NhbGUgKyBsb2NhbDtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgY2hpc3F1YXJlIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jaGlzcXVhcmUsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZG9mKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKChkb2YgLyAyIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyAyIC0gKGRvZiAvIDIpICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coMikgLSBqU3RhdC5nYW1tYWxuKGRvZiAvIDIpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkb2YpIHtcbiAgICByZXR1cm4galN0YXQuZ2FtbWFwKGRvZiAvIDIsIHggLyAyKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIGRvZikge1xuICAgIHJldHVybiAyICogalN0YXQuZ2FtbWFwaW52KHAsIDAuNSAqIGRvZik7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKGRvZikge1xuICAgIHJldHVybiBkb2Y7XG4gIH0sXG5cbiAgLy8gVE9ETzogdGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIChpcyB0aGVyZSBhIGJldHRlciB3YXk/KVxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihkb2YpIHtcbiAgICByZXR1cm4gZG9mICogTWF0aC5wb3coMSAtICgyIC8gKDkgKiBkb2YpKSwgMyk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShkb2YpIHtcbiAgICByZXR1cm4gKGRvZiAtIDIgPiAwKSA/IGRvZiAtIDIgOiAwO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGRvZikge1xuICAgIHJldHVybiBqU3RhdC5yYW5kZyhkb2YgLyAyKSAqIDI7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRvZikge1xuICAgIHJldHVybiAyICogZG9mO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBleHBvbmVudGlhbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuZXhwb25lbnRpYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgcmF0ZSkge1xuICAgIHJldHVybiB4IDwgMCA/IDAgOiByYXRlICogTWF0aC5leHAoLXJhdGUgKiB4KTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCByYXRlKSB7XG4gICAgcmV0dXJuIHggPCAwID8gMCA6IDEgLSBNYXRoLmV4cCgtcmF0ZSAqIHgpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgcmF0ZSkge1xuICAgIHJldHVybiAtTWF0aC5sb2coMSAtIHApIC8gcmF0ZTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24ocmF0ZSkge1xuICAgIHJldHVybiAxIC8gcmF0ZTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIChyYXRlKSB7XG4gICAgcmV0dXJuICgxIC8gcmF0ZSkgKiBNYXRoLmxvZygyKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHJhdGUpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShyYXRlKSB7XG4gICAgcmV0dXJuIC0xIC8gcmF0ZSAqIE1hdGgubG9nKE1hdGgucmFuZG9tKCkpO1xuICB9LFxuXG4gIHZhcmlhbmNlIDogZnVuY3Rpb24ocmF0ZSkge1xuICAgIHJldHVybiBNYXRoLnBvdyhyYXRlLCAtMik7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIGdhbW1hIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5nYW1tYSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoKHNoYXBlIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyBzY2FsZSAtXG4gICAgICAgICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oc2hhcGUpIC0gc2hhcGUgKiBNYXRoLmxvZyhzY2FsZSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5nYW1tYXAoc2hhcGUsIHggLyBzY2FsZSk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQuZ2FtbWFwaW52KHAsIHNoYXBlKSAqIHNjYWxlO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2hhcGUgKiBzY2FsZTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNoYXBlLCBzY2FsZSkge1xuICAgIGlmKHNoYXBlID4gMSkgcmV0dXJuIChzaGFwZSAtIDEpICogc2NhbGU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQucmFuZGcoc2hhcGUpICogc2NhbGU7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzaGFwZSAqIHNjYWxlICogc2NhbGU7XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgaW52ZXJzZSBnYW1tYSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuaW52Z2FtbWEsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0oc2hhcGUgKyAxKSAqIE1hdGgubG9nKHgpIC0gc2NhbGUgLyB4IC1cbiAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihzaGFwZSkgKyBzaGFwZSAqIE1hdGgubG9nKHNjYWxlKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIDEgLSBqU3RhdC5nYW1tYXAoc2hhcGUsIHNjYWxlIC8geCk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgLyBqU3RhdC5nYW1tYXBpbnYoMSAtIHAsIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIChzaGFwZSA+IDEpID8gc2NhbGUgLyAoc2hhcGUgLSAxKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIChzaGFwZSArIDEpO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIGpTdGF0LnJhbmRnKHNoYXBlKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2FsZSAqIHNjYWxlIC8gKChzaGFwZSAtIDEpICogKHNoYXBlIC0gMSkgKiAoc2hhcGUgLSAyKSk7XG4gIH1cbn0pO1xuXG5cbi8vIGV4dGVuZCBrdW1hcmFzd2FteSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQua3VtYXJhc3dhbXksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoTWF0aC5sb2coYWxwaGEpICsgTWF0aC5sb2coYmV0YSkgKyAoYWxwaGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKHgpICsgKGJldGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKDEgLSBNYXRoLnBvdyh4LCBhbHBoYSkpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoMSAtIE1hdGgucG93KDEgLSBNYXRoLnBvdyh4LCBhbHBoYSksIGJldGEpKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKGJldGEgKiBqU3RhdC5nYW1tYWZuKDEgKyAxIC8gYWxwaGEpICpcbiAgICAgICAgICAgIGpTdGF0LmdhbW1hZm4oYmV0YSkpIC8gKGpTdGF0LmdhbW1hZm4oMSArIDEgLyBhbHBoYSArIGJldGEpKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiBNYXRoLnBvdygxIC0gTWF0aC5wb3coMiwgLTEgLyBiZXRhKSwgMSAvIGFscGhhKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGFscGhhLCBiZXRhKSB7XG4gICAgaWYgKCEoYWxwaGEgPj0gMSAmJiBiZXRhID49IDEgJiYgKGFscGhhICE9PSAxICYmIGJldGEgIT09IDEpKSlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIE1hdGgucG93KChhbHBoYSAtIDEpIC8gKGFscGhhICogYmV0YSAtIDEpLCAxIC8gYWxwaGEpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhbHBoYSwgYmV0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFuY2Ugbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIC8vIFRPRE86IGNvbXBsZXRlIHRoaXNcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgbG9nbm9ybWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5sb2dub3JtYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC1NYXRoLmxvZyh4KSAtIDAuNSAqIE1hdGgubG9nKDIgKiBNYXRoLlBJKSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKHNpZ21hKSAtIE1hdGgucG93KE1hdGgubG9nKHgpIC0gbXUsIDIpIC9cbiAgICAgICAgICAgICAgICAgICAgKDIgKiBzaWdtYSAqIHNpZ21hKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIDAuNSArXG4gICAgICAgICgwLjUgKiBqU3RhdC5lcmYoKE1hdGgubG9nKHgpIC0gbXUpIC8gTWF0aC5zcXJ0KDIgKiBzaWdtYSAqIHNpZ21hKSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgbXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0xLjQxNDIxMzU2MjM3MzA5NTA1ICogc2lnbWEgKiBqU3RhdC5lcmZjaW52KDIgKiBwKSArIG11KTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cChtdSArIHNpZ21hICogc2lnbWEgLyAyKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUobXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKG11IC0gc2lnbWEgKiBzaWdtYSk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKGpTdGF0LnJhbmRuKCkgKiBzaWdtYSArIG11KTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UobXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIChNYXRoLmV4cChzaWdtYSAqIHNpZ21hKSAtIDEpICogTWF0aC5leHAoMiAqIG11ICsgc2lnbWEgKiBzaWdtYSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubm9ybWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtMC41ICogTWF0aC5sb2coMiAqIE1hdGguUEkpIC1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coc3RkKSAtIE1hdGgucG93KHggLSBtZWFuLCAyKSAvICgyICogc3RkICogc3RkKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxICsgalN0YXQuZXJmKCh4IC0gbWVhbikgLyBNYXRoLnNxcnQoMiAqIHN0ZCAqIHN0ZCkpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiAtMS40MTQyMTM1NjIzNzMwOTUwNSAqIHN0ZCAqIGpTdGF0LmVyZmNpbnYoMiAqIHApICsgbWVhbjtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24obWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIG1lYW47XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4obWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIG1lYW47XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kbigpICogc3RkICsgbWVhbjtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBzdGQgKiBzdGQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHBhcmV0byBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQucGFyZXRvLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDw9IHNjYWxlKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKHNoYXBlICogTWF0aC5wb3coc2NhbGUsIHNoYXBlKSkgLyBNYXRoLnBvdyh4LCBzaGFwZSArIDEpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coc2NhbGUgLyB4LCBzaGFwZSk7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihzY2FsZSwgc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUgPD0gMSlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChzaGFwZSAqIE1hdGgucG93KHNjYWxlLCBzaGFwZSkpIC8gKHNoYXBlIC0gMSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogKHNoYXBlICogTWF0aC5TUVJUMik7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihzY2FsZSwgc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUgPD0gMilcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChzY2FsZSpzY2FsZSAqIHNoYXBlKSAvIChNYXRoLnBvdyhzaGFwZSAtIDEsIDIpICogKHNoYXBlIC0gMikpO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBzdHVkZW50dCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuc3R1ZGVudHQsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZG9mKSB7XG4gICAgcmV0dXJuIChqU3RhdC5nYW1tYWZuKChkb2YgKyAxKSAvIDIpIC8gKE1hdGguc3FydChkb2YgKiBNYXRoLlBJKSAqXG4gICAgICAgIGpTdGF0LmdhbW1hZm4oZG9mIC8gMikpKSAqXG4gICAgICAgIE1hdGgucG93KDEgKyAoKHggKiB4KSAvIGRvZiksIC0oKGRvZiArIDEpIC8gMikpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGRvZikge1xuICAgIHZhciBkb2YyID0gZG9mIC8gMjtcbiAgICByZXR1cm4galN0YXQuaWJldGEoKHggKyBNYXRoLnNxcnQoeCAqIHggKyBkb2YpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICgyICogTWF0aC5zcXJ0KHggKiB4ICsgZG9mKSksIGRvZjIsIGRvZjIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgZG9mKSB7XG4gICAgdmFyIHggPSBqU3RhdC5pYmV0YWludigyICogTWF0aC5taW4ocCwgMSAtIHApLCAwLjUgKiBkb2YsIDAuNSk7XG4gICAgeCA9IE1hdGguc3FydChkb2YgKiAoMSAtIHgpIC8geCk7XG4gICAgcmV0dXJuIChwID4gMC41KSA/IHggOiAteDtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGRvZikge1xuICAgIHJldHVybiAoZG9mID4gMSkgPyAwIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGRvZikge1xuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoZG9mKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoZG9mKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRuKCkgKiBNYXRoLnNxcnQoZG9mIC8gKDIgKiBqU3RhdC5yYW5kZyhkb2YgLyAyKSkpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShkb2YpIHtcbiAgICByZXR1cm4gKGRvZiAgPiAyKSA/IGRvZiAvIChkb2YgLSAyKSA6IChkb2YgPiAxKSA/IEluZmluaXR5IDogdW5kZWZpbmVkO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB3ZWlidWxsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC53ZWlidWxsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAoc2hhcGUgLyBzY2FsZSkgKiBNYXRoLnBvdygoeCAvIHNjYWxlKSwgKHNoYXBlIC0gMSkpICpcbiAgICAgICAgTWF0aC5leHAoLShNYXRoLnBvdygoeCAvIHNjYWxlKSwgc2hhcGUpKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHggPCAwID8gMCA6IDEgLSBNYXRoLmV4cCgtTWF0aC5wb3coKHggLyBzY2FsZSksIHNoYXBlKSk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdygtTWF0aC5sb2coMSAtIHApLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBqU3RhdC5nYW1tYWZuKDEgKyAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIE1hdGgucG93KE1hdGgubG9nKDIpLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDEpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2FsZSAqIE1hdGgucG93KChzaGFwZSAtIDEpIC8gc2hhcGUsIDEgLyBzaGFwZSk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coLU1hdGgubG9nKE1hdGgucmFuZG9tKCkpLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBzY2FsZSAqIGpTdGF0LmdhbW1hZm4oMSArIDIgLyBzaGFwZSkgLVxuICAgICAgICBNYXRoLnBvdyh0aGlzLm1lYW4oc2NhbGUsIHNoYXBlKSwgMik7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnVuaWZvcm0sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYSwgYikge1xuICAgIHJldHVybiAoeCA8IGEgfHwgeCA+IGIpID8gMCA6IDEgLyAoYiAtIGEpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGEsIGIpIHtcbiAgICBpZiAoeCA8IGEpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmICh4IDwgYilcbiAgICAgIHJldHVybiAoeCAtIGEpIC8gKGIgLSBhKTtcbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGEsIGIpIHtcbiAgICByZXR1cm4gMC41ICogKGEgKyBiKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhLCBiKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm1lYW4oYSwgYik7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhLCBiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShhLCBiKSB7XG4gICAgcmV0dXJuIChhIC8gMiArIGIgLyAyKSArIChiIC8gMiAtIGEgLyAyKSAqICgyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGIgLSBhLCAyKSAvIDEyO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5iaW5vbWlhbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZihrLCBuLCBwKSB7XG4gICAgcmV0dXJuIChwID09PSAwIHx8IHAgPT09IDEpID9cbiAgICAgICgobiAqIHApID09PSBrID8gMSA6IDApIDpcbiAgICAgIGpTdGF0LmNvbWJpbmF0aW9uKG4sIGspICogTWF0aC5wb3cocCwgaykgKiBNYXRoLnBvdygxIC0gcCwgbiAtIGspO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG4sIHApIHtcbiAgICB2YXIgYmlub21hcnIgPSBbXSxcbiAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA8IG4pIHtcbiAgICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgICBiaW5vbWFyclsgayBdID0galN0YXQuYmlub21pYWwucGRmKGssIG4sIHApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpTdGF0LnN1bShiaW5vbWFycik7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5uZWdiaW4sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgciwgcCkge1xuICAgIHJldHVybiBrICE9PSBrIHwgMFxuICAgICAgPyBmYWxzZVxuICAgICAgOiBrIDwgMFxuICAgICAgICA/IDBcbiAgICAgICAgOiBqU3RhdC5jb21iaW5hdGlvbihrICsgciAtIDEsIHIgLSAxKSAqIE1hdGgucG93KDEgLSBwLCBrKSAqIE1hdGgucG93KHAsIHIpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHIsIHApIHtcbiAgICB2YXIgc3VtID0gMCxcbiAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHJldHVybiAwO1xuICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgc3VtICs9IGpTdGF0Lm5lZ2Jpbi5wZGYoaywgciwgcCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0Lmh5cGdlb20sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgTiwgbSwgbikge1xuICAgIC8vIEh5cGVyZ2VvbWV0cmljIFBERi5cblxuICAgIC8vIEEgc2ltcGxpZmljYXRpb24gb2YgdGhlIENERiBhbGdvcml0aG0gYmVsb3cuXG5cbiAgICAvLyBrID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBkcmF3blxuICAgIC8vIE4gPSBwb3B1bGF0aW9uIHNpemVcbiAgICAvLyBtID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBpbiBwb3B1bGF0aW9uXG4gICAgLy8gbiA9IG51bWJlciBvZiBpdGVtcyBkcmF3biBmcm9tIHBvcHVsYXRpb25cblxuICAgIGlmKGsgIT09IGsgfCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmKGsgPCAwIHx8IGsgPCBtIC0gKE4gLSBuKSkge1xuICAgICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGhhdmUgdGhpcyBmZXcgc3VjY2Vzc2VzIGRyYXduLlxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmKGsgPiBuIHx8IGsgPiBtKSB7XG4gICAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gaGF2ZSB0aGlzIG1hbnkgc3VjY2Vzc2VzIGRyYXduLlxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChtICogMiA+IE4pIHtcbiAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgaWYobiAqIDIgPiBOKSB7XG4gICAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKE4gLSBtIC0gbiArIGssIE4sIE4gLSBtLCBOIC0gbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihuIC0gaywgTiwgTiAtIG0sIG4pO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKG4gKiAyID4gTikge1xuICAgICAgLy8gSGFsZiBvciBsZXNzIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKG0gLSBrLCBOLCBtLCBOIC0gbik7XG5cbiAgICB9IGVsc2UgaWYobSA8IG4pIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gaGF2ZSB0aGUgbnVtYmVyIG9mIHRoaW5ncyBzYW1wbGVkIHRvIGJlIGxlc3MgdGhhbiB0aGVcbiAgICAgIC8vIHN1Y2Nlc3NlcyBhdmFpbGFibGUuIFNvIHN3YXAgdGhlIGRlZmluaXRpb25zIG9mIHN1Y2Nlc3NmdWwgYW5kIHNhbXBsZWQuXG4gICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5wZGYoaywgTiwgbiwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBoYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gd2FzIHNhbXBsZWQsIGhhbGYgb3JcbiAgICAgIC8vIGxlc3Mgb2YgaXQgd2FzIHN1Y2Nlc3NlcywgYW5kIHdlIGhhZCBmZXdlciBzYW1wbGVkIHRoaW5ncyB0aGFuXG4gICAgICAvLyBzdWNjZXNzZXMuIE5vdyB3ZSBjYW4gZG8gdGhpcyBjb21wbGljYXRlZCBpdGVyYXRpdmUgYWxnb3JpdGhtIGluIGFuXG4gICAgICAvLyBlZmZpY2llbnQgd2F5LlxuXG4gICAgICAvLyBUaGUgYmFzaWMgcHJlbWlzZSBvZiB0aGUgYWxnb3JpdGhtIGlzIHRoYXQgd2UgcGFydGlhbGx5IG5vcm1hbGl6ZSBvdXJcbiAgICAgIC8vIGludGVybWVkaWF0ZSBwcm9kdWN0IHRvIGtlZXAgaXQgaW4gYSBudW1lcmljYWxseSBnb29kIHJlZ2lvbiwgYW5kIHRoZW5cbiAgICAgIC8vIGZpbmlzaCB0aGUgbm9ybWFsaXphdGlvbiBhdCB0aGUgZW5kLlxuXG4gICAgICAvLyBUaGlzIHZhcmlhYmxlIGhvbGRzIHRoZSBzY2FsZWQgcHJvYmFiaWxpdHkgb2YgdGhlIGN1cnJlbnQgbnVtYmVyIG9mXG4gICAgICAvLyBzdWNjZXNzZXMuXG4gICAgICB2YXIgc2NhbGVkUERGID0gMTtcblxuICAgICAgLy8gVGhpcyBrZWVwcyB0cmFjayBvZiBob3cgbXVjaCB3ZSBoYXZlIG5vcm1hbGl6ZWQuXG4gICAgICB2YXIgc2FtcGxlc0RvbmUgPSAwO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgIC8vIEZvciBldmVyeSBwb3NzaWJsZSBudW1iZXIgb2Ygc3VjY2Vzc2VzIHVwIHRvIHRoYXQgb2JzZXJ2ZWQuLi5cblxuICAgICAgICB3aGlsZShzY2FsZWRQREYgPiAxICYmIHNhbXBsZXNEb25lIDwgbikge1xuICAgICAgICAgIC8vIEludGVybWVkaWF0ZSByZXN1bHQgaXMgZ3Jvd2luZyB0b28gYmlnLiBBcHBseSBzb21lIG9mIHRoZVxuICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24gdG8gc2hyaW5rIGV2ZXJ5dGhpbmcuXG5cbiAgICAgICAgICBzY2FsZWRQREYgKj0gMSAtIChtIC8gKE4gLSBzYW1wbGVzRG9uZSkpO1xuXG4gICAgICAgICAgLy8gU2F5IHdlJ3ZlIG5vcm1hbGl6ZWQgYnkgdGhpcyBzYW1wbGUgYWxyZWFkeS5cbiAgICAgICAgICBzYW1wbGVzRG9uZSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV29yayBvdXQgdGhlIHBhcnRpYWxseS1ub3JtYWxpemVkIGh5cGVyZ2VvbWV0cmljIFBERiBmb3IgdGhlIG5leHRcbiAgICAgICAgLy8gbnVtYmVyIG9mIHN1Y2Nlc3Nlc1xuICAgICAgICBzY2FsZWRQREYgKj0gKG4gLSBpKSAqIChtIC0gaSkgLyAoKGkgKyAxKSAqIChOIC0gbSAtIG4gKyBpICsgMSkpO1xuICAgICAgfVxuXG4gICAgICBmb3IoOyBzYW1wbGVzRG9uZSA8IG47IHNhbXBsZXNEb25lKyspIHtcbiAgICAgICAgLy8gQXBwbHkgYWxsIHRoZSByZXN0IG9mIHRoZSBub3JtYWxpemF0aW9uXG4gICAgICAgIHNjYWxlZFBERiAqPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIGFuc3dlciBzYW5lbHkgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBzY2FsZWRQREYpKTtcbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgTiwgbSwgbikge1xuICAgIC8vIEh5cGVyZ2VvbWV0cmljIENERi5cblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGlzIGR1ZSB0byBQcm9mLiBUaG9tYXMgUy4gRmVyZ3Vzb24sIDx0b21AbWF0aC51Y2xhLmVkdT4sXG4gICAgLy8gYW5kIGNvbWVzIGZyb20gaGlzIGh5cGVyZ2VvbWV0cmljIHRlc3QgY2FsY3VsYXRvciBhdFxuICAgIC8vIDxodHRwOi8vd3d3Lm1hdGgudWNsYS5lZHUvfnRvbS9kaXN0cmlidXRpb25zL0h5cGVyZ2VvbWV0cmljLmh0bWw+LlxuXG4gICAgLy8geCA9IG51bWJlciBvZiBzdWNjZXNzZXMgZHJhd25cbiAgICAvLyBOID0gcG9wdWxhdGlvbiBzaXplXG4gICAgLy8gbSA9IG51bWJlciBvZiBzdWNjZXNzZXMgaW4gcG9wdWxhdGlvblxuICAgIC8vIG4gPSBudW1iZXIgb2YgaXRlbXMgZHJhd24gZnJvbSBwb3B1bGF0aW9uXG5cbiAgICBpZih4IDwgMCB8fCB4IDwgbSAtIChOIC0gbikpIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgZmV3IHN1Y2Nlc3NlcyBkcmF3biBvciBmZXdlci5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZih4ID49IG4gfHwgeCA+PSBtKSB7XG4gICAgICAvLyBXZSB3aWxsIGFsd2F5cyBoYXZlIHRoaXMgbWFueSBzdWNjZXNzZXMgb3IgZmV3ZXIuXG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKG0gKiAyID4gTikge1xuICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc3VjY2Vzc2VzLlxuXG4gICAgICBpZihuICogMiA+IE4pIHtcbiAgICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cblxuICAgICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5jZGYoTiAtIG0gLSBuICsgeCwgTiwgTiAtIG0sIE4gLSBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIDEgLSBqU3RhdC5oeXBnZW9tLmNkZihuIC0geCAtIDEsIE4sIE4gLSBtLCBuKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZihuICogMiA+IE4pIHtcbiAgICAgIC8vIEhhbGYgb3IgbGVzcyBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIHJldHVybiAxIC0galN0YXQuaHlwZ2VvbS5jZGYobSAtIHggLSAxLCBOLCBtLCBOIC0gbik7XG5cbiAgICB9IGVsc2UgaWYobSA8IG4pIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gaGF2ZSB0aGUgbnVtYmVyIG9mIHRoaW5ncyBzYW1wbGVkIHRvIGJlIGxlc3MgdGhhbiB0aGVcbiAgICAgIC8vIHN1Y2Nlc3NlcyBhdmFpbGFibGUuIFNvIHN3YXAgdGhlIGRlZmluaXRpb25zIG9mIHN1Y2Nlc3NmdWwgYW5kIHNhbXBsZWQuXG4gICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5jZGYoeCwgTiwgbiwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBoYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gd2FzIHNhbXBsZWQsIGhhbGYgb3JcbiAgICAgIC8vIGxlc3Mgb2YgaXQgd2FzIHN1Y2Nlc3NlcywgYW5kIHdlIGhhZCBmZXdlciBzYW1wbGVkIHRoaW5ncyB0aGFuXG4gICAgICAvLyBzdWNjZXNzZXMuIE5vdyB3ZSBjYW4gZG8gdGhpcyBjb21wbGljYXRlZCBpdGVyYXRpdmUgYWxnb3JpdGhtIGluIGFuXG4gICAgICAvLyBlZmZpY2llbnQgd2F5LlxuXG4gICAgICAvLyBUaGUgYmFzaWMgcHJlbWlzZSBvZiB0aGUgYWxnb3JpdGhtIGlzIHRoYXQgd2UgcGFydGlhbGx5IG5vcm1hbGl6ZSBvdXJcbiAgICAgIC8vIGludGVybWVkaWF0ZSBzdW0gdG8ga2VlcCBpdCBpbiBhIG51bWVyaWNhbGx5IGdvb2QgcmVnaW9uLCBhbmQgdGhlblxuICAgICAgLy8gZmluaXNoIHRoZSBub3JtYWxpemF0aW9uIGF0IHRoZSBlbmQuXG5cbiAgICAgIC8vIEhvbGRzIHRoZSBpbnRlcm1lZGlhdGUsIHNjYWxlZCB0b3RhbCBDREYuXG4gICAgICB2YXIgc2NhbGVkQ0RGID0gMTtcblxuICAgICAgLy8gVGhpcyB2YXJpYWJsZSBob2xkcyB0aGUgc2NhbGVkIHByb2JhYmlsaXR5IG9mIHRoZSBjdXJyZW50IG51bWJlciBvZlxuICAgICAgLy8gc3VjY2Vzc2VzLlxuICAgICAgdmFyIHNjYWxlZFBERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG11Y2ggd2UgaGF2ZSBub3JtYWxpemVkLlxuICAgICAgdmFyIHNhbXBsZXNEb25lID0gMDtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHg7IGkrKykge1xuICAgICAgICAvLyBGb3IgZXZlcnkgcG9zc2libGUgbnVtYmVyIG9mIHN1Y2Nlc3NlcyB1cCB0byB0aGF0IG9ic2VydmVkLi4uXG5cbiAgICAgICAgd2hpbGUoc2NhbGVkQ0RGID4gMSAmJiBzYW1wbGVzRG9uZSA8IG4pIHtcbiAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgcmVzdWx0IGlzIGdyb3dpbmcgdG9vIGJpZy4gQXBwbHkgc29tZSBvZiB0aGVcbiAgICAgICAgICAvLyBub3JtYWxpemF0aW9uIHRvIHNocmluayBldmVyeXRoaW5nLlxuXG4gICAgICAgICAgdmFyIGZhY3RvciA9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcblxuICAgICAgICAgIHNjYWxlZFBERiAqPSBmYWN0b3I7XG4gICAgICAgICAgc2NhbGVkQ0RGICo9IGZhY3RvcjtcblxuICAgICAgICAgIC8vIFNheSB3ZSd2ZSBub3JtYWxpemVkIGJ5IHRoaXMgc2FtcGxlIGFscmVhZHkuXG4gICAgICAgICAgc2FtcGxlc0RvbmUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBwYXJ0aWFsbHktbm9ybWFsaXplZCBoeXBlcmdlb21ldHJpYyBQREYgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIG51bWJlciBvZiBzdWNjZXNzZXNcbiAgICAgICAgc2NhbGVkUERGICo9IChuIC0gaSkgKiAobSAtIGkpIC8gKChpICsgMSkgKiAoTiAtIG0gLSBuICsgaSArIDEpKTtcblxuICAgICAgICAvLyBBZGQgdG8gdGhlIENERiBhbnN3ZXIuXG4gICAgICAgIHNjYWxlZENERiArPSBzY2FsZWRQREY7XG4gICAgICB9XG5cbiAgICAgIGZvcig7IHNhbXBsZXNEb25lIDwgbjsgc2FtcGxlc0RvbmUrKykge1xuICAgICAgICAvLyBBcHBseSBhbGwgdGhlIHJlc3Qgb2YgdGhlIG5vcm1hbGl6YXRpb25cbiAgICAgICAgc2NhbGVkQ0RGICo9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQm91bmQgYW5zd2VyIHNhbmVseSBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHNjYWxlZENERikpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQucG9pc3Nvbiwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZihrLCBsKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGwsIGspICogTWF0aC5leHAoLWwpIC8galN0YXQuZmFjdG9yaWFsKGspO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGwpIHtcbiAgICB2YXIgc3VtYXJyID0gW10sXG4gICAgayA9IDA7XG4gICAgaWYgKHggPCAwKSByZXR1cm4gMDtcbiAgICBmb3IgKDsgayA8PSB4OyBrKyspIHtcbiAgICAgIHN1bWFyci5wdXNoKGpTdGF0LnBvaXNzb24ucGRmKGssIGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0LnN1bShzdW1hcnIpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGw7XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGw7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobCkge1xuICAgIHZhciBwID0gMSwgayA9IDAsIEwgPSBNYXRoLmV4cCgtbCk7XG4gICAgZG8ge1xuICAgICAgaysrO1xuICAgICAgcCAqPSBNYXRoLnJhbmRvbSgpO1xuICAgIH0gd2hpbGUgKHAgPiBMKTtcbiAgICByZXR1cm4gayAtIDE7XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgdHJpYW5ndWxhciBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQudHJpYW5ndWxhciwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChiIDw9IGEgfHwgYyA8IGEgfHwgYyA+IGIpXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiAoeCA8IGEgfHwgeCA+IGIpXG4gICAgICAgID8gMFxuICAgICAgICA6ICh4IDw9IGMpXG4gICAgICAgICAgPyAoMiAqICh4IC0gYSkpIC8gKChiIC0gYSkgKiAoYyAtIGEpKVxuICAgICAgICAgIDogKDIgKiAoYiAtIHgpKSAvICgoYiAtIGEpICogKGIgLSBjKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYSwgYiwgYykge1xuICAgIGlmIChiIDw9IGEgfHwgYyA8IGEgfHwgYyA+IGIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh4IDwgYSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4IDw9IGMpXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyh4IC0gYSwgMikgLyAoKGIgLSBhKSAqIChjIC0gYSkpO1xuICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdyhiIC0geCwgMikgLyAoKGIgLSBhKSAqIChiIC0gYykpO1xuICAgIH1cbiAgICAvLyBuZXZlciByZWFjaCB0aGlzXG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICsgYiArIGMpIC8gMztcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhLCBiLCBjKSB7XG4gICAgaWYgKGMgPD0gKGEgKyBiKSAvIDIpIHtcbiAgICAgIHJldHVybiBiIC0gTWF0aC5zcXJ0KChiIC0gYSkgKiAoYiAtIGMpKSAvIE1hdGguc3FydCgyKTtcbiAgICB9IGVsc2UgaWYgKGMgPiAoYSArIGIpIC8gMikge1xuICAgICAgcmV0dXJuIGEgKyBNYXRoLnNxcnQoKGIgLSBhKSAqIChjIC0gYSkpIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH1cbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYztcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShhLCBiLCBjKSB7XG4gICAgdmFyIHUgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGlmICh1IDwgKChjIC0gYSkgLyAoYiAtIGEpKSlcbiAgICAgIHJldHVybiBhICsgTWF0aC5zcXJ0KHUgKiAoYiAtIGEpICogKGMgLSBhKSlcbiAgICByZXR1cm4gYiAtIE1hdGguc3FydCgoMSAtIHUpICogKGIgLSBhKSAqIChiIC0gYykpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICogYSArIGIgKiBiICsgYyAqIGMgLSBhICogYiAtIGEgKiBjIC0gYiAqIGMpIC8gMTg7XG4gIH1cbn0pO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbi8qIFByb3ZpZGVzIGZ1bmN0aW9ucyBmb3IgdGhlIHNvbHV0aW9uIG9mIGxpbmVhciBzeXN0ZW0gb2YgZXF1YXRpb25zLCBpbnRlZ3JhdGlvbiwgZXh0cmFwb2xhdGlvbixcbiAqIGludGVycG9sYXRpb24sIGVpZ2VudmFsdWUgcHJvYmxlbXMsIGRpZmZlcmVudGlhbCBlcXVhdGlvbnMgYW5kIFBDQSBhbmFseXNpcy4gKi9cblxuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbnZhciBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG52YXIgaXNBcnJheSA9IGpTdGF0LnV0aWxzLmlzQXJyYXk7XG5cbmpTdGF0LmV4dGVuZCh7XG5cbiAgLy8gYWRkIGEgdmVjdG9yL21hdHJpeCB0byBhIHZlY3Rvci9tYXRyaXggb3Igc2NhbGFyXG4gIGFkZDogZnVuY3Rpb24gYWRkKGFyciwgYXJnKSB7XG4gICAgLy8gY2hlY2sgaWYgYXJnIGlzIGEgdmVjdG9yIG9yIHNjYWxhclxuICAgIGlmIChpc0FycmF5KGFyZykpIHtcbiAgICAgIGlmICghaXNBcnJheShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlLCByb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBhcmdbcm93XVtjb2xdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIHN1YnRyYWN0IGEgdmVjdG9yIG9yIHNjYWxhciBmcm9tIHRoZSB2ZWN0b3JcbiAgc3VidHJhY3Q6IGZ1bmN0aW9uIHN1YnRyYWN0KGFyciwgYXJnKSB7XG4gICAgLy8gY2hlY2sgaWYgYXJnIGlzIGEgdmVjdG9yIG9yIHNjYWxhclxuICAgIGlmIChpc0FycmF5KGFyZykpIHtcbiAgICAgIGlmICghaXNBcnJheShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlLCByb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgLSBhcmdbcm93XVtjb2xdIHx8IDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAtIGFyZzsgfSk7XG4gIH0sXG5cbiAgLy8gbWF0cml4IGRpdmlzaW9uXG4gIGRpdmlkZTogZnVuY3Rpb24gZGl2aWRlKGFyciwgYXJnKSB7XG4gICAgaWYgKGlzQXJyYXkoYXJnKSkge1xuICAgICAgaWYgKCFpc0FycmF5KGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubXVsdGlwbHkoYXJyLCBqU3RhdC5pbnYoYXJnKSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLyBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkoYXJyLCBhcmcpIHtcbiAgICB2YXIgcm93LCBjb2wsIG5yZXNjb2xzLCBzdW0sXG4gICAgbnJvdyA9IGFyci5sZW5ndGgsXG4gICAgbmNvbCA9IGFyclswXS5sZW5ndGgsXG4gICAgcmVzID0galN0YXQuemVyb3MobnJvdywgbnJlc2NvbHMgPSAoaXNBcnJheShhcmcpKSA/IGFyZ1swXS5sZW5ndGggOiBuY29sKSxcbiAgICByZXNjb2xzID0gMDtcbiAgICBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgICBmb3IgKDsgcmVzY29scyA8IG5yZXNjb2xzOyByZXNjb2xzKyspIHtcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBucm93OyByb3crKykge1xuICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgICAgICBzdW0gKz0gYXJyW3Jvd11bY29sXSAqIGFyZ1tjb2xdW3Jlc2NvbHNdO1xuICAgICAgICAgIHJlc1tyb3ddW3Jlc2NvbHNdID0gc3VtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKG5yb3cgPT09IDEgJiYgcmVzY29scyA9PT0gMSkgPyByZXNbMF1bMF0gOiByZXM7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKiBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBtYXRyaWNpZXNcbiAgZG90OiBmdW5jdGlvbiBkb3QoYXJyLCBhcmcpIHtcbiAgICBpZiAoIWlzQXJyYXkoYXJyWzBdKSkgYXJyID0gWyBhcnIgXTtcbiAgICBpZiAoIWlzQXJyYXkoYXJnWzBdKSkgYXJnID0gWyBhcmcgXTtcbiAgICAvLyBjb252ZXJ0IGNvbHVtbiB0byByb3cgdmVjdG9yXG4gICAgdmFyIGxlZnQgPSAoYXJyWzBdLmxlbmd0aCA9PT0gMSAmJiBhcnIubGVuZ3RoICE9PSAxKSA/IGpTdGF0LnRyYW5zcG9zZShhcnIpIDogYXJyLFxuICAgIHJpZ2h0ID0gKGFyZ1swXS5sZW5ndGggPT09IDEgJiYgYXJnLmxlbmd0aCAhPT0gMSkgPyBqU3RhdC50cmFuc3Bvc2UoYXJnKSA6IGFyZyxcbiAgICByZXMgPSBbXSxcbiAgICByb3cgPSAwLFxuICAgIG5yb3cgPSBsZWZ0Lmxlbmd0aCxcbiAgICBuY29sID0gbGVmdFswXS5sZW5ndGgsXG4gICAgc3VtLCBjb2w7XG4gICAgZm9yICg7IHJvdyA8IG5yb3c7IHJvdysrKSB7XG4gICAgICByZXNbcm93XSA9IFtdO1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICBzdW0gKz0gbGVmdFtyb3ddW2NvbF0gKiByaWdodFtyb3ddW2NvbF07XG4gICAgICByZXNbcm93XSA9IHN1bTtcbiAgICB9XG4gICAgcmV0dXJuIChyZXMubGVuZ3RoID09PSAxKSA/IHJlc1swXSA6IHJlcztcbiAgfSxcblxuICAvLyByYWlzZSBldmVyeSBlbGVtZW50IGJ5IGEgc2NhbGFyXG4gIHBvdzogZnVuY3Rpb24gcG93KGFyciwgYXJnKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBNYXRoLnBvdyh2YWx1ZSwgYXJnKTsgfSk7XG4gIH0sXG5cbiAgLy8gZ2VuZXJhdGUgdGhlIGFic29sdXRlIHZhbHVlcyBvZiB0aGUgdmVjdG9yXG4gIGFiczogZnVuY3Rpb24gYWJzKGFycikge1xuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gTWF0aC5hYnModmFsdWUpOyB9KTtcbiAgfSxcblxuICAvLyBjb21wdXRlcyB0aGUgcC1ub3JtIG9mIHRoZSB2ZWN0b3JcbiAgLy8gSW4gdGhlIGNhc2UgdGhhdCBhIG1hdHJpeCBpcyBwYXNzZWQsIHVzZXMgdGhlIGZpcnN0IHJvdyBhcyB0aGUgdmVjdG9yXG4gIG5vcm06IGZ1bmN0aW9uIG5vcm0oYXJyLCBwKSB7XG4gICAgdmFyIG5ub3JtID0gMCxcbiAgICBpID0gMDtcbiAgICAvLyBjaGVjayB0aGUgcC12YWx1ZSBvZiB0aGUgbm9ybSwgYW5kIHNldCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICAgIGlmIChpc05hTihwKSkgcCA9IDI7XG4gICAgLy8gY2hlY2sgaWYgbXVsdGktZGltZW5zaW9uYWwgYXJyYXksIGFuZCBtYWtlIHZlY3RvciBjb3JyZWN0aW9uXG4gICAgaWYgKGlzQXJyYXkoYXJyWzBdKSkgYXJyID0gYXJyWzBdO1xuICAgIC8vIHZlY3RvciBub3JtXG4gICAgZm9yICg7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ub3JtICs9IE1hdGgucG93KE1hdGguYWJzKGFycltpXSksIHApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5wb3cobm5vcm0sIDEgLyBwKTtcbiAgfSxcblxuICAvLyBUT0RPOiBtYWtlIGNvbXBhdGlibGUgd2l0aCBtYXRyaWNlc1xuICAvLyBjb21wdXRlcyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyBpbiByYWRzXG4gIGFuZ2xlOiBmdW5jdGlvbiBhbmdsZShhcnIsIGFyZykge1xuICAgIHJldHVybiBNYXRoLmFjb3MoalN0YXQuZG90KGFyciwgYXJnKSAvIChqU3RhdC5ub3JtKGFycikgKiBqU3RhdC5ub3JtKGFyZykpKTtcbiAgfSxcblxuICAvLyBhdWdtZW50IG9uZSBtYXRyaXggYnkgYW5vdGhlclxuICBhdWc6IGZ1bmN0aW9uIGF1ZyhhLCBiKSB7XG4gICAgdmFyIG5ld2FyciA9IGEuc2xpY2UoKSxcbiAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG5ld2Fyci5sZW5ndGg7IGkrKykge1xuICAgICAgcHVzaC5hcHBseShuZXdhcnJbaV0sIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3YXJyO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KGEpIHtcbiAgICB2YXIgcm93cyA9IGEubGVuZ3RoLFxuICAgIGNvbHMgPSBhWzBdLmxlbmd0aCxcbiAgICBiID0galN0YXQuaWRlbnRpdHkocm93cywgY29scyksXG4gICAgYyA9IGpTdGF0LmdhdXNzX2pvcmRhbihhLCBiKSxcbiAgICBvYmogPSBbXSxcbiAgICBpID0gMCxcbiAgICBqO1xuICAgIGZvciAoOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBvYmpbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IGNvbHMgLSAxOyBqIDwgY1swXS5sZW5ndGg7IGorKylcbiAgICAgIG9ialtpXVtqIC0gY29sc10gPSBjW2ldW2pdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAgZGV0OiBmdW5jdGlvbiBkZXQoYSkge1xuICAgIHZhciBhbGVuID0gYS5sZW5ndGgsXG4gICAgYWxlbmQgPSBhbGVuICogMixcbiAgICB2YWxzID0gbmV3IEFycmF5KGFsZW5kKSxcbiAgICByb3dzaGlmdCA9IGFsZW4gLSAxLFxuICAgIGNvbHNoaWZ0ID0gYWxlbmQgLSAxLFxuICAgIG1yb3cgPSByb3dzaGlmdCAtIGFsZW4gKyAxLFxuICAgIG1jb2wgPSBjb2xzaGlmdCxcbiAgICBpID0gMCxcbiAgICByZXN1bHQgPSAwLFxuICAgIGo7XG4gICAgLy8gY2hlY2sgZm9yIHNwZWNpYWwgMngyIGNhc2VcbiAgICBpZiAoYWxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGFbMF1bMF0gKiBhWzFdWzFdIC0gYVswXVsxXSAqIGFbMV1bMF07XG4gICAgfVxuICAgIGZvciAoOyBpIDwgYWxlbmQ7IGkrKykge1xuICAgICAgdmFsc1tpXSA9IDE7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhbGVuOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhbGVuOyBqKyspIHtcbiAgICAgICAgdmFsc1sobXJvdyA8IDApID8gbXJvdyArIGFsZW4gOiBtcm93IF0gKj0gYVtpXVtqXTtcbiAgICAgICAgdmFsc1sobWNvbCA8IGFsZW4pID8gbWNvbCArIGFsZW4gOiBtY29sIF0gKj0gYVtpXVtqXTtcbiAgICAgICAgbXJvdysrO1xuICAgICAgICBtY29sLS07XG4gICAgICB9XG4gICAgICBtcm93ID0gLS1yb3dzaGlmdCAtIGFsZW4gKyAxO1xuICAgICAgbWNvbCA9IC0tY29sc2hpZnQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSB2YWxzW2ldO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGFsZW5kOyBpKyspIHtcbiAgICAgIHJlc3VsdCAtPSB2YWxzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGdhdXNzX2VsaW1pbmF0aW9uOiBmdW5jdGlvbiBnYXVzc19lbGltaW5hdGlvbihhLCBiKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgIGogPSAwLFxuICAgIG4gPSBhLmxlbmd0aCxcbiAgICBtID0gYVswXS5sZW5ndGgsXG4gICAgZmFjdG9yID0gMSxcbiAgICBzdW0gPSAwLFxuICAgIHggPSBbXSxcbiAgICBtYXVnLCBwaXZvdCwgdGVtcCwgaztcbiAgICBhID0galN0YXQuYXVnKGEsIGIpO1xuICAgIG1hdWcgPSBhWzBdLmxlbmd0aDtcbiAgICBmb3IoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBwaXZvdCA9IGFbaV1baV07XG4gICAgICBqID0gaTtcbiAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbTsgaysrKSB7XG4gICAgICAgIGlmIChwaXZvdCA8IE1hdGguYWJzKGFba11baV0pKSB7XG4gICAgICAgICAgcGl2b3QgPSBhW2tdW2ldO1xuICAgICAgICAgIGogPSBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaiAhPSBpKSB7XG4gICAgICAgIGZvcihrID0gMDsgayA8IG1hdWc7IGsrKykge1xuICAgICAgICAgIHRlbXAgPSBhW2ldW2tdO1xuICAgICAgICAgIGFbaV1ba10gPSBhW2pdW2tdO1xuICAgICAgICAgIGFbal1ba10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICBmYWN0b3IgPSBhW2pdW2ldIC8gYVtpXVtpXTtcbiAgICAgICAgZm9yKGsgPSBpOyBrIDwgbWF1ZzsgaysrKSB7XG4gICAgICAgICAgYVtqXVtrXSA9IGFbal1ba10gLSBmYWN0b3IgKiBhW2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqPD0gbiAtIDE7IGorKykge1xuICAgICAgICBzdW0gPSB4W2pdICogYVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIHhbaV0gPShhW2ldW21hdWcgLSAxXSAtIHN1bSkgLyBhW2ldW2ldO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBnYXVzc19qb3JkYW46IGZ1bmN0aW9uIGdhdXNzX2pvcmRhbihhLCBiKSB7XG4gICAgdmFyIG0gPSBqU3RhdC5hdWcoYSwgYiksXG4gICAgaCA9IG0ubGVuZ3RoLFxuICAgIHcgPSBtWzBdLmxlbmd0aDtcbiAgICAvLyBmaW5kIG1heCBwaXZvdFxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICB2YXIgbWF4cm93ID0geTtcbiAgICAgIGZvciAodmFyIHkyID0geSsxOyB5MiA8IGg7IHkyKyspIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKG1beTJdW3ldKSA+IE1hdGguYWJzKG1bbWF4cm93XVt5XSkpXG4gICAgICAgICAgbWF4cm93ID0geTI7XG4gICAgICB9XG4gICAgICB2YXIgdG1wID0gbVt5XTtcbiAgICAgIG1beV0gPSBtW21heHJvd107XG4gICAgICBtW21heHJvd10gPSB0bXBcbiAgICAgIGZvciAodmFyIHkyID0geSsxOyB5MiA8IGg7IHkyKyspIHtcbiAgICAgICAgYyA9IG1beTJdW3ldIC8gbVt5XVt5XTtcbiAgICAgICAgZm9yICh2YXIgeCA9IHk7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICBtW3kyXVt4XSAtPSBtW3ldW3hdICogYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBiYWNrc3Vic3RpdHV0ZVxuICAgIGZvciAodmFyIHkgPSBoLTE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICBjID0gbVt5XVt5XTtcbiAgICAgIGZvciAodmFyIHkyID0gMDsgeTIgPCB5OyB5MisrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSB3LTE7IHggPiB5LTE7IHgtLSkge1xuICAgICAgICAgIG1beTJdW3hdIC09IG1beV1beF0gKiBtW3kyXVt5XSAvIGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1beV1beV0gLz0gYztcbiAgICAgIGZvciAodmFyIHggPSBoOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgIG1beV1beF0gLz0gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH0sXG5cbiAgbHU6IGZ1bmN0aW9uIGx1KGEsIGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2x1IG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBjaG9sZXNreTogZnVuY3Rpb24gY2hvbGVza3koYSwgYikge1xuICAgIHRocm93IG5ldyBFcnJvcignY2hvbGVza3kgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIGdhdXNzX2phY29iaTogZnVuY3Rpb24gZ2F1c3NfamFjb2JpKGEsIGIsIHgsIHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIHh2LCBjLCBoLCB4aztcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IFtdO1xuICAgICAgdVtpXSA9IFtdO1xuICAgICAgZFtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICBsW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICB1W2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGopIHtcbiAgICAgICAgICB1W2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IHVbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoZCksIGpTdGF0LmFkZChsLCB1KSksIC0xKTtcbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KGQpLCBiKTtcbiAgICB4diA9IHg7XG4gICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeCksIGMpO1xuICAgIGkgPSAyO1xuICAgIHdoaWxlIChNYXRoLmFicyhqU3RhdC5ub3JtKGpTdGF0LnN1YnRyYWN0KHhrLHh2KSkpID4gcikge1xuICAgICAgeHYgPSB4aztcbiAgICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHh2KSwgYyk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB4aztcbiAgfSxcblxuICBnYXVzc19zZWlkZWw6IGZ1bmN0aW9uIGdhdXNzX3NlaWRlbChhLCBiLCB4LCByKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGosIHh2LCBjLCBoLCB4aztcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IFtdO1xuICAgICAgdVtpXSA9IFtdO1xuICAgICAgZFtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICBsW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICB1W2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGopIHtcbiAgICAgICAgICB1W2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IHVbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsIGwpKSwgdSksIC0xKTtcbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KGpTdGF0LmFkZChkLCBsKSksIGIpO1xuICAgIHh2ID0geDtcbiAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4KSwgYyk7XG4gICAgaSA9IDI7XG4gICAgd2hpbGUgKE1hdGguYWJzKGpTdGF0Lm5vcm0oalN0YXQuc3VidHJhY3QoeGssIHh2KSkpID4gcikge1xuICAgICAgeHYgPSB4aztcbiAgICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHh2KSwgYyk7XG4gICAgICBpID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiB4aztcbiAgfSxcblxuICBTT1I6IGZ1bmN0aW9uIFNPUihhLCBiLCB4LCByLCB3KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGosIHh2LCBjLCBoLCB4aztcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IFtdO1xuICAgICAgdVtpXSA9IFtdO1xuICAgICAgZFtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICBsW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICB1W2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGopIHtcbiAgICAgICAgICB1W2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IHVbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsIGpTdGF0Lm11bHRpcGx5KGwsIHcpKSksXG4gICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LnN1YnRyYWN0KGpTdGF0Lm11bHRpcGx5KGQsIDEgLSB3KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalN0YXQubXVsdGlwbHkodSwgdykpKTtcbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkoalN0YXQuaW52KGpTdGF0LmFkZChkLFxuICAgICAgICBqU3RhdC5tdWx0aXBseShsLCB3KSkpLCBiKSwgdyk7XG4gICAgeHYgPSB4O1xuICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHgpLCBjKTtcbiAgICBpID0gMjtcbiAgICB3aGlsZSAoTWF0aC5hYnMoalN0YXQubm9ybShqU3RhdC5zdWJ0cmFjdCh4aywgeHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIGhvdXNlaG9sZGVyOiBmdW5jdGlvbiBob3VzZWhvbGRlcihhKSB7XG4gICAgdmFyIG0gPSBhLmxlbmd0aDtcbiAgICB2YXIgbiA9IGFbMF0ubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdyA9IFtdO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIGFscGhhLCByLCBrLCBqLCBmYWN0b3I7XG4gICAgZm9yICg7IGkgPCBtIC0gMTsgaSsrKSB7XG4gICAgICBhbHBoYSA9IDA7XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKylcbiAgICAgIGFscGhhICs9IChhW2pdW2ldICogYVtqXVtpXSk7XG4gICAgICBmYWN0b3IgPSAoYVtpICsgMV1baV0gPiAwKSA/IC0xIDogMTtcbiAgICAgIGFscGhhID0gZmFjdG9yICogTWF0aC5zcXJ0KGFscGhhKTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoKCgoYWxwaGEgKiBhbHBoYSkgLSBhW2kgKyAxXVtpXSAqIGFscGhhKSAvIDIpKTtcbiAgICAgIHcgPSBqU3RhdC56ZXJvcyhtLCAxKTtcbiAgICAgIHdbaSArIDFdWzBdID0gKGFbaSArIDFdW2ldIC0gYWxwaGEpIC8gKDIgKiByKTtcbiAgICAgIGZvciAoayA9IGkgKyAyOyBrIDwgbTsgaysrKSB3W2tdWzBdID0gYVtrXVtpXSAvICgyICogcik7XG4gICAgICBwID0galN0YXQuc3VidHJhY3QoalN0YXQuaWRlbnRpdHkobSwgbiksXG4gICAgICAgICAgalN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkodywgalN0YXQudHJhbnNwb3NlKHcpKSwgMikpO1xuICAgICAgYSA9IGpTdGF0Lm11bHRpcGx5KHAsIGpTdGF0Lm11bHRpcGx5KGEsIHApKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH0sXG5cbiAgLy8gVE9ETzogbm90IHdvcmtpbmcgcHJvcGVybHkuXG4gIFFSOiBmdW5jdGlvbiBRUihhLCBiKSB7XG4gICAgdmFyIG0gPSBhLmxlbmd0aDtcbiAgICB2YXIgbiA9IGFbMF0ubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdyA9IFtdO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIHggPSBbXTtcbiAgICB2YXIgaiwgYWxwaGEsIHIsIGssIGZhY3Rvciwgc3VtO1xuICAgIGZvciAoOyBpIDwgbSAtIDE7IGkrKykge1xuICAgICAgYWxwaGEgPSAwO1xuICAgICAgZm9yIChqID0gaSArIDE7IGogPCBuOyBqKyspXG4gICAgICAgIGFscGhhICs9IChhW2pdW2ldICogYVtqXVtpXSk7XG4gICAgICBmYWN0b3IgPSAoYVtpICsgMV1baV0gPiAwKSA/IC0xIDogMTtcbiAgICAgIGFscGhhID0gZmFjdG9yICogTWF0aC5zcXJ0KGFscGhhKTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoKCgoYWxwaGEgKiBhbHBoYSkgLSBhW2kgKyAxXVtpXSAqIGFscGhhKSAvIDIpKTtcbiAgICAgIHcgPSBqU3RhdC56ZXJvcyhtLCAxKTtcbiAgICAgIHdbaSArIDFdWzBdID0gKGFbaSArIDFdW2ldIC0gYWxwaGEpIC8gKDIgKiByKTtcbiAgICAgIGZvciAoayA9IGkgKyAyOyBrIDwgbTsgaysrKVxuICAgICAgICB3W2tdWzBdID0gYVtrXVtpXSAvICgyICogcik7XG4gICAgICBwID0galN0YXQuc3VidHJhY3QoalN0YXQuaWRlbnRpdHkobSwgbiksXG4gICAgICAgICAgalN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkodywgalN0YXQudHJhbnNwb3NlKHcpKSwgMikpO1xuICAgICAgYSA9IGpTdGF0Lm11bHRpcGx5KHAsIGEpO1xuICAgICAgYiA9IGpTdGF0Lm11bHRpcGx5KHAsIGIpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBtIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHN1bSA9IDA7XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8PSBuIC0gMTsgaisrKVxuICAgICAgc3VtID0geFtqXSAqIGFbaV1bal07XG4gICAgICB4W2ldID0gYltpXVswXSAvIGFbaV1baV07XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9LFxuXG4gIGphY29iaTogZnVuY3Rpb24gamFjb2JpKGEpIHtcbiAgICB2YXIgY29uZGl0aW9uID0gMTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGUgPSBqU3RhdC5pZGVudGl0eShuLCBuKTtcbiAgICB2YXIgZXYgPSBbXTtcbiAgICB2YXIgYiwgaSwgaiwgcCwgcSwgbWF4aW0sIHRoZXRhLCBzO1xuICAgIC8vIGNvbmRpdGlvbiA9PT0gMSBvbmx5IGlmIHRvbGVyYW5jZSBpcyBub3QgcmVhY2hlZFxuICAgIHdoaWxlIChjb25kaXRpb24gPT09IDEpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBtYXhpbSA9IGFbMF1bMV07XG4gICAgICBwID0gMDtcbiAgICAgIHEgPSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgIT0gaikge1xuICAgICAgICAgICAgaWYgKG1heGltIDwgTWF0aC5hYnMoYVtpXVtqXSkpIHtcbiAgICAgICAgICAgICAgbWF4aW0gPSBNYXRoLmFicyhhW2ldW2pdKTtcbiAgICAgICAgICAgICAgcCA9IGk7XG4gICAgICAgICAgICAgIHEgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFbcF1bcF0gPT09IGFbcV1bcV0pXG4gICAgICAgIHRoZXRhID0gKGFbcF1bcV0gPiAwKSA/IE1hdGguUEkgLyA0IDogLU1hdGguUEkgLyA0O1xuICAgICAgZWxzZVxuICAgICAgICB0aGV0YSA9IE1hdGguYXRhbigyICogYVtwXVtxXSAvIChhW3BdW3BdIC0gYVtxXVtxXSkpIC8gMjtcbiAgICAgIHMgPSBqU3RhdC5pZGVudGl0eShuLCBuKTtcbiAgICAgIHNbcF1bcF0gPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICBzW3BdW3FdID0gLU1hdGguc2luKHRoZXRhKTtcbiAgICAgIHNbcV1bcF0gPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICBzW3FdW3FdID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgLy8gZWlnZW4gdmVjdG9yIG1hdHJpeFxuICAgICAgZSA9IGpTdGF0Lm11bHRpcGx5KGUsIHMpO1xuICAgICAgYiA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihzKSwgYSksIHMpO1xuICAgICAgYSA9IGI7XG4gICAgICBjb25kaXRpb24gPSAwO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgIT0gaiAmJiBNYXRoLmFicyhhW2ldW2pdKSA+IDAuMDAxKSB7XG4gICAgICAgICAgICBjb25kaXRpb24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBldi5wdXNoKGFbaV1baV0pO1xuICAgIC8vcmV0dXJucyBib3RoIHRoZSBlaWdlbnZhbHVlIGFuZCBlaWdlbm1hdHJpeFxuICAgIHJldHVybiBbZSwgZXZdO1xuICB9LFxuXG4gIHJ1bmdla3V0dGE6IGZ1bmN0aW9uIHJ1bmdla3V0dGEoZiwgaCwgcCwgdF9qLCB1X2osIG9yZGVyKSB7XG4gICAgdmFyIGsxLCBrMiwgdV9qMSwgazMsIGs0O1xuICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgd2hpbGUgKHRfaiA8PSBwKSB7XG4gICAgICAgIGsxID0gaCAqIGYodF9qLCB1X2opO1xuICAgICAgICBrMiA9IGggKiBmKHRfaiArIGgsIHVfaiArIGsxKTtcbiAgICAgICAgdV9qMSA9IHVfaiArIChrMSArIGsyKSAvIDI7XG4gICAgICAgIHVfaiA9IHVfajE7XG4gICAgICAgIHRfaiA9IHRfaiArIGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcmRlciA9PT0gNCkge1xuICAgICAgd2hpbGUgKHRfaiA8PSBwKSB7XG4gICAgICAgIGsxID0gaCAqIGYodF9qLCB1X2opO1xuICAgICAgICBrMiA9IGggKiBmKHRfaiArIGggLyAyLCB1X2ogKyBrMSAvIDIpO1xuICAgICAgICBrMyA9IGggKiBmKHRfaiArIGggLyAyLCB1X2ogKyBrMiAvIDIpO1xuICAgICAgICBrNCA9IGggKiBmKHRfaiAraCwgdV9qICsgazMpO1xuICAgICAgICB1X2oxID0gdV9qICsgKGsxICsgMiAqIGsyICsgMiAqIGszICsgazQpIC8gNjtcbiAgICAgICAgdV9qID0gdV9qMTtcbiAgICAgICAgdF9qID0gdF9qICsgaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVfajtcbiAgfSxcblxuICByb21iZXJnOiBmdW5jdGlvbiByb21iZXJnKGYsIGEsIGIsIG9yZGVyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBoID0gKGIgLSBhKSAvIDI7XG4gICAgdmFyIHggPSBbXTtcbiAgICB2YXIgaDEgPSBbXTtcbiAgICB2YXIgZyA9IFtdO1xuICAgIHZhciBtLCBhMSwgaiwgaywgSSwgZDtcbiAgICB3aGlsZSAoaSA8IG9yZGVyIC8gMikge1xuICAgICAgSSA9IGYoYSk7XG4gICAgICBmb3IgKGogPSBhLCBrID0gMDsgaiA8PSBiOyBqID0gaiArIGgsIGsrKykgeFtrXSA9IGo7XG4gICAgICBtID0geC5sZW5ndGg7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgbSAtIDE7IGorKykge1xuICAgICAgICBJICs9ICgoKGogJSAyKSAhPT0gMCkgPyA0IDogMikgKiBmKHhbal0pO1xuICAgICAgfVxuICAgICAgSSA9IChoIC8gMykgKiAoSSArIGYoYikpO1xuICAgICAgZ1tpXSA9IEk7XG4gICAgICBoIC89IDI7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGExID0gZy5sZW5ndGg7XG4gICAgbSA9IDE7XG4gICAgd2hpbGUgKGExICE9PSAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYTEgLSAxOyBqKyspXG4gICAgICBoMVtqXSA9ICgoTWF0aC5wb3coNCwgbSkpICogZ1tqICsgMV0gLSBnW2pdKSAvIChNYXRoLnBvdyg0LCBtKSAtIDEpO1xuICAgICAgYTEgPSBoMS5sZW5ndGg7XG4gICAgICBnID0gaDE7XG4gICAgICBoMSA9IFtdO1xuICAgICAgbSsrO1xuICAgIH1cbiAgICByZXR1cm4gZztcbiAgfSxcblxuICByaWNoYXJkc29uOiBmdW5jdGlvbiByaWNoYXJkc29uKFgsIGYsIHgsIGgpIHtcbiAgICBmdW5jdGlvbiBwb3MoWCwgeCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIG4gPSBYLmxlbmd0aDtcbiAgICAgIHZhciBwO1xuICAgICAgZm9yICg7IGkgPCBuOyBpKyspXG4gICAgICAgIGlmIChYW2ldID09PSB4KSBwID0gaTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICB2YXIgbiA9IFgubGVuZ3RoLFxuICAgIGhfbWluID0gTWF0aC5hYnMoeCAtIFhbcG9zKFgsIHgpICsgMV0pLFxuICAgIGkgPSAwLFxuICAgIGcgPSBbXSxcbiAgICBoMSA9IFtdLFxuICAgIHkxLCB5MiwgbSwgYSwgajtcbiAgICB3aGlsZSAoaCA+PSBoX21pbikge1xuICAgICAgeTEgPSBwb3MoWCwgeCArIGgpO1xuICAgICAgeTIgPSBwb3MoWCwgeCk7XG4gICAgICBnW2ldID0gKGZbeTFdIC0gMiAqIGZbeTJdICsgZlsyICogeTIgLSB5MV0pIC8gKGggKiBoKTtcbiAgICAgIGggLz0gMjtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgYSA9IGcubGVuZ3RoO1xuICAgIG0gPSAxO1xuICAgIHdoaWxlIChhICE9IDEpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhIC0gMTsgaisrKVxuICAgICAgaDFbal0gPSAoKE1hdGgucG93KDQsIG0pKSAqIGdbaiArIDFdIC0gZ1tqXSkgLyAoTWF0aC5wb3coNCwgbSkgLSAxKTtcbiAgICAgIGEgPSBoMS5sZW5ndGg7XG4gICAgICBnID0gaDE7XG4gICAgICBoMSA9IFtdO1xuICAgICAgbSsrO1xuICAgIH1cbiAgICByZXR1cm4gZztcbiAgfSxcblxuICBzaW1wc29uOiBmdW5jdGlvbiBzaW1wc29uKGYsIGEsIGIsIG4pIHtcbiAgICB2YXIgaCA9IChiIC0gYSkgLyBuO1xuICAgIHZhciBJID0gZihhKTtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHZhciBqID0gYTtcbiAgICB2YXIgayA9IDA7XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBtO1xuICAgIGZvciAoOyBqIDw9IGI7IGogPSBqICsgaCwgaysrKVxuICAgICAgeFtrXSA9IGo7XG4gICAgbSA9IHgubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbSAtIDE7IGkrKykge1xuICAgICAgSSArPSAoKGkgJSAyICE9PSAwKSA/IDQgOiAyKSAqIGYoeFtpXSk7XG4gICAgfVxuICAgIHJldHVybiAoaCAvIDMpICogKEkgKyBmKGIpKTtcbiAgfSxcblxuICBoZXJtaXRlOiBmdW5jdGlvbiBoZXJtaXRlKFgsIEYsIGRGLCB2YWx1ZSkge1xuICAgIHZhciBuID0gWC5sZW5ndGg7XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciBkbCA9IFtdO1xuICAgIHZhciBBID0gW107XG4gICAgdmFyIEIgPSBbXTtcbiAgICB2YXIgajtcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IDE7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpICE9IGopIGxbaV0gKj0gKHZhbHVlIC0gWFtqXSkgLyAoWFtpXSAtIFhbal0pO1xuICAgICAgfVxuICAgICAgZGxbaV0gPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqKSBkbFtpXSArPSAxIC8gKFggW2ldIC0gWFtqXSk7XG4gICAgICB9XG4gICAgICBBW2ldID0gKDEgLSAyICogKHZhbHVlIC0gWFtpXSkgKiBkbFtpXSkgKiAobFtpXSAqIGxbaV0pO1xuICAgICAgQltpXSA9ICh2YWx1ZSAtIFhbaV0pICogKGxbaV0gKiBsW2ldKTtcbiAgICAgIHAgKz0gKEFbaV0gKiBGW2ldICsgQltpXSAqIGRGW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgbGFncmFuZ2U6IGZ1bmN0aW9uIGxhZ3JhbmdlKFgsIEYsIHZhbHVlKSB7XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiwgbDtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsID0gRltpXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgLy8gY2FsY3VsYXRpbmcgdGhlIGxhZ3JhbmdlIHBvbHlub21pYWwgTF9pXG4gICAgICAgIGlmIChpICE9IGopIGwgKj0gKHZhbHVlIC0gWFtqXSkgLyAoWFtpXSAtIFhbal0pO1xuICAgICAgfVxuICAgICAgLy8gYWRkaW5nIHRoZSBsYWdyYW5nZSBwb2x5bm9taWFscyBmb3VuZCBhYm92ZVxuICAgICAgcCArPSBsO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICBjdWJpY19zcGxpbmU6IGZ1bmN0aW9uIGN1YmljX3NwbGluZShYLCBGLCB2YWx1ZSkge1xuICAgIHZhciBuID0gWC5sZW5ndGg7XG4gICAgdmFyIGkgPSAwLCBqO1xuICAgIHZhciBBID0gW107XG4gICAgdmFyIEIgPSBbXTtcbiAgICB2YXIgYWxwaGEgPSBbXTtcbiAgICB2YXIgYyA9IFtdO1xuICAgIHZhciBoID0gW107XG4gICAgdmFyIGIgPSBbXTtcbiAgICB2YXIgZCA9IFtdO1xuICAgIGZvciAoOyBpIDwgbiAtIDE7IGkrKylcbiAgICAgIGhbaV0gPSBYW2kgKyAxXSAtIFhbaV07XG4gICAgYWxwaGFbMF0gPSAwO1xuICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICBhbHBoYVtpXSA9ICgzIC8gaFtpXSkgKiAoRltpICsgMV0gLSBGW2ldKSAtXG4gICAgICAgICAgKDMgLyBoW2ktMV0pICogKEZbaV0gLSBGW2ktMV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgQVtpXSA9IFtdO1xuICAgICAgQltpXSA9IFtdO1xuICAgICAgQVtpXVtpLTFdID0gaFtpLTFdO1xuICAgICAgQVtpXVtpXSA9IDIgKiAoaFtpIC0gMV0gKyBoW2ldKTtcbiAgICAgIEFbaV1baSsxXSA9IGhbaV07XG4gICAgICBCW2ldWzBdID0gYWxwaGFbaV07XG4gICAgfVxuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoQSksIEIpO1xuICAgIGZvciAoaiA9IDA7IGogPCBuIC0gMTsgaisrKSB7XG4gICAgICBiW2pdID0gKEZbaiArIDFdIC0gRltqXSkgLyBoW2pdIC0gaFtqXSAqIChjW2ogKyAxXVswXSArIDIgKiBjW2pdWzBdKSAvIDM7XG4gICAgICBkW2pdID0gKGNbaiArIDFdWzBdIC0gY1tqXVswXSkgLyAoMyAqIGhbal0pO1xuICAgIH1cbiAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoWFtqXSA+IHZhbHVlKSBicmVhaztcbiAgICB9XG4gICAgaiAtPSAxO1xuICAgIHJldHVybiBGW2pdICsgKHZhbHVlIC0gWFtqXSkgKiBiW2pdICsgalN0YXQuc3EodmFsdWUtWFtqXSkgKlxuICAgICAgICBjW2pdICsgKHZhbHVlIC0gWFtqXSkgKiBqU3RhdC5zcSh2YWx1ZSAtIFhbal0pICogZFtqXTtcbiAgfSxcblxuICBnYXVzc19xdWFkcmF0dXJlOiBmdW5jdGlvbiBnYXVzc19xdWFkcmF0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2F1c3NfcXVhZHJhdHVyZSBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgUENBOiBmdW5jdGlvbiBQQ0EoWCkge1xuICAgIHZhciBtID0gWC5sZW5ndGg7XG4gICAgdmFyIG4gPSBYWzBdLmxlbmd0aDtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiwgdGVtcDE7XG4gICAgdmFyIHUgPSBbXTtcbiAgICB2YXIgRCA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgdGVtcDIgPSBbXTtcbiAgICB2YXIgWSA9IFtdO1xuICAgIHZhciBCdCA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIEMgPSBbXTtcbiAgICB2YXIgViA9IFtdO1xuICAgIHZhciBWdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgIHVbaV0gPSBqU3RhdC5zdW0oWFtpXSkgLyBuO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBCW2ldID0gW107XG4gICAgICBmb3IoaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgQltpXVtqXSA9IFhbal1baV0gLSB1W2pdO1xuICAgICAgfVxuICAgIH1cbiAgICBCID0galN0YXQudHJhbnNwb3NlKEIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgIENbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgQ1tpXVtqXSA9IChqU3RhdC5kb3QoW0JbaV1dLCBbQltqXV0pKSAvIChuIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IGpTdGF0LmphY29iaShDKTtcbiAgICBWID0gcmVzdWx0WzBdO1xuICAgIEQgPSByZXN1bHRbMV07XG4gICAgVnQgPSBqU3RhdC50cmFuc3Bvc2UoVik7XG4gICAgZm9yIChpID0gMDsgaSA8IEQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IGk7IGogPCBELmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmKERbaV0gPCBEW2pdKSAge1xuICAgICAgICAgIHRlbXAxID0gRFtpXTtcbiAgICAgICAgICBEW2ldID0gRFtqXTtcbiAgICAgICAgICBEW2pdID0gdGVtcDE7XG4gICAgICAgICAgdGVtcDIgPSBWdFtpXTtcbiAgICAgICAgICBWdFtpXSA9IFZ0W2pdO1xuICAgICAgICAgIFZ0W2pdID0gdGVtcDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgQnQgPSBqU3RhdC50cmFuc3Bvc2UoQik7XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgWVtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IEJ0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIFlbaV1bal0gPSBqU3RhdC5kb3QoW1Z0W2ldXSwgW0J0W2pdXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbWCwgRCwgVnQsIFldO1xuICB9XG59KTtcblxuLy8gZXh0ZW5kIGpTdGF0LmZuIHdpdGggbWV0aG9kcyB0aGF0IHJlcXVpcmUgb25lIGFyZ3VtZW50XG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalN0YXQuZm5bcGFzc2Z1bmNdID0gZnVuY3Rpb24oYXJnLCBmdW5jKSB7XG4gICAgICB2YXIgdG1wdGhpcyA9IHRoaXM7XG4gICAgICAvLyBjaGVjayBmb3IgY2FsbGJhY2tcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHRtcHRoaXMsIGpTdGF0LmZuW3Bhc3NmdW5jXS5jYWxsKHRtcHRoaXMsIGFyZykpO1xuICAgICAgICB9LCAxNSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBqU3RhdFtwYXNzZnVuY10odGhpcywgYXJnKSA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10odGhpcywgYXJnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpKTtcbiAgICB9O1xuICB9KGZ1bmNzW2ldKSk7XG59KCdhZGQgZGl2aWRlIG11bHRpcGx5IHN1YnRyYWN0IGRvdCBwb3cgYWJzIG5vcm0gYW5nbGUnLnNwbGl0KCcgJykpKTtcblxufSh0aGlzLmpTdGF0LCBNYXRoKSk7XG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgaXNOdW1iZXIgPSBqU3RhdC51dGlscy5pc051bWJlcjtcblxuLy8gZmxhZz09dHJ1ZSBkZW5vdGVzIHVzZSBvZiBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4vLyBaIFN0YXRpc3RpY3NcbmpTdGF0LmV4dGVuZCh7XG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtZXRlciBsaXN0czpcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZClcbiAgLy8gKHZhbHVlLCBhcnJheSwgZmxhZylcbiAgenNjb3JlOiBmdW5jdGlvbiB6c2NvcmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKGlzTnVtYmVyKGFyZ3NbMV0pKSB7XG4gICAgICByZXR1cm4gKGFyZ3NbMF0gLSBhcmdzWzFdKSAvIGFyZ3NbMl07XG4gICAgfVxuICAgIHJldHVybiAoYXJnc1swXSAtIGpTdGF0Lm1lYW4oYXJnc1sxXSkpIC8galN0YXQuc3RkZXYoYXJnc1sxXSwgYXJnc1syXSk7XG4gIH0sXG5cbiAgLy8gMyBkaWZmZXJlbnQgcGFyYW10ZXIgbGlzdHM6XG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QsIHNpZGVzKVxuICAvLyAoenNjb3JlLCBzaWRlcylcbiAgLy8gKHZhbHVlLCBhcnJheSwgc2lkZXMsIGZsYWcpXG4gIHp0ZXN0OiBmdW5jdGlvbiB6dGVzdCgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGlmKGlzTnVtYmVyKGFyZ3NbMV0pKSB7XG4gICAgICAgIHZhciB6ID0galN0YXQuenNjb3JlKGFyZ3NbMF0sYXJnc1sxXSxhcmdzWzJdKVxuICAgICAgICByZXR1cm4gKGFyZ3NbM10gPT09IDEpID9cbiAgICAgICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksMCwxKSkgOlxuICAgICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKiAyKTtcbiAgICAgIH1cbiAgICAgIHZhciB6ID0gYXJnc1swXVxuICAgICAgcmV0dXJuIChhcmdzWzJdID09PSAxKSA/XG4gICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKSA6XG4gICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKjIpO1xuICAgIH1cbiAgICB2YXIgeiA9IGpTdGF0LnpzY29yZShhcmdzWzBdLGFyZ3NbMV0sYXJnc1szXSlcbiAgICByZXR1cm4gKGFyZ3NbMV0gPT09IDEpID9cbiAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwgMCwgMSkpIDpcbiAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwgMCwgMSkqMik7XG4gIH1cbn0pO1xuXG5qU3RhdC5leHRlbmQoalN0YXQuZm4sIHtcbiAgenNjb3JlOiBmdW5jdGlvbiB6c2NvcmUodmFsdWUsIGZsYWcpIHtcbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5tZWFuKCkpIC8gdGhpcy5zdGRldihmbGFnKTtcbiAgfSxcblxuICB6dGVzdDogZnVuY3Rpb24genRlc3QodmFsdWUsIHNpZGVzLCBmbGFnKSB7XG4gICAgdmFyIHpzY29yZSA9IE1hdGguYWJzKHRoaXMuenNjb3JlKHZhbHVlLCBmbGFnKSk7XG4gICAgcmV0dXJuIChzaWRlcyA9PT0gMSkgP1xuICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLXpzY29yZSwgMCwgMSkpIDpcbiAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC16c2NvcmUsIDAsIDEpICogMik7XG4gIH1cbn0pO1xuXG4vLyBUIFN0YXRpc3RpY3NcbmpTdGF0LmV4dGVuZCh7XG4gIC8vIDIgcGFyYW1ldGVyIGxpc3RzXG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QsIG4pXG4gIC8vICh2YWx1ZSwgYXJyYXkpXG4gIHRzY29yZTogZnVuY3Rpb24gdHNjb3JlKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHJldHVybiAoYXJncy5sZW5ndGggPT09IDQpID9cbiAgICAgICgoYXJnc1swXSAtIGFyZ3NbMV0pIC8gKGFyZ3NbMl0gLyBNYXRoLnNxcnQoYXJnc1szXSkpKSA6XG4gICAgICAoKGFyZ3NbMF0gLSBqU3RhdC5tZWFuKGFyZ3NbMV0pKSAvXG4gICAgICAgKGpTdGF0LnN0ZGV2KGFyZ3NbMV0sIHRydWUpIC8gTWF0aC5zcXJ0KGFyZ3NbMV0ubGVuZ3RoKSkpO1xuICB9LFxuXG4gIC8vIDMgZGlmZmVyZW50IHBhcmFtdGVyIGxpc3RzOlxuICAvLyAodmFsdWUsIG1lYW4sIHNkLCBuLCBzaWRlcylcbiAgLy8gKHRzY29yZSwgbiwgc2lkZXMpXG4gIC8vICh2YWx1ZSwgYXJyYXksIHNpZGVzKVxuICB0dGVzdDogZnVuY3Rpb24gdHRlc3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHRzY29yZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDUpIHtcbiAgICAgIHRzY29yZSA9IE1hdGguYWJzKGpTdGF0LnRzY29yZShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKSk7XG4gICAgICByZXR1cm4gKGFyZ3NbNF0gPT09IDEpID9cbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzNdLTEpKSA6XG4gICAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1szXS0xKSoyKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGFyZ3NbMV0pKSB7XG4gICAgICB0c2NvcmUgPSBNYXRoLmFicyhhcmdzWzBdKVxuICAgICAgcmV0dXJuIChhcmdzWzJdID09IDEpID9cbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLTEpKSA6XG4gICAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1sxXS0xKSAqIDIpO1xuICAgIH1cbiAgICB0c2NvcmUgPSBNYXRoLmFicyhqU3RhdC50c2NvcmUoYXJnc1swXSwgYXJnc1sxXSkpXG4gICAgcmV0dXJuIChhcmdzWzJdID09IDEpID9cbiAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1sxXS5sZW5ndGgtMSkpIDpcbiAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1sxXS5sZW5ndGgtMSkgKiAyKTtcbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICB0c2NvcmU6IGZ1bmN0aW9uIHRzY29yZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1lYW4oKSkgLyAodGhpcy5zdGRldih0cnVlKSAvIE1hdGguc3FydCh0aGlzLmNvbHMoKSkpO1xuICB9LFxuXG4gIHR0ZXN0OiBmdW5jdGlvbiB0dGVzdCh2YWx1ZSwgc2lkZXMpIHtcbiAgICByZXR1cm4gKHNpZGVzID09PSAxKSA/XG4gICAgICAoMSAtIGpTdGF0LnN0dWRlbnR0LmNkZihNYXRoLmFicyh0aGlzLnRzY29yZSh2YWx1ZSkpLCB0aGlzLmNvbHMoKS0xKSkgOlxuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtTWF0aC5hYnModGhpcy50c2NvcmUodmFsdWUpKSwgdGhpcy5jb2xzKCktMSkqMik7XG4gIH1cbn0pO1xuXG4vLyBGIFN0YXRpc3RpY3NcbmpTdGF0LmV4dGVuZCh7XG4gIC8vIFBhcmFtdGVyIGxpc3QgaXMgYXMgZm9sbG93czpcbiAgLy8gKGFycmF5MSwgYXJyYXkyLCBhcnJheTMsIC4uLilcbiAgLy8gb3IgaXQgaXMgYW4gYXJyYXkgb2YgYXJyYXlzXG4gIC8vIGFycmF5IG9mIGFycmF5cyBjb252ZXJzaW9uXG4gIGFub3ZhZnNjb3JlOiBmdW5jdGlvbiBhbm92YWZzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBleHBWYXIsIHNhbXBsZSwgc2FtcE1lYW4sIHNhbXBTYW1wTWVhbiwgdG1wYXJncywgdW5leHBWYXIsIGksIGo7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICB0bXBhcmdzID0gbmV3IEFycmF5KGFyZ3NbMF0ubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRtcGFyZ3NbaV0gPSBhcmdzWzBdW2ldO1xuICAgICAgfVxuICAgICAgYXJncyA9IHRtcGFyZ3M7XG4gICAgfVxuICAgIC8vIDIgc2FtcGxlIGNhc2VcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiBqU3RhdC52YXJpYW5jZShhcmdzWzBdKSAvIGpTdGF0LnZhcmlhbmNlKGFyZ3NbMV0pO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgc2FtcGxlIGFycmF5XG4gICAgc2FtcGxlID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZS5jb25jYXQoYXJnc1tpXSk7XG4gICAgfVxuICAgIHNhbXBNZWFuID0galN0YXQubWVhbihzYW1wbGUpO1xuICAgIC8vIENvbXB1dGVzIHRoZSBleHBsYWluZWQgdmFyaWFuY2VcbiAgICBleHBWYXIgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHBWYXIgPSBleHBWYXIgKyBhcmdzW2ldLmxlbmd0aCAqIE1hdGgucG93KGpTdGF0Lm1lYW4oYXJnc1tpXSkgLSBzYW1wTWVhbiwgMik7XG4gICAgfVxuICAgIGV4cFZhciAvPSAoYXJncy5sZW5ndGggLSAxKTtcbiAgICAvLyBDb21wdXRlcyB1bmV4cGxhaW5lZCB2YXJpYW5jZVxuICAgIHVuZXhwVmFyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgc2FtcFNhbXBNZWFuID0galN0YXQubWVhbihhcmdzW2ldKTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhcmdzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVuZXhwVmFyICs9IE1hdGgucG93KGFyZ3NbaV1bal0gLSBzYW1wU2FtcE1lYW4sIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bmV4cFZhciAvPSAoc2FtcGxlLmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICByZXR1cm4gZXhwVmFyIC8gdW5leHBWYXI7XG4gIH0sXG5cbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW10ZXIgc2V0dXBzXG4gIC8vIChhcnJheTEsIGFycmF5MiwgYXJyYXkzLCAuLi4pXG4gIC8vIChhbm92YWZzY29yZSwgZGYxLCBkZjIpXG4gIGFub3ZhZnRlc3Q6IGZ1bmN0aW9uIGFub3ZhZnRlc3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgZGYxLCBkZjIsIG4sIGk7XG4gICAgaWYgKGlzTnVtYmVyKGFyZ3NbMF0pKSB7XG4gICAgICByZXR1cm4gMSAtIGpTdGF0LmNlbnRyYWxGLmNkZihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgYW5vdmFmc2NvcmUgPSBqU3RhdC5hbm92YWZzY29yZShhcmdzKTtcbiAgICBkZjEgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgbiA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBuICsgYXJnc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIGRmMiA9IG4gLSBkZjEgLSAxO1xuICAgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKGFub3ZhZnNjb3JlLCBkZjEsIGRmMik7XG4gIH0sXG5cbiAgZnRlc3Q6IGZ1bmN0aW9uIGZ0ZXN0KGZzY29yZSwgZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gMSAtIGpTdGF0LmNlbnRyYWxGLmNkZihmc2NvcmUsIGRmMSwgZGYyKTtcbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICBhbm92YWZzY29yZTogZnVuY3Rpb24gYW5vdmFmc2NvcmUoKSB7XG4gICAgcmV0dXJuIGpTdGF0LmFub3ZhZnNjb3JlKHRoaXMudG9BcnJheSgpKTtcbiAgfSxcblxuICBhbm92YWZ0ZXM6IGZ1bmN0aW9uIGFub3ZhZnRlcygpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBuICsgdGhpc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5mdGVzdCh0aGlzLmFub3ZhZnNjb3JlKCksIHRoaXMubGVuZ3RoIC0gMSwgbiAtIHRoaXMubGVuZ3RoKTtcbiAgfVxufSk7XG5cbi8vIEVycm9yIEJvdW5kc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIHNldHVwc1xuICAvLyAodmFsdWUsIGFscGhhLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhbHBoYSwgYXJyYXkpXG4gIG5vcm1hbGNpOiBmdW5jdGlvbiBub3JtYWxjaSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBhbnMgPSBuZXcgQXJyYXkoMiksXG4gICAgY2hhbmdlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQubm9ybWFsLmludihhcmdzWzFdIC8gMiwgMCwgMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZSA9IE1hdGguYWJzKGpTdGF0Lm5vcm1hbC5pbnYoYXJnc1sxXSAvIDIsIDAsIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LnN0ZGV2KGFyZ3NbMl0pIC8gTWF0aC5zcXJ0KGFyZ3NbMl0ubGVuZ3RoKSk7XG4gICAgfVxuICAgIGFuc1swXSA9IGFyZ3NbMF0gLSBjaGFuZ2U7XG4gICAgYW5zWzFdID0gYXJnc1swXSArIGNoYW5nZTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtZXRlciBzZXR1cHNcbiAgLy8gKHZhbHVlLCBhbHBoYSwgc2QsIG4pXG4gIC8vICh2YWx1ZSwgYWxwaGEsIGFycmF5KVxuICB0Y2k6IGZ1bmN0aW9uIHRjaSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBhbnMgPSBuZXcgQXJyYXkoMiksXG4gICAgY2hhbmdlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQuc3R1ZGVudHQuaW52KGFyZ3NbMV0gLyAyLCBhcmdzWzNdIC0gMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZSA9IE1hdGguYWJzKGpTdGF0LnN0dWRlbnR0LmludihhcmdzWzFdIC8gMiwgYXJnc1syXS5sZW5ndGggLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5zdGRldihhcmdzWzJdLCB0cnVlKSAvIE1hdGguc3FydChhcmdzWzJdLmxlbmd0aCkpO1xuICAgIH1cbiAgICBhbnNbMF0gPSBhcmdzWzBdIC0gY2hhbmdlO1xuICAgIGFuc1sxXSA9IGFyZ3NbMF0gKyBjaGFuZ2U7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBzaWduaWZpY2FudDogZnVuY3Rpb24gc2lnbmlmaWNhbnQocHZhbHVlLCBhbHBoYSkge1xuICAgIHJldHVybiBwdmFsdWUgPCBhbHBoYTtcbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICBub3JtYWxjaTogZnVuY3Rpb24gbm9ybWFsY2kodmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm5vcm1hbGNpKHZhbHVlLCBhbHBoYSwgdGhpcy50b0FycmF5KCkpO1xuICB9LFxuXG4gIHRjaTogZnVuY3Rpb24gdGNpKHZhbHVlLCBhbHBoYSkge1xuICAgIHJldHVybiBqU3RhdC50Y2kodmFsdWUsIGFscGhhLCB0aGlzLnRvQXJyYXkoKSk7XG4gIH1cbn0pO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbiIsIi8qIVxuICogbnVtZXJhbC5qc1xuICogdmVyc2lvbiA6IDEuNS4zXG4gKiBhdXRob3IgOiBBZGFtIERyYXBlclxuICogbGljZW5zZSA6IE1JVFxuICogaHR0cDovL2FkYW13ZHJhcGVyLmdpdGh1Yi5jb20vTnVtZXJhbC1qcy9cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbnVtZXJhbCxcbiAgICAgICAgVkVSU0lPTiA9ICcxLjUuMycsXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxhbmd1YWdlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsYW5ndWFnZXMgPSB7fSxcbiAgICAgICAgY3VycmVudExhbmd1YWdlID0gJ2VuJyxcbiAgICAgICAgemVyb0Zvcm1hdCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSAnMCwwJyxcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5vZGVKU1xuICAgICAgICBoYXNNb2R1bGUgPSAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbCAobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICpcbiAgICAgKiBGaXhlcyBiaW5hcnkgcm91bmRpbmcgaXNzdWVzIChlZy4gKDAuNjE1KS50b0ZpeGVkKDIpID09PSAnMC42MScpIHRoYXQgcHJlc2VudFxuICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRml4ZWQgKHZhbHVlLCBwcmVjaXNpb24sIHJvdW5kaW5nRnVuY3Rpb24sIG9wdGlvbmFscykge1xuICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCxcbiAgICAgICAgICAgIG91dHB1dDtcbiAgICAgICAgICAgIFxuICAgICAgICAvL3JvdW5kaW5nRnVuY3Rpb24gPSAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmQpO1xuICAgICAgICAvLyBNdWx0aXBseSB1cCBieSBwcmVjaXNpb24sIHJvdW5kIGFjY3VyYXRlbHksIHRoZW4gZGl2aWRlIGFuZCB1c2UgbmF0aXZlIHRvRml4ZWQoKTpcbiAgICAgICAgb3V0cHV0ID0gKHJvdW5kaW5nRnVuY3Rpb24odmFsdWUgKiBwb3dlcikgLyBwb3dlcikudG9GaXhlZChwcmVjaXNpb24pO1xuXG4gICAgICAgIGlmIChvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCA9IG5ldyBSZWdFeHAoJzB7MSwnICsgb3B0aW9uYWxzICsgJ30kJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShvcHRpb25hbHNSZWdFeHAsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGb3JtYXR0aW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgdHlwZSBvZiBmb3JtYXR0aW5nIHdlIG5lZWQgdG8gZG9cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1lcmFsIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG91dHB1dDtcblxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQga2luZCBvZiBmb3JtYXQgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyQnKSA+IC0xKSB7IC8vIGN1cnJlbmN5ISEhISFcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEN1cnJlbmN5KG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyUnKSA+IC0xKSB7IC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFBlcmNlbnRhZ2UobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignOicpID4gLTEpIHsgLy8gdGltZVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0VGltZShuLCBmb3JtYXQpO1xuICAgICAgICB9IGVsc2UgeyAvLyBwbGFpbiBvbCcgbnVtYmVycyBvciBieXRlc1xuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKG4uX3ZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHN0cmluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8vIHJldmVydCB0byBudW1iZXJcbiAgICBmdW5jdGlvbiB1bmZvcm1hdE51bWVyYWwgKG4sIHN0cmluZykge1xuICAgICAgICB2YXIgc3RyaW5nT3JpZ2luYWwgPSBzdHJpbmcsXG4gICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCxcbiAgICAgICAgICAgIG1pbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBiaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgdHJpbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBzdWZmaXhlcyA9IFsnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IGZhbHNlLFxuICAgICAgICAgICAgcG93ZXI7XG5cbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgbi5fdmFsdWUgPSB1bmZvcm1hdFRpbWUoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT09IHplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csJycpLnJlcGxhY2UobGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsLCAnLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb25zIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICBtaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgYmlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIHRyaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGJ5dGVzIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IChzdHJpbmcuaW5kZXhPZihzdWZmaXhlc1twb3dlcl0pID4gLTEpID8gTWF0aC5wb3coMTAyNCwgcG93ZXIgKyAxKSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlc011bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZSBtYXRoIHRvIGNyZWF0ZSBvdXIgbnVtYmVyXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoKGJ5dGVzTXVsdGlwbGllcikgPyBieXRlc011bHRpcGxpZXIgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2godGhvdXNhbmRSZWdFeHApKSA/IE1hdGgucG93KDEwLCAzKSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaChtaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgNikgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2goYmlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDkpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKHRyaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgMTIpIDogMSkgKiAoKHN0cmluZy5pbmRleE9mKCclJykgPiAtMSkgPyAwLjAxIDogMSkgKiAoKChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGgtMSwgc3RyaW5nLnNwbGl0KCcpJykubGVuZ3RoLTEpKSAlIDIpPyAxOiAtMSkgKiBOdW1iZXIoc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHJvdW5kIGlmIHdlIGFyZSB0YWxraW5nIGFib3V0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoYnl0ZXNNdWx0aXBsaWVyKSA/IE1hdGguY2VpbChuLl92YWx1ZSkgOiBuLl92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5fdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3kgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3ltYm9sSW5kZXggPSBmb3JtYXQuaW5kZXhPZignJCcpLFxuICAgICAgICAgICAgb3BlblBhcmVuSW5kZXggPSBmb3JtYXQuaW5kZXhPZignKCcpLFxuICAgICAgICAgICAgbWludXNTaWduSW5kZXggPSBmb3JtYXQuaW5kZXhPZignLScpLFxuICAgICAgICAgICAgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIHNwbGljZUluZGV4LFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgb3IgYWZ0ZXIgY3VycmVuY3lcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJCcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAkJywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCckICcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQgJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgdGhlIG51bWJlclxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIobi5fdmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5bWJvbFxuICAgICAgICBpZiAoc3ltYm9sSW5kZXggPD0gMSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcoJykgPiAtMSB8fCBvdXRwdXQuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sSW5kZXggPCBvcGVuUGFyZW5JbmRleCB8fCBzeW1ib2xJbmRleCA8IG1pbnVzU2lnbkluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bWJvbCBhcHBlYXJzIGJlZm9yZSB0aGUgXCIoXCIgb3IgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKHNwbGljZUluZGV4LCAwLCBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSArIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJjZW50YWdlIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNwYWNlID0gJycsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB2YWx1ZSA9IG4uX3ZhbHVlICogMTAwO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgJVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyAlJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICUnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEgKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyAnJScpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgc3BhY2UgKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWUgKG4pIHtcbiAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihuLl92YWx1ZS82MC82MCksXG4gICAgICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcigobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSkvNjApLFxuICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgucm91bmQobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW51dGVzICogNjApKTtcbiAgICAgICAgcmV0dXJuIGhvdXJzICsgJzonICsgKChtaW51dGVzIDwgMTApID8gJzAnICsgbWludXRlcyA6IG1pbnV0ZXMpICsgJzonICsgKChzZWNvbmRzIDwgMTApID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZm9ybWF0VGltZSAoc3RyaW5nKSB7XG4gICAgICAgIHZhciB0aW1lQXJyYXkgPSBzdHJpbmcuc3BsaXQoJzonKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSAwO1xuICAgICAgICAvLyB0dXJuIGhvdXJzIGFuZCBtaW51dGVzIGludG8gc2Vjb25kcyBhbmQgYWRkIHRoZW0gYWxsIHVwXG4gICAgICAgIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVswXSkgKiA2MCAqIDYwKTtcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMV0pICogNjApO1xuICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzJdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwKTtcbiAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgTnVtYmVyKHRpbWVBcnJheVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIgKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG5lZ1AgPSBmYWxzZSxcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlLFxuICAgICAgICAgICAgb3B0RGVjID0gZmFsc2UsXG4gICAgICAgICAgICBhYmJyID0gJycsXG4gICAgICAgICAgICBhYmJySyA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdGhvdXNhbmRzXG4gICAgICAgICAgICBhYmJyTSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gbWlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJCID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBiaWxsaW9uc1xuICAgICAgICAgICAgYWJiclQgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRyaWxsaW9uc1xuICAgICAgICAgICAgYWJickZvcmNlID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgYnl0ZXMgPSAnJyxcbiAgICAgICAgICAgIG9yZCA9ICcnLFxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpLFxuICAgICAgICAgICAgc3VmZml4ZXMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgIHRob3VzYW5kcyxcbiAgICAgICAgICAgIGQgPSAnJyxcbiAgICAgICAgICAgIG5lZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIG51bWJlciBpcyB6ZXJvIGFuZCBhIGN1c3RvbSB6ZXJvIGZvcm1hdCBoYXMgYmVlbiBzZXRcbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHplcm9Gb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRm9ybWF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIHNob3VsZCB1c2UgcGFyZW50aGVzZXMgZm9yIG5lZ2F0aXZlIG51bWJlciBvciBpZiB3ZSBzaG91bGQgcHJlZml4IHdpdGggYSBzaWduXG4gICAgICAgICAgICAvLyBpZiBib3RoIGFyZSBwcmVzZW50IHdlIGRlZmF1bHQgdG8gcGFyZW50aGVzZXNcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignKycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXCsvZywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgYWJicmV2aWF0aW9uIGlzIHdhbnRlZFxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdhJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFiYnJldmlhdGlvbiBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICBhYmJySyA9IGZvcm1hdC5pbmRleE9mKCdhSycpID49IDA7XG4gICAgICAgICAgICAgICAgYWJick0gPSBmb3JtYXQuaW5kZXhPZignYU0nKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJCID0gZm9ybWF0LmluZGV4T2YoJ2FCJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyVCA9IGZvcm1hdC5pbmRleE9mKCdhVCcpID49IDA7XG4gICAgICAgICAgICAgICAgYWJickZvcmNlID0gYWJicksgfHwgYWJick0gfHwgYWJickIgfHwgYWJiclQ7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGEnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYScsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnYScsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWJzID49IE1hdGgucG93KDEwLCAxMikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgMTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDEyKSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDkpICYmICFhYmJyRm9yY2UgfHwgYWJickIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMuYmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA5KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDYpICYmICFhYmJyRm9yY2UgfHwgYWJick0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA2KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDMpICYmICFhYmJyRm9yY2UgfHwgYWJickspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIGFyZSBmb3JtYXR0aW5nIGJ5dGVzXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2InKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGInKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGInLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2InLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChwb3dlciA9IDA7IHBvd2VyIDw9IHN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLnBvdygxMDI0LCBwb3dlcik7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KDEwMjQsIHBvd2VyKzEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMgKyBzdWZmaXhlc1twb3dlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIG9yZGluYWwgaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ28nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIG8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBvJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdvJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9yZCA9IG9yZCArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLm9yZGluYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ1suXScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHREZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdbLl0nLCAnLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gZm9ybWF0LnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICB0aG91c2FuZHMgPSBmb3JtYXQuaW5kZXhPZignLCcpO1xuXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbi5pbmRleE9mKCdbJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnNwbGl0KCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0b0ZpeGVkKHZhbHVlLCAocHJlY2lzaW9uWzBdLmxlbmd0aCArIHByZWNpc2lvblsxXS5sZW5ndGgpLCByb3VuZGluZ0Z1bmN0aW9uLCBwcmVjaXNpb25bMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uLmxlbmd0aCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdyA9IGQuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChkLnNwbGl0KCcuJylbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgKyBkLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHREZWMgJiYgTnVtYmVyKGQuc2xpY2UoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSB0b0ZpeGVkKHZhbHVlLCBudWxsLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9ybWF0IG51bWJlclxuICAgICAgICAgICAgaWYgKHcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBuZWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhvdXNhbmRzID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy50b1N0cmluZygpLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJyQxJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoKG5lZ1AgJiYgbmVnKSA/ICcoJyA6ICcnKSArICgoIW5lZ1AgJiYgbmVnKSA/ICctJyA6ICcnKSArICgoIW5lZyAmJiBzaWduZWQpID8gJysnIDogJycpICsgdyArIGQgKyAoKG9yZCkgPyBvcmQgOiAnJykgKyAoKGFiYnIpID8gYWJiciA6ICcnKSArICgoYnl0ZXMpID8gYnl0ZXMgOiAnJykgKyAoKG5lZ1AgJiYgbmVnKSA/ICcpJyA6ICcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVG9wIExldmVsIEZ1bmN0aW9uc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKG51bWVyYWwuaXNOdW1lcmFsKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAwIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBudW1lcmFsLmZuLnVuZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTnVtZXJhbChOdW1iZXIoaW5wdXQpKTtcbiAgICB9O1xuXG4gICAgLy8gdmVyc2lvbiBudW1iZXJcbiAgICBudW1lcmFsLnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gY29tcGFyZSBudW1lcmFsIG9iamVjdFxuICAgIG51bWVyYWwuaXNOdW1lcmFsID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbGFuZ3VhZ2VzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxhbmd1YWdlIGtleS5cbiAgICBudW1lcmFsLmxhbmd1YWdlID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudExhbmd1YWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSAmJiAhdmFsdWVzKSB7XG4gICAgICAgICAgICBpZighbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMgfHwgIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGxhbmd1YWdlIGRhdGEuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAvLyBnbG9iYWwgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgIG51bWVyYWwubGFuZ3VhZ2VEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1trZXldO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmxhbmd1YWdlKCdlbicsIHtcbiAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgICAgICBkZWNpbWFsOiAnLidcbiAgICAgICAgfSxcbiAgICAgICAgYWJicmV2aWF0aW9uczoge1xuICAgICAgICAgICAgdGhvdXNhbmQ6ICdrJyxcbiAgICAgICAgICAgIG1pbGxpb246ICdtJyxcbiAgICAgICAgICAgIGJpbGxpb246ICdiJyxcbiAgICAgICAgICAgIHRyaWxsaW9uOiAndCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgIHJldHVybiAofn4gKG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVuY3k6IHtcbiAgICAgICAgICAgIHN5bWJvbDogJyQnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG51bWVyYWwuemVyb0Zvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgemVyb0Zvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6IG51bGw7XG4gICAgfTtcblxuICAgIG51bWVyYWwuZGVmYXVsdEZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6ICcwLjAnO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgbGFuZ3VhZ2VzW2tleV0gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGbG9hdGluZy1wb2ludCBoZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gVGhlIGZsb2F0aW5nLXBvaW50IGhlbHBlciBmdW5jdGlvbnMgYW5kIGltcGxlbWVudGF0aW9uXG4gICAgLy8gYm9ycm93cyBoZWF2aWx5IGZyb20gc2luZnVsLmpzOiBodHRwOi8vZ3VpcG4uZ2l0aHViLmlvL3NpbmZ1bC5qcy9cblxuICAgIC8qKlxuICAgICAqIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L1JlZHVjZSNDb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMgfHwgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIG1vbWVudCBhbGwgbW9kZXJuIGJyb3dzZXJzLCB0aGF0IHN1cHBvcnQgc3RyaWN0IG1vZGUsIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZS4gRm9yIGluc3RhbmNlLCBJRThcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBzbyB0aGlzIGNoZWNrIGlzIGFjdHVhbGx5IHVzZWxlc3MuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0X2luaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGxlbmd0aCA+IGluZGV4OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbXVsdGlwbGllciBuZWNlc3NhcnkgdG8gbWFrZSB4ID49IDEsXG4gICAgICogZWZmZWN0aXZlbHkgZWxpbWluYXRpbmcgbWlzY2FsY3VsYXRpb25zIGNhdXNlZCBieVxuICAgICAqIGZpbml0ZSBwcmVjaXNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbGllcih4KSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBwYXJ0c1sxXS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgcmV0dXJucyB0aGUgbWF4aW11bVxuICAgICAqIG11bHRpcGxpZXIgdGhhdCBtdXN0IGJlIHVzZWQgdG8gbm9ybWFsaXplIGFuIG9wZXJhdGlvbiBpbnZvbHZpbmdcbiAgICAgKiBhbGwgb2YgdGhlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3JyZWN0aW9uRmFjdG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICAgICAgdmFyIG1wID0gbXVsdGlwbGllcihwcmV2KSxcbiAgICAgICAgICAgICAgICBtbiA9IG11bHRpcGxpZXIobmV4dCk7XG4gICAgICAgIHJldHVybiBtcCA+IG1uID8gbXAgOiBtbjtcbiAgICAgICAgfSwgLUluZmluaXR5KTtcbiAgICB9ICAgICAgICBcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgbnVtZXJhbC5mbiA9IE51bWVyYWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nLCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtZXJhbCh0aGlzLCBcbiAgICAgICAgICAgICAgICAgIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0LCBcbiAgICAgICAgICAgICAgICAgIChyb3VuZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bmZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dFN0cmluZykgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7IFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZzsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5mb3JtYXROdW1lcmFsKHRoaXMsIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgY29yckZhY3RvciAqIGN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMCkgLyBjb3JyRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBjb3JyRmFjdG9yICogY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3ZhbHVlXS5yZWR1Y2UoY2JhY2ssIHRoaXMuX3ZhbHVlICogY29yckZhY3RvcikgLyBjb3JyRmFjdG9yOyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbHkgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvXG4gICAgICAgICAgICAgICAgICAgIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXZpZGUgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpIC8gKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpZmZlcmVuY2UgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEV4cG9zaW5nIE51bWVyYWxcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBDb21tb25KUyBtb2R1bGUgaXMgZGVmaW5lZFxuICAgIGlmIChoYXNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBudW1lcmFsO1xuICAgIH1cblxuICAgIC8qZ2xvYmFsIGVuZGVyOmZhbHNlICovXG4gICAgaWYgKHR5cGVvZiBlbmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gaGVyZSwgYHRoaXNgIG1lYW5zIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFkZCBgbnVtZXJhbGAgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAgICAgICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciAnYWR2YW5jZWQnIG1vZGVcbiAgICAgICAgdGhpc1snbnVtZXJhbCddID0gbnVtZXJhbDtcbiAgICB9XG5cbiAgICAvKmdsb2JhbCBkZWZpbmU6ZmFsc2UgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG51bWVyaWMgPSAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIpPyhmdW5jdGlvbiBudW1lcmljKCkge30pOihleHBvcnRzKTtcbmlmKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHsgZ2xvYmFsLm51bWVyaWMgPSBudW1lcmljOyB9XG5cbm51bWVyaWMudmVyc2lvbiA9IFwiMS4yLjZcIjtcblxuLy8gMS4gVXRpbGl0eSBmdW5jdGlvbnNcbm51bWVyaWMuYmVuY2ggPSBmdW5jdGlvbiBiZW5jaCAoZixpbnRlcnZhbCkge1xuICAgIHZhciB0MSx0MixuLGk7XG4gICAgaWYodHlwZW9mIGludGVydmFsID09PSBcInVuZGVmaW5lZFwiKSB7IGludGVydmFsID0gMTU7IH1cbiAgICBuID0gMC41O1xuICAgIHQxID0gbmV3IERhdGUoKTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIG4qPTI7XG4gICAgICAgIGZvcihpPW47aT4zO2ktPTQpIHsgZigpOyBmKCk7IGYoKTsgZigpOyB9XG4gICAgICAgIHdoaWxlKGk+MCkgeyBmKCk7IGktLTsgfVxuICAgICAgICB0MiA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmKHQyLXQxID4gaW50ZXJ2YWwpIGJyZWFrO1xuICAgIH1cbiAgICBmb3IoaT1uO2k+MztpLT00KSB7IGYoKTsgZigpOyBmKCk7IGYoKTsgfVxuICAgIHdoaWxlKGk+MCkgeyBmKCk7IGktLTsgfVxuICAgIHQyID0gbmV3IERhdGUoKTtcbiAgICByZXR1cm4gMTAwMCooMypuLTEpLyh0Mi10MSk7XG59XG5cbm51bWVyaWMuX215SW5kZXhPZiA9IChmdW5jdGlvbiBfbXlJbmRleE9mKHcpIHtcbiAgICB2YXIgbiA9IHRoaXMubGVuZ3RoLGs7XG4gICAgZm9yKGs9MDtrPG47KytrKSBpZih0aGlzW2tdPT09dykgcmV0dXJuIGs7XG4gICAgcmV0dXJuIC0xO1xufSk7XG5udW1lcmljLm15SW5kZXhPZiA9IChBcnJheS5wcm90b3R5cGUuaW5kZXhPZik/QXJyYXkucHJvdG90eXBlLmluZGV4T2Y6bnVtZXJpYy5fbXlJbmRleE9mO1xuXG5udW1lcmljLkZ1bmN0aW9uID0gRnVuY3Rpb247XG5udW1lcmljLnByZWNpc2lvbiA9IDQ7XG5udW1lcmljLmxhcmdlQXJyYXkgPSA1MDtcblxubnVtZXJpYy5wcmV0dHlQcmludCA9IGZ1bmN0aW9uIHByZXR0eVByaW50KHgpIHtcbiAgICBmdW5jdGlvbiBmbXRudW0oeCkge1xuICAgICAgICBpZih4ID09PSAwKSB7IHJldHVybiAnMCc7IH1cbiAgICAgICAgaWYoaXNOYU4oeCkpIHsgcmV0dXJuICdOYU4nOyB9XG4gICAgICAgIGlmKHg8MCkgeyByZXR1cm4gJy0nK2ZtdG51bSgteCk7IH1cbiAgICAgICAgaWYoaXNGaW5pdGUoeCkpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGguZmxvb3IoTWF0aC5sb2coeCkgLyBNYXRoLmxvZygxMCkpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB4IC8gTWF0aC5wb3coMTAsc2NhbGUpO1xuICAgICAgICAgICAgdmFyIGJhc2ljID0gbm9ybWFsaXplZC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7XG4gICAgICAgICAgICBpZihwYXJzZUZsb2F0KGJhc2ljKSA9PT0gMTApIHsgc2NhbGUrKzsgbm9ybWFsaXplZCA9IDE7IGJhc2ljID0gbm9ybWFsaXplZC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGJhc2ljKS50b1N0cmluZygpKydlJytzY2FsZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnSW5maW5pdHknO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gW107XG4gICAgZnVuY3Rpb24gZm9vKHgpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldC5wdXNoKEFycmF5KG51bWVyaWMucHJlY2lzaW9uKzgpLmpvaW4oJyAnKSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikgeyByZXQucHVzaCgnXCInK3grJ1wiJyk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJib29sZWFuXCIpIHsgcmV0LnB1c2goeC50b1N0cmluZygpKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGZtdG51bSh4KTtcbiAgICAgICAgICAgIHZhciBiID0geC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7XG4gICAgICAgICAgICB2YXIgYyA9IHBhcnNlRmxvYXQoeC50b1N0cmluZygpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGQgPSBbYSxiLGMscGFyc2VGbG9hdChiKS50b1N0cmluZygpLHBhcnNlRmxvYXQoYykudG9TdHJpbmcoKV07XG4gICAgICAgICAgICBmb3Ioaz0xO2s8ZC5sZW5ndGg7aysrKSB7IGlmKGRba10ubGVuZ3RoIDwgYS5sZW5ndGgpIGEgPSBkW2tdOyB9XG4gICAgICAgICAgICByZXQucHVzaChBcnJheShudW1lcmljLnByZWNpc2lvbis4LWEubGVuZ3RoKS5qb2luKCcgJykrYSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCA9PT0gbnVsbCkgeyByZXQucHVzaChcIm51bGxcIik7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSB7IFxuICAgICAgICAgICAgcmV0LnB1c2goeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IoayBpbiB4KSB7IGlmKHguaGFzT3duUHJvcGVydHkoaykpIHsgXG4gICAgICAgICAgICAgICAgaWYoZmxhZykgcmV0LnB1c2goJyxcXG4nKTtcbiAgICAgICAgICAgICAgICBlbHNlIHJldC5wdXNoKCdcXG57Jyk7XG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7IFxuICAgICAgICAgICAgICAgIHJldC5wdXNoKGspOyBcbiAgICAgICAgICAgICAgICByZXQucHVzaCgnOiBcXG4nKTsgXG4gICAgICAgICAgICAgICAgZm9vKHhba10pOyBcbiAgICAgICAgICAgIH0gfVxuICAgICAgICAgICAgaWYoZmxhZykgcmV0LnB1c2goJ31cXG4nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYoeC5sZW5ndGggPiBudW1lcmljLmxhcmdlQXJyYXkpIHsgcmV0LnB1c2goJy4uLkxhcmdlIEFycmF5Li4uJyk7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0LnB1c2goJ1snKTtcbiAgICAgICAgICAgIGZvcihrPTA7azx4Lmxlbmd0aDtrKyspIHsgaWYoaz4wKSB7IHJldC5wdXNoKCcsJyk7IGlmKGZsYWcpIHJldC5wdXNoKCdcXG4gJyk7IH0gZmxhZyA9IGZvbyh4W2tdKTsgfVxuICAgICAgICAgICAgcmV0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldC5wdXNoKCd7Jyk7XG4gICAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvcihrIGluIHgpIHsgaWYoeC5oYXNPd25Qcm9wZXJ0eShrKSkgeyBpZihmbGFnKSByZXQucHVzaCgnLFxcbicpOyBmbGFnID0gdHJ1ZTsgcmV0LnB1c2goayk7IHJldC5wdXNoKCc6IFxcbicpOyBmb28oeFtrXSk7IH0gfVxuICAgICAgICByZXQucHVzaCgnfScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9vKHgpO1xuICAgIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbm51bWVyaWMucGFyc2VEYXRlID0gZnVuY3Rpb24gcGFyc2VEYXRlKGQpIHtcbiAgICBmdW5jdGlvbiBmb28oZCkge1xuICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIERhdGUucGFyc2UoZC5yZXBsYWNlKC8tL2csJy8nKSk7IH1cbiAgICAgICAgaWYoIShkIGluc3RhbmNlb2YgQXJyYXkpKSB7IHRocm93IG5ldyBFcnJvcihcInBhcnNlRGF0ZTogcGFyYW1ldGVyIG11c3QgYmUgYXJyYXlzIG9mIHN0cmluZ3NcIik7IH1cbiAgICAgICAgdmFyIHJldCA9IFtdLGs7XG4gICAgICAgIGZvcihrPTA7azxkLmxlbmd0aDtrKyspIHsgcmV0W2tdID0gZm9vKGRba10pOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBmb28oZCk7XG59XG5cbm51bWVyaWMucGFyc2VGbG9hdCA9IGZ1bmN0aW9uIHBhcnNlRmxvYXRfKGQpIHtcbiAgICBmdW5jdGlvbiBmb28oZCkge1xuICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHBhcnNlRmxvYXQoZCk7IH1cbiAgICAgICAgaWYoIShkIGluc3RhbmNlb2YgQXJyYXkpKSB7IHRocm93IG5ldyBFcnJvcihcInBhcnNlRmxvYXQ6IHBhcmFtZXRlciBtdXN0IGJlIGFycmF5cyBvZiBzdHJpbmdzXCIpOyB9XG4gICAgICAgIHZhciByZXQgPSBbXSxrO1xuICAgICAgICBmb3Ioaz0wO2s8ZC5sZW5ndGg7aysrKSB7IHJldFtrXSA9IGZvbyhkW2tdKTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gZm9vKGQpO1xufVxuXG5udW1lcmljLnBhcnNlQ1NWID0gZnVuY3Rpb24gcGFyc2VDU1YodCkge1xuICAgIHZhciBmb28gPSB0LnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgaixrO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgcGF0ID0gLygoW14nXCIsXSopfCgnW14nXSonKXwoXCJbXlwiXSpcIikpLC9nO1xuICAgIHZhciBwYXRudW0gPSAvXlxccyooKFsrLV0/WzAtOV0rKFxcLlswLTldKik/KGVbKy1dP1swLTldKyk/KXwoWystXT9bMC05XSooXFwuWzAtOV0rKT8oZVsrLV0/WzAtOV0rKT8pKVxccyokLztcbiAgICB2YXIgc3RyaXBwZXIgPSBmdW5jdGlvbihuKSB7IHJldHVybiBuLnN1YnN0cigwLG4ubGVuZ3RoLTEpOyB9XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3Ioaz0wO2s8Zm9vLmxlbmd0aDtrKyspIHtcbiAgICAgIHZhciBiYXIgPSAoZm9vW2tdK1wiLFwiKS5tYXRjaChwYXQpLGJhejtcbiAgICAgIGlmKGJhci5sZW5ndGg+MCkge1xuICAgICAgICAgIHJldFtjb3VudF0gPSBbXTtcbiAgICAgICAgICBmb3Ioaj0wO2o8YmFyLmxlbmd0aDtqKyspIHtcbiAgICAgICAgICAgICAgYmF6ID0gc3RyaXBwZXIoYmFyW2pdKTtcbiAgICAgICAgICAgICAgaWYocGF0bnVtLnRlc3QoYmF6KSkgeyByZXRbY291bnRdW2pdID0gcGFyc2VGbG9hdChiYXopOyB9XG4gICAgICAgICAgICAgIGVsc2UgcmV0W2NvdW50XVtqXSA9IGJhejtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy50b0NTViA9IGZ1bmN0aW9uIHRvQ1NWKEEpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKEEpO1xuICAgIHZhciBpLGosbSxuLHJvdyxyZXQ7XG4gICAgbSA9IHNbMF07XG4gICAgbiA9IHNbMV07XG4gICAgcmV0ID0gW107XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIHJvdyA9IFtdO1xuICAgICAgICBmb3Ioaj0wO2o8bTtqKyspIHsgcm93W2pdID0gQVtpXVtqXS50b1N0cmluZygpOyB9XG4gICAgICAgIHJldFtpXSA9IHJvdy5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpKydcXG4nO1xufVxuXG5udW1lcmljLmdldFVSTCA9IGZ1bmN0aW9uIGdldFVSTCh1cmwpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY2xpZW50Lm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO1xuICAgIGNsaWVudC5zZW5kKCk7XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cblxubnVtZXJpYy5pbWFnZVVSTCA9IGZ1bmN0aW9uIGltYWdlVVJMKGltZykge1xuICAgIGZ1bmN0aW9uIGJhc2U2NChBKSB7XG4gICAgICAgIHZhciBuID0gQS5sZW5ndGgsIGkseCx5LHoscCxxLHIscztcbiAgICAgICAgdmFyIGtleSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvcihpPTA7aTxuO2krPTMpIHtcbiAgICAgICAgICAgIHggPSBBW2ldO1xuICAgICAgICAgICAgeSA9IEFbaSsxXTtcbiAgICAgICAgICAgIHogPSBBW2krMl07XG4gICAgICAgICAgICBwID0geCA+PiAyO1xuICAgICAgICAgICAgcSA9ICgoeCAmIDMpIDw8IDQpICsgKHkgPj4gNCk7XG4gICAgICAgICAgICByID0gKCh5ICYgMTUpIDw8IDIpICsgKHogPj4gNik7XG4gICAgICAgICAgICBzID0geiAmIDYzO1xuICAgICAgICAgICAgaWYoaSsxPj1uKSB7IHIgPSBzID0gNjQ7IH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsyPj1uKSB7IHMgPSA2NDsgfVxuICAgICAgICAgICAgcmV0ICs9IGtleS5jaGFyQXQocCkgKyBrZXkuY2hhckF0KHEpICsga2V5LmNoYXJBdChyKSArIGtleS5jaGFyQXQocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyYzMyQXJyYXkgKGEsZnJvbSx0bykge1xuICAgICAgICBpZih0eXBlb2YgZnJvbSA9PT0gXCJ1bmRlZmluZWRcIikgeyBmcm9tID0gMDsgfVxuICAgICAgICBpZih0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHsgdG8gPSBhLmxlbmd0aDsgfVxuICAgICAgICB2YXIgdGFibGUgPSBbMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhFRTBFNjEyQywgMHg5OTA5NTFCQSwgMHgwNzZEQzQxOSwgMHg3MDZBRjQ4RiwgMHhFOTYzQTUzNSwgMHg5RTY0OTVBMyxcbiAgICAgICAgICAgICAgICAgICAgIDB4MEVEQjg4MzIsIDB4NzlEQ0I4QTQsIDB4RTBENUU5MUUsIDB4OTdEMkQ5ODgsIDB4MDlCNjRDMkIsIDB4N0VCMTdDQkQsIDB4RTdCODJEMDcsIDB4OTBCRjFEOTEsIFxuICAgICAgICAgICAgICAgICAgICAgMHgxREI3MTA2NCwgMHg2QUIwMjBGMiwgMHhGM0I5NzE0OCwgMHg4NEJFNDFERSwgMHgxQURBRDQ3RCwgMHg2RERERTRFQiwgMHhGNEQ0QjU1MSwgMHg4M0QzODVDNyxcbiAgICAgICAgICAgICAgICAgICAgIDB4MTM2Qzk4NTYsIDB4NjQ2QkE4QzAsIDB4RkQ2MkY5N0EsIDB4OEE2NUM5RUMsIDB4MTQwMTVDNEYsIDB4NjMwNjZDRDksIDB4RkEwRjNENjMsIDB4OEQwODBERjUsIFxuICAgICAgICAgICAgICAgICAgICAgMHgzQjZFMjBDOCwgMHg0QzY5MTA1RSwgMHhENTYwNDFFNCwgMHhBMjY3NzE3MiwgMHgzQzAzRTREMSwgMHg0QjA0RDQ0NywgMHhEMjBEODVGRCwgMHhBNTBBQjU2QiwgXG4gICAgICAgICAgICAgICAgICAgICAweDM1QjVBOEZBLCAweDQyQjI5ODZDLCAweERCQkJDOUQ2LCAweEFDQkNGOTQwLCAweDMyRDg2Q0UzLCAweDQ1REY1Qzc1LCAweERDRDYwRENGLCAweEFCRDEzRDU5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4MjZEOTMwQUMsIDB4NTFERTAwM0EsIDB4QzhENzUxODAsIDB4QkZEMDYxMTYsIDB4MjFCNEY0QjUsIDB4NTZCM0M0MjMsIDB4Q0ZCQTk1OTksIDB4QjhCREE1MEYsXG4gICAgICAgICAgICAgICAgICAgICAweDI4MDJCODlFLCAweDVGMDU4ODA4LCAweEM2MENEOUIyLCAweEIxMEJFOTI0LCAweDJGNkY3Qzg3LCAweDU4Njg0QzExLCAweEMxNjExREFCLCAweEI2NjYyRDNELFxuICAgICAgICAgICAgICAgICAgICAgMHg3NkRDNDE5MCwgMHgwMURCNzEwNiwgMHg5OEQyMjBCQywgMHhFRkQ1MTAyQSwgMHg3MUIxODU4OSwgMHgwNkI2QjUxRiwgMHg5RkJGRTRBNSwgMHhFOEI4RDQzMyxcbiAgICAgICAgICAgICAgICAgICAgIDB4NzgwN0M5QTIsIDB4MEYwMEY5MzQsIDB4OTYwOUE4OEUsIDB4RTEwRTk4MTgsIDB4N0Y2QTBEQkIsIDB4MDg2RDNEMkQsIDB4OTE2NDZDOTcsIDB4RTY2MzVDMDEsIFxuICAgICAgICAgICAgICAgICAgICAgMHg2QjZCNTFGNCwgMHgxQzZDNjE2MiwgMHg4NTY1MzBEOCwgMHhGMjYyMDA0RSwgMHg2QzA2OTVFRCwgMHgxQjAxQTU3QiwgMHg4MjA4RjRDMSwgMHhGNTBGQzQ1NywgXG4gICAgICAgICAgICAgICAgICAgICAweDY1QjBEOUM2LCAweDEyQjdFOTUwLCAweDhCQkVCOEVBLCAweEZDQjk4ODdDLCAweDYyREQxRERGLCAweDE1REEyRDQ5LCAweDhDRDM3Q0YzLCAweEZCRDQ0QzY1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NERCMjYxNTgsIDB4M0FCNTUxQ0UsIDB4QTNCQzAwNzQsIDB4RDRCQjMwRTIsIDB4NEFERkE1NDEsIDB4M0REODk1RDcsIDB4QTREMUM0NkQsIDB4RDNENkY0RkIsIFxuICAgICAgICAgICAgICAgICAgICAgMHg0MzY5RTk2QSwgMHgzNDZFRDlGQywgMHhBRDY3ODg0NiwgMHhEQTYwQjhEMCwgMHg0NDA0MkQ3MywgMHgzMzAzMURFNSwgMHhBQTBBNEM1RiwgMHhERDBEN0NDOSwgXG4gICAgICAgICAgICAgICAgICAgICAweDUwMDU3MTNDLCAweDI3MDI0MUFBLCAweEJFMEIxMDEwLCAweEM5MEMyMDg2LCAweDU3NjhCNTI1LCAweDIwNkY4NUIzLCAweEI5NjZENDA5LCAweENFNjFFNDlGLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NUVERUY5MEUsIDB4MjlEOUM5OTgsIDB4QjBEMDk4MjIsIDB4QzdEN0E4QjQsIDB4NTlCMzNEMTcsIDB4MkVCNDBEODEsIDB4QjdCRDVDM0IsIDB4QzBCQTZDQUQsIFxuICAgICAgICAgICAgICAgICAgICAgMHhFREI4ODMyMCwgMHg5QUJGQjNCNiwgMHgwM0I2RTIwQywgMHg3NEIxRDI5QSwgMHhFQUQ1NDczOSwgMHg5REQyNzdBRiwgMHgwNERCMjYxNSwgMHg3M0RDMTY4MywgXG4gICAgICAgICAgICAgICAgICAgICAweEUzNjMwQjEyLCAweDk0NjQzQjg0LCAweDBENkQ2QTNFLCAweDdBNkE1QUE4LCAweEU0MEVDRjBCLCAweDkzMDlGRjlELCAweDBBMDBBRTI3LCAweDdEMDc5RUIxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RjAwRjkzNDQsIDB4ODcwOEEzRDIsIDB4MUUwMUYyNjgsIDB4NjkwNkMyRkUsIDB4Rjc2MjU3NUQsIDB4ODA2NTY3Q0IsIDB4MTk2QzM2NzEsIDB4NkU2QjA2RTcsIFxuICAgICAgICAgICAgICAgICAgICAgMHhGRUQ0MUI3NiwgMHg4OUQzMkJFMCwgMHgxMERBN0E1QSwgMHg2N0RENEFDQywgMHhGOUI5REY2RiwgMHg4RUJFRUZGOSwgMHgxN0I3QkU0MywgMHg2MEIwOEVENSwgXG4gICAgICAgICAgICAgICAgICAgICAweEQ2RDZBM0U4LCAweEExRDE5MzdFLCAweDM4RDhDMkM0LCAweDRGREZGMjUyLCAweEQxQkI2N0YxLCAweEE2QkM1NzY3LCAweDNGQjUwNkRELCAweDQ4QjIzNjRCLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RDgwRDJCREEsIDB4QUYwQTFCNEMsIDB4MzYwMzRBRjYsIDB4NDEwNDdBNjAsIDB4REY2MEVGQzMsIDB4QTg2N0RGNTUsIDB4MzE2RThFRUYsIDB4NDY2OUJFNzksIFxuICAgICAgICAgICAgICAgICAgICAgMHhDQjYxQjM4QywgMHhCQzY2ODMxQSwgMHgyNTZGRDJBMCwgMHg1MjY4RTIzNiwgMHhDQzBDNzc5NSwgMHhCQjBCNDcwMywgMHgyMjAyMTZCOSwgMHg1NTA1MjYyRiwgXG4gICAgICAgICAgICAgICAgICAgICAweEM1QkEzQkJFLCAweEIyQkQwQjI4LCAweDJCQjQ1QTkyLCAweDVDQjM2QTA0LCAweEMyRDdGRkE3LCAweEI1RDBDRjMxLCAweDJDRDk5RThCLCAweDVCREVBRTFELCBcbiAgICAgICAgICAgICAgICAgICAgIDB4OUI2NEMyQjAsIDB4RUM2M0YyMjYsIDB4NzU2QUEzOUMsIDB4MDI2RDkzMEEsIDB4OUMwOTA2QTksIDB4RUIwRTM2M0YsIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsIFxuICAgICAgICAgICAgICAgICAgICAgMHg5NUJGNEE4MiwgMHhFMkI4N0ExNCwgMHg3QkIxMkJBRSwgMHgwQ0I2MUIzOCwgMHg5MkQyOEU5QiwgMHhFNUQ1QkUwRCwgMHg3Q0RDRUZCNywgMHgwQkRCREYyMSwgXG4gICAgICAgICAgICAgICAgICAgICAweDg2RDNEMkQ0LCAweEYxRDRFMjQyLCAweDY4RERCM0Y4LCAweDFGREE4MzZFLCAweDgxQkUxNkNELCAweEY2QjkyNjVCLCAweDZGQjA3N0UxLCAweDE4Qjc0Nzc3LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4ODgwODVBRTYsIDB4RkYwRjZBNzAsIDB4NjYwNjNCQ0EsIDB4MTEwMTBCNUMsIDB4OEY2NTlFRkYsIDB4Rjg2MkFFNjksIDB4NjE2QkZGRDMsIDB4MTY2Q0NGNDUsIFxuICAgICAgICAgICAgICAgICAgICAgMHhBMDBBRTI3OCwgMHhENzBERDJFRSwgMHg0RTA0ODM1NCwgMHgzOTAzQjNDMiwgMHhBNzY3MjY2MSwgMHhEMDYwMTZGNywgMHg0OTY5NDc0RCwgMHgzRTZFNzdEQiwgXG4gICAgICAgICAgICAgICAgICAgICAweEFFRDE2QTRBLCAweEQ5RDY1QURDLCAweDQwREYwQjY2LCAweDM3RDgzQkYwLCAweEE5QkNBRTUzLCAweERFQkI5RUM1LCAweDQ3QjJDRjdGLCAweDMwQjVGRkU5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QkRCREYyMUMsIDB4Q0FCQUMyOEEsIDB4NTNCMzkzMzAsIDB4MjRCNEEzQTYsIDB4QkFEMDM2MDUsIDB4Q0RENzA2OTMsIDB4NTRERTU3MjksIDB4MjNEOTY3QkYsIFxuICAgICAgICAgICAgICAgICAgICAgMHhCMzY2N0EyRSwgMHhDNDYxNEFCOCwgMHg1RDY4MUIwMiwgMHgyQTZGMkI5NCwgMHhCNDBCQkUzNywgMHhDMzBDOEVBMSwgMHg1QTA1REYxQiwgMHgyRDAyRUY4RF07XG4gICAgIFxuICAgICAgICB2YXIgY3JjID0gLTEsIHkgPSAwLCBuID0gYS5sZW5ndGgsaTtcblxuICAgICAgICBmb3IgKGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgeSA9IChjcmMgXiBhW2ldKSAmIDB4RkY7XG4gICAgICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlW3ldO1xuICAgICAgICB9XG4gICAgIFxuICAgICAgICByZXR1cm4gY3JjIF4gKC0xKTtcbiAgICB9XG5cbiAgICB2YXIgaCA9IGltZ1swXS5sZW5ndGgsIHcgPSBpbWdbMF1bMF0ubGVuZ3RoLCBzMSwgczIsIG5leHQsayxsZW5ndGgsYSxiLGksaixhZGxlcjMyLGNyYzMyO1xuICAgIHZhciBzdHJlYW0gPSBbXG4gICAgICAgICAgICAgICAgICAxMzcsIDgwLCA3OCwgNzEsIDEzLCAxMCwgMjYsIDEwLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAwOiBQTkcgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAwLDAsMCwxMywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA4OiBJSERSIENodW5rIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgNzMsIDcyLCA2OCwgODIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMjogXCJJSERSXCIgXG4gICAgICAgICAgICAgICAgICAodyA+PiAyNCkgJiAyNTUsICh3ID4+IDE2KSAmIDI1NSwgKHcgPj4gOCkgJiAyNTUsIHcmMjU1LCAgIC8vIDE2OiBXaWR0aFxuICAgICAgICAgICAgICAgICAgKGggPj4gMjQpICYgMjU1LCAoaCA+PiAxNikgJiAyNTUsIChoID4+IDgpICYgMjU1LCBoJjI1NSwgICAvLyAyMDogSGVpZ2h0XG4gICAgICAgICAgICAgICAgICA4LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI0OiBiaXQgZGVwdGhcbiAgICAgICAgICAgICAgICAgIDIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjU6IFJHQlxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNjogZGVmbGF0ZVxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNzogbm8gZmlsdGVyXG4gICAgICAgICAgICAgICAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI4OiBubyBpbnRlcmxhY2VcbiAgICAgICAgICAgICAgICAgIC0xLC0yLC0zLC00LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjk6IENSQ1xuICAgICAgICAgICAgICAgICAgLTUsLTYsLTcsLTgsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzMzogSURBVCBDaHVuayBsZW5ndGhcbiAgICAgICAgICAgICAgICAgIDczLCA2OCwgNjUsIDg0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzc6IFwiSURBVFwiXG4gICAgICAgICAgICAgICAgICAvLyBSRkMgMTk1MCBoZWFkZXIgc3RhcnRzIGhlcmVcbiAgICAgICAgICAgICAgICAgIDgsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDE6IFJGQzE5NTAgQ01GXG4gICAgICAgICAgICAgICAgICAyOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQyOiBSRkMxOTUwIEZMR1xuICAgICAgICAgICAgICAgICAgXTtcbiAgICBjcmMzMiA9IGNyYzMyQXJyYXkoc3RyZWFtLDEyLDI5KTtcbiAgICBzdHJlYW1bMjldID0gKGNyYzMyPj4yNCkmMjU1O1xuICAgIHN0cmVhbVszMF0gPSAoY3JjMzI+PjE2KSYyNTU7XG4gICAgc3RyZWFtWzMxXSA9IChjcmMzMj4+OCkmMjU1O1xuICAgIHN0cmVhbVszMl0gPSAoY3JjMzIpJjI1NTtcbiAgICBzMSA9IDE7XG4gICAgczIgPSAwO1xuICAgIGZvcihpPTA7aTxoO2krKykge1xuICAgICAgICBpZihpPGgtMSkgeyBzdHJlYW0ucHVzaCgwKTsgfVxuICAgICAgICBlbHNlIHsgc3RyZWFtLnB1c2goMSk7IH1cbiAgICAgICAgYSA9ICgzKncrMSsoaT09PTApKSYyNTU7IGIgPSAoKDMqdysxKyhpPT09MCkpPj44KSYyNTU7XG4gICAgICAgIHN0cmVhbS5wdXNoKGEpOyBzdHJlYW0ucHVzaChiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goKH5hKSYyNTUpOyBzdHJlYW0ucHVzaCgofmIpJjI1NSk7XG4gICAgICAgIGlmKGk9PT0wKSBzdHJlYW0ucHVzaCgwKTtcbiAgICAgICAgZm9yKGo9MDtqPHc7aisrKSB7XG4gICAgICAgICAgICBmb3Ioaz0wO2s8MztrKyspIHtcbiAgICAgICAgICAgICAgICBhID0gaW1nW2tdW2ldW2pdO1xuICAgICAgICAgICAgICAgIGlmKGE+MjU1KSBhID0gMjU1O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYoYTwwKSBhPTA7XG4gICAgICAgICAgICAgICAgZWxzZSBhID0gTWF0aC5yb3VuZChhKTtcbiAgICAgICAgICAgICAgICBzMSA9IChzMSArIGEgKSU2NTUyMTtcbiAgICAgICAgICAgICAgICBzMiA9IChzMiArIHMxKSU2NTUyMTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICB9XG4gICAgYWRsZXIzMiA9IChzMjw8MTYpK3MxO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyPj4yNCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoYWRsZXIzMj4+MTYpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzI+PjgpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzIpJjI1NSk7XG4gICAgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aCAtIDQxO1xuICAgIHN0cmVhbVszM10gPSAobGVuZ3RoPj4yNCkmMjU1O1xuICAgIHN0cmVhbVszNF0gPSAobGVuZ3RoPj4xNikmMjU1O1xuICAgIHN0cmVhbVszNV0gPSAobGVuZ3RoPj44KSYyNTU7XG4gICAgc3RyZWFtWzM2XSA9IChsZW5ndGgpJjI1NTtcbiAgICBjcmMzMiA9IGNyYzMyQXJyYXkoc3RyZWFtLDM3KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzI+PjI0KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMj4+MTYpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGNyYzMyPj44KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMikmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbi8vICAgIGEgPSBzdHJlYW0ubGVuZ3RoO1xuICAgIHN0cmVhbS5wdXNoKDczKTsgIC8vIElcbiAgICBzdHJlYW0ucHVzaCg2OSk7ICAvLyBFXG4gICAgc3RyZWFtLnB1c2goNzgpOyAgLy8gTlxuICAgIHN0cmVhbS5wdXNoKDY4KTsgIC8vIERcbiAgICBzdHJlYW0ucHVzaCgxNzQpOyAvLyBDUkMxXG4gICAgc3RyZWFtLnB1c2goNjYpOyAgLy8gQ1JDMlxuICAgIHN0cmVhbS5wdXNoKDk2KTsgIC8vIENSQzNcbiAgICBzdHJlYW0ucHVzaCgxMzApOyAvLyBDUkM0XG4gICAgcmV0dXJuICdkYXRhOmltYWdlL3BuZztiYXNlNjQsJytiYXNlNjQoc3RyZWFtKTtcbn1cblxuLy8gMi4gTGluZWFyIGFsZ2VicmEgd2l0aCBBcnJheXMuXG5udW1lcmljLl9kaW0gPSBmdW5jdGlvbiBfZGltKHgpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgd2hpbGUodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHsgcmV0LnB1c2goeC5sZW5ndGgpOyB4ID0geFswXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZGltID0gZnVuY3Rpb24gZGltKHgpIHtcbiAgICB2YXIgeSx6O1xuICAgIGlmKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHkgPSB4WzBdO1xuICAgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgeiA9IHlbMF07XG4gICAgICAgICAgICBpZih0eXBlb2YgeiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1lcmljLl9kaW0oeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gubGVuZ3RoLHkubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gubGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5udW1lcmljLm1hcHJlZHVjZSA9IGZ1bmN0aW9uIG1hcHJlZHVjZShib2R5LGluaXQpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3gnLCdhY2N1bScsJ19zJywnX2snLFxuICAgICAgICAgICAgJ2lmKHR5cGVvZiBhY2N1bSA9PT0gXCJ1bmRlZmluZWRcIikgYWNjdW0gPSAnK2luaXQrJztcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7IHZhciB4aSA9IHg7ICcrYm9keSsnOyByZXR1cm4gYWNjdW07IH1cXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfcyA9PT0gXCJ1bmRlZmluZWRcIikgX3MgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfayA9PT0gXCJ1bmRlZmluZWRcIikgX2sgPSAwO1xcbicrXG4gICAgICAgICAgICAndmFyIF9uID0gX3NbX2tdO1xcbicrXG4gICAgICAgICAgICAndmFyIGkseGk7XFxuJytcbiAgICAgICAgICAgICdpZihfayA8IF9zLmxlbmd0aC0xKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgZm9yKGk9X24tMTtpPj0wO2ktLSkge1xcbicrXG4gICAgICAgICAgICAnICAgICAgICBhY2N1bSA9IGFyZ3VtZW50cy5jYWxsZWUoeFtpXSxhY2N1bSxfcyxfaysxKTtcXG4nK1xuICAgICAgICAgICAgJyAgICB9JytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIGFjY3VtO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnZm9yKGk9X24tMTtpPj0xO2ktPTIpIHsgXFxuJytcbiAgICAgICAgICAgICcgICAgeGkgPSB4W2ldO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpLTFdO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnaWYoaSA9PT0gMCkge1xcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJ1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIGFjY3VtOydcbiAgICAgICAgICAgICk7XG59XG5udW1lcmljLm1hcHJlZHVjZTIgPSBmdW5jdGlvbiBtYXByZWR1Y2UyKGJvZHksc2V0dXApIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3gnLFxuICAgICAgICAgICAgJ3ZhciBuID0geC5sZW5ndGg7XFxuJytcbiAgICAgICAgICAgICd2YXIgaSx4aTtcXG4nK3NldHVwKyc7XFxuJytcbiAgICAgICAgICAgICdmb3IoaT1uLTE7aSE9PS0xOy0taSkgeyBcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaV07XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5Kyc7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gYWNjdW07J1xuICAgICAgICAgICAgKTtcbn1cblxuXG5udW1lcmljLnNhbWUgPSBmdW5jdGlvbiBzYW1lKHgseSkge1xuICAgIHZhciBpLG47XG4gICAgaWYoISh4IGluc3RhbmNlb2YgQXJyYXkpIHx8ICEoeSBpbnN0YW5jZW9mIEFycmF5KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBuID0geC5sZW5ndGg7XG4gICAgaWYobiAhPT0geS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yKGk9MDtpPG47aSsrKSB7XG4gICAgICAgIGlmKHhbaV0gPT09IHlbaV0pIHsgY29udGludWU7IH1cbiAgICAgICAgaWYodHlwZW9mIHhbaV0gPT09IFwib2JqZWN0XCIpIHsgaWYoIXNhbWUoeFtpXSx5W2ldKSkgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbm51bWVyaWMucmVwID0gZnVuY3Rpb24gcmVwKHMsdixrKSB7XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIHsgaz0wOyB9XG4gICAgdmFyIG4gPSBzW2tdLCByZXQgPSBBcnJheShuKSwgaTtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7XG4gICAgICAgIGZvcihpPW4tMjtpPj0wO2ktPTIpIHsgcmV0W2krMV0gPSB2OyByZXRbaV0gPSB2OyB9XG4gICAgICAgIGlmKGk9PT0tMSkgeyByZXRbMF0gPSB2OyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyByZXRbaV0gPSBudW1lcmljLnJlcChzLHYsaysxKTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblxubnVtZXJpYy5kb3RNTXNtYWxsID0gZnVuY3Rpb24gZG90TU1zbWFsbCh4LHkpIHtcbiAgICB2YXIgaSxqLGsscCxxLHIscmV0LGZvbyxiYXIsd29vLGkwLGswLHAwLHIwO1xuICAgIHAgPSB4Lmxlbmd0aDsgcSA9IHkubGVuZ3RoOyByID0geVswXS5sZW5ndGg7XG4gICAgcmV0ID0gQXJyYXkocCk7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIGZvbyA9IEFycmF5KHIpO1xuICAgICAgICBiYXIgPSB4W2ldO1xuICAgICAgICBmb3Ioaz1yLTE7az49MDtrLS0pIHtcbiAgICAgICAgICAgIHdvbyA9IGJhcltxLTFdKnlbcS0xXVtrXTtcbiAgICAgICAgICAgIGZvcihqPXEtMjtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgICAgICBpMCA9IGotMTtcbiAgICAgICAgICAgICAgICB3b28gKz0gYmFyW2pdKnlbal1ba10gKyBiYXJbaTBdKnlbaTBdW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaj09PTApIHsgd29vICs9IGJhclswXSp5WzBdW2tdOyB9XG4gICAgICAgICAgICBmb29ba10gPSB3b287XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gZm9vO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5fZ2V0Q29sID0gZnVuY3Rpb24gX2dldENvbChBLGoseCkge1xuICAgIHZhciBuID0gQS5sZW5ndGgsIGk7XG4gICAgZm9yKGk9bi0xO2k+MDstLWkpIHtcbiAgICAgICAgeFtpXSA9IEFbaV1bal07XG4gICAgICAgIC0taTtcbiAgICAgICAgeFtpXSA9IEFbaV1bal07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB4WzBdID0gQVswXVtqXTtcbn1cbm51bWVyaWMuZG90TU1iaWcgPSBmdW5jdGlvbiBkb3RNTWJpZyh4LHkpe1xuICAgIHZhciBnYyA9IG51bWVyaWMuX2dldENvbCwgcCA9IHkubGVuZ3RoLCB2ID0gQXJyYXkocCk7XG4gICAgdmFyIG0gPSB4Lmxlbmd0aCwgbiA9IHlbMF0ubGVuZ3RoLCBBID0gbmV3IEFycmF5KG0pLCB4ajtcbiAgICB2YXIgVlYgPSBudW1lcmljLmRvdFZWO1xuICAgIHZhciBpLGosayx6O1xuICAgIC0tcDtcbiAgICAtLW07XG4gICAgZm9yKGk9bTtpIT09LTE7LS1pKSBBW2ldID0gQXJyYXkobik7XG4gICAgLS1uO1xuICAgIGZvcihpPW47aSE9PS0xOy0taSkge1xuICAgICAgICBnYyh5LGksdik7XG4gICAgICAgIGZvcihqPW07aiE9PS0xOy0taikge1xuICAgICAgICAgICAgej0wO1xuICAgICAgICAgICAgeGogPSB4W2pdO1xuICAgICAgICAgICAgQVtqXVtpXSA9IFZWKHhqLHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5udW1lcmljLmRvdE1WID0gZnVuY3Rpb24gZG90TVYoeCx5KSB7XG4gICAgdmFyIHAgPSB4Lmxlbmd0aCwgcSA9IHkubGVuZ3RoLGk7XG4gICAgdmFyIHJldCA9IEFycmF5KHApLCBkb3RWViA9IG51bWVyaWMuZG90VlY7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7IHJldFtpXSA9IGRvdFZWKHhbaV0seSk7IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdFZNID0gZnVuY3Rpb24gZG90Vk0oeCx5KSB7XG4gICAgdmFyIGksaixrLHAscSxyLHJldCxmb28sYmFyLHdvbyxpMCxrMCxwMCxyMCxzMSxzMixzMyxiYXosYWNjdW07XG4gICAgcCA9IHgubGVuZ3RoOyBxID0geVswXS5sZW5ndGg7XG4gICAgcmV0ID0gQXJyYXkocSk7XG4gICAgZm9yKGs9cS0xO2s+PTA7ay0tKSB7XG4gICAgICAgIHdvbyA9IHhbcC0xXSp5W3AtMV1ba107XG4gICAgICAgIGZvcihqPXAtMjtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgIGkwID0gai0xO1xuICAgICAgICAgICAgd29vICs9IHhbal0qeVtqXVtrXSArIHhbaTBdKnlbaTBdW2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHdvbyArPSB4WzBdKnlbMF1ba107IH1cbiAgICAgICAgcmV0W2tdID0gd29vO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdFZWID0gZnVuY3Rpb24gZG90VlYoeCx5KSB7XG4gICAgdmFyIGksbj14Lmxlbmd0aCxpMSxyZXQgPSB4W24tMV0qeVtuLTFdO1xuICAgIGZvcihpPW4tMjtpPj0xO2ktPTIpIHtcbiAgICAgICAgaTEgPSBpLTE7XG4gICAgICAgIHJldCArPSB4W2ldKnlbaV0gKyB4W2kxXSp5W2kxXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHsgcmV0ICs9IHhbMF0qeVswXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZG90ID0gZnVuY3Rpb24gZG90KHgseSkge1xuICAgIHZhciBkID0gbnVtZXJpYy5kaW07XG4gICAgc3dpdGNoKGQoeCkubGVuZ3RoKjEwMDArZCh5KS5sZW5ndGgpIHtcbiAgICBjYXNlIDIwMDI6XG4gICAgICAgIGlmKHkubGVuZ3RoIDwgMTApIHJldHVybiBudW1lcmljLmRvdE1Nc21hbGwoeCx5KTtcbiAgICAgICAgZWxzZSByZXR1cm4gbnVtZXJpYy5kb3RNTWJpZyh4LHkpO1xuICAgIGNhc2UgMjAwMTogcmV0dXJuIG51bWVyaWMuZG90TVYoeCx5KTtcbiAgICBjYXNlIDEwMDI6IHJldHVybiBudW1lcmljLmRvdFZNKHgseSk7XG4gICAgY2FzZSAxMDAxOiByZXR1cm4gbnVtZXJpYy5kb3RWVih4LHkpO1xuICAgIGNhc2UgMTAwMDogcmV0dXJuIG51bWVyaWMubXVsVlMoeCx5KTtcbiAgICBjYXNlIDE6IHJldHVybiBudW1lcmljLm11bFNWKHgseSk7XG4gICAgY2FzZSAwOiByZXR1cm4geCp5O1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignbnVtZXJpYy5kb3Qgb25seSB3b3JrcyBvbiB2ZWN0b3JzIGFuZCBtYXRyaWNlcycpO1xuICAgIH1cbn1cblxubnVtZXJpYy5kaWFnID0gZnVuY3Rpb24gZGlhZyhkKSB7XG4gICAgdmFyIGksaTEsaixuID0gZC5sZW5ndGgsIEEgPSBBcnJheShuKSwgQWk7XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQXJyYXkobik7XG4gICAgICAgIGkxID0gaSsyO1xuICAgICAgICBmb3Ioaj1uLTE7aj49aTE7ai09Mikge1xuICAgICAgICAgICAgQWlbal0gPSAwO1xuICAgICAgICAgICAgQWlbai0xXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj5pKSB7IEFpW2pdID0gMDsgfVxuICAgICAgICBBaVtpXSA9IGRbaV07XG4gICAgICAgIGZvcihqPWktMTtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgIEFpW2pdID0gMDtcbiAgICAgICAgICAgIEFpW2otMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IEFpWzBdID0gMDsgfVxuICAgICAgICBBW2ldID0gQWk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxubnVtZXJpYy5nZXREaWFnID0gZnVuY3Rpb24oQSkge1xuICAgIHZhciBuID0gTWF0aC5taW4oQS5sZW5ndGgsQVswXS5sZW5ndGgpLGkscmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTE7LS1pKSB7XG4gICAgICAgIHJldFtpXSA9IEFbaV1baV07XG4gICAgICAgIC0taTtcbiAgICAgICAgcmV0W2ldID0gQVtpXVtpXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgcmV0WzBdID0gQVswXVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KG4pIHsgcmV0dXJuIG51bWVyaWMuZGlhZyhudW1lcmljLnJlcChbbl0sMSkpOyB9XG5udW1lcmljLnBvaW50d2lzZSA9IGZ1bmN0aW9uIHBvaW50d2lzZShwYXJhbXMsYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgeyBzZXR1cCA9IFwiXCI7IH1cbiAgICB2YXIgZnVuID0gW107XG4gICAgdmFyIGs7XG4gICAgdmFyIGF2ZWMgPSAvXFxbaVxcXSQvLHAsdGhldmVjID0gJyc7XG4gICAgdmFyIGhhdmVyZXQgPSBmYWxzZTtcbiAgICBmb3Ioaz0wO2s8cGFyYW1zLmxlbmd0aDtrKyspIHtcbiAgICAgICAgaWYoYXZlYy50ZXN0KHBhcmFtc1trXSkpIHtcbiAgICAgICAgICAgIHAgPSBwYXJhbXNba10uc3Vic3RyaW5nKDAscGFyYW1zW2tdLmxlbmd0aC0zKTtcbiAgICAgICAgICAgIHRoZXZlYyA9IHA7XG4gICAgICAgIH0gZWxzZSB7IHAgPSBwYXJhbXNba107IH1cbiAgICAgICAgaWYocD09PSdyZXQnKSBoYXZlcmV0ID0gdHJ1ZTtcbiAgICAgICAgZnVuLnB1c2gocCk7XG4gICAgfVxuICAgIGZ1bltwYXJhbXMubGVuZ3RoXSA9ICdfcyc7XG4gICAgZnVuW3BhcmFtcy5sZW5ndGgrMV0gPSAnX2snO1xuICAgIGZ1bltwYXJhbXMubGVuZ3RoKzJdID0gKFxuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfcyA9PT0gXCJ1bmRlZmluZWRcIikgX3MgPSBudW1lcmljLmRpbSgnK3RoZXZlYysnKTtcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfayA9PT0gXCJ1bmRlZmluZWRcIikgX2sgPSAwO1xcbicrXG4gICAgICAgICAgICAndmFyIF9uID0gX3NbX2tdO1xcbicrXG4gICAgICAgICAgICAndmFyIGknKyhoYXZlcmV0PycnOicsIHJldCA9IEFycmF5KF9uKScpKyc7XFxuJytcbiAgICAgICAgICAgICdpZihfayA8IF9zLmxlbmd0aC0xKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgZm9yKGk9X24tMTtpPj0wO2ktLSkgcmV0W2ldID0gYXJndW1lbnRzLmNhbGxlZSgnK3BhcmFtcy5qb2luKCcsJykrJyxfcyxfaysxKTtcXG4nK1xuICAgICAgICAgICAgJyAgICByZXR1cm4gcmV0O1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdmb3IoaT1fbi0xO2khPT0tMTstLWkpIHtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJ1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIHJldDsnXG4gICAgICAgICAgICApO1xuICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLGZ1bik7XG59XG5udW1lcmljLnBvaW50d2lzZTIgPSBmdW5jdGlvbiBwb2ludHdpc2UyKHBhcmFtcyxib2R5LHNldHVwKSB7XG4gICAgaWYodHlwZW9mIHNldHVwID09PSBcInVuZGVmaW5lZFwiKSB7IHNldHVwID0gXCJcIjsgfVxuICAgIHZhciBmdW4gPSBbXTtcbiAgICB2YXIgaztcbiAgICB2YXIgYXZlYyA9IC9cXFtpXFxdJC8scCx0aGV2ZWMgPSAnJztcbiAgICB2YXIgaGF2ZXJldCA9IGZhbHNlO1xuICAgIGZvcihrPTA7azxwYXJhbXMubGVuZ3RoO2srKykge1xuICAgICAgICBpZihhdmVjLnRlc3QocGFyYW1zW2tdKSkge1xuICAgICAgICAgICAgcCA9IHBhcmFtc1trXS5zdWJzdHJpbmcoMCxwYXJhbXNba10ubGVuZ3RoLTMpO1xuICAgICAgICAgICAgdGhldmVjID0gcDtcbiAgICAgICAgfSBlbHNlIHsgcCA9IHBhcmFtc1trXTsgfVxuICAgICAgICBpZihwPT09J3JldCcpIGhhdmVyZXQgPSB0cnVlO1xuICAgICAgICBmdW4ucHVzaChwKTtcbiAgICB9XG4gICAgZnVuW3BhcmFtcy5sZW5ndGhdID0gKFxuICAgICAgICAgICAgJ3ZhciBfbiA9ICcrdGhldmVjKycubGVuZ3RoO1xcbicrXG4gICAgICAgICAgICAndmFyIGknKyhoYXZlcmV0PycnOicsIHJldCA9IEFycmF5KF9uKScpKyc7XFxuJytcbiAgICAgICAgICAgIHNldHVwKydcXG4nK1xuICAgICAgICAgICAgJ2ZvcihpPV9uLTE7aSE9PS0xOy0taSkge1xcbicrXG4gICAgICAgICAgICBib2R5KydcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiByZXQ7J1xuICAgICAgICAgICAgKTtcbiAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCxmdW4pO1xufVxubnVtZXJpYy5fYmlmb3JlYWNoID0gKGZ1bmN0aW9uIF9iaWZvcmVhY2goeCx5LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyBmKHgseSk7IHJldHVybjsgfVxuICAgIHZhciBpLG49c1trXTtcbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgX2JpZm9yZWFjaCh0eXBlb2YgeD09PVwib2JqZWN0XCI/eFtpXTp4LHR5cGVvZiB5PT09XCJvYmplY3RcIj95W2ldOnkscyxrKzEsZik7IH1cbn0pO1xubnVtZXJpYy5fYmlmb3JlYWNoMiA9IChmdW5jdGlvbiBfYmlmb3JlYWNoMih4LHkscyxrLGYpIHtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IHJldHVybiBmKHgseSk7IH1cbiAgICB2YXIgaSxuPXNba10scmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTA7LS1pKSB7IHJldFtpXSA9IF9iaWZvcmVhY2gyKHR5cGVvZiB4PT09XCJvYmplY3RcIj94W2ldOngsdHlwZW9mIHk9PT1cIm9iamVjdFwiP3lbaV06eSxzLGsrMSxmKTsgfVxuICAgIHJldHVybiByZXQ7XG59KTtcbm51bWVyaWMuX2ZvcmVhY2ggPSAoZnVuY3Rpb24gX2ZvcmVhY2goeCxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZih4KTsgcmV0dXJuOyB9XG4gICAgdmFyIGksbj1zW2tdO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyBfZm9yZWFjaCh4W2ldLHMsaysxLGYpOyB9XG59KTtcbm51bWVyaWMuX2ZvcmVhY2gyID0gKGZ1bmN0aW9uIF9mb3JlYWNoMih4LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyByZXR1cm4gZih4KTsgfVxuICAgIHZhciBpLG49c1trXSwgcmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7IHJldFtpXSA9IF9mb3JlYWNoMih4W2ldLHMsaysxLGYpOyB9XG4gICAgcmV0dXJuIHJldDtcbn0pO1xuXG4vKm51bWVyaWMuYW55ViA9IG51bWVyaWMubWFwcmVkdWNlKCdpZih4aSkgcmV0dXJuIHRydWU7JywnZmFsc2UnKTtcbm51bWVyaWMuYWxsViA9IG51bWVyaWMubWFwcmVkdWNlKCdpZigheGkpIHJldHVybiBmYWxzZTsnLCd0cnVlJyk7XG5udW1lcmljLmFueSA9IGZ1bmN0aW9uKHgpIHsgaWYodHlwZW9mIHgubGVuZ3RoID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4geDsgcmV0dXJuIG51bWVyaWMuYW55Vih4KTsgfVxubnVtZXJpYy5hbGwgPSBmdW5jdGlvbih4KSB7IGlmKHR5cGVvZiB4Lmxlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHg7IHJldHVybiBudW1lcmljLmFsbFYoeCk7IH0qL1xuXG5udW1lcmljLm9wczIgPSB7XG4gICAgICAgIGFkZDogJysnLFxuICAgICAgICBzdWI6ICctJyxcbiAgICAgICAgbXVsOiAnKicsXG4gICAgICAgIGRpdjogJy8nLFxuICAgICAgICBtb2Q6ICclJyxcbiAgICAgICAgYW5kOiAnJiYnLFxuICAgICAgICBvcjogICd8fCcsXG4gICAgICAgIGVxOiAgJz09PScsXG4gICAgICAgIG5lcTogJyE9PScsXG4gICAgICAgIGx0OiAgJzwnLFxuICAgICAgICBndDogICc+JyxcbiAgICAgICAgbGVxOiAnPD0nLFxuICAgICAgICBnZXE6ICc+PScsXG4gICAgICAgIGJhbmQ6ICcmJyxcbiAgICAgICAgYm9yOiAnfCcsXG4gICAgICAgIGJ4b3I6ICdeJyxcbiAgICAgICAgbHNoaWZ0OiAnPDwnLFxuICAgICAgICByc2hpZnQ6ICc+PicsXG4gICAgICAgIHJyc2hpZnQ6ICc+Pj4nXG59O1xubnVtZXJpYy5vcHNlcSA9IHtcbiAgICAgICAgYWRkZXE6ICcrPScsXG4gICAgICAgIHN1YmVxOiAnLT0nLFxuICAgICAgICBtdWxlcTogJyo9JyxcbiAgICAgICAgZGl2ZXE6ICcvPScsXG4gICAgICAgIG1vZGVxOiAnJT0nLFxuICAgICAgICBsc2hpZnRlcTogJzw8PScsXG4gICAgICAgIHJzaGlmdGVxOiAnPj49JyxcbiAgICAgICAgcnJzaGlmdGVxOiAnPj4+PScsXG4gICAgICAgIGJhbmRlcTogJyY9JyxcbiAgICAgICAgYm9yZXE6ICd8PScsXG4gICAgICAgIGJ4b3JlcTogJ149J1xufTtcbm51bWVyaWMubWF0aGZ1bnMgPSBbJ2FicycsJ2Fjb3MnLCdhc2luJywnYXRhbicsJ2NlaWwnLCdjb3MnLFxuICAgICAgICAgICAgICAgICAgICAnZXhwJywnZmxvb3InLCdsb2cnLCdyb3VuZCcsJ3NpbicsJ3NxcnQnLCd0YW4nLFxuICAgICAgICAgICAgICAgICAgICAnaXNOYU4nLCdpc0Zpbml0ZSddO1xubnVtZXJpYy5tYXRoZnVuczIgPSBbJ2F0YW4yJywncG93JywnbWF4JywnbWluJ107XG5udW1lcmljLm9wczEgPSB7XG4gICAgICAgIG5lZzogJy0nLFxuICAgICAgICBub3Q6ICchJyxcbiAgICAgICAgYm5vdDogJ34nLFxuICAgICAgICBjbG9uZTogJydcbn07XG5udW1lcmljLm1hcHJlZHVjZXJzID0ge1xuICAgICAgICBhbnk6IFsnaWYoeGkpIHJldHVybiB0cnVlOycsJ3ZhciBhY2N1bSA9IGZhbHNlOyddLFxuICAgICAgICBhbGw6IFsnaWYoIXhpKSByZXR1cm4gZmFsc2U7JywndmFyIGFjY3VtID0gdHJ1ZTsnXSxcbiAgICAgICAgc3VtOiBbJ2FjY3VtICs9IHhpOycsJ3ZhciBhY2N1bSA9IDA7J10sXG4gICAgICAgIHByb2Q6IFsnYWNjdW0gKj0geGk7JywndmFyIGFjY3VtID0gMTsnXSxcbiAgICAgICAgbm9ybTJTcXVhcmVkOiBbJ2FjY3VtICs9IHhpKnhpOycsJ3ZhciBhY2N1bSA9IDA7J10sXG4gICAgICAgIG5vcm1pbmY6IFsnYWNjdW0gPSBtYXgoYWNjdW0sYWJzKHhpKSk7JywndmFyIGFjY3VtID0gMCwgbWF4ID0gTWF0aC5tYXgsIGFicyA9IE1hdGguYWJzOyddLFxuICAgICAgICBub3JtMTogWydhY2N1bSArPSBhYnMoeGkpJywndmFyIGFjY3VtID0gMCwgYWJzID0gTWF0aC5hYnM7J10sXG4gICAgICAgIHN1cDogWydhY2N1bSA9IG1heChhY2N1bSx4aSk7JywndmFyIGFjY3VtID0gLUluZmluaXR5LCBtYXggPSBNYXRoLm1heDsnXSxcbiAgICAgICAgaW5mOiBbJ2FjY3VtID0gbWluKGFjY3VtLHhpKTsnLCd2YXIgYWNjdW0gPSBJbmZpbml0eSwgbWluID0gTWF0aC5taW47J11cbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksbztcbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVuczIubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuczJbaV07XG4gICAgICAgIG51bWVyaWMub3BzMltvXSA9IG87XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMub3BzMikge1xuICAgICAgICBpZihudW1lcmljLm9wczIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG8gPSBudW1lcmljLm9wczJbaV07XG4gICAgICAgICAgICB2YXIgY29kZSwgY29kZWVxLCBzZXR1cCA9ICcnO1xuICAgICAgICAgICAgaWYobnVtZXJpYy5teUluZGV4T2YuY2FsbChudW1lcmljLm1hdGhmdW5zMixpKSE9PS0xKSB7XG4gICAgICAgICAgICAgICAgc2V0dXAgPSAndmFyICcrbysnID0gTWF0aC4nK28rJztcXG4nO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBmdW5jdGlvbihyLHgseSkgeyByZXR1cm4gcisnID0gJytvKycoJyt4KycsJyt5KycpJzsgfTtcbiAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyA9ICcrbysnKCcreCsnLCcreSsnKSc7IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBmdW5jdGlvbihyLHgseSkgeyByZXR1cm4gcisnID0gJyt4KycgJytvKycgJyt5OyB9O1xuICAgICAgICAgICAgICAgIGlmKG51bWVyaWMub3BzZXEuaGFzT3duUHJvcGVydHkoaSsnZXEnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyAnK28rJz0gJyt5OyB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVlcSA9IGZ1bmN0aW9uKHgseSkgeyByZXR1cm4geCsnID0gJyt4KycgJytvKycgJyt5OyB9OyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtZXJpY1tpKydWViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXScsJ3lbaV0nXSxjb2RlKCdyZXRbaV0nLCd4W2ldJywneVtpXScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnU1YnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3gnLCd5W2ldJ10sY29kZSgncmV0W2ldJywneCcsJ3lbaV0nKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ1ZTJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWyd4W2ldJywneSddLGNvZGUoJ3JldFtpXScsJ3hbaV0nLCd5Jyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpXSA9IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBpLCB4ID0gYXJndW1lbnRzWzBdLCB5O1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgVlYgPSBudW1lcmljLicraSsnVlYsIFZTID0gbnVtZXJpYy4nK2krJ1ZTLCBTViA9IG51bWVyaWMuJytpKydTVjtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIGRpbSA9IG51bWVyaWMuZGltO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT0xO2khPT1uOysraSkgeyBcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICB5ID0gYXJndW1lbnRzW2ldO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGlmKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgICAgIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHgpLDAsVlYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICAgICBlbHNlIHggPSBudW1lcmljLl9iaWZvcmVhY2gyKHgseSxkaW0oeCksMCxWUyk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgfSBlbHNlIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHkpLDAsU1YpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGVsc2UgJytjb2RlZXEoJ3gnLCd5JykrJ1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxucmV0dXJuIHg7XFxuJyk7XG4gICAgICAgICAgICBudW1lcmljW29dID0gbnVtZXJpY1tpXTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXFWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWydyZXRbaV0nLCd4W2ldJ10sIGNvZGVlcSgncmV0W2ldJywneFtpXScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXFTJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWydyZXRbaV0nLCd4J10sIGNvZGVlcSgncmV0W2ldJywneCcpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXEnXSA9IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBpLCB4ID0gYXJndW1lbnRzWzBdLCB5O1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgViA9IG51bWVyaWMuJytpKydlcVYsIFMgPSBudW1lcmljLicraSsnZXFTXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBzID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2ZvcihpPTE7aSE9PW47KytpKSB7IFxcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIHkgPSBhcmd1bWVudHNbaV07XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIG51bWVyaWMuX2JpZm9yZWFjaCh4LHkscywwLFYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGVsc2UgbnVtZXJpYy5fYmlmb3JlYWNoKHgseSxzLDAsUyk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ31cXG5yZXR1cm4geDtcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVuczIubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuczJbaV07XG4gICAgICAgIGRlbGV0ZSBudW1lcmljLm9wczJbb107XG4gICAgfVxuICAgIGZvcihpPTA7aTxudW1lcmljLm1hdGhmdW5zLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnNbaV07XG4gICAgICAgIG51bWVyaWMub3BzMVtvXSA9IG87XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMub3BzMSkge1xuICAgICAgICBpZihudW1lcmljLm9wczEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHNldHVwID0gJyc7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5vcHMxW2ldO1xuICAgICAgICAgICAgaWYobnVtZXJpYy5teUluZGV4T2YuY2FsbChudW1lcmljLm1hdGhmdW5zLGkpIT09LTEpIHtcbiAgICAgICAgICAgICAgICBpZihNYXRoLmhhc093blByb3BlcnR5KG8pKSBzZXR1cCA9ICd2YXIgJytvKycgPSBNYXRoLicrbysnO1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsncmV0W2ldJ10sJ3JldFtpXSA9ICcrbysnKHJldFtpXSk7JyxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxJ10gPSBGdW5jdGlvbigneCcsXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgcmV0dXJuICcrbysneFxcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgaTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFYgPSBudW1lcmljLicraSsnZXFWO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdudW1lcmljLl9mb3JlYWNoKHgscywwLFYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4geDtcXG4nKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXSddLCdyZXRbaV0gPSAnK28rJyh4W2ldKTsnLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaV0gPSBGdW5jdGlvbigneCcsXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgcmV0dXJuICcrbysnKHgpXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgViA9IG51bWVyaWMuJytpKydWO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4gbnVtZXJpYy5fZm9yZWFjaDIoeCxzLDAsVik7XFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuc1tpXTtcbiAgICAgICAgZGVsZXRlIG51bWVyaWMub3BzMVtvXTtcbiAgICB9XG4gICAgZm9yKGkgaW4gbnVtZXJpYy5tYXByZWR1Y2Vycykge1xuICAgICAgICBpZihudW1lcmljLm1hcHJlZHVjZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5tYXByZWR1Y2Vyc1tpXTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnViddID0gbnVtZXJpYy5tYXByZWR1Y2UyKG9bMF0sb1sxXSk7XG4gICAgICAgICAgICBudW1lcmljW2ldID0gRnVuY3Rpb24oJ3gnLCdzJywnaycsXG4gICAgICAgICAgICAgICAgICAgIG9bMV0rXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgeycrXG4gICAgICAgICAgICAgICAgICAgICcgICAgeGkgPSB4O1xcbicrXG4gICAgICAgICAgICAgICAgICAgIG9bMF0rJztcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgIHJldHVybiBhY2N1bTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfScrXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgcyA9PT0gXCJ1bmRlZmluZWRcIikgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgayA9IDA7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2lmKGsgPT09IHMubGVuZ3RoLTEpIHJldHVybiBudW1lcmljLicraSsnVih4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHhpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgbiA9IHgubGVuZ3RoLCBpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICB4aSA9IGFyZ3VtZW50cy5jYWxsZWUoeFtpXSk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgb1swXSsnO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybiBhY2N1bTtcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cbn0oKSk7XG5cbm51bWVyaWMudHJ1bmNWViA9IG51bWVyaWMucG9pbnR3aXNlKFsneFtpXScsJ3lbaV0nXSwncmV0W2ldID0gcm91bmQoeFtpXS95W2ldKSp5W2ldOycsJ3ZhciByb3VuZCA9IE1hdGgucm91bmQ7Jyk7XG5udW1lcmljLnRydW5jVlMgPSBudW1lcmljLnBvaW50d2lzZShbJ3hbaV0nLCd5J10sJ3JldFtpXSA9IHJvdW5kKHhbaV0veSkqeTsnLCd2YXIgcm91bmQgPSBNYXRoLnJvdW5kOycpO1xubnVtZXJpYy50cnVuY1NWID0gbnVtZXJpYy5wb2ludHdpc2UoWyd4JywneVtpXSddLCdyZXRbaV0gPSByb3VuZCh4L3lbaV0pKnlbaV07JywndmFyIHJvdW5kID0gTWF0aC5yb3VuZDsnKTtcbm51bWVyaWMudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyh4LHkpIHtcbiAgICBpZih0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIG51bWVyaWMudHJ1bmNWVih4LHkpO1xuICAgICAgICByZXR1cm4gbnVtZXJpYy50cnVuY1ZTKHgseSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIG51bWVyaWMudHJ1bmNTVih4LHkpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHgveSkqeTtcbn1cblxubnVtZXJpYy5pbnYgPSBmdW5jdGlvbiBpbnYoeCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCksIGFicyA9IE1hdGguYWJzLCBtID0gc1swXSwgbiA9IHNbMV07XG4gICAgdmFyIEEgPSBudW1lcmljLmNsb25lKHgpLCBBaSwgQWo7XG4gICAgdmFyIEkgPSBudW1lcmljLmlkZW50aXR5KG0pLCBJaSwgSWo7XG4gICAgdmFyIGksaixrLHg7XG4gICAgZm9yKGo9MDtqPG47KytqKSB7XG4gICAgICAgIHZhciBpMCA9IC0xO1xuICAgICAgICB2YXIgdjAgPSAtMTtcbiAgICAgICAgZm9yKGk9ajtpIT09bTsrK2kpIHsgayA9IGFicyhBW2ldW2pdKTsgaWYoaz52MCkgeyBpMCA9IGk7IHYwID0gazsgfSB9XG4gICAgICAgIEFqID0gQVtpMF07IEFbaTBdID0gQVtqXTsgQVtqXSA9IEFqO1xuICAgICAgICBJaiA9IElbaTBdOyBJW2kwXSA9IElbal07IElbal0gPSBJajtcbiAgICAgICAgeCA9IEFqW2pdO1xuICAgICAgICBmb3Ioaz1qO2shPT1uOysraykgICAgQWpba10gLz0geDsgXG4gICAgICAgIGZvcihrPW4tMTtrIT09LTE7LS1rKSBJaltrXSAvPSB4O1xuICAgICAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAgICAgaWYoaSE9PWopIHtcbiAgICAgICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICAgICAgSWkgPSBJW2ldO1xuICAgICAgICAgICAgICAgIHggPSBBaVtqXTtcbiAgICAgICAgICAgICAgICBmb3Ioaz1qKzE7ayE9PW47KytrKSAgQWlba10gLT0gQWpba10qeDtcbiAgICAgICAgICAgICAgICBmb3Ioaz1uLTE7az4wOy0taykgeyBJaVtrXSAtPSBJaltrXSp4OyAtLWs7IElpW2tdIC09IElqW2tdKng7IH1cbiAgICAgICAgICAgICAgICBpZihrPT09MCkgSWlbMF0gLT0gSWpbMF0qeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSTtcbn1cblxubnVtZXJpYy5kZXQgPSBmdW5jdGlvbiBkZXQoeCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCk7XG4gICAgaWYocy5sZW5ndGggIT09IDIgfHwgc1swXSAhPT0gc1sxXSkgeyB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IGRldCgpIG9ubHkgd29ya3Mgb24gc3F1YXJlIG1hdHJpY2VzJyk7IH1cbiAgICB2YXIgbiA9IHNbMF0sIHJldCA9IDEsaSxqLGssQSA9IG51bWVyaWMuY2xvbmUoeCksQWosQWksYWxwaGEsdGVtcCxrMSxrMixrMztcbiAgICBmb3Ioaj0wO2o8bi0xO2orKykge1xuICAgICAgICBrPWo7XG4gICAgICAgIGZvcihpPWorMTtpPG47aSsrKSB7IGlmKE1hdGguYWJzKEFbaV1bal0pID4gTWF0aC5hYnMoQVtrXVtqXSkpIHsgayA9IGk7IH0gfVxuICAgICAgICBpZihrICE9PSBqKSB7XG4gICAgICAgICAgICB0ZW1wID0gQVtrXTsgQVtrXSA9IEFbal07IEFbal0gPSB0ZW1wO1xuICAgICAgICAgICAgcmV0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIEFqID0gQVtqXTtcbiAgICAgICAgZm9yKGk9aisxO2k8bjtpKyspIHtcbiAgICAgICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgICAgIGFscGhhID0gQWlbal0vQWpbal07XG4gICAgICAgICAgICBmb3Ioaz1qKzE7azxuLTE7ays9Mikge1xuICAgICAgICAgICAgICAgIGsxID0gaysxO1xuICAgICAgICAgICAgICAgIEFpW2tdIC09IEFqW2tdKmFscGhhO1xuICAgICAgICAgICAgICAgIEFpW2sxXSAtPSBBaltrMV0qYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihrIT09bikgeyBBaVtrXSAtPSBBaltrXSphbHBoYTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKEFqW2pdID09PSAwKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldCAqPSBBaltqXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldCpBW2pdW2pdO1xufVxuXG5udW1lcmljLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZSh4KSB7XG4gICAgdmFyIGksaixtID0geC5sZW5ndGgsbiA9IHhbMF0ubGVuZ3RoLCByZXQ9QXJyYXkobiksQTAsQTEsQmo7XG4gICAgZm9yKGo9MDtqPG47aisrKSByZXRbal0gPSBBcnJheShtKTtcbiAgICBmb3IoaT1tLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIEExID0geFtpXTtcbiAgICAgICAgQTAgPSB4W2ktMV07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gQTFbal07IEJqW2ktMV0gPSBBMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEJqID0gcmV0W2pdOyBCaltpXSA9IEExW2pdOyBCaltpLTFdID0gQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHtcbiAgICAgICAgICAgIEJqID0gcmV0WzBdOyBCaltpXSA9IEExWzBdOyBCaltpLTFdID0gQTBbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgQTAgPSB4WzBdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IEEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHsgcmV0WzBdWzBdID0gQTBbMF07IH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMubmVndHJhbnNwb3NlID0gZnVuY3Rpb24gbmVndHJhbnNwb3NlKHgpIHtcbiAgICB2YXIgaSxqLG0gPSB4Lmxlbmd0aCxuID0geFswXS5sZW5ndGgsIHJldD1BcnJheShuKSxBMCxBMSxCajtcbiAgICBmb3Ioaj0wO2o8bjtqKyspIHJldFtqXSA9IEFycmF5KG0pO1xuICAgIGZvcihpPW0tMTtpPj0xO2ktPTIpIHtcbiAgICAgICAgQTEgPSB4W2ldO1xuICAgICAgICBBMCA9IHhbaS0xXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTE7LS1qKSB7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSAtQTFbal07IEJqW2ktMV0gPSAtQTBbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSAtQTFbal07IEJqW2ktMV0gPSAtQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHtcbiAgICAgICAgICAgIEJqID0gcmV0WzBdOyBCaltpXSA9IC1BMVswXTsgQmpbaS0xXSA9IC1BMFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihpPT09MCkge1xuICAgICAgICBBMCA9IHhbMF07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gLUEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gLUEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHJldFswXVswXSA9IC1BMFswXTsgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLl9yYW5kb20gPSBmdW5jdGlvbiBfcmFuZG9tKHMsaykge1xuICAgIHZhciBpLG49c1trXSxyZXQ9QXJyYXkobiksIHJuZDtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7XG4gICAgICAgIHJuZCA9IE1hdGgucmFuZG9tO1xuICAgICAgICBmb3IoaT1uLTE7aT49MTtpLT0yKSB7XG4gICAgICAgICAgICByZXRbaV0gPSBybmQoKTtcbiAgICAgICAgICAgIHJldFtpLTFdID0gcm5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaT09PTApIHsgcmV0WzBdID0gcm5kKCk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSByZXRbaV0gPSBfcmFuZG9tKHMsaysxKTtcbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5yYW5kb20gPSBmdW5jdGlvbiByYW5kb20ocykgeyByZXR1cm4gbnVtZXJpYy5fcmFuZG9tKHMsMCk7IH1cblxubnVtZXJpYy5ub3JtMiA9IGZ1bmN0aW9uIG5vcm0yKHgpIHsgcmV0dXJuIE1hdGguc3FydChudW1lcmljLm5vcm0yU3F1YXJlZCh4KSk7IH1cblxubnVtZXJpYy5saW5zcGFjZSA9IGZ1bmN0aW9uIGxpbnNwYWNlKGEsYixuKSB7XG4gICAgaWYodHlwZW9mIG4gPT09IFwidW5kZWZpbmVkXCIpIG4gPSBNYXRoLm1heChNYXRoLnJvdW5kKGItYSkrMSwxKTtcbiAgICBpZihuPDIpIHsgcmV0dXJuIG49PT0xP1thXTpbXTsgfVxuICAgIHZhciBpLHJldCA9IEFycmF5KG4pO1xuICAgIG4tLTtcbiAgICBmb3IoaT1uO2k+PTA7aS0tKSB7IHJldFtpXSA9IChpKmIrKG4taSkqYSkvbjsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZ2V0QmxvY2sgPSBmdW5jdGlvbiBnZXRCbG9jayh4LGZyb20sdG8pIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGZ1bmN0aW9uIGZvbyh4LGspIHtcbiAgICAgICAgdmFyIGksYSA9IGZyb21ba10sIG4gPSB0b1trXS1hLCByZXQgPSBBcnJheShuKTtcbiAgICAgICAgaWYoayA9PT0gcy5sZW5ndGgtMSkge1xuICAgICAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSB4W2krYV07IH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSBmb28oeFtpK2FdLGsrMSk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGZvbyh4LDApO1xufVxuXG5udW1lcmljLnNldEJsb2NrID0gZnVuY3Rpb24gc2V0QmxvY2soeCxmcm9tLHRvLEIpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGZ1bmN0aW9uIGZvbyh4LHksaykge1xuICAgICAgICB2YXIgaSxhID0gZnJvbVtrXSwgbiA9IHRvW2tdLWE7XG4gICAgICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZm9yKGk9bjtpPj0wO2ktLSkgeyB4W2krYV0gPSB5W2ldOyB9IH1cbiAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyBmb28oeFtpK2FdLHlbaV0saysxKTsgfVxuICAgIH1cbiAgICBmb28oeCxCLDApO1xuICAgIHJldHVybiB4O1xufVxuXG5udW1lcmljLmdldFJhbmdlID0gZnVuY3Rpb24gZ2V0UmFuZ2UoQSxJLEopIHtcbiAgICB2YXIgbSA9IEkubGVuZ3RoLCBuID0gSi5sZW5ndGg7XG4gICAgdmFyIGksajtcbiAgICB2YXIgQiA9IEFycmF5KG0pLCBCaSwgQUk7XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgQltpXSA9IEFycmF5KG4pO1xuICAgICAgICBCaSA9IEJbaV07XG4gICAgICAgIEFJID0gQVtJW2ldXTtcbiAgICAgICAgZm9yKGo9bi0xO2ohPT0tMTstLWopIEJpW2pdID0gQUlbSltqXV07XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxuXG5udW1lcmljLmJsb2NrTWF0cml4ID0gZnVuY3Rpb24gYmxvY2tNYXRyaXgoWCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oWCk7XG4gICAgaWYocy5sZW5ndGg8NCkgcmV0dXJuIG51bWVyaWMuYmxvY2tNYXRyaXgoW1hdKTtcbiAgICB2YXIgbT1zWzBdLG49c1sxXSxNLE4saSxqLFhpajtcbiAgICBNID0gMDsgTiA9IDA7XG4gICAgZm9yKGk9MDtpPG07KytpKSBNKz1YW2ldWzBdLmxlbmd0aDtcbiAgICBmb3Ioaj0wO2o8bjsrK2opIE4rPVhbMF1bal1bMF0ubGVuZ3RoO1xuICAgIHZhciBaID0gQXJyYXkoTSk7XG4gICAgZm9yKGk9MDtpPE07KytpKSBaW2ldID0gQXJyYXkoTik7XG4gICAgdmFyIEk9MCxKLFpJLGssbCxYaWprO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBKPU47XG4gICAgICAgIGZvcihqPW4tMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBYaWogPSBYW2ldW2pdO1xuICAgICAgICAgICAgSiAtPSBYaWpbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKGs9WGlqLmxlbmd0aC0xO2shPT0tMTstLWspIHtcbiAgICAgICAgICAgICAgICBYaWprID0gWGlqW2tdO1xuICAgICAgICAgICAgICAgIFpJID0gWltJK2tdO1xuICAgICAgICAgICAgICAgIGZvcihsID0gWGlqay5sZW5ndGgtMTtsIT09LTE7LS1sKSBaSVtKK2xdID0gWGlqa1tsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBJICs9IFhbaV1bMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gWjtcbn1cblxubnVtZXJpYy50ZW5zb3IgPSBmdW5jdGlvbiB0ZW5zb3IoeCx5KSB7XG4gICAgaWYodHlwZW9mIHggPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHJldHVybiBudW1lcmljLm11bCh4LHkpO1xuICAgIHZhciBzMSA9IG51bWVyaWMuZGltKHgpLCBzMiA9IG51bWVyaWMuZGltKHkpO1xuICAgIGlmKHMxLmxlbmd0aCAhPT0gMSB8fCBzMi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiB0ZW5zb3IgcHJvZHVjdCBpcyBvbmx5IGRlZmluZWQgZm9yIHZlY3RvcnMnKTtcbiAgICB9XG4gICAgdmFyIG0gPSBzMVswXSwgbiA9IHMyWzBdLCBBID0gQXJyYXkobSksIEFpLCBpLGoseGk7XG4gICAgZm9yKGk9bS0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQXJyYXkobik7XG4gICAgICAgIHhpID0geFtpXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTM7LS1qKSB7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEFpW2pdID0geGkgKiB5W2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShqPj0wKSB7IEFpW2pdID0geGkgKiB5W2pdOyAtLWo7IH1cbiAgICAgICAgQVtpXSA9IEFpO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxuLy8gMy4gVGhlIFRlbnNvciB0eXBlIFRcbm51bWVyaWMuVCA9IGZ1bmN0aW9uIFQoeCx5KSB7IHRoaXMueCA9IHg7IHRoaXMueSA9IHk7IH1cbm51bWVyaWMudCA9IGZ1bmN0aW9uIHQoeCx5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHgseSk7IH1cblxubnVtZXJpYy5UYmlub3AgPSBmdW5jdGlvbiBUYmlub3AocnIscmMsY3IsY2Msc2V0dXApIHtcbiAgICB2YXIgaW8gPSBudW1lcmljLmluZGV4T2Y7XG4gICAgaWYodHlwZW9mIHNldHVwICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBzZXR1cCA9ICcnO1xuICAgICAgICBmb3IoayBpbiBudW1lcmljKSB7XG4gICAgICAgICAgICBpZihudW1lcmljLmhhc093blByb3BlcnR5KGspICYmIChyci5pbmRleE9mKGspPj0wIHx8IHJjLmluZGV4T2Yoayk+PTAgfHwgY3IuaW5kZXhPZihrKT49MCB8fCBjYy5pbmRleE9mKGspPj0wKSAmJiBrLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICAgICAgc2V0dXAgKz0gJ3ZhciAnK2srJyA9IG51bWVyaWMuJytrKyc7XFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRnVuY3Rpb24oWyd5J10sXG4gICAgICAgICAgICAndmFyIHggPSB0aGlzO1xcbicrXG4gICAgICAgICAgICAnaWYoISh5IGluc3RhbmNlb2YgbnVtZXJpYy5UKSkgeyB5ID0gbmV3IG51bWVyaWMuVCh5KTsgfVxcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdpZih4LnkpIHsnK1xuICAgICAgICAgICAgJyAgaWYoeS55KSB7JytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIG5ldyBudW1lcmljLlQoJytjYysnKTtcXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICByZXR1cm4gbmV3IG51bWVyaWMuVCgnK2NyKycpO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnaWYoeS55KSB7XFxuJytcbiAgICAgICAgICAgICcgIHJldHVybiBuZXcgbnVtZXJpYy5UKCcrcmMrJyk7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVCgnK3JyKycpO1xcbidcbiAgICApO1xufVxuXG5udW1lcmljLlQucHJvdG90eXBlLmFkZCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnYWRkKHgueCx5LngpJyxcbiAgICAgICAgJ2FkZCh4LngseS54KSx5LnknLFxuICAgICAgICAnYWRkKHgueCx5LngpLHgueScsXG4gICAgICAgICdhZGQoeC54LHkueCksYWRkKHgueSx5LnkpJyk7XG5udW1lcmljLlQucHJvdG90eXBlLnN1YiA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnc3ViKHgueCx5LngpJyxcbiAgICAgICAgJ3N1Yih4LngseS54KSxuZWcoeS55KScsXG4gICAgICAgICdzdWIoeC54LHkueCkseC55JyxcbiAgICAgICAgJ3N1Yih4LngseS54KSxzdWIoeC55LHkueSknKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubXVsID0gbnVtZXJpYy5UYmlub3AoXG4gICAgICAgICdtdWwoeC54LHkueCknLFxuICAgICAgICAnbXVsKHgueCx5LngpLG11bCh4LngseS55KScsXG4gICAgICAgICdtdWwoeC54LHkueCksbXVsKHgueSx5LngpJyxcbiAgICAgICAgJ3N1YihtdWwoeC54LHkueCksbXVsKHgueSx5LnkpKSxhZGQobXVsKHgueCx5LnkpLG11bCh4LnkseS54KSknKTtcblxubnVtZXJpYy5ULnByb3RvdHlwZS5yZWNpcHJvY2FsID0gZnVuY3Rpb24gcmVjaXByb2NhbCgpIHtcbiAgICB2YXIgbXVsID0gbnVtZXJpYy5tdWwsIGRpdiA9IG51bWVyaWMuZGl2O1xuICAgIGlmKHRoaXMueSkge1xuICAgICAgICB2YXIgZCA9IG51bWVyaWMuYWRkKG11bCh0aGlzLngsdGhpcy54KSxtdWwodGhpcy55LHRoaXMueSkpO1xuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LGQpLGRpdihudW1lcmljLm5lZyh0aGlzLnkpLGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUKGRpdigxLHRoaXMueCkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYoeSkge1xuICAgIGlmKCEoeSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIHkgPSBuZXcgbnVtZXJpYy5UKHkpO1xuICAgIGlmKHkueSkgeyByZXR1cm4gdGhpcy5tdWwoeS5yZWNpcHJvY2FsKCkpOyB9XG4gICAgdmFyIGRpdiA9IG51bWVyaWMuZGl2O1xuICAgIGlmKHRoaXMueSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LHkueCksZGl2KHRoaXMueSx5LngpKTsgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpdih0aGlzLngseS54KSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmRvdCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnZG90KHgueCx5LngpJyxcbiAgICAgICAgJ2RvdCh4LngseS54KSxkb3QoeC54LHkueSknLFxuICAgICAgICAnZG90KHgueCx5LngpLGRvdCh4LnkseS54KScsXG4gICAgICAgICdzdWIoZG90KHgueCx5LngpLGRvdCh4LnkseS55KSksYWRkKGRvdCh4LngseS55KSxkb3QoeC55LHkueCkpJ1xuICAgICAgICApO1xubnVtZXJpYy5ULnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoKSB7XG4gICAgdmFyIHQgPSBudW1lcmljLnRyYW5zcG9zZSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHQoeCksdCh5KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUudHJhbnNqdWdhdGUgPSBmdW5jdGlvbiB0cmFuc2p1Z2F0ZSgpIHtcbiAgICB2YXIgdCA9IG51bWVyaWMudHJhbnNwb3NlLCB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSxudW1lcmljLm5lZ3RyYW5zcG9zZSh5KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpKTtcbn1cbm51bWVyaWMuVHVub3AgPSBmdW5jdGlvbiBUdW5vcChyLGMscykge1xuICAgIGlmKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7IHMgPSAnJzsgfVxuICAgIHJldHVybiBGdW5jdGlvbihcbiAgICAgICAgICAgICd2YXIgeCA9IHRoaXM7XFxuJytcbiAgICAgICAgICAgIHMrJ1xcbicrXG4gICAgICAgICAgICAnaWYoeC55KSB7JytcbiAgICAgICAgICAgICcgICcrYysnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICByKyc7XFxuJ1xuICAgICk7XG59XG5cbm51bWVyaWMuVC5wcm90b3R5cGUuZXhwID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKGV4KScsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChtdWwoY29zKHgueSksZXgpLG11bChzaW4oeC55KSxleCkpJyxcbiAgICAgICAgJ3ZhciBleCA9IG51bWVyaWMuZXhwKHgueCksIGNvcyA9IG51bWVyaWMuY29zLCBzaW4gPSBudW1lcmljLnNpbiwgbXVsID0gbnVtZXJpYy5tdWw7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmNvbmogPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoeC54KTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoeC54LG51bWVyaWMubmVnKHgueSkpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5uZWcgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobmVnKHgueCkpOycsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChuZWcoeC54KSxuZWcoeC55KSk7JyxcbiAgICAgICAgJ3ZhciBuZWcgPSBudW1lcmljLm5lZzsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuc2luID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuc2luKHgueCkpJyxcbiAgICAgICAgJ3JldHVybiB4LmV4cCgpLnN1Yih4Lm5lZygpLmV4cCgpKS5kaXYobmV3IG51bWVyaWMuVCgwLDIpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuY29zID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuY29zKHgueCkpJyxcbiAgICAgICAgJ3JldHVybiB4LmV4cCgpLmFkZCh4Lm5lZygpLmV4cCgpKS5kaXYoMik7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmFicyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmFicyh4LngpKTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5zcXJ0KG51bWVyaWMuYWRkKG11bCh4LngseC54KSxtdWwoeC55LHgueSkpKSk7JyxcbiAgICAgICAgJ3ZhciBtdWwgPSBudW1lcmljLm11bDsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubG9nID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMubG9nKHgueCkpOycsXG4gICAgICAgICd2YXIgdGhldGEgPSBuZXcgbnVtZXJpYy5UKG51bWVyaWMuYXRhbjIoeC55LHgueCkpLCByID0geC5hYnMoKTtcXG4nK1xuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5sb2coci54KSx0aGV0YS54KTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubm9ybTIgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG51bWVyaWMubm9ybTIoeC54KTsnLFxuICAgICAgICAndmFyIGYgPSBudW1lcmljLm5vcm0yU3F1YXJlZDtcXG4nK1xuICAgICAgICAncmV0dXJuIE1hdGguc3FydChmKHgueCkrZih4LnkpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuaW52ID0gZnVuY3Rpb24gaW52KCkge1xuICAgIHZhciBBID0gdGhpcztcbiAgICBpZih0eXBlb2YgQS55ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuaW52KEEueCkpOyB9XG4gICAgdmFyIG4gPSBBLngubGVuZ3RoLCBpLCBqLCBrO1xuICAgIHZhciBSeCA9IG51bWVyaWMuaWRlbnRpdHkobiksUnkgPSBudW1lcmljLnJlcChbbixuXSwwKTtcbiAgICB2YXIgQXggPSBudW1lcmljLmNsb25lKEEueCksIEF5ID0gbnVtZXJpYy5jbG9uZShBLnkpO1xuICAgIHZhciBBaXgsIEFpeSwgQWp4LCBBanksIFJpeCwgUml5LCBSangsIFJqeTtcbiAgICB2YXIgaSxqLGssZCxkMSxheCxheSxieCxieSx0ZW1wO1xuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICBheCA9IEF4W2ldW2ldOyBheSA9IEF5W2ldW2ldO1xuICAgICAgICBkID0gYXgqYXgrYXkqYXk7XG4gICAgICAgIGsgPSBpO1xuICAgICAgICBmb3Ioaj1pKzE7ajxuO2orKykge1xuICAgICAgICAgICAgYXggPSBBeFtqXVtpXTsgYXkgPSBBeVtqXVtpXTtcbiAgICAgICAgICAgIGQxID0gYXgqYXgrYXkqYXk7XG4gICAgICAgICAgICBpZihkMSA+IGQpIHsgaz1qOyBkID0gZDE7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihrIT09aSkge1xuICAgICAgICAgICAgdGVtcCA9IEF4W2ldOyBBeFtpXSA9IEF4W2tdOyBBeFtrXSA9IHRlbXA7XG4gICAgICAgICAgICB0ZW1wID0gQXlbaV07IEF5W2ldID0gQXlba107IEF5W2tdID0gdGVtcDtcbiAgICAgICAgICAgIHRlbXAgPSBSeFtpXTsgUnhbaV0gPSBSeFtrXTsgUnhba10gPSB0ZW1wO1xuICAgICAgICAgICAgdGVtcCA9IFJ5W2ldOyBSeVtpXSA9IFJ5W2tdOyBSeVtrXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgQWl4ID0gQXhbaV07IEFpeSA9IEF5W2ldO1xuICAgICAgICBSaXggPSBSeFtpXTsgUml5ID0gUnlbaV07XG4gICAgICAgIGF4ID0gQWl4W2ldOyBheSA9IEFpeVtpXTtcbiAgICAgICAgZm9yKGo9aSsxO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGJ4ID0gQWl4W2pdOyBieSA9IEFpeVtqXTtcbiAgICAgICAgICAgIEFpeFtqXSA9IChieCpheCtieSpheSkvZDtcbiAgICAgICAgICAgIEFpeVtqXSA9IChieSpheC1ieCpheSkvZDtcbiAgICAgICAgfVxuICAgICAgICBmb3Ioaj0wO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGJ4ID0gUml4W2pdOyBieSA9IFJpeVtqXTtcbiAgICAgICAgICAgIFJpeFtqXSA9IChieCpheCtieSpheSkvZDtcbiAgICAgICAgICAgIFJpeVtqXSA9IChieSpheC1ieCpheSkvZDtcbiAgICAgICAgfVxuICAgICAgICBmb3Ioaj1pKzE7ajxuO2orKykge1xuICAgICAgICAgICAgQWp4ID0gQXhbal07IEFqeSA9IEF5W2pdO1xuICAgICAgICAgICAgUmp4ID0gUnhbal07IFJqeSA9IFJ5W2pdO1xuICAgICAgICAgICAgYXggPSBBanhbaV07IGF5ID0gQWp5W2ldO1xuICAgICAgICAgICAgZm9yKGs9aSsxO2s8bjtrKyspIHtcbiAgICAgICAgICAgICAgICBieCA9IEFpeFtrXTsgYnkgPSBBaXlba107XG4gICAgICAgICAgICAgICAgQWp4W2tdIC09IGJ4KmF4LWJ5KmF5O1xuICAgICAgICAgICAgICAgIEFqeVtrXSAtPSBieSpheCtieCpheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihrPTA7azxuO2srKykge1xuICAgICAgICAgICAgICAgIGJ4ID0gUml4W2tdOyBieSA9IFJpeVtrXTtcbiAgICAgICAgICAgICAgICBSanhba10gLT0gYngqYXgtYnkqYXk7XG4gICAgICAgICAgICAgICAgUmp5W2tdIC09IGJ5KmF4K2J4KmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPjA7aS0tKSB7XG4gICAgICAgIFJpeCA9IFJ4W2ldOyBSaXkgPSBSeVtpXTtcbiAgICAgICAgZm9yKGo9aS0xO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBSanggPSBSeFtqXTsgUmp5ID0gUnlbal07XG4gICAgICAgICAgICBheCA9IEF4W2pdW2ldOyBheSA9IEF5W2pdW2ldO1xuICAgICAgICAgICAgZm9yKGs9bi0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICAgICAgYnggPSBSaXhba107IGJ5ID0gUml5W2tdO1xuICAgICAgICAgICAgICAgIFJqeFtrXSAtPSBheCpieCAtIGF5KmJ5O1xuICAgICAgICAgICAgICAgIFJqeVtrXSAtPSBheCpieSArIGF5KmJ4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKFJ4LFJ5KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGkpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgayA9IDAsIGlrLCBuID0gaS5sZW5ndGg7XG4gICAgaWYoeSkge1xuICAgICAgICB3aGlsZShrPG4pIHtcbiAgICAgICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgICAgIHkgPSB5W2lrXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh4LHkpO1xuICAgIH1cbiAgICB3aGlsZShrPG4pIHtcbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4ID0geFtpa107XG4gICAgICAgIGsrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoeCk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChpLHYpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgayA9IDAsIGlrLCBuID0gaS5sZW5ndGgsIHZ4ID0gdi54LCB2eSA9IHYueTtcbiAgICBpZihuPT09MCkge1xuICAgICAgICBpZih2eSkgeyB0aGlzLnkgPSB2eTsgfVxuICAgICAgICBlbHNlIGlmKHkpIHsgdGhpcy55ID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZih2eSkge1xuICAgICAgICBpZih5KSB7IC8qIG9rICovIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0oeCksMCk7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKGs8bi0xKSB7XG4gICAgICAgICAgICBpayA9IGlba107XG4gICAgICAgICAgICB4ID0geFtpa107XG4gICAgICAgICAgICB5ID0geVtpa107XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4W2lrXSA9IHZ4O1xuICAgICAgICB5W2lrXSA9IHZ5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYoeSkge1xuICAgICAgICB3aGlsZShrPG4tMSkge1xuICAgICAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICAgICAgeSA9IHlbaWtdO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeFtpa10gPSB2eDtcbiAgICAgICAgaWYodnggaW5zdGFuY2VvZiBBcnJheSkgeVtpa10gPSBudW1lcmljLnJlcChudW1lcmljLmRpbSh2eCksMCk7XG4gICAgICAgIGVsc2UgeVtpa10gPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2hpbGUoazxuLTEpIHtcbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4ID0geFtpa107XG4gICAgICAgIGsrKztcbiAgICB9XG4gICAgaWsgPSBpW2tdO1xuICAgIHhbaWtdID0gdng7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbiBnZXRSb3dzKGkwLGkxKSB7XG4gICAgdmFyIG4gPSBpMS1pMCsxLCBqO1xuICAgIHZhciByeCA9IEFycmF5KG4pLCByeSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnhbai1pMF0gPSB4W2pdOyB9XG4gICAgaWYoeSkge1xuICAgICAgICByeSA9IEFycmF5KG4pO1xuICAgICAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnlbai1pMF0gPSB5W2pdOyB9XG4gICAgICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHJ4LHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQocngpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXRSb3dzID0gZnVuY3Rpb24gc2V0Um93cyhpMCxpMSxBKSB7XG4gICAgdmFyIGo7XG4gICAgdmFyIHJ4ID0gdGhpcy54LCByeSA9IHRoaXMueSwgeCA9IEEueCwgeSA9IEEueTtcbiAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnhbal0gPSB4W2otaTBdOyB9XG4gICAgaWYoeSkge1xuICAgICAgICBpZighcnkpIHsgcnkgPSBudW1lcmljLnJlcChudW1lcmljLmRpbShyeCksMCk7IHRoaXMueSA9IHJ5OyB9XG4gICAgICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeVtqXSA9IHlbai1pMF07IH1cbiAgICB9IGVsc2UgaWYocnkpIHtcbiAgICAgICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ5W2pdID0gbnVtZXJpYy5yZXAoW3hbai1pMF0ubGVuZ3RoXSwwKTsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gZ2V0Um93KGspIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHhba10seVtrXSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh4W2tdKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0Um93ID0gZnVuY3Rpb24gc2V0Um93KGksdikge1xuICAgIHZhciByeCA9IHRoaXMueCwgcnkgPSB0aGlzLnksIHggPSB2LngsIHkgPSB2Lnk7XG4gICAgcnhbaV0gPSB4O1xuICAgIGlmKHkpIHtcbiAgICAgICAgaWYoIXJ5KSB7IHJ5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0ocngpLDApOyB0aGlzLnkgPSByeTsgfVxuICAgICAgICByeVtpXSA9IHk7XG4gICAgfSBlbHNlIGlmKHJ5KSB7XG4gICAgICAgIHJ5ID0gbnVtZXJpYy5yZXAoW3gubGVuZ3RoXSwwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiBnZXRCbG9jayhmcm9tLHRvKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGIgPSBudW1lcmljLmdldEJsb2NrO1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQoYih4LGZyb20sdG8pLGIoeSxmcm9tLHRvKSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChiKHgsZnJvbSx0bykpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXRCbG9jayA9IGZ1bmN0aW9uIHNldEJsb2NrKGZyb20sdG8sQSkge1xuICAgIGlmKCEoQSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIEEgPSBuZXcgbnVtZXJpYy5UKEEpO1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCBiID0gbnVtZXJpYy5zZXRCbG9jaywgQXggPSBBLngsIEF5ID0gQS55O1xuICAgIGlmKEF5KSB7XG4gICAgICAgIGlmKCF5KSB7IHRoaXMueSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHRoaXMpLDApOyB5ID0gdGhpcy55OyB9XG4gICAgICAgIGIoeCxmcm9tLHRvLEF4KTtcbiAgICAgICAgYih5LGZyb20sdG8sQXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYih4LGZyb20sdG8sQXgpO1xuICAgIGlmKHkpIGIoeSxmcm9tLHRvLG51bWVyaWMucmVwKG51bWVyaWMuZGltKEF4KSwwKSk7XG59XG5udW1lcmljLlQucmVwID0gZnVuY3Rpb24gcmVwKHMsdikge1xuICAgIHZhciBUID0gbnVtZXJpYy5UO1xuICAgIGlmKCEodiBpbnN0YW5jZW9mIFQpKSB2ID0gbmV3IFQodik7XG4gICAgdmFyIHggPSB2LngsIHkgPSB2LnksIHIgPSBudW1lcmljLnJlcDtcbiAgICBpZih5KSByZXR1cm4gbmV3IFQocihzLHgpLHIocyx5KSk7XG4gICAgcmV0dXJuIG5ldyBUKHIocyx4KSk7XG59XG5udW1lcmljLlQuZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIGlmKCEoZCBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIGQgPSBuZXcgbnVtZXJpYy5UKGQpO1xuICAgIHZhciB4ID0gZC54LCB5ID0gZC55LCBkaWFnID0gbnVtZXJpYy5kaWFnO1xuICAgIGlmKHkpIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpYWcoeCksZGlhZyh5KSk7XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoZGlhZyh4KSk7XG59XG5udW1lcmljLlQuZWlnID0gZnVuY3Rpb24gZWlnKCkge1xuICAgIGlmKHRoaXMueSkgeyB0aHJvdyBuZXcgRXJyb3IoJ2VpZzogbm90IGltcGxlbWVudGVkIGZvciBjb21wbGV4IG1hdHJpY2VzLicpOyB9XG4gICAgcmV0dXJuIG51bWVyaWMuZWlnKHRoaXMueCk7XG59XG5udW1lcmljLlQuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShuKSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuaWRlbnRpdHkobikpOyB9XG5udW1lcmljLlQucHJvdG90eXBlLmdldERpYWcgPSBmdW5jdGlvbiBnZXREaWFnKCkge1xuICAgIHZhciBuID0gbnVtZXJpYztcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbi5UKG4uZ2V0RGlhZyh4KSxuLmdldERpYWcoeSkpOyB9XG4gICAgcmV0dXJuIG5ldyBuLlQobi5nZXREaWFnKHgpKTtcbn1cblxuLy8gNC4gRWlnZW52YWx1ZXMgb2YgcmVhbCBtYXRyaWNlc1xuXG5udW1lcmljLmhvdXNlID0gZnVuY3Rpb24gaG91c2UoeCkge1xuICAgIHZhciB2ID0gbnVtZXJpYy5jbG9uZSh4KTtcbiAgICB2YXIgcyA9IHhbMF0gPj0gMCA/IDEgOiAtMTtcbiAgICB2YXIgYWxwaGEgPSBzKm51bWVyaWMubm9ybTIoeCk7XG4gICAgdlswXSArPSBhbHBoYTtcbiAgICB2YXIgZm9vID0gbnVtZXJpYy5ub3JtMih2KTtcbiAgICBpZihmb28gPT09IDApIHsgLyogdGhpcyBzaG91bGQgbm90IGhhcHBlbiAqLyB0aHJvdyBuZXcgRXJyb3IoJ2VpZzogaW50ZXJuYWwgZXJyb3InKTsgfVxuICAgIHJldHVybiBudW1lcmljLmRpdih2LGZvbyk7XG59XG5cbm51bWVyaWMudG9VcHBlckhlc3NlbmJlcmcgPSBmdW5jdGlvbiB0b1VwcGVySGVzc2VuYmVyZyhtZSkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0obWUpO1xuICAgIGlmKHMubGVuZ3RoICE9PSAyIHx8IHNbMF0gIT09IHNbMV0pIHsgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiB0b1VwcGVySGVzc2VuYmVyZygpIG9ubHkgd29ya3Mgb24gc3F1YXJlIG1hdHJpY2VzJyk7IH1cbiAgICB2YXIgbSA9IHNbMF0sIGksaixrLHgsdixBID0gbnVtZXJpYy5jbG9uZShtZSksQixDLEFpLENpLFEgPSBudW1lcmljLmlkZW50aXR5KG0pLFFpO1xuICAgIGZvcihqPTA7ajxtLTI7aisrKSB7XG4gICAgICAgIHggPSBBcnJheShtLWotMSk7XG4gICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IHhbaS1qLTFdID0gQVtpXVtqXTsgfVxuICAgICAgICBpZihudW1lcmljLm5vcm0yKHgpPjApIHtcbiAgICAgICAgICAgIHYgPSBudW1lcmljLmhvdXNlKHgpO1xuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soQSxbaisxLGpdLFttLTEsbS0xXSk7XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IEFpID0gQVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9ajtrPG07aysrKSBBaVtrXSAtPSAyKkNpW2stal07IH1cbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEEsWzAsaisxXSxbbS0xLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKG51bWVyaWMuZG90KEIsdiksdik7XG4gICAgICAgICAgICBmb3IoaT0wO2k8bTtpKyspIHsgQWkgPSBBW2ldOyBDaSA9IENbaV07IGZvcihrPWorMTtrPG07aysrKSBBaVtrXSAtPSAyKkNpW2stai0xXTsgfVxuICAgICAgICAgICAgQiA9IEFycmF5KG0tai0xKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSBCW2ktai0xXSA9IFFbaV07XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IFFpID0gUVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtIOkEsIFE6UX07XG59XG5cbm51bWVyaWMuZXBzaWxvbiA9IDIuMjIwNDQ2MDQ5MjUwMzEzZS0xNjtcblxubnVtZXJpYy5RUkZyYW5jaXMgPSBmdW5jdGlvbihILG1heGl0ZXIpIHtcbiAgICBpZih0eXBlb2YgbWF4aXRlciA9PT0gXCJ1bmRlZmluZWRcIikgeyBtYXhpdGVyID0gMTAwMDA7IH1cbiAgICBIID0gbnVtZXJpYy5jbG9uZShIKTtcbiAgICB2YXIgSDAgPSBudW1lcmljLmNsb25lKEgpO1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oSCksbT1zWzBdLHgsdixhLGIsYyxkLGRldCx0ciwgSGxvYywgUSA9IG51bWVyaWMuaWRlbnRpdHkobSksIFFpLCBIaSwgQiwgQywgQ2ksaSxqLGssaXRlcjtcbiAgICBpZihtPDMpIHsgcmV0dXJuIHtROlEsIEI6WyBbMCxtLTFdIF19OyB9XG4gICAgdmFyIGVwc2lsb24gPSBudW1lcmljLmVwc2lsb247XG4gICAgZm9yKGl0ZXI9MDtpdGVyPG1heGl0ZXI7aXRlcisrKSB7XG4gICAgICAgIGZvcihqPTA7ajxtLTE7aisrKSB7XG4gICAgICAgICAgICBpZihNYXRoLmFicyhIW2orMV1bal0pIDwgZXBzaWxvbiooTWF0aC5hYnMoSFtqXVtqXSkrTWF0aC5hYnMoSFtqKzFdW2orMV0pKSkge1xuICAgICAgICAgICAgICAgIHZhciBRSDEgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsWzAsMF0sW2osal0pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBRSDIgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsW2orMSxqKzFdLFttLTEsbS0xXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgQiA9IEFycmF5KGorMSk7XG4gICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1qO2krKykgeyBCW2ldID0gUVtpXTsgfVxuICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDEuUSxCKTtcbiAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWo7aSsrKSB7IFFbaV0gPSBDW2ldOyB9XG4gICAgICAgICAgICAgICAgQiA9IEFycmF5KG0tai0xKTtcbiAgICAgICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBCW2ktai0xXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgyLlEsQik7XG4gICAgICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgUVtpXSA9IENbaS1qLTFdOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtROlEsQjpRSDEuQi5jb25jYXQobnVtZXJpYy5hZGQoUUgyLkIsaisxKSl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGEgPSBIW20tMl1bbS0yXTsgYiA9IEhbbS0yXVttLTFdO1xuICAgICAgICBjID0gSFttLTFdW20tMl07IGQgPSBIW20tMV1bbS0xXTtcbiAgICAgICAgdHIgPSBhK2Q7XG4gICAgICAgIGRldCA9IChhKmQtYipjKTtcbiAgICAgICAgSGxvYyA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsMF0sIFsyLDJdKTtcbiAgICAgICAgaWYodHIqdHI+PTQqZGV0KSB7XG4gICAgICAgICAgICB2YXIgczEsczI7XG4gICAgICAgICAgICBzMSA9IDAuNSoodHIrTWF0aC5zcXJ0KHRyKnRyLTQqZGV0KSk7XG4gICAgICAgICAgICBzMiA9IDAuNSoodHItTWF0aC5zcXJ0KHRyKnRyLTQqZGV0KSk7XG4gICAgICAgICAgICBIbG9jID0gbnVtZXJpYy5hZGQobnVtZXJpYy5zdWIobnVtZXJpYy5kb3QoSGxvYyxIbG9jKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLm11bChIbG9jLHMxK3MyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5kaWFnKG51bWVyaWMucmVwKFszXSxzMSpzMikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhsb2MgPSBudW1lcmljLmFkZChudW1lcmljLnN1YihudW1lcmljLmRvdChIbG9jLEhsb2MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMubXVsKEhsb2MsdHIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLmRpYWcobnVtZXJpYy5yZXAoWzNdLGRldCkpKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gW0hsb2NbMF1bMF0sSGxvY1sxXVswXSxIbG9jWzJdWzBdXTtcbiAgICAgICAgdiA9IG51bWVyaWMuaG91c2UoeCk7XG4gICAgICAgIEIgPSBbSFswXSxIWzFdLEhbMl1dO1xuICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgZm9yKGk9MDtpPDM7aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz0wO2s8bTtrKyspIEhpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsMF0sW20tMSwyXSk7XG4gICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICBmb3IoaT0wO2k8bTtpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaV07IGZvcihrPTA7azwzO2srKykgSGlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICBCID0gW1FbMF0sUVsxXSxRWzJdXTtcbiAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgIGZvcihpPTA7aTwzO2krKykgeyBRaSA9IFFbaV07IENpID0gQ1tpXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIHZhciBKO1xuICAgICAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICAgICAgZm9yKGs9ajtrPD1qKzE7aysrKSB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoSFtrKzFdW2tdKSA8IGVwc2lsb24qKE1hdGguYWJzKEhba11ba10pK01hdGguYWJzKEhbaysxXVtrKzFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFFIMSA9IG51bWVyaWMuUVJGcmFuY2lzKG51bWVyaWMuZ2V0QmxvY2soSCxbMCwwXSxbayxrXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBRSDIgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsW2srMSxrKzFdLFttLTEsbS0xXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgICAgIEIgPSBBcnJheShrKzEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWs7aSsrKSB7IEJbaV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDEuUSxCKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1rO2krKykgeyBRW2ldID0gQ1tpXTsgfVxuICAgICAgICAgICAgICAgICAgICBCID0gQXJyYXkobS1rLTEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT1rKzE7aTxtO2krKykgeyBCW2ktay0xXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICAgICAgQyA9IG51bWVyaWMuZG90KFFIMi5RLEIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT1rKzE7aTxtO2krKykgeyBRW2ldID0gQ1tpLWstMV07IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtROlEsQjpRSDEuQi5jb25jYXQobnVtZXJpYy5hZGQoUUgyLkIsaysxKSl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEogPSBNYXRoLm1pbihtLTEsaiszKTtcbiAgICAgICAgICAgIHggPSBBcnJheShKLWopO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSB7IHhbaS1qLTFdID0gSFtpXVtqXTsgfVxuICAgICAgICAgICAgdiA9IG51bWVyaWMuaG91c2UoeCk7XG4gICAgICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhILCBbaisxLGpdLFtKLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz1qO2s8bTtrKyspIEhpW2tdIC09IDIqQ2lbay1qXTsgfVxuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsaisxXSxbbS0xLEpdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICAgICAgZm9yKGk9MDtpPG07aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz1qKzE7azw9SjtrKyspIEhpW2tdIC09IDIqQ2lbay1qLTFdOyB9XG4gICAgICAgICAgICBCID0gQXJyYXkoSi1qKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPD1KO2krKykgQltpLWotMV0gPSBRW2ldO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIHsgUWkgPSBRW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz0wO2s8bTtrKyspIFFpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IGVpZ2VudmFsdWUgaXRlcmF0aW9uIGRvZXMgbm90IGNvbnZlcmdlIC0tIGluY3JlYXNlIG1heGl0ZXI/Jyk7XG59XG5cbm51bWVyaWMuZWlnID0gZnVuY3Rpb24gZWlnKEEsbWF4aXRlcikge1xuICAgIHZhciBRSCA9IG51bWVyaWMudG9VcHBlckhlc3NlbmJlcmcoQSk7XG4gICAgdmFyIFFCID0gbnVtZXJpYy5RUkZyYW5jaXMoUUguSCxtYXhpdGVyKTtcbiAgICB2YXIgVCA9IG51bWVyaWMuVDtcbiAgICB2YXIgbiA9IEEubGVuZ3RoLGksayxmbGFnID0gZmFsc2UsQiA9IFFCLkIsSCA9IG51bWVyaWMuZG90KFFCLlEsbnVtZXJpYy5kb3QoUUguSCxudW1lcmljLnRyYW5zcG9zZShRQi5RKSkpO1xuICAgIHZhciBRID0gbmV3IFQobnVtZXJpYy5kb3QoUUIuUSxRSC5RKSksUTA7XG4gICAgdmFyIG0gPSBCLmxlbmd0aCxqO1xuICAgIHZhciBhLGIsYyxkLHAxLHAyLGRpc2MseCx5LHAscSxuMSxuMjtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICBmb3Ioaz0wO2s8bTtrKyspIHtcbiAgICAgICAgaSA9IEJba11bMF07XG4gICAgICAgIGlmKGkgPT09IEJba11bMV0pIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGogPSBpKzE7XG4gICAgICAgICAgICBhID0gSFtpXVtpXTtcbiAgICAgICAgICAgIGIgPSBIW2ldW2pdO1xuICAgICAgICAgICAgYyA9IEhbal1baV07XG4gICAgICAgICAgICBkID0gSFtqXVtqXTtcbiAgICAgICAgICAgIGlmKGIgPT09IDAgJiYgYyA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBwMSA9IC1hLWQ7XG4gICAgICAgICAgICBwMiA9IGEqZC1iKmM7XG4gICAgICAgICAgICBkaXNjID0gcDEqcDEtNCpwMjtcbiAgICAgICAgICAgIGlmKGRpc2M+PTApIHtcbiAgICAgICAgICAgICAgICBpZihwMTwwKSB4ID0gLTAuNSoocDEtc3FydChkaXNjKSk7XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgeCA9IC0wLjUqKHAxK3NxcnQoZGlzYykpO1xuICAgICAgICAgICAgICAgIG4xID0gKGEteCkqKGEteCkrYipiO1xuICAgICAgICAgICAgICAgIG4yID0gYypjKyhkLXgpKihkLXgpO1xuICAgICAgICAgICAgICAgIGlmKG4xPm4yKSB7XG4gICAgICAgICAgICAgICAgICAgIG4xID0gc3FydChuMSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYS14KS9uMTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IGIvbjE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBzcXJ0KG4yKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGMvbjI7XG4gICAgICAgICAgICAgICAgICAgIHEgPSAoZC14KS9uMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUTAgPSBuZXcgVChbW3EsLXBdLFtwLHFdXSk7XG4gICAgICAgICAgICAgICAgUS5zZXRSb3dzKGksaixRMC5kb3QoUS5nZXRSb3dzKGksaikpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IC0wLjUqcDE7XG4gICAgICAgICAgICAgICAgeSA9IDAuNSpzcXJ0KC1kaXNjKTtcbiAgICAgICAgICAgICAgICBuMSA9IChhLXgpKihhLXgpK2IqYjtcbiAgICAgICAgICAgICAgICBuMiA9IGMqYysoZC14KSooZC14KTtcbiAgICAgICAgICAgICAgICBpZihuMT5uMikge1xuICAgICAgICAgICAgICAgICAgICBuMSA9IHNxcnQobjEreSp5KTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChhLXgpL24xO1xuICAgICAgICAgICAgICAgICAgICBxID0gYi9uMTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHkgLz0gbjE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBzcXJ0KG4yK3kqeSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBjL24yO1xuICAgICAgICAgICAgICAgICAgICBxID0gKGQteCkvbjI7XG4gICAgICAgICAgICAgICAgICAgIHggPSB5L24yO1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUTAgPSBuZXcgVChbW3EsLXBdLFtwLHFdXSxbW3gseV0sW3ksLXhdXSk7XG4gICAgICAgICAgICAgICAgUS5zZXRSb3dzKGksaixRMC5kb3QoUS5nZXRSb3dzKGksaikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgUiA9IFEuZG90KEEpLmRvdChRLnRyYW5zanVnYXRlKCkpLCBuID0gQS5sZW5ndGgsIEUgPSBudW1lcmljLlQuaWRlbnRpdHkobik7XG4gICAgZm9yKGo9MDtqPG47aisrKSB7XG4gICAgICAgIGlmKGo+MCkge1xuICAgICAgICAgICAgZm9yKGs9ai0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIFJrID0gUi5nZXQoW2ssa10pLCBSaiA9IFIuZ2V0KFtqLGpdKTtcbiAgICAgICAgICAgICAgICBpZihudW1lcmljLm5lcShSay54LFJqLngpIHx8IG51bWVyaWMubmVxKFJrLnksUmoueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IFIuZ2V0Um93KGspLmdldEJsb2NrKFtrXSxbai0xXSk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBFLmdldFJvdyhqKS5nZXRCbG9jayhba10sW2otMV0pO1xuICAgICAgICAgICAgICAgICAgICBFLnNldChbaixrXSwoUi5nZXQoW2ssal0pLm5lZygpLnN1Yih4LmRvdCh5KSkpLmRpdihSay5zdWIoUmopKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgRS5zZXRSb3coaixFLmdldFJvdyhrKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3Ioaj0wO2o8bjtqKyspIHtcbiAgICAgICAgeCA9IEUuZ2V0Um93KGopO1xuICAgICAgICBFLnNldFJvdyhqLHguZGl2KHgubm9ybTIoKSkpO1xuICAgIH1cbiAgICBFID0gRS50cmFuc3Bvc2UoKTtcbiAgICBFID0gUS50cmFuc2p1Z2F0ZSgpLmRvdChFKTtcbiAgICByZXR1cm4geyBsYW1iZGE6Ui5nZXREaWFnKCksIEU6RSB9O1xufTtcblxuLy8gNS4gQ29tcHJlc3NlZCBDb2x1bW4gU3RvcmFnZSBtYXRyaWNlc1xubnVtZXJpYy5jY3NTcGFyc2UgPSBmdW5jdGlvbiBjY3NTcGFyc2UoQSkge1xuICAgIHZhciBtID0gQS5sZW5ndGgsbixmb28sIGksaiwgY291bnRzID0gW107XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZm9vID0gQVtpXTtcbiAgICAgICAgZm9yKGogaW4gZm9vKSB7XG4gICAgICAgICAgICBqID0gcGFyc2VJbnQoaik7XG4gICAgICAgICAgICB3aGlsZShqPj1jb3VudHMubGVuZ3RoKSBjb3VudHNbY291bnRzLmxlbmd0aF0gPSAwO1xuICAgICAgICAgICAgaWYoZm9vW2pdIT09MCkgY291bnRzW2pdKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG4gPSBjb3VudHMubGVuZ3RoO1xuICAgIHZhciBBaSA9IEFycmF5KG4rMSk7XG4gICAgQWlbMF0gPSAwO1xuICAgIGZvcihpPTA7aTxuOysraSkgQWlbaSsxXSA9IEFpW2ldICsgY291bnRzW2ldO1xuICAgIHZhciBBaiA9IEFycmF5KEFpW25dKSwgQXYgPSBBcnJheShBaVtuXSk7XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZm9vID0gQVtpXTtcbiAgICAgICAgZm9yKGogaW4gZm9vKSB7XG4gICAgICAgICAgICBpZihmb29bal0hPT0wKSB7XG4gICAgICAgICAgICAgICAgY291bnRzW2pdLS07XG4gICAgICAgICAgICAgICAgQWpbQWlbal0rY291bnRzW2pdXSA9IGk7XG4gICAgICAgICAgICAgICAgQXZbQWlbal0rY291bnRzW2pdXSA9IGZvb1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW0FpLEFqLEF2XTtcbn1cbm51bWVyaWMuY2NzRnVsbCA9IGZ1bmN0aW9uIGNjc0Z1bGwoQSkge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLCBzID0gbnVtZXJpYy5jY3NEaW0oQSksIG0gPSBzWzBdLCBuID0gc1sxXSwgaSxqLGowLGoxLGs7XG4gICAgdmFyIEIgPSBudW1lcmljLnJlcChbbSxuXSwwKTtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgajAgPSBBaVtpXTtcbiAgICAgICAgajEgPSBBaVtpKzFdO1xuICAgICAgICBmb3Ioaj1qMDtqPGoxOysraikgeyBCW0FqW2pdXVtpXSA9IEF2W2pdOyB9XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxubnVtZXJpYy5jY3NUU29sdmUgPSBmdW5jdGlvbiBjY3NUU29sdmUoQSxiLHgsYmoseGopIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG1heCA9IE1hdGgubWF4LG49MDtcbiAgICBpZih0eXBlb2YgYmogPT09IFwidW5kZWZpbmVkXCIpIHggPSBudW1lcmljLnJlcChbbV0sMCk7XG4gICAgaWYodHlwZW9mIGJqID09PSBcInVuZGVmaW5lZFwiKSBiaiA9IG51bWVyaWMubGluc3BhY2UoMCx4Lmxlbmd0aC0xKTtcbiAgICBpZih0eXBlb2YgeGogPT09IFwidW5kZWZpbmVkXCIpIHhqID0gW107XG4gICAgZnVuY3Rpb24gZGZzKGopIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmKHhbal0gIT09IDApIHJldHVybjtcbiAgICAgICAgeFtqXSA9IDE7XG4gICAgICAgIGZvcihrPUFpW2pdO2s8QWlbaisxXTsrK2spIGRmcyhBaltrXSk7XG4gICAgICAgIHhqW25dID0gajtcbiAgICAgICAgKytuO1xuICAgIH1cbiAgICB2YXIgaSxqLGowLGoxLGssbCxsMCxsMSxhO1xuICAgIGZvcihpPWJqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgZGZzKGJqW2ldKTsgfVxuICAgIHhqLmxlbmd0aCA9IG47XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyB4W3hqW2ldXSA9IDA7IH1cbiAgICBmb3IoaT1iai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IGogPSBialtpXTsgeFtqXSA9IGJbal07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgajAgPSBBaVtqXTtcbiAgICAgICAgajEgPSBtYXgoQWlbaisxXSxqMCk7XG4gICAgICAgIGZvcihrPWowO2shPT1qMTsrK2spIHsgaWYoQWpba10gPT09IGopIHsgeFtqXSAvPSBBdltrXTsgYnJlYWs7IH0gfVxuICAgICAgICBhID0geFtqXTtcbiAgICAgICAgZm9yKGs9ajA7ayE9PWoxOysraykge1xuICAgICAgICAgICAgbCA9IEFqW2tdO1xuICAgICAgICAgICAgaWYobCAhPT0gaikgeFtsXSAtPSBhKkF2W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxubnVtZXJpYy5jY3NERlMgPSBmdW5jdGlvbiBjY3NERlMobikge1xuICAgIHRoaXMuayA9IEFycmF5KG4pO1xuICAgIHRoaXMuazEgPSBBcnJheShuKTtcbiAgICB0aGlzLmogPSBBcnJheShuKTtcbn1cbm51bWVyaWMuY2NzREZTLnByb3RvdHlwZS5kZnMgPSBmdW5jdGlvbiBkZnMoSixBaSxBaix4LHhqLFBpbnYpIHtcbiAgICB2YXIgbSA9IDAsZm9vLG49eGoubGVuZ3RoO1xuICAgIHZhciBrID0gdGhpcy5rLCBrMSA9IHRoaXMuazEsIGogPSB0aGlzLmosa20sazExO1xuICAgIGlmKHhbSl0hPT0wKSByZXR1cm47XG4gICAgeFtKXSA9IDE7XG4gICAgalswXSA9IEo7XG4gICAga1swXSA9IGttID0gQWlbSl07XG4gICAgazFbMF0gPSBrMTEgPSBBaVtKKzFdO1xuICAgIHdoaWxlKDEpIHtcbiAgICAgICAgaWYoa20gPj0gazExKSB7XG4gICAgICAgICAgICB4altuXSA9IGpbbV07XG4gICAgICAgICAgICBpZihtPT09MCkgcmV0dXJuO1xuICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgLS1tO1xuICAgICAgICAgICAga20gPSBrW21dO1xuICAgICAgICAgICAgazExID0gazFbbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb28gPSBQaW52W0FqW2ttXV07XG4gICAgICAgICAgICBpZih4W2Zvb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICB4W2Zvb10gPSAxO1xuICAgICAgICAgICAgICAgIGtbbV0gPSBrbTtcbiAgICAgICAgICAgICAgICArK207XG4gICAgICAgICAgICAgICAgalttXSA9IGZvbztcbiAgICAgICAgICAgICAgICBrbSA9IEFpW2Zvb107XG4gICAgICAgICAgICAgICAgazFbbV0gPSBrMTEgPSBBaVtmb28rMV07XG4gICAgICAgICAgICB9IGVsc2UgKytrbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm51bWVyaWMuY2NzTFBTb2x2ZSA9IGZ1bmN0aW9uIGNjc0xQU29sdmUoQSxCLHgseGosSSxQaW52LGRmcykge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLG0gPSBBaS5sZW5ndGgtMSwgbj0wO1xuICAgIHZhciBCaSA9IEJbMF0sIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIFxuICAgIHZhciBpLGkwLGkxLGosSixqMCxqMSxrLGwsbDAsbDEsYTtcbiAgICBpMCA9IEJpW0ldO1xuICAgIGkxID0gQmlbSSsxXTtcbiAgICB4ai5sZW5ndGggPSAwO1xuICAgIGZvcihpPWkwO2k8aTE7KytpKSB7IGRmcy5kZnMoUGludltCaltpXV0sQWksQWoseCx4aixQaW52KTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgeFt4altpXV0gPSAwOyB9XG4gICAgZm9yKGk9aTA7aSE9PWkxOysraSkgeyBqID0gUGludltCaltpXV07IHhbal0gPSBCdltpXTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgaiA9IHhqW2ldO1xuICAgICAgICBqMCA9IEFpW2pdO1xuICAgICAgICBqMSA9IEFpW2orMV07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7IGlmKFBpbnZbQWpba11dID09PSBqKSB7IHhbal0gLz0gQXZba107IGJyZWFrOyB9IH1cbiAgICAgICAgYSA9IHhbal07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7XG4gICAgICAgICAgICBsID0gUGludltBaltrXV07XG4gICAgICAgICAgICBpZihsICE9PSBqKSB4W2xdIC09IGEqQXZba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5udW1lcmljLmNjc0xVUDEgPSBmdW5jdGlvbiBjY3NMVVAxKEEsdGhyZXNob2xkKSB7XG4gICAgdmFyIG0gPSBBWzBdLmxlbmd0aC0xO1xuICAgIHZhciBMID0gW251bWVyaWMucmVwKFttKzFdLDApLFtdLFtdXSwgVSA9IFtudW1lcmljLnJlcChbbSsxXSwgMCksW10sW11dO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdLCBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLCB4aiA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICB2YXIgaSxqLGssajAsajEsYSxlLGMsZCxLO1xuICAgIHZhciBzb2wgPSBudW1lcmljLmNjc0xQU29sdmUsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgUCA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpLFBpbnYgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTtcbiAgICB2YXIgZGZzID0gbmV3IG51bWVyaWMuY2NzREZTKG0pO1xuICAgIGlmKHR5cGVvZiB0aHJlc2hvbGQgPT09IFwidW5kZWZpbmVkXCIpIHsgdGhyZXNob2xkID0gMTsgfVxuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBzb2woTCxBLHgseGosaSxQaW52LGRmcyk7XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZSA9IC0xO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBpZihrIDw9IGkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYyA9IGFicyh4W2tdKTtcbiAgICAgICAgICAgIGlmKGMgPiBhKSB7IGUgPSBrOyBhID0gYzsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFicyh4W2ldKTx0aHJlc2hvbGQqYSkge1xuICAgICAgICAgICAgaiA9IFBbaV07XG4gICAgICAgICAgICBhID0gUFtlXTtcbiAgICAgICAgICAgIFBbaV0gPSBhOyBQaW52W2FdID0gaTtcbiAgICAgICAgICAgIFBbZV0gPSBqOyBQaW52W2pdID0gZTtcbiAgICAgICAgICAgIGEgPSB4W2ldOyB4W2ldID0geFtlXTsgeFtlXSA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IExpW2ldO1xuICAgICAgICBlID0gVWlbaV07XG4gICAgICAgIGQgPSB4W2ldO1xuICAgICAgICBMalthXSA9IFBbaV07XG4gICAgICAgIEx2W2FdID0gMTtcbiAgICAgICAgKythO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBjID0geFtrXTtcbiAgICAgICAgICAgIHhqW2pdID0gMDtcbiAgICAgICAgICAgIHhba10gPSAwO1xuICAgICAgICAgICAgaWYoazw9aSkgeyBValtlXSA9IGs7IFV2W2VdID0gYzsgICArK2U7IH1cbiAgICAgICAgICAgIGVsc2UgICAgIHsgTGpbYV0gPSBQW2tdOyBMdlthXSA9IGMvZDsgKythOyB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbaSsxXSA9IGE7XG4gICAgICAgIFVpW2krMV0gPSBlO1xuICAgIH1cbiAgICBmb3Ioaj1Mai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7IExqW2pdID0gUGludltMaltqXV07IH1cbiAgICByZXR1cm4ge0w6TCwgVTpVLCBQOlAsIFBpbnY6UGludn07XG59XG5udW1lcmljLmNjc0RGUzAgPSBmdW5jdGlvbiBjY3NERlMwKG4pIHtcbiAgICB0aGlzLmsgPSBBcnJheShuKTtcbiAgICB0aGlzLmsxID0gQXJyYXkobik7XG4gICAgdGhpcy5qID0gQXJyYXkobik7XG59XG5udW1lcmljLmNjc0RGUzAucHJvdG90eXBlLmRmcyA9IGZ1bmN0aW9uIGRmcyhKLEFpLEFqLHgseGosUGludixQKSB7XG4gICAgdmFyIG0gPSAwLGZvbyxuPXhqLmxlbmd0aDtcbiAgICB2YXIgayA9IHRoaXMuaywgazEgPSB0aGlzLmsxLCBqID0gdGhpcy5qLGttLGsxMTtcbiAgICBpZih4W0pdIT09MCkgcmV0dXJuO1xuICAgIHhbSl0gPSAxO1xuICAgIGpbMF0gPSBKO1xuICAgIGtbMF0gPSBrbSA9IEFpW1BpbnZbSl1dO1xuICAgIGsxWzBdID0gazExID0gQWlbUGludltKXSsxXTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIGlmKGlzTmFOKGttKSkgdGhyb3cgbmV3IEVycm9yKFwiT3chXCIpO1xuICAgICAgICBpZihrbSA+PSBrMTEpIHtcbiAgICAgICAgICAgIHhqW25dID0gUGludltqW21dXTtcbiAgICAgICAgICAgIGlmKG09PT0wKSByZXR1cm47XG4gICAgICAgICAgICArK247XG4gICAgICAgICAgICAtLW07XG4gICAgICAgICAgICBrbSA9IGtbbV07XG4gICAgICAgICAgICBrMTEgPSBrMVttXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvbyA9IEFqW2ttXTtcbiAgICAgICAgICAgIGlmKHhbZm9vXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHhbZm9vXSA9IDE7XG4gICAgICAgICAgICAgICAga1ttXSA9IGttO1xuICAgICAgICAgICAgICAgICsrbTtcbiAgICAgICAgICAgICAgICBqW21dID0gZm9vO1xuICAgICAgICAgICAgICAgIGZvbyA9IFBpbnZbZm9vXTtcbiAgICAgICAgICAgICAgICBrbSA9IEFpW2Zvb107XG4gICAgICAgICAgICAgICAgazFbbV0gPSBrMTEgPSBBaVtmb28rMV07XG4gICAgICAgICAgICB9IGVsc2UgKytrbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm51bWVyaWMuY2NzTFBTb2x2ZTAgPSBmdW5jdGlvbiBjY3NMUFNvbHZlMChBLEIseSx4aixJLFBpbnYsUCxkZnMpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG49MDtcbiAgICB2YXIgQmkgPSBCWzBdLCBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICBcbiAgICB2YXIgaSxpMCxpMSxqLEosajAsajEsayxsLGwwLGwxLGE7XG4gICAgaTAgPSBCaVtJXTtcbiAgICBpMSA9IEJpW0krMV07XG4gICAgeGoubGVuZ3RoID0gMDtcbiAgICBmb3IoaT1pMDtpPGkxOysraSkgeyBkZnMuZGZzKEJqW2ldLEFpLEFqLHkseGosUGludixQKTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgaiA9IHhqW2ldOyB5W1Bbal1dID0gMDsgfVxuICAgIGZvcihpPWkwO2khPT1pMTsrK2kpIHsgaiA9IEJqW2ldOyB5W2pdID0gQnZbaV07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgbCA9IFBbal07XG4gICAgICAgIGowID0gQWlbal07XG4gICAgICAgIGoxID0gQWlbaisxXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHsgaWYoQWpba10gPT09IGwpIHsgeVtsXSAvPSBBdltrXTsgYnJlYWs7IH0gfVxuICAgICAgICBhID0geVtsXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHlbQWpba11dIC09IGEqQXZba107XG4gICAgICAgIHlbbF0gPSBhO1xuICAgIH1cbn1cbm51bWVyaWMuY2NzTFVQMCA9IGZ1bmN0aW9uIGNjc0xVUDAoQSx0aHJlc2hvbGQpIHtcbiAgICB2YXIgbSA9IEFbMF0ubGVuZ3RoLTE7XG4gICAgdmFyIEwgPSBbbnVtZXJpYy5yZXAoW20rMV0sMCksW10sW11dLCBVID0gW251bWVyaWMucmVwKFttKzFdLCAwKSxbXSxbXV07XG4gICAgdmFyIExpID0gTFswXSwgTGogPSBMWzFdLCBMdiA9IExbMl0sIFVpID0gVVswXSwgVWogPSBVWzFdLCBVdiA9IFVbMl07XG4gICAgdmFyIHkgPSBudW1lcmljLnJlcChbbV0sMCksIHhqID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIHZhciBpLGosayxqMCxqMSxhLGUsYyxkLEs7XG4gICAgdmFyIHNvbCA9IG51bWVyaWMuY2NzTFBTb2x2ZTAsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgUCA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpLFBpbnYgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTtcbiAgICB2YXIgZGZzID0gbmV3IG51bWVyaWMuY2NzREZTMChtKTtcbiAgICBpZih0eXBlb2YgdGhyZXNob2xkID09PSBcInVuZGVmaW5lZFwiKSB7IHRocmVzaG9sZCA9IDE7IH1cbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgc29sKEwsQSx5LHhqLGksUGludixQLGRmcyk7XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZSA9IC0xO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBpZihrIDw9IGkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYyA9IGFicyh5W1Bba11dKTtcbiAgICAgICAgICAgIGlmKGMgPiBhKSB7IGUgPSBrOyBhID0gYzsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFicyh5W1BbaV1dKTx0aHJlc2hvbGQqYSkge1xuICAgICAgICAgICAgaiA9IFBbaV07XG4gICAgICAgICAgICBhID0gUFtlXTtcbiAgICAgICAgICAgIFBbaV0gPSBhOyBQaW52W2FdID0gaTtcbiAgICAgICAgICAgIFBbZV0gPSBqOyBQaW52W2pdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBhID0gTGlbaV07XG4gICAgICAgIGUgPSBVaVtpXTtcbiAgICAgICAgZCA9IHlbUFtpXV07XG4gICAgICAgIExqW2FdID0gUFtpXTtcbiAgICAgICAgTHZbYV0gPSAxO1xuICAgICAgICArK2E7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIGsgPSB4altqXTtcbiAgICAgICAgICAgIGMgPSB5W1Bba11dO1xuICAgICAgICAgICAgeGpbal0gPSAwO1xuICAgICAgICAgICAgeVtQW2tdXSA9IDA7XG4gICAgICAgICAgICBpZihrPD1pKSB7IFVqW2VdID0gazsgVXZbZV0gPSBjOyAgICsrZTsgfVxuICAgICAgICAgICAgZWxzZSAgICAgeyBMalthXSA9IFBba107IEx2W2FdID0gYy9kOyArK2E7IH1cbiAgICAgICAgfVxuICAgICAgICBMaVtpKzFdID0gYTtcbiAgICAgICAgVWlbaSsxXSA9IGU7XG4gICAgfVxuICAgIGZvcihqPUxqLmxlbmd0aC0xO2ohPT0tMTstLWopIHsgTGpbal0gPSBQaW52W0xqW2pdXTsgfVxuICAgIHJldHVybiB7TDpMLCBVOlUsIFA6UCwgUGludjpQaW52fTtcbn1cbm51bWVyaWMuY2NzTFVQID0gbnVtZXJpYy5jY3NMVVAwO1xuXG5udW1lcmljLmNjc0RpbSA9IGZ1bmN0aW9uIGNjc0RpbShBKSB7IHJldHVybiBbbnVtZXJpYy5zdXAoQVsxXSkrMSxBWzBdLmxlbmd0aC0xXTsgfVxubnVtZXJpYy5jY3NHZXRCbG9jayA9IGZ1bmN0aW9uIGNjc0dldEJsb2NrKEEsaSxqKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmNjc0RpbShBKSxtPXNbMF0sbj1zWzFdO1xuICAgIGlmKHR5cGVvZiBpID09PSBcInVuZGVmaW5lZFwiKSB7IGkgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTsgfVxuICAgIGVsc2UgaWYodHlwZW9mIGkgPT09IFwibnVtYmVyXCIpIHsgaSA9IFtpXTsgfVxuICAgIGlmKHR5cGVvZiBqID09PSBcInVuZGVmaW5lZFwiKSB7IGogPSBudW1lcmljLmxpbnNwYWNlKDAsbi0xKTsgfVxuICAgIGVsc2UgaWYodHlwZW9mIGogPT09IFwibnVtYmVyXCIpIHsgaiA9IFtqXTsgfVxuICAgIHZhciBwLHAwLHAxLFAgPSBpLmxlbmd0aCxxLFEgPSBqLmxlbmd0aCxyLGpxLGlwO1xuICAgIHZhciBCaSA9IG51bWVyaWMucmVwKFtuXSwwKSwgQmo9W10sIEJ2PVtdLCBCID0gW0JpLEJqLEJ2XTtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSxjb3VudD0wLGZsYWdzID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIGZvcihxPTA7cTxROysrcSkge1xuICAgICAgICBqcSA9IGpbcV07XG4gICAgICAgIHZhciBxMCA9IEFpW2pxXTtcbiAgICAgICAgdmFyIHExID0gQWlbanErMV07XG4gICAgICAgIGZvcihwPXEwO3A8cTE7KytwKSB7XG4gICAgICAgICAgICByID0gQWpbcF07XG4gICAgICAgICAgICBmbGFnc1tyXSA9IDE7XG4gICAgICAgICAgICB4W3JdID0gQXZbcF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHA9MDtwPFA7KytwKSB7XG4gICAgICAgICAgICBpcCA9IGlbcF07XG4gICAgICAgICAgICBpZihmbGFnc1tpcF0pIHtcbiAgICAgICAgICAgICAgICBCaltjb3VudF0gPSBwO1xuICAgICAgICAgICAgICAgIEJ2W2NvdW50XSA9IHhbaVtwXV07XG4gICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IocD1xMDtwPHExOysrcCkge1xuICAgICAgICAgICAgciA9IEFqW3BdO1xuICAgICAgICAgICAgZmxhZ3Nbcl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIEJpW3ErMV0gPSBjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIEI7XG59XG5cbm51bWVyaWMuY2NzRG90ID0gZnVuY3Rpb24gY2NzRG90KEEsQikge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciBCaSA9IEJbMF0sIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIHZhciBzQSA9IG51bWVyaWMuY2NzRGltKEEpLCBzQiA9IG51bWVyaWMuY2NzRGltKEIpO1xuICAgIHZhciBtID0gc0FbMF0sIG4gPSBzQVsxXSwgbyA9IHNCWzFdO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLCBmbGFncyA9IG51bWVyaWMucmVwKFttXSwwKSwgeGogPSBBcnJheShtKTtcbiAgICB2YXIgQ2kgPSBudW1lcmljLnJlcChbb10sMCksIENqID0gW10sIEN2ID0gW10sIEMgPSBbQ2ksQ2osQ3ZdO1xuICAgIHZhciBpLGosayxqMCxqMSxpMCxpMSxsLHAsYSxiO1xuICAgIGZvcihrPTA7ayE9PW87KytrKSB7XG4gICAgICAgIGowID0gQmlba107XG4gICAgICAgIGoxID0gQmlbaysxXTtcbiAgICAgICAgcCA9IDA7XG4gICAgICAgIGZvcihqPWowO2o8ajE7KytqKSB7XG4gICAgICAgICAgICBhID0gQmpbal07XG4gICAgICAgICAgICBiID0gQnZbal07XG4gICAgICAgICAgICBpMCA9IEFpW2FdO1xuICAgICAgICAgICAgaTEgPSBBaVthKzFdO1xuICAgICAgICAgICAgZm9yKGk9aTA7aTxpMTsrK2kpIHtcbiAgICAgICAgICAgICAgICBsID0gQWpbaV07XG4gICAgICAgICAgICAgICAgaWYoZmxhZ3NbbF09PT0wKSB7XG4gICAgICAgICAgICAgICAgICAgIHhqW3BdID0gbDtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbbF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBwID0gcCsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4W2xdID0geFtsXSArIEF2W2ldKmI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgajAgPSBDaVtrXTtcbiAgICAgICAgajEgPSBqMCtwO1xuICAgICAgICBDaVtrKzFdID0gajE7XG4gICAgICAgIGZvcihqPXAtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBiID0gajArajtcbiAgICAgICAgICAgIGkgPSB4altqXTtcbiAgICAgICAgICAgIENqW2JdID0gaTtcbiAgICAgICAgICAgIEN2W2JdID0geFtpXTtcbiAgICAgICAgICAgIGZsYWdzW2ldID0gMDtcbiAgICAgICAgICAgIHhbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIENpW2srMV0gPSBDaVtrXStwO1xuICAgIH1cbiAgICByZXR1cm4gQztcbn1cblxubnVtZXJpYy5jY3NMVVBTb2x2ZSA9IGZ1bmN0aW9uIGNjc0xVUFNvbHZlKExVUCxCKSB7XG4gICAgdmFyIEwgPSBMVVAuTCwgVSA9IExVUC5VLCBQID0gTFVQLlA7XG4gICAgdmFyIEJpID0gQlswXTtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIGlmKHR5cGVvZiBCaSAhPT0gXCJvYmplY3RcIikgeyBCID0gW1swLEIubGVuZ3RoXSxudW1lcmljLmxpbnNwYWNlKDAsQi5sZW5ndGgtMSksQl07IEJpID0gQlswXTsgZmxhZyA9IHRydWU7IH1cbiAgICB2YXIgQmogPSBCWzFdLCBCdiA9IEJbMl07XG4gICAgdmFyIG4gPSBMWzBdLmxlbmd0aC0xLCBtID0gQmkubGVuZ3RoLTE7XG4gICAgdmFyIHggPSBudW1lcmljLnJlcChbbl0sMCksIHhqID0gQXJyYXkobik7XG4gICAgdmFyIGIgPSBudW1lcmljLnJlcChbbl0sMCksIGJqID0gQXJyYXkobik7XG4gICAgdmFyIFhpID0gbnVtZXJpYy5yZXAoW20rMV0sMCksIFhqID0gW10sIFh2ID0gW107XG4gICAgdmFyIHNvbCA9IG51bWVyaWMuY2NzVFNvbHZlO1xuICAgIHZhciBpLGosajAsajEsayxKLE49MDtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIGowID0gQmlbaV07XG4gICAgICAgIGoxID0gQmlbaSsxXTtcbiAgICAgICAgZm9yKGo9ajA7ajxqMTsrK2opIHsgXG4gICAgICAgICAgICBKID0gTFVQLlBpbnZbQmpbal1dO1xuICAgICAgICAgICAgYmpba10gPSBKO1xuICAgICAgICAgICAgYltKXSA9IEJ2W2pdO1xuICAgICAgICAgICAgKytrO1xuICAgICAgICB9XG4gICAgICAgIGJqLmxlbmd0aCA9IGs7XG4gICAgICAgIHNvbChMLGIseCxiaix4aik7XG4gICAgICAgIGZvcihqPWJqLmxlbmd0aC0xO2ohPT0tMTstLWopIGJbYmpbal1dID0gMDtcbiAgICAgICAgc29sKFUseCxiLHhqLGJqKTtcbiAgICAgICAgaWYoZmxhZykgcmV0dXJuIGI7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHhbeGpbal1dID0gMDtcbiAgICAgICAgZm9yKGo9YmoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgSiA9IGJqW2pdO1xuICAgICAgICAgICAgWGpbTl0gPSBKO1xuICAgICAgICAgICAgWHZbTl0gPSBiW0pdO1xuICAgICAgICAgICAgYltKXSA9IDA7XG4gICAgICAgICAgICArK047XG4gICAgICAgIH1cbiAgICAgICAgWGlbaSsxXSA9IE47XG4gICAgfVxuICAgIHJldHVybiBbWGksWGosWHZdO1xufVxuXG5udW1lcmljLmNjc2Jpbm9wID0gZnVuY3Rpb24gY2NzYmlub3AoYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgc2V0dXA9Jyc7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdYJywnWScsXG4gICAgICAgICAgICAndmFyIFhpID0gWFswXSwgWGogPSBYWzFdLCBYdiA9IFhbMl07XFxuJytcbiAgICAgICAgICAgICd2YXIgWWkgPSBZWzBdLCBZaiA9IFlbMV0sIFl2ID0gWVsyXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBuID0gWGkubGVuZ3RoLTEsbSA9IE1hdGgubWF4KG51bWVyaWMuc3VwKFhqKSxudW1lcmljLnN1cChZaikpKzE7XFxuJytcbiAgICAgICAgICAgICd2YXIgWmkgPSBudW1lcmljLnJlcChbbisxXSwwKSwgWmogPSBbXSwgWnYgPSBbXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLHkgPSBudW1lcmljLnJlcChbbV0sMCk7XFxuJytcbiAgICAgICAgICAgICd2YXIgeGsseWssems7XFxuJytcbiAgICAgICAgICAgICd2YXIgaSxqLGowLGoxLGsscD0wO1xcbicrXG4gICAgICAgICAgICBzZXR1cCtcbiAgICAgICAgICAgICdmb3IoaT0wO2k8bjsrK2kpIHtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBYaVtpXTsgajEgPSBYaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgayA9IFhqW2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIHhba10gPSAxO1xcbicrXG4gICAgICAgICAgICAnICAgIFpqW3BdID0gaztcXG4nK1xuICAgICAgICAgICAgJyAgICArK3A7XFxuJytcbiAgICAgICAgICAgICcgIH1cXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBZaVtpXTsgajEgPSBZaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgayA9IFlqW2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIHlba10gPSBZdltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICBpZih4W2tdID09PSAwKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgICBaaltwXSA9IGs7XFxuJytcbiAgICAgICAgICAgICcgICAgICArK3A7XFxuJytcbiAgICAgICAgICAgICcgICAgfVxcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIFppW2krMV0gPSBwO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFhpW2ldOyBqMSA9IFhpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHhbWGpbal1dID0gWHZbal07XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWmlbaV07IGoxID0gWmlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikge1xcbicrXG4gICAgICAgICAgICAnICAgIGsgPSBaaltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB4ayA9IHhba107XFxuJytcbiAgICAgICAgICAgICcgICAgeWsgPSB5W2tdO1xcbicrXG4gICAgICAgICAgICBib2R5KydcXG4nK1xuICAgICAgICAgICAgJyAgICBadltqXSA9IHprO1xcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWGlbaV07IGoxID0gWGlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikgeFtYaltqXV0gPSAwO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFlpW2ldOyBqMSA9IFlpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHlbWWpbal1dID0gMDtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiBbWmksWmosWnZdOydcbiAgICAgICAgICAgICk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGssQSxCLEM7XG4gICAgZm9yKGsgaW4gbnVtZXJpYy5vcHMyKSB7XG4gICAgICAgIGlmKGlzRmluaXRlKGV2YWwoJzEnK251bWVyaWMub3BzMltrXSsnMCcpKSkgQSA9ICdbWVswXSxZWzFdLG51bWVyaWMuJytrKycoWCxZWzJdKV0nO1xuICAgICAgICBlbHNlIEEgPSAnTmFOJztcbiAgICAgICAgaWYoaXNGaW5pdGUoZXZhbCgnMCcrbnVtZXJpYy5vcHMyW2tdKycxJykpKSBCID0gJ1tYWzBdLFhbMV0sbnVtZXJpYy4nK2srJyhYWzJdLFkpXSc7XG4gICAgICAgIGVsc2UgQiA9ICdOYU4nO1xuICAgICAgICBpZihpc0Zpbml0ZShldmFsKCcxJytudW1lcmljLm9wczJba10rJzAnKSkgJiYgaXNGaW5pdGUoZXZhbCgnMCcrbnVtZXJpYy5vcHMyW2tdKycxJykpKSBDID0gJ251bWVyaWMuY2NzJytrKydNTShYLFkpJztcbiAgICAgICAgZWxzZSBDID0gJ05hTic7XG4gICAgICAgIG51bWVyaWNbJ2NjcycraysnTU0nXSA9IG51bWVyaWMuY2NzYmlub3AoJ3prID0geGsgJytudW1lcmljLm9wczJba10rJ3lrOycpO1xuICAgICAgICBudW1lcmljWydjY3MnK2tdID0gRnVuY3Rpb24oJ1gnLCdZJyxcbiAgICAgICAgICAgICAgICAnaWYodHlwZW9mIFggPT09IFwibnVtYmVyXCIpIHJldHVybiAnK0ErJztcXG4nK1xuICAgICAgICAgICAgICAgICdpZih0eXBlb2YgWSA9PT0gXCJudW1iZXJcIikgcmV0dXJuICcrQisnO1xcbicrXG4gICAgICAgICAgICAgICAgJ3JldHVybiAnK0MrJztcXG4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICB9XG59KCkpO1xuXG5udW1lcmljLmNjc1NjYXR0ZXIgPSBmdW5jdGlvbiBjY3NTY2F0dGVyKEEpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgbiA9IG51bWVyaWMuc3VwKEFqKSsxLG09QWkubGVuZ3RoO1xuICAgIHZhciBSaSA9IG51bWVyaWMucmVwKFtuXSwwKSxSaj1BcnJheShtKSwgUnYgPSBBcnJheShtKTtcbiAgICB2YXIgY291bnRzID0gbnVtZXJpYy5yZXAoW25dLDApLGk7XG4gICAgZm9yKGk9MDtpPG07KytpKSBjb3VudHNbQWpbaV1dKys7XG4gICAgZm9yKGk9MDtpPG47KytpKSBSaVtpKzFdID0gUmlbaV0gKyBjb3VudHNbaV07XG4gICAgdmFyIHB0ciA9IFJpLnNsaWNlKDApLGssQWlpO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBBaWkgPSBBaltpXTtcbiAgICAgICAgayA9IHB0cltBaWldO1xuICAgICAgICBSaltrXSA9IEFpW2ldO1xuICAgICAgICBSdltrXSA9IEF2W2ldO1xuICAgICAgICBwdHJbQWlpXT1wdHJbQWlpXSsxO1xuICAgIH1cbiAgICByZXR1cm4gW1JpLFJqLFJ2XTtcbn1cblxubnVtZXJpYy5jY3NHYXRoZXIgPSBmdW5jdGlvbiBjY3NHYXRoZXIoQSkge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciBuID0gQWkubGVuZ3RoLTEsbSA9IEFqLmxlbmd0aDtcbiAgICB2YXIgUmkgPSBBcnJheShtKSwgUmogPSBBcnJheShtKSwgUnYgPSBBcnJheShtKTtcbiAgICB2YXIgaSxqLGowLGoxLHA7XG4gICAgcD0wO1xuICAgIGZvcihpPTA7aTxuOysraSkge1xuICAgICAgICBqMCA9IEFpW2ldO1xuICAgICAgICBqMSA9IEFpW2krMV07XG4gICAgICAgIGZvcihqPWowO2ohPT1qMTsrK2opIHtcbiAgICAgICAgICAgIFJqW3BdID0gaTtcbiAgICAgICAgICAgIFJpW3BdID0gQWpbal07XG4gICAgICAgICAgICBSdltwXSA9IEF2W2pdO1xuICAgICAgICAgICAgKytwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbUmksUmosUnZdO1xufVxuXG4vLyBUaGUgZm9sbG93aW5nIHNwYXJzZSBsaW5lYXIgYWxnZWJyYSByb3V0aW5lcyBhcmUgZGVwcmVjYXRlZC5cblxubnVtZXJpYy5zZGltID0gZnVuY3Rpb24gZGltKEEscmV0LGspIHtcbiAgICBpZih0eXBlb2YgcmV0ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldCA9IFtdOyB9XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXQ7XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIHsgaz0wOyB9XG4gICAgaWYoIShrIGluIHJldCkpIHsgcmV0W2tdID0gMDsgfVxuICAgIGlmKEEubGVuZ3RoID4gcmV0W2tdKSByZXRba10gPSBBLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIGRpbShBW2ldLHJldCxrKzEpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5zY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShBLGssbikge1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSB7IGs9MDsgfVxuICAgIGlmKHR5cGVvZiBuID09PSBcInVuZGVmaW5lZFwiKSB7IG4gPSBudW1lcmljLnNkaW0oQSkubGVuZ3RoOyB9XG4gICAgdmFyIGkscmV0ID0gQXJyYXkoQS5sZW5ndGgpO1xuICAgIGlmKGsgPT09IG4tMSkge1xuICAgICAgICBmb3IoaSBpbiBBKSB7IGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIHJldFtpXSA9IEFbaV07IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSByZXRbaV0gPSBjbG9uZShBW2ldLGsrMSxuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIHZhciBuID0gZC5sZW5ndGgsaSxyZXQgPSBBcnJheShuKSxpMSxpMixpMztcbiAgICBmb3IoaT1uLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIGkxID0gaS0xO1xuICAgICAgICByZXRbaV0gPSBbXTsgcmV0W2ldW2ldID0gZFtpXTtcbiAgICAgICAgcmV0W2kxXSA9IFtdOyByZXRbaTFdW2kxXSA9IGRbaTFdO1xuICAgIH1cbiAgICBpZihpPT09MCkgeyByZXRbMF0gPSBbXTsgcmV0WzBdWzBdID0gZFtpXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2lkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkobikgeyByZXR1cm4gbnVtZXJpYy5zZGlhZyhudW1lcmljLnJlcChbbl0sMSkpOyB9XG5cbm51bWVyaWMuc3RyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZShBKSB7XG4gICAgdmFyIHJldCA9IFtdLCBuID0gQS5sZW5ndGgsIGksaixBaTtcbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKCEoQS5oYXNPd25Qcm9wZXJ0eShpKSkpIGNvbnRpbnVlO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGZvcihqIGluIEFpKSB7XG4gICAgICAgICAgICBpZighKEFpLmhhc093blByb3BlcnR5KGopKSkgY29udGludWU7XG4gICAgICAgICAgICBpZih0eXBlb2YgcmV0W2pdICE9PSBcIm9iamVjdFwiKSB7IHJldFtqXSA9IFtdOyB9XG4gICAgICAgICAgICByZXRbal1baV0gPSBBaVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNMVVAgPSBmdW5jdGlvbiBMVVAoQSx0b2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gbnVtZXJpYy5zTFVQIGhhZCBhIGJ1ZyBpbiBpdCBhbmQgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgbmV3IG51bWVyaWMuY2NzTFVQIGZ1bmN0aW9uIGluc3RlYWQuXCIpO1xufTtcblxubnVtZXJpYy5zZG90TU0gPSBmdW5jdGlvbiBkb3RNTShBLEIpIHtcbiAgICB2YXIgcCA9IEEubGVuZ3RoLCBxID0gQi5sZW5ndGgsIEJUID0gbnVtZXJpYy5zdHJhbnNwb3NlKEIpLCByID0gQlQubGVuZ3RoLCBBaSwgQlRrO1xuICAgIHZhciBpLGosayxhY2N1bTtcbiAgICB2YXIgcmV0ID0gQXJyYXkocCkscmV0aTtcbiAgICBmb3IoaT1wLTE7aT49MDtpLS0pIHtcbiAgICAgICAgcmV0aSA9IFtdO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGZvcihrPXItMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgYWNjdW0gPSAwO1xuICAgICAgICAgICAgQlRrID0gQlRba107XG4gICAgICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgICAgIGlmKCEoQWkuaGFzT3duUHJvcGVydHkoaikpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihqIGluIEJUaykgeyBhY2N1bSArPSBBaVtqXSpCVGtbal07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFjY3VtKSByZXRpW2tdID0gYWNjdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gcmV0aTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90TVYgPSBmdW5jdGlvbiBkb3RNVihBLHgpIHtcbiAgICB2YXIgcCA9IEEubGVuZ3RoLCBBaSwgaSxqO1xuICAgIHZhciByZXQgPSBBcnJheShwKSwgYWNjdW07XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgYWNjdW0gPSAwO1xuICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgaWYoIShBaS5oYXNPd25Qcm9wZXJ0eShqKSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYoeFtqXSkgYWNjdW0gKz0gQWlbal0qeFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihhY2N1bSkgcmV0W2ldID0gYWNjdW07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RvdFZNID0gZnVuY3Rpb24gZG90TVYoeCxBKSB7XG4gICAgdmFyIGksaixBaSxhbHBoYTtcbiAgICB2YXIgcmV0ID0gW10sIGFjY3VtO1xuICAgIGZvcihpIGluIHgpIHtcbiAgICAgICAgaWYoIXguaGFzT3duUHJvcGVydHkoaSkpIGNvbnRpbnVlO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGFscGhhID0geFtpXTtcbiAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgIGlmKCFBaS5oYXNPd25Qcm9wZXJ0eShqKSkgY29udGludWU7XG4gICAgICAgICAgICBpZighcmV0W2pdKSB7IHJldFtqXSA9IDA7IH1cbiAgICAgICAgICAgIHJldFtqXSArPSBhbHBoYSpBaVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3RWViA9IGZ1bmN0aW9uIGRvdFZWKHgseSkge1xuICAgIHZhciBpLHJldD0wO1xuICAgIGZvcihpIGluIHgpIHsgaWYoeFtpXSAmJiB5W2ldKSByZXQrPSB4W2ldKnlbaV07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3QgPSBmdW5jdGlvbiBkb3QoQSxCKSB7XG4gICAgdmFyIG0gPSBudW1lcmljLnNkaW0oQSkubGVuZ3RoLCBuID0gbnVtZXJpYy5zZGltKEIpLmxlbmd0aDtcbiAgICB2YXIgayA9IG0qMTAwMCtuO1xuICAgIHN3aXRjaChrKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gQSpCO1xuICAgIGNhc2UgMTAwMTogcmV0dXJuIG51bWVyaWMuc2RvdFZWKEEsQik7XG4gICAgY2FzZSAyMDAxOiByZXR1cm4gbnVtZXJpYy5zZG90TVYoQSxCKTtcbiAgICBjYXNlIDEwMDI6IHJldHVybiBudW1lcmljLnNkb3RWTShBLEIpO1xuICAgIGNhc2UgMjAwMjogcmV0dXJuIG51bWVyaWMuc2RvdE1NKEEsQik7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdudW1lcmljLnNkb3Qgbm90IGltcGxlbWVudGVkIGZvciB0ZW5zb3JzIG9mIG9yZGVyICcrbSsnIGFuZCAnK24pO1xuICAgIH1cbn1cblxubnVtZXJpYy5zc2NhdHRlciA9IGZ1bmN0aW9uIHNjYXR0ZXIoVikge1xuICAgIHZhciBuID0gVlswXS5sZW5ndGgsIFZpaiwgaSwgaiwgbSA9IFYubGVuZ3RoLCBBID0gW10sIEFqO1xuICAgIGZvcihpPW4tMTtpPj0wOy0taSkge1xuICAgICAgICBpZighVlttLTFdW2ldKSBjb250aW51ZTtcbiAgICAgICAgQWogPSBBO1xuICAgICAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICAgICAgVmlqID0gVltqXVtpXTtcbiAgICAgICAgICAgIGlmKCFBaltWaWpdKSBBaltWaWpdID0gW107XG4gICAgICAgICAgICBBaiA9IEFqW1Zpal07XG4gICAgICAgIH1cbiAgICAgICAgQWpbVltqXVtpXV0gPSBWW2orMV1baV07XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5udW1lcmljLnNnYXRoZXIgPSBmdW5jdGlvbiBnYXRoZXIoQSxyZXQsaykge1xuICAgIGlmKHR5cGVvZiByZXQgPT09IFwidW5kZWZpbmVkXCIpIHJldCA9IFtdO1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSBrID0gW107XG4gICAgdmFyIG4saSxBaTtcbiAgICBuID0gay5sZW5ndGg7XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBrW25dID0gcGFyc2VJbnQoaSk7XG4gICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICBpZih0eXBlb2YgQWkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZihBaSkge1xuICAgICAgICAgICAgICAgICAgICBpZihyZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoaT1uKzE7aT49MDstLWkpIHJldFtpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPW47aT49MDstLWkpIHJldFtpXS5wdXNoKGtbaV0pO1xuICAgICAgICAgICAgICAgICAgICByZXRbbisxXS5wdXNoKEFpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgZ2F0aGVyKEFpLHJldCxrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihrLmxlbmd0aD5uKSBrLnBvcCgpO1xuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDYuIENvb3JkaW5hdGUgbWF0cmljZXNcbm51bWVyaWMuY0xVID0gZnVuY3Rpb24gTFUoQSkge1xuICAgIHZhciBJID0gQVswXSwgSiA9IEFbMV0sIFYgPSBBWzJdO1xuICAgIHZhciBwID0gSS5sZW5ndGgsIG09MCwgaSxqLGssYSxiLGM7XG4gICAgZm9yKGk9MDtpPHA7aSsrKSBpZihJW2ldPm0pIG09SVtpXTtcbiAgICBtKys7XG4gICAgdmFyIEwgPSBBcnJheShtKSwgVSA9IEFycmF5KG0pLCBsZWZ0ID0gbnVtZXJpYy5yZXAoW21dLEluZmluaXR5KSwgcmlnaHQgPSBudW1lcmljLnJlcChbbV0sLUluZmluaXR5KTtcbiAgICB2YXIgVWksIFVqLGFscGhhO1xuICAgIGZvcihrPTA7azxwO2srKykge1xuICAgICAgICBpID0gSVtrXTtcbiAgICAgICAgaiA9IEpba107XG4gICAgICAgIGlmKGo8bGVmdFtpXSkgbGVmdFtpXSA9IGo7XG4gICAgICAgIGlmKGo+cmlnaHRbaV0pIHJpZ2h0W2ldID0gajtcbiAgICB9XG4gICAgZm9yKGk9MDtpPG0tMTtpKyspIHsgaWYocmlnaHRbaV0gPiByaWdodFtpKzFdKSByaWdodFtpKzFdID0gcmlnaHRbaV07IH1cbiAgICBmb3IoaT1tLTE7aT49MTtpLS0pIHsgaWYobGVmdFtpXTxsZWZ0W2ktMV0pIGxlZnRbaS0xXSA9IGxlZnRbaV07IH1cbiAgICB2YXIgY291bnRMID0gMCwgY291bnRVID0gMDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgVVtpXSA9IG51bWVyaWMucmVwKFtyaWdodFtpXS1sZWZ0W2ldKzFdLDApO1xuICAgICAgICBMW2ldID0gbnVtZXJpYy5yZXAoW2ktbGVmdFtpXV0sMCk7XG4gICAgICAgIGNvdW50TCArPSBpLWxlZnRbaV0rMTtcbiAgICAgICAgY291bnRVICs9IHJpZ2h0W2ldLWkrMTtcbiAgICB9XG4gICAgZm9yKGs9MDtrPHA7aysrKSB7IGkgPSBJW2tdOyBVW2ldW0pba10tbGVmdFtpXV0gPSBWW2tdOyB9XG4gICAgZm9yKGk9MDtpPG0tMTtpKyspIHtcbiAgICAgICAgYSA9IGktbGVmdFtpXTtcbiAgICAgICAgVWkgPSBVW2ldO1xuICAgICAgICBmb3Ioaj1pKzE7bGVmdFtqXTw9aSAmJiBqPG07aisrKSB7XG4gICAgICAgICAgICBiID0gaS1sZWZ0W2pdO1xuICAgICAgICAgICAgYyA9IHJpZ2h0W2ldLWk7XG4gICAgICAgICAgICBVaiA9IFVbal07XG4gICAgICAgICAgICBhbHBoYSA9IFVqW2JdL1VpW2FdO1xuICAgICAgICAgICAgaWYoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBmb3Ioaz0xO2s8PWM7aysrKSB7IFVqW2srYl0gLT0gYWxwaGEqVWlbaythXTsgfVxuICAgICAgICAgICAgICAgIExbal1baS1sZWZ0W2pdXSA9IGFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBVaSA9IFtdLCBVaiA9IFtdLCBVdiA9IFtdLCBMaSA9IFtdLCBMaiA9IFtdLCBMdiA9IFtdO1xuICAgIHZhciBwLHEsZm9vO1xuICAgIHA9MDsgcT0wO1xuICAgIGZvcihpPTA7aTxtO2krKykge1xuICAgICAgICBhID0gbGVmdFtpXTtcbiAgICAgICAgYiA9IHJpZ2h0W2ldO1xuICAgICAgICBmb28gPSBVW2ldO1xuICAgICAgICBmb3Ioaj1pO2o8PWI7aisrKSB7XG4gICAgICAgICAgICBpZihmb29bai1hXSkge1xuICAgICAgICAgICAgICAgIFVpW3BdID0gaTtcbiAgICAgICAgICAgICAgICBValtwXSA9IGo7XG4gICAgICAgICAgICAgICAgVXZbcF0gPSBmb29bai1hXTtcbiAgICAgICAgICAgICAgICBwKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9vID0gTFtpXTtcbiAgICAgICAgZm9yKGo9YTtqPGk7aisrKSB7XG4gICAgICAgICAgICBpZihmb29bai1hXSkge1xuICAgICAgICAgICAgICAgIExpW3FdID0gaTtcbiAgICAgICAgICAgICAgICBMaltxXSA9IGo7XG4gICAgICAgICAgICAgICAgTHZbcV0gPSBmb29bai1hXTtcbiAgICAgICAgICAgICAgICBxKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbcV0gPSBpO1xuICAgICAgICBMaltxXSA9IGk7XG4gICAgICAgIEx2W3FdID0gMTtcbiAgICAgICAgcSsrO1xuICAgIH1cbiAgICByZXR1cm4ge1U6W1VpLFVqLFV2XSwgTDpbTGksTGosTHZdfTtcbn07XG5cbm51bWVyaWMuY0xVc29sdmUgPSBmdW5jdGlvbiBMVXNvbHZlKGx1LGIpIHtcbiAgICB2YXIgTCA9IGx1LkwsIFUgPSBsdS5VLCByZXQgPSBudW1lcmljLmNsb25lKGIpO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdO1xuICAgIHZhciBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciBwID0gVWkubGVuZ3RoLCBxID0gTGkubGVuZ3RoO1xuICAgIHZhciBtID0gcmV0Lmxlbmd0aCxpLGosaztcbiAgICBrID0gMDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgd2hpbGUoTGpba10gPCBpKSB7XG4gICAgICAgICAgICByZXRbaV0gLT0gTHZba10qcmV0W0xqW2tdXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgfVxuICAgIGsgPSBwLTE7XG4gICAgZm9yKGk9bS0xO2k+PTA7aS0tKSB7XG4gICAgICAgIHdoaWxlKFVqW2tdID4gaSkge1xuICAgICAgICAgICAgcmV0W2ldIC09IFV2W2tdKnJldFtValtrXV07XG4gICAgICAgICAgICBrLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldIC89IFV2W2tdO1xuICAgICAgICBrLS07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5udW1lcmljLmNncmlkID0gZnVuY3Rpb24gZ3JpZChuLHNoYXBlKSB7XG4gICAgaWYodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpIG4gPSBbbixuXTtcbiAgICB2YXIgcmV0ID0gbnVtZXJpYy5yZXAobiwtMSk7XG4gICAgdmFyIGksaixjb3VudDtcbiAgICBpZih0eXBlb2Ygc2hhcGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzd2l0Y2goc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBzaGFwZSA9IGZ1bmN0aW9uKGksaikgeyByZXR1cm4gKGk+PW5bMF0vMiB8fCBqPG5bMV0vMik7IH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2hhcGUgPSBmdW5jdGlvbihpLGopIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudD0wO1xuICAgIGZvcihpPTE7aTxuWzBdLTE7aSsrKSBmb3Ioaj0xO2o8blsxXS0xO2orKykgXG4gICAgICAgIGlmKHNoYXBlKGksaikpIHtcbiAgICAgICAgICAgIHJldFtpXVtqXSA9IGNvdW50O1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuY2RlbHNxID0gZnVuY3Rpb24gZGVsc3EoZykge1xuICAgIHZhciBkaXIgPSBbWy0xLDBdLFswLC0xXSxbMCwxXSxbMSwwXV07XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShnKSwgbSA9IHNbMF0sIG4gPSBzWzFdLCBpLGosayxwLHE7XG4gICAgdmFyIExpID0gW10sIExqID0gW10sIEx2ID0gW107XG4gICAgZm9yKGk9MTtpPG0tMTtpKyspIGZvcihqPTE7ajxuLTE7aisrKSB7XG4gICAgICAgIGlmKGdbaV1bal08MCkgY29udGludWU7XG4gICAgICAgIGZvcihrPTA7azw0O2srKykge1xuICAgICAgICAgICAgcCA9IGkrZGlyW2tdWzBdO1xuICAgICAgICAgICAgcSA9IGorZGlyW2tdWzFdO1xuICAgICAgICAgICAgaWYoZ1twXVtxXTwwKSBjb250aW51ZTtcbiAgICAgICAgICAgIExpLnB1c2goZ1tpXVtqXSk7XG4gICAgICAgICAgICBMai5wdXNoKGdbcF1bcV0pO1xuICAgICAgICAgICAgTHYucHVzaCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgTGkucHVzaChnW2ldW2pdKTtcbiAgICAgICAgTGoucHVzaChnW2ldW2pdKTtcbiAgICAgICAgTHYucHVzaCg0KTtcbiAgICB9XG4gICAgcmV0dXJuIFtMaSxMaixMdl07XG59XG5cbm51bWVyaWMuY2RvdE1WID0gZnVuY3Rpb24gZG90TVYoQSx4KSB7XG4gICAgdmFyIHJldCwgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxrLHA9QWkubGVuZ3RoLE47XG4gICAgTj0wO1xuICAgIGZvcihrPTA7azxwO2srKykgeyBpZihBaVtrXT5OKSBOID0gQWlba107IH1cbiAgICBOKys7XG4gICAgcmV0ID0gbnVtZXJpYy5yZXAoW05dLDApO1xuICAgIGZvcihrPTA7azxwO2srKykgeyByZXRbQWlba11dKz1BdltrXSp4W0FqW2tdXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDcuIFNwbGluZXNcblxubnVtZXJpYy5TcGxpbmUgPSBmdW5jdGlvbiBTcGxpbmUoeCx5bCx5cixrbCxrcikgeyB0aGlzLnggPSB4OyB0aGlzLnlsID0geWw7IHRoaXMueXIgPSB5cjsgdGhpcy5rbCA9IGtsOyB0aGlzLmtyID0ga3I7IH1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5fYXQgPSBmdW5jdGlvbiBfYXQoeDEscCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5bCA9IHRoaXMueWw7XG4gICAgdmFyIHlyID0gdGhpcy55cjtcbiAgICB2YXIga2wgPSB0aGlzLmtsO1xuICAgIHZhciBrciA9IHRoaXMua3I7XG4gICAgdmFyIHgxLGEsYix0O1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgc3ViID0gbnVtZXJpYy5zdWIsIG11bCA9IG51bWVyaWMubXVsO1xuICAgIGEgPSBzdWIobXVsKGtsW3BdLHhbcCsxXS14W3BdKSxzdWIoeXJbcCsxXSx5bFtwXSkpO1xuICAgIGIgPSBhZGQobXVsKGtyW3ArMV0seFtwXS14W3ArMV0pLHN1Yih5cltwKzFdLHlsW3BdKSk7XG4gICAgdCA9ICh4MS14W3BdKS8oeFtwKzFdLXhbcF0pO1xuICAgIHZhciBzID0gdCooMS10KTtcbiAgICByZXR1cm4gYWRkKGFkZChhZGQobXVsKDEtdCx5bFtwXSksbXVsKHQseXJbcCsxXSkpLG11bChhLHMqKDEtdCkpKSxtdWwoYixzKnQpKTtcbn1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0KHgwKSB7XG4gICAgaWYodHlwZW9mIHgwID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgICAgICB2YXIgcCxxLG1pZCxmbG9vciA9IE1hdGguZmxvb3IsYSxiLHQ7XG4gICAgICAgIHAgPSAwO1xuICAgICAgICBxID0gbi0xO1xuICAgICAgICB3aGlsZShxLXA+MSkge1xuICAgICAgICAgICAgbWlkID0gZmxvb3IoKHArcSkvMik7XG4gICAgICAgICAgICBpZih4W21pZF0gPD0geDApIHAgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIHEgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0KHgwLHApO1xuICAgIH1cbiAgICB2YXIgbiA9IHgwLmxlbmd0aCwgaSwgcmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHJldFtpXSA9IHRoaXMuYXQoeDBbaV0pO1xuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIGRpZmYoKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHlsID0gdGhpcy55bDtcbiAgICB2YXIgeXIgPSB0aGlzLnlyO1xuICAgIHZhciBrbCA9IHRoaXMua2w7XG4gICAgdmFyIGtyID0gdGhpcy5rcjtcbiAgICB2YXIgbiA9IHlsLmxlbmd0aDtcbiAgICB2YXIgaSxkeCxkeTtcbiAgICB2YXIgemwgPSBrbCwgenIgPSBrciwgcGwgPSBBcnJheShuKSwgcHIgPSBBcnJheShuKTtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIG11bCA9IG51bWVyaWMubXVsLCBkaXYgPSBudW1lcmljLmRpdiwgc3ViID0gbnVtZXJpYy5zdWI7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZHggPSB4W2krMV0teFtpXTtcbiAgICAgICAgZHkgPSBzdWIoeXJbaSsxXSx5bFtpXSk7XG4gICAgICAgIHBsW2ldID0gZGl2KGFkZChtdWwoZHksIDYpLG11bChrbFtpXSwtNCpkeCksbXVsKGtyW2krMV0sLTIqZHgpKSxkeCpkeCk7XG4gICAgICAgIHByW2krMV0gPSBkaXYoYWRkKG11bChkeSwtNiksbXVsKGtsW2ldLCAyKmR4KSxtdWwoa3JbaSsxXSwgNCpkeCkpLGR4KmR4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlNwbGluZSh4LHpsLHpyLHBsLHByKTtcbn1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5yb290cyA9IGZ1bmN0aW9uIHJvb3RzKCkge1xuICAgIGZ1bmN0aW9uIHNxcih4KSB7IHJldHVybiB4Kng7IH1cbiAgICBmdW5jdGlvbiBoZXZhbCh5MCx5MSxrMCxrMSx4KSB7XG4gICAgICAgIHZhciBBID0gazAqMi0oeTEteTApO1xuICAgICAgICB2YXIgQiA9IC1rMSoyKyh5MS15MCk7XG4gICAgICAgIHZhciB0ID0gKHgrMSkqMC41O1xuICAgICAgICB2YXIgcyA9IHQqKDEtdCk7XG4gICAgICAgIHJldHVybiAoMS10KSp5MCt0KnkxK0EqcyooMS10KStCKnMqdDtcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciB4ID0gdGhpcy54LCB5bCA9IHRoaXMueWwsIHlyID0gdGhpcy55ciwga2wgPSB0aGlzLmtsLCBrciA9IHRoaXMua3I7XG4gICAgaWYodHlwZW9mIHlsWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHlsID0gW3lsXTtcbiAgICAgICAgeXIgPSBbeXJdO1xuICAgICAgICBrbCA9IFtrbF07XG4gICAgICAgIGtyID0gW2tyXTtcbiAgICB9XG4gICAgdmFyIG0gPSB5bC5sZW5ndGgsbj14Lmxlbmd0aC0xLGksaixrLHkscyx0O1xuICAgIHZhciBhaSxiaSxjaSxkaSwgcmV0ID0gQXJyYXkobSkscmksazAsazEseTAseTEsQSxCLEQsZHgsY3gsc3RvcHMsejAsejEsem0sdDAsdDEsdG07XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgZm9yKGk9MDtpIT09bTsrK2kpIHtcbiAgICAgICAgYWkgPSB5bFtpXTtcbiAgICAgICAgYmkgPSB5cltpXTtcbiAgICAgICAgY2kgPSBrbFtpXTtcbiAgICAgICAgZGkgPSBrcltpXTtcbiAgICAgICAgcmkgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqIT09bjtqKyspIHtcbiAgICAgICAgICAgIGlmKGo+MCAmJiBiaVtqXSphaVtqXTwwKSByaS5wdXNoKHhbal0pO1xuICAgICAgICAgICAgZHggPSAoeFtqKzFdLXhbal0pO1xuICAgICAgICAgICAgY3ggPSB4W2pdO1xuICAgICAgICAgICAgeTAgPSBhaVtqXTtcbiAgICAgICAgICAgIHkxID0gYmlbaisxXTtcbiAgICAgICAgICAgIGswID0gY2lbal0vZHg7XG4gICAgICAgICAgICBrMSA9IGRpW2orMV0vZHg7XG4gICAgICAgICAgICBEID0gc3FyKGswLWsxKzMqKHkwLXkxKSkgKyAxMiprMSp5MDtcbiAgICAgICAgICAgIEEgPSBrMSszKnkwKzIqazAtMyp5MTtcbiAgICAgICAgICAgIEIgPSAzKihrMStrMCsyKih5MC15MSkpO1xuICAgICAgICAgICAgaWYoRDw9MCkge1xuICAgICAgICAgICAgICAgIHowID0gQS9CO1xuICAgICAgICAgICAgICAgIGlmKHowPnhbal0gJiYgejA8eFtqKzFdKSBzdG9wcyA9IFt4W2pdLHowLHhbaisxXV07XG4gICAgICAgICAgICAgICAgZWxzZSBzdG9wcyA9IFt4W2pdLHhbaisxXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHowID0gKEEtc3FydChEKSkvQjtcbiAgICAgICAgICAgICAgICB6MSA9IChBK3NxcnQoRCkpL0I7XG4gICAgICAgICAgICAgICAgc3RvcHMgPSBbeFtqXV07XG4gICAgICAgICAgICAgICAgaWYoejA+eFtqXSAmJiB6MDx4W2orMV0pIHN0b3BzLnB1c2goejApO1xuICAgICAgICAgICAgICAgIGlmKHoxPnhbal0gJiYgejE8eFtqKzFdKSBzdG9wcy5wdXNoKHoxKTtcbiAgICAgICAgICAgICAgICBzdG9wcy5wdXNoKHhbaisxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MCA9IHN0b3BzWzBdO1xuICAgICAgICAgICAgejAgPSB0aGlzLl9hdCh0MCxqKTtcbiAgICAgICAgICAgIGZvcihrPTA7azxzdG9wcy5sZW5ndGgtMTtrKyspIHtcbiAgICAgICAgICAgICAgICB0MSA9IHN0b3BzW2srMV07XG4gICAgICAgICAgICAgICAgejEgPSB0aGlzLl9hdCh0MSxqKTtcbiAgICAgICAgICAgICAgICBpZih6MCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaS5wdXNoKHQwKTsgXG4gICAgICAgICAgICAgICAgICAgIHQwID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHowID0gejE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih6MSA9PT0gMCB8fCB6MCp6MT4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHowID0gejE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUoMSkge1xuICAgICAgICAgICAgICAgICAgICB0bSA9ICh6MCp0MS16MSp0MCkvKHowLXoxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG0gPD0gdDAgfHwgdG0gPj0gdDEpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgem0gPSB0aGlzLl9hdCh0bSxqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoem0qejE+MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSB0bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHoxID0gem07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09PSAtMSkgejAqPTAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHptKnowPjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQwID0gdG07XG4gICAgICAgICAgICAgICAgICAgICAgICB6MCA9IHptO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gMSkgejEqPTAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJpLnB1c2godG0pO1xuICAgICAgICAgICAgICAgIHQwID0gc3RvcHNbaysxXTtcbiAgICAgICAgICAgICAgICB6MCA9IHRoaXMuX2F0KHQwLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHoxID09PSAwKSByaS5wdXNoKHQxKTtcbiAgICAgICAgfVxuICAgICAgICByZXRbaV0gPSByaTtcbiAgICB9XG4gICAgaWYodHlwZW9mIHRoaXMueWxbMF0gPT09IFwibnVtYmVyXCIpIHJldHVybiByZXRbMF07XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMuc3BsaW5lID0gZnVuY3Rpb24gc3BsaW5lKHgseSxrMSxrbikge1xuICAgIHZhciBuID0geC5sZW5ndGgsIGIgPSBbXSwgZHggPSBbXSwgZHkgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3ViID0gbnVtZXJpYy5zdWIsbXVsID0gbnVtZXJpYy5tdWwsYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgZm9yKGk9bi0yO2k+PTA7aS0tKSB7IGR4W2ldID0geFtpKzFdLXhbaV07IGR5W2ldID0gc3ViKHlbaSsxXSx5W2ldKTsgfVxuICAgIGlmKHR5cGVvZiBrMSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Yga24gPT09IFwic3RyaW5nXCIpIHsgXG4gICAgICAgIGsxID0ga24gPSBcInBlcmlvZGljXCI7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHNwYXJzZSB0cmlkaWFnb25hbCBzeXN0ZW1cbiAgICB2YXIgVCA9IFtbXSxbXSxbXV07XG4gICAgc3dpdGNoKHR5cGVvZiBrMSkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgYlswXSA9IG11bCgzLyhkeFswXSpkeFswXSksZHlbMF0pO1xuICAgICAgICBUWzBdLnB1c2goMCwwKTtcbiAgICAgICAgVFsxXS5wdXNoKDAsMSk7XG4gICAgICAgIFRbMl0ucHVzaCgyL2R4WzBdLDEvZHhbMF0pO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGJbMF0gPSBhZGQobXVsKDMvKGR4W24tMl0qZHhbbi0yXSksZHlbbi0yXSksbXVsKDMvKGR4WzBdKmR4WzBdKSxkeVswXSkpO1xuICAgICAgICBUWzBdLnB1c2goMCwwLDApO1xuICAgICAgICBUWzFdLnB1c2gobi0yLDAsMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxL2R4W24tMl0sMi9keFtuLTJdKzIvZHhbMF0sMS9keFswXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGJbMF0gPSBrMTtcbiAgICAgICAgVFswXS5wdXNoKDApO1xuICAgICAgICBUWzFdLnB1c2goMCk7XG4gICAgICAgIFRbMl0ucHVzaCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvcihpPTE7aTxuLTE7aSsrKSB7XG4gICAgICAgIGJbaV0gPSBhZGQobXVsKDMvKGR4W2ktMV0qZHhbaS0xXSksZHlbaS0xXSksbXVsKDMvKGR4W2ldKmR4W2ldKSxkeVtpXSkpO1xuICAgICAgICBUWzBdLnB1c2goaSxpLGkpO1xuICAgICAgICBUWzFdLnB1c2goaS0xLGksaSsxKTtcbiAgICAgICAgVFsyXS5wdXNoKDEvZHhbaS0xXSwyL2R4W2ktMV0rMi9keFtpXSwxL2R4W2ldKTtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGVvZiBrbikge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgYltuLTFdID0gbXVsKDMvKGR4W24tMl0qZHhbbi0yXSksZHlbbi0yXSk7XG4gICAgICAgIFRbMF0ucHVzaChuLTEsbi0xKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMixuLTEpO1xuICAgICAgICBUWzJdLnB1c2goMS9keFtuLTJdLDIvZHhbbi0yXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgVFsxXVtUWzFdLmxlbmd0aC0xXSA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGJbbi0xXSA9IGtuO1xuICAgICAgICBUWzBdLnB1c2gobi0xKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKHR5cGVvZiBiWzBdICE9PSBcIm51bWJlclwiKSBiID0gbnVtZXJpYy50cmFuc3Bvc2UoYik7XG4gICAgZWxzZSBiID0gW2JdO1xuICAgIHZhciBrID0gQXJyYXkoYi5sZW5ndGgpO1xuICAgIGlmKHR5cGVvZiBrMSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IoaT1rLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIGtbaV0gPSBudW1lcmljLmNjc0xVUFNvbHZlKG51bWVyaWMuY2NzTFVQKG51bWVyaWMuY2NzU2NhdHRlcihUKSksYltpXSk7XG4gICAgICAgICAgICBrW2ldW24tMV0gPSBrW2ldWzBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGk9ay5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICBrW2ldID0gbnVtZXJpYy5jTFVzb2x2ZShudW1lcmljLmNMVShUKSxiW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZih0eXBlb2YgeVswXSA9PT0gXCJudW1iZXJcIikgayA9IGtbMF07XG4gICAgZWxzZSBrID0gbnVtZXJpYy50cmFuc3Bvc2Uoayk7XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlNwbGluZSh4LHkseSxrLGspO1xufVxuXG4vLyA4LiBGRlRcbm51bWVyaWMuZmZ0cG93MiA9IGZ1bmN0aW9uIGZmdHBvdzIoeCx5KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICBpZihuID09PSAxKSByZXR1cm47XG4gICAgdmFyIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbiwgaSxqO1xuICAgIHZhciB4ZSA9IEFycmF5KG4vMiksIHllID0gQXJyYXkobi8yKSwgeG8gPSBBcnJheShuLzIpLCB5byA9IEFycmF5KG4vMik7XG4gICAgaiA9IG4vMjtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIHhvW2pdID0geFtpXTtcbiAgICAgICAgeW9bal0gPSB5W2ldO1xuICAgICAgICAtLWk7XG4gICAgICAgIHhlW2pdID0geFtpXTtcbiAgICAgICAgeWVbal0gPSB5W2ldO1xuICAgIH1cbiAgICBmZnRwb3cyKHhlLHllKTtcbiAgICBmZnRwb3cyKHhvLHlvKTtcbiAgICBqID0gbi8yO1xuICAgIHZhciB0LGsgPSAoLTYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTU5MDA1NzY4Mzk0MzM4Nzk4NzUwMjExNjQxOS9uKSxjaSxzaTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIGlmKGogPT09IC0xKSBqID0gbi8yLTE7XG4gICAgICAgIHQgPSBrKmk7XG4gICAgICAgIGNpID0gY29zKHQpO1xuICAgICAgICBzaSA9IHNpbih0KTtcbiAgICAgICAgeFtpXSA9IHhlW2pdICsgY2kqeG9bal0gLSBzaSp5b1tqXTtcbiAgICAgICAgeVtpXSA9IHllW2pdICsgY2kqeW9bal0gKyBzaSp4b1tqXTtcbiAgICB9XG59XG5udW1lcmljLl9pZmZ0cG93MiA9IGZ1bmN0aW9uIF9pZmZ0cG93Mih4LHkpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgIGlmKG4gPT09IDEpIHJldHVybjtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luLCBpLGo7XG4gICAgdmFyIHhlID0gQXJyYXkobi8yKSwgeWUgPSBBcnJheShuLzIpLCB4byA9IEFycmF5KG4vMiksIHlvID0gQXJyYXkobi8yKTtcbiAgICBqID0gbi8yO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgeG9bal0gPSB4W2ldO1xuICAgICAgICB5b1tqXSA9IHlbaV07XG4gICAgICAgIC0taTtcbiAgICAgICAgeGVbal0gPSB4W2ldO1xuICAgICAgICB5ZVtqXSA9IHlbaV07XG4gICAgfVxuICAgIF9pZmZ0cG93Mih4ZSx5ZSk7XG4gICAgX2lmZnRwb3cyKHhvLHlvKTtcbiAgICBqID0gbi8yO1xuICAgIHZhciB0LGsgPSAoNi4yODMxODUzMDcxNzk1ODY0NzY5MjUyODY3NjY1NTkwMDU3NjgzOTQzMzg3OTg3NTAyMTE2NDE5L24pLGNpLHNpO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgaWYoaiA9PT0gLTEpIGogPSBuLzItMTtcbiAgICAgICAgdCA9IGsqaTtcbiAgICAgICAgY2kgPSBjb3ModCk7XG4gICAgICAgIHNpID0gc2luKHQpO1xuICAgICAgICB4W2ldID0geGVbal0gKyBjaSp4b1tqXSAtIHNpKnlvW2pdO1xuICAgICAgICB5W2ldID0geWVbal0gKyBjaSp5b1tqXSArIHNpKnhvW2pdO1xuICAgIH1cbn1cbm51bWVyaWMuaWZmdHBvdzIgPSBmdW5jdGlvbiBpZmZ0cG93Mih4LHkpIHtcbiAgICBudW1lcmljLl9pZmZ0cG93Mih4LHkpO1xuICAgIG51bWVyaWMuZGl2ZXEoeCx4Lmxlbmd0aCk7XG4gICAgbnVtZXJpYy5kaXZlcSh5LHkubGVuZ3RoKTtcbn1cbm51bWVyaWMuY29udnBvdzIgPSBmdW5jdGlvbiBjb252cG93MihheCxheSxieCxieSkge1xuICAgIG51bWVyaWMuZmZ0cG93MihheCxheSk7XG4gICAgbnVtZXJpYy5mZnRwb3cyKGJ4LGJ5KTtcbiAgICB2YXIgaSxuID0gYXgubGVuZ3RoLGF4aSxieGksYXlpLGJ5aTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBheGkgPSBheFtpXTsgYXlpID0gYXlbaV07IGJ4aSA9IGJ4W2ldOyBieWkgPSBieVtpXTtcbiAgICAgICAgYXhbaV0gPSBheGkqYnhpLWF5aSpieWk7XG4gICAgICAgIGF5W2ldID0gYXhpKmJ5aStheWkqYnhpO1xuICAgIH1cbiAgICBudW1lcmljLmlmZnRwb3cyKGF4LGF5KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZmZ0ID0gZnVuY3Rpb24gZmZ0KCkge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIHZhciBuID0geC5sZW5ndGgsIGxvZyA9IE1hdGgubG9nLCBsb2cyID0gbG9nKDIpLFxuICAgICAgICBwID0gTWF0aC5jZWlsKGxvZygyKm4tMSkvbG9nMiksIG0gPSBNYXRoLnBvdygyLHApO1xuICAgIHZhciBjeCA9IG51bWVyaWMucmVwKFttXSwwKSwgY3kgPSBudW1lcmljLnJlcChbbV0sMCksIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgaywgYyA9ICgtMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjAvbiksdDtcbiAgICB2YXIgYSA9IG51bWVyaWMucmVwKFttXSwwKSwgYiA9IG51bWVyaWMucmVwKFttXSwwKSxuaGFsZiA9IE1hdGguZmxvb3Iobi8yKTtcbiAgICBmb3Ioaz0wO2s8bjtrKyspIGFba10gPSB4W2tdO1xuICAgIGlmKHR5cGVvZiB5ICE9PSBcInVuZGVmaW5lZFwiKSBmb3Ioaz0wO2s8bjtrKyspIGJba10gPSB5W2tdO1xuICAgIGN4WzBdID0gMTtcbiAgICBmb3Ioaz0xO2s8PW0vMjtrKyspIHtcbiAgICAgICAgdCA9IGMqayprO1xuICAgICAgICBjeFtrXSA9IGNvcyh0KTtcbiAgICAgICAgY3lba10gPSBzaW4odCk7XG4gICAgICAgIGN4W20ta10gPSBjb3ModCk7XG4gICAgICAgIGN5W20ta10gPSBzaW4odClcbiAgICB9XG4gICAgdmFyIFggPSBuZXcgbnVtZXJpYy5UKGEsYiksIFkgPSBuZXcgbnVtZXJpYy5UKGN4LGN5KTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgbnVtZXJpYy5jb252cG93MihYLngsWC55LG51bWVyaWMuY2xvbmUoWS54KSxudW1lcmljLm5lZyhZLnkpKTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgWC54Lmxlbmd0aCA9IG47XG4gICAgWC55Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIFg7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmlmZnQgPSBmdW5jdGlvbiBpZmZ0KCkge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIHZhciBuID0geC5sZW5ndGgsIGxvZyA9IE1hdGgubG9nLCBsb2cyID0gbG9nKDIpLFxuICAgICAgICBwID0gTWF0aC5jZWlsKGxvZygyKm4tMSkvbG9nMiksIG0gPSBNYXRoLnBvdygyLHApO1xuICAgIHZhciBjeCA9IG51bWVyaWMucmVwKFttXSwwKSwgY3kgPSBudW1lcmljLnJlcChbbV0sMCksIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgaywgYyA9ICgzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMC9uKSx0O1xuICAgIHZhciBhID0gbnVtZXJpYy5yZXAoW21dLDApLCBiID0gbnVtZXJpYy5yZXAoW21dLDApLG5oYWxmID0gTWF0aC5mbG9vcihuLzIpO1xuICAgIGZvcihrPTA7azxuO2srKykgYVtrXSA9IHhba107XG4gICAgaWYodHlwZW9mIHkgIT09IFwidW5kZWZpbmVkXCIpIGZvcihrPTA7azxuO2srKykgYltrXSA9IHlba107XG4gICAgY3hbMF0gPSAxO1xuICAgIGZvcihrPTE7azw9bS8yO2srKykge1xuICAgICAgICB0ID0gYyprKms7XG4gICAgICAgIGN4W2tdID0gY29zKHQpO1xuICAgICAgICBjeVtrXSA9IHNpbih0KTtcbiAgICAgICAgY3hbbS1rXSA9IGNvcyh0KTtcbiAgICAgICAgY3lbbS1rXSA9IHNpbih0KVxuICAgIH1cbiAgICB2YXIgWCA9IG5ldyBudW1lcmljLlQoYSxiKSwgWSA9IG5ldyBudW1lcmljLlQoY3gsY3kpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBudW1lcmljLmNvbnZwb3cyKFgueCxYLnksbnVtZXJpYy5jbG9uZShZLngpLG51bWVyaWMubmVnKFkueSkpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBYLngubGVuZ3RoID0gbjtcbiAgICBYLnkubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gWC5kaXYobik7XG59XG5cbi8vOS4gVW5jb25zdHJhaW5lZCBvcHRpbWl6YXRpb25cbm51bWVyaWMuZ3JhZGllbnQgPSBmdW5jdGlvbiBncmFkaWVudChmLHgpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgIHZhciBmMCA9IGYoeCk7XG4gICAgaWYoaXNOYU4oZjApKSB0aHJvdyBuZXcgRXJyb3IoJ2dyYWRpZW50OiBmKHgpIGlzIGEgTmFOIScpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgaSx4MCA9IG51bWVyaWMuY2xvbmUoeCksZjEsZjIsIEogPSBBcnJheShuKTtcbiAgICB2YXIgZGl2ID0gbnVtZXJpYy5kaXYsIHN1YiA9IG51bWVyaWMuc3ViLGVycmVzdCxyb3VuZG9mZixtYXggPSBNYXRoLm1heCxlcHMgPSAxZS0zLGFicyA9IE1hdGguYWJzLCBtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgdDAsdDEsdDIsaXQ9MCxkMSxkMixOO1xuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICB2YXIgaCA9IG1heCgxZS02KmYwLDFlLTgpO1xuICAgICAgICB3aGlsZSgxKSB7XG4gICAgICAgICAgICArK2l0O1xuICAgICAgICAgICAgaWYoaXQ+MjApIHsgdGhyb3cgbmV3IEVycm9yKFwiTnVtZXJpY2FsIGdyYWRpZW50IGZhaWxzXCIpOyB9XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV0raDtcbiAgICAgICAgICAgIGYxID0gZih4MCk7XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV0taDtcbiAgICAgICAgICAgIGYyID0gZih4MCk7XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV07XG4gICAgICAgICAgICBpZihpc05hTihmMSkgfHwgaXNOYU4oZjIpKSB7IGgvPTE2OyBjb250aW51ZTsgfVxuICAgICAgICAgICAgSltpXSA9IChmMS1mMikvKDIqaCk7XG4gICAgICAgICAgICB0MCA9IHhbaV0taDtcbiAgICAgICAgICAgIHQxID0geFtpXTtcbiAgICAgICAgICAgIHQyID0geFtpXStoO1xuICAgICAgICAgICAgZDEgPSAoZjEtZjApL2g7XG4gICAgICAgICAgICBkMiA9IChmMC1mMikvaDtcbiAgICAgICAgICAgIE4gPSBtYXgoYWJzKEpbaV0pLGFicyhmMCksYWJzKGYxKSxhYnMoZjIpLGFicyh0MCksYWJzKHQxKSxhYnModDIpLDFlLTgpO1xuICAgICAgICAgICAgZXJyZXN0ID0gbWluKG1heChhYnMoZDEtSltpXSksYWJzKGQyLUpbaV0pLGFicyhkMS1kMikpL04saC9OKTtcbiAgICAgICAgICAgIGlmKGVycmVzdD5lcHMpIHsgaC89MTY7IH1cbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKO1xufVxuXG5udW1lcmljLnVuY21pbiA9IGZ1bmN0aW9uIHVuY21pbihmLHgwLHRvbCxncmFkaWVudCxtYXhpdCxjYWxsYmFjayxvcHRpb25zKSB7XG4gICAgdmFyIGdyYWQgPSBudW1lcmljLmdyYWRpZW50O1xuICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHsgdG9sID0gMWUtODsgfVxuICAgIGlmKHR5cGVvZiBncmFkaWVudCA9PT0gXCJ1bmRlZmluZWRcIikgeyBncmFkaWVudCA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGdyYWQoZix4KTsgfTsgfVxuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgbWF4aXQgPSAxMDAwO1xuICAgIHgwID0gbnVtZXJpYy5jbG9uZSh4MCk7XG4gICAgdmFyIG4gPSB4MC5sZW5ndGg7XG4gICAgdmFyIGYwID0gZih4MCksZjEsZGYwO1xuICAgIGlmKGlzTmFOKGYwKSkgdGhyb3cgbmV3IEVycm9yKCd1bmNtaW46IGYoeDApIGlzIGEgTmFOIScpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCwgbm9ybTIgPSBudW1lcmljLm5vcm0yO1xuICAgIHRvbCA9IG1heCh0b2wsbnVtZXJpYy5lcHNpbG9uKTtcbiAgICB2YXIgc3RlcCxnMCxnMSxIMSA9IG9wdGlvbnMuSGludiB8fCBudW1lcmljLmlkZW50aXR5KG4pO1xuICAgIHZhciBkb3QgPSBudW1lcmljLmRvdCwgaW52ID0gbnVtZXJpYy5pbnYsIHN1YiA9IG51bWVyaWMuc3ViLCBhZGQgPSBudW1lcmljLmFkZCwgdGVuID0gbnVtZXJpYy50ZW5zb3IsIGRpdiA9IG51bWVyaWMuZGl2LCBtdWwgPSBudW1lcmljLm11bDtcbiAgICB2YXIgYWxsID0gbnVtZXJpYy5hbGwsIGlzZmluaXRlID0gbnVtZXJpYy5pc0Zpbml0ZSwgbmVnID0gbnVtZXJpYy5uZWc7XG4gICAgdmFyIGl0PTAsaSxzLHgxLHksSHksSHMseXMsaTAsdCxuc3RlcCx0MSx0MjtcbiAgICB2YXIgbXNnID0gXCJcIjtcbiAgICBnMCA9IGdyYWRpZW50KHgwKTtcbiAgICB3aGlsZShpdDxtYXhpdCkge1xuICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgeyBpZihjYWxsYmFjayhpdCx4MCxmMCxnMCxIMSkpIHsgbXNnID0gXCJDYWxsYmFjayByZXR1cm5lZCB0cnVlXCI7IGJyZWFrOyB9IH1cbiAgICAgICAgaWYoIWFsbChpc2Zpbml0ZShnMCkpKSB7IG1zZyA9IFwiR3JhZGllbnQgaGFzIEluZmluaXR5IG9yIE5hTlwiOyBicmVhazsgfVxuICAgICAgICBzdGVwID0gbmVnKGRvdChIMSxnMCkpO1xuICAgICAgICBpZighYWxsKGlzZmluaXRlKHN0ZXApKSkgeyBtc2cgPSBcIlNlYXJjaCBkaXJlY3Rpb24gaGFzIEluZmluaXR5IG9yIE5hTlwiOyBicmVhazsgfVxuICAgICAgICBuc3RlcCA9IG5vcm0yKHN0ZXApO1xuICAgICAgICBpZihuc3RlcCA8IHRvbCkgeyBtc2c9XCJOZXd0b24gc3RlcCBzbWFsbGVyIHRoYW4gdG9sXCI7IGJyZWFrOyB9XG4gICAgICAgIHQgPSAxO1xuICAgICAgICBkZjAgPSBkb3QoZzAsc3RlcCk7XG4gICAgICAgIC8vIGxpbmUgc2VhcmNoXG4gICAgICAgIHgxID0geDA7XG4gICAgICAgIHdoaWxlKGl0IDwgbWF4aXQpIHtcbiAgICAgICAgICAgIGlmKHQqbnN0ZXAgPCB0b2wpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIHMgPSBtdWwoc3RlcCx0KTtcbiAgICAgICAgICAgIHgxID0gYWRkKHgwLHMpO1xuICAgICAgICAgICAgZjEgPSBmKHgxKTtcbiAgICAgICAgICAgIGlmKGYxLWYwID49IDAuMSp0KmRmMCB8fCBpc05hTihmMSkpIHtcbiAgICAgICAgICAgICAgICB0ICo9IDAuNTtcbiAgICAgICAgICAgICAgICArK2l0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYodCpuc3RlcCA8IHRvbCkgeyBtc2cgPSBcIkxpbmUgc2VhcmNoIHN0ZXAgc2l6ZSBzbWFsbGVyIHRoYW4gdG9sXCI7IGJyZWFrOyB9XG4gICAgICAgIGlmKGl0ID09PSBtYXhpdCkgeyBtc2cgPSBcIm1heGl0IHJlYWNoZWQgZHVyaW5nIGxpbmUgc2VhcmNoXCI7IGJyZWFrOyB9XG4gICAgICAgIGcxID0gZ3JhZGllbnQoeDEpO1xuICAgICAgICB5ID0gc3ViKGcxLGcwKTtcbiAgICAgICAgeXMgPSBkb3QoeSxzKTtcbiAgICAgICAgSHkgPSBkb3QoSDEseSk7XG4gICAgICAgIEgxID0gc3ViKGFkZChIMSxcbiAgICAgICAgICAgICAgICBtdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAoeXMrZG90KHksSHkpKS8oeXMqeXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuKHMscykgICAgKSksXG4gICAgICAgICAgICAgICAgZGl2KGFkZCh0ZW4oSHkscyksdGVuKHMsSHkpKSx5cykpO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICBmMCA9IGYxO1xuICAgICAgICBnMCA9IGcxO1xuICAgICAgICArK2l0O1xuICAgIH1cbiAgICByZXR1cm4ge3NvbHV0aW9uOiB4MCwgZjogZjAsIGdyYWRpZW50OiBnMCwgaW52SGVzc2lhbjogSDEsIGl0ZXJhdGlvbnM6aXQsIG1lc3NhZ2U6IG1zZ307XG59XG5cbi8vIDEwLiBPZGUgc29sdmVyIChEb3JtYW5kLVByaW5jZSlcbm51bWVyaWMuRG9wcmkgPSBmdW5jdGlvbiBEb3ByaSh4LHksZix5bWlkLGl0ZXJhdGlvbnMsbXNnLGV2ZW50cykge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMueW1pZCA9IHltaWQ7XG4gICAgdGhpcy5pdGVyYXRpb25zID0gaXRlcmF0aW9ucztcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG59XG5udW1lcmljLkRvcHJpLnByb3RvdHlwZS5fYXQgPSBmdW5jdGlvbiBfYXQoeGksaikge1xuICAgIGZ1bmN0aW9uIHNxcih4KSB7IHJldHVybiB4Kng7IH1cbiAgICB2YXIgc29sID0gdGhpcztcbiAgICB2YXIgeHMgPSBzb2wueDtcbiAgICB2YXIgeXMgPSBzb2wueTtcbiAgICB2YXIgazEgPSBzb2wuZjtcbiAgICB2YXIgeW1pZCA9IHNvbC55bWlkO1xuICAgIHZhciBuID0geHMubGVuZ3RoO1xuICAgIHZhciB4MCx4MSx4aCx5MCx5MSx5aCx4aTtcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yLGg7XG4gICAgdmFyIGMgPSAwLjU7XG4gICAgdmFyIGFkZCA9IG51bWVyaWMuYWRkLCBtdWwgPSBudW1lcmljLm11bCxzdWIgPSBudW1lcmljLnN1YiwgcCxxLHc7XG4gICAgeDAgPSB4c1tqXTtcbiAgICB4MSA9IHhzW2orMV07XG4gICAgeTAgPSB5c1tqXTtcbiAgICB5MSA9IHlzW2orMV07XG4gICAgaCAgPSB4MS14MDtcbiAgICB4aCA9IHgwK2MqaDtcbiAgICB5aCA9IHltaWRbal07XG4gICAgcCA9IHN1YihrMVtqICBdLG11bCh5MCwxLyh4MC14aCkrMi8oeDAteDEpKSk7XG4gICAgcSA9IHN1YihrMVtqKzFdLG11bCh5MSwxLyh4MS14aCkrMi8oeDEteDApKSk7XG4gICAgdyA9IFtzcXIoeGkgLSB4MSkgKiAoeGkgLSB4aCkgLyBzcXIoeDAgLSB4MSkgLyAoeDAgLSB4aCksXG4gICAgICAgICBzcXIoeGkgLSB4MCkgKiBzcXIoeGkgLSB4MSkgLyBzcXIoeDAgLSB4aCkgLyBzcXIoeDEgLSB4aCksXG4gICAgICAgICBzcXIoeGkgLSB4MCkgKiAoeGkgLSB4aCkgLyBzcXIoeDEgLSB4MCkgLyAoeDEgLSB4aCksXG4gICAgICAgICAoeGkgLSB4MCkgKiBzcXIoeGkgLSB4MSkgKiAoeGkgLSB4aCkgLyBzcXIoeDAteDEpIC8gKHgwIC0geGgpLFxuICAgICAgICAgKHhpIC0geDEpICogc3FyKHhpIC0geDApICogKHhpIC0geGgpIC8gc3FyKHgwLXgxKSAvICh4MSAtIHhoKV07XG4gICAgcmV0dXJuIGFkZChhZGQoYWRkKGFkZChtdWwoeTAsd1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoeWgsd1sxXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKHkxLHdbMl0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bCggcCx3WzNdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoIHEsd1s0XSkpO1xufVxubnVtZXJpYy5Eb3ByaS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCh4KSB7XG4gICAgdmFyIGksaixrLGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICBpZih0eXBlb2YgeCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgbiA9IHgubGVuZ3RoLCByZXQgPSBBcnJheShuKTtcbiAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHRoaXMuYXQoeFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdmFyIHgwID0gdGhpcy54O1xuICAgIGkgPSAwOyBqID0geDAubGVuZ3RoLTE7XG4gICAgd2hpbGUoai1pPjEpIHtcbiAgICAgICAgayA9IGZsb29yKDAuNSooaStqKSk7XG4gICAgICAgIGlmKHgwW2tdIDw9IHgpIGkgPSBrO1xuICAgICAgICBlbHNlIGogPSBrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXQoeCxpKTtcbn1cblxubnVtZXJpYy5kb3ByaSA9IGZ1bmN0aW9uIGRvcHJpKHgwLHgxLHkwLGYsdG9sLG1heGl0LGV2ZW50KSB7XG4gICAgaWYodHlwZW9mIHRvbCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0b2wgPSAxZS02OyB9XG4gICAgaWYodHlwZW9mIG1heGl0ID09PSBcInVuZGVmaW5lZFwiKSB7IG1heGl0ID0gMTAwMDsgfVxuICAgIHZhciB4cyA9IFt4MF0sIHlzID0gW3kwXSwgazEgPSBbZih4MCx5MCldLCBrMixrMyxrNCxrNSxrNixrNywgeW1pZCA9IFtdO1xuICAgIHZhciBBMiA9IDEvNTtcbiAgICB2YXIgQTMgPSBbMy80MCw5LzQwXTtcbiAgICB2YXIgQTQgPSBbNDQvNDUsLTU2LzE1LDMyLzldO1xuICAgIHZhciBBNSA9IFsxOTM3Mi82NTYxLC0yNTM2MC8yMTg3LDY0NDQ4LzY1NjEsLTIxMi83MjldO1xuICAgIHZhciBBNiA9IFs5MDE3LzMxNjgsLTM1NS8zMyw0NjczMi81MjQ3LDQ5LzE3NiwtNTEwMy8xODY1Nl07XG4gICAgdmFyIGIgPSBbMzUvMzg0LDAsNTAwLzExMTMsMTI1LzE5MiwtMjE4Ny82Nzg0LDExLzg0XTtcbiAgICB2YXIgYm0gPSBbMC41KjYwMjUxOTI3NDMvMzAwODU1NTMxNTIsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAuNSo1MTI1MjI5MjkyNS82NTQwMDgyMTU5OCxcbiAgICAgICAgICAgICAgMC41Ki0yNjkxODY4OTI1LzQ1MTI4MzI5NzI4LFxuICAgICAgICAgICAgICAwLjUqMTg3OTQwMzcyMDY3LzE1OTQ1MzQzMTcwNTYsXG4gICAgICAgICAgICAgIDAuNSotMTc3NjA5NDMzMS8xOTc0MzY0NDI1NixcbiAgICAgICAgICAgICAgMC41KjExMjM3MDk5LzIzNTA0MzM4NF07XG4gICAgdmFyIGMgPSBbMS81LDMvMTAsNC81LDgvOSwxLDFdO1xuICAgIHZhciBlID0gWy03MS81NzYwMCwwLDcxLzE2Njk1LC03MS8xOTIwLDE3MjUzLzMzOTIwMCwtMjIvNTI1LDEvNDBdO1xuICAgIHZhciBpID0gMCxlcixqO1xuICAgIHZhciBoID0gKHgxLXgwKS8xMDtcbiAgICB2YXIgaXQgPSAwO1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgbXVsID0gbnVtZXJpYy5tdWwsIHkxLGVyaW5mO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCwgbWluID0gTWF0aC5taW4sIGFicyA9IE1hdGguYWJzLCBub3JtaW5mID0gbnVtZXJpYy5ub3JtaW5mLHBvdyA9IE1hdGgucG93O1xuICAgIHZhciBhbnkgPSBudW1lcmljLmFueSwgbHQgPSBudW1lcmljLmx0LCBhbmQgPSBudW1lcmljLmFuZCwgc3ViID0gbnVtZXJpYy5zdWI7XG4gICAgdmFyIGUwLCBlMSwgZXY7XG4gICAgdmFyIHJldCA9IG5ldyBudW1lcmljLkRvcHJpKHhzLHlzLGsxLHltaWQsLTEsXCJcIik7XG4gICAgaWYodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIGUwID0gZXZlbnQoeDAseTApO1xuICAgIHdoaWxlKHgwPHgxICYmIGl0PG1heGl0KSB7XG4gICAgICAgICsraXQ7XG4gICAgICAgIGlmKHgwK2g+eDEpIGggPSB4MS14MDtcbiAgICAgICAgazIgPSBmKHgwK2NbMF0qaCwgICAgICAgICAgICAgICAgYWRkKHkwLG11bCggICBBMipoLGsxW2ldKSkpO1xuICAgICAgICBrMyA9IGYoeDArY1sxXSpoLCAgICAgICAgICAgIGFkZChhZGQoeTAsbXVsKEEzWzBdKmgsazFbaV0pKSxtdWwoQTNbMV0qaCxrMikpKTtcbiAgICAgICAgazQgPSBmKHgwK2NbMl0qaCwgICAgICAgIGFkZChhZGQoYWRkKHkwLG11bChBNFswXSpoLGsxW2ldKSksbXVsKEE0WzFdKmgsazIpKSxtdWwoQTRbMl0qaCxrMykpKTtcbiAgICAgICAgazUgPSBmKHgwK2NbM10qaCwgICAgYWRkKGFkZChhZGQoYWRkKHkwLG11bChBNVswXSpoLGsxW2ldKSksbXVsKEE1WzFdKmgsazIpKSxtdWwoQTVbMl0qaCxrMykpLG11bChBNVszXSpoLGs0KSkpO1xuICAgICAgICBrNiA9IGYoeDArY1s0XSpoLGFkZChhZGQoYWRkKGFkZChhZGQoeTAsbXVsKEE2WzBdKmgsazFbaV0pKSxtdWwoQTZbMV0qaCxrMikpLG11bChBNlsyXSpoLGszKSksbXVsKEE2WzNdKmgsazQpKSxtdWwoQTZbNF0qaCxrNSkpKTtcbiAgICAgICAgeTEgPSBhZGQoYWRkKGFkZChhZGQoYWRkKHkwLG11bChrMVtpXSxoKmJbMF0pKSxtdWwoazMsaCpiWzJdKSksbXVsKGs0LGgqYlszXSkpLG11bChrNSxoKmJbNF0pKSxtdWwoazYsaCpiWzVdKSk7XG4gICAgICAgIGs3ID0gZih4MCtoLHkxKTtcbiAgICAgICAgZXIgPSBhZGQoYWRkKGFkZChhZGQoYWRkKG11bChrMVtpXSxoKmVbMF0pLG11bChrMyxoKmVbMl0pKSxtdWwoazQsaCplWzNdKSksbXVsKGs1LGgqZVs0XSkpLG11bChrNixoKmVbNV0pKSxtdWwoazcsaCplWzZdKSk7XG4gICAgICAgIGlmKHR5cGVvZiBlciA9PT0gXCJudW1iZXJcIikgZXJpbmYgPSBhYnMoZXIpO1xuICAgICAgICBlbHNlIGVyaW5mID0gbm9ybWluZihlcik7XG4gICAgICAgIGlmKGVyaW5mID4gdG9sKSB7IC8vIHJlamVjdFxuICAgICAgICAgICAgaCA9IDAuMipoKnBvdyh0b2wvZXJpbmYsMC4yNSk7XG4gICAgICAgICAgICBpZih4MCtoID09PSB4MCkge1xuICAgICAgICAgICAgICAgIHJldC5tc2cgPSBcIlN0ZXAgc2l6ZSBiZWNhbWUgdG9vIHNtYWxsXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB5bWlkW2ldID0gYWRkKGFkZChhZGQoYWRkKGFkZChhZGQoeTAsXG4gICAgICAgICAgICAgICAgbXVsKGsxW2ldLGgqYm1bMF0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazMgICAsaCpibVsyXSkpLFxuICAgICAgICAgICAgICAgIG11bChrNCAgICxoKmJtWzNdKSksXG4gICAgICAgICAgICAgICAgbXVsKGs1ICAgLGgqYm1bNF0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazYgICAsaCpibVs1XSkpLFxuICAgICAgICAgICAgICAgIG11bChrNyAgICxoKmJtWzZdKSk7XG4gICAgICAgICsraTtcbiAgICAgICAgeHNbaV0gPSB4MCtoO1xuICAgICAgICB5c1tpXSA9IHkxO1xuICAgICAgICBrMVtpXSA9IGs3O1xuICAgICAgICBpZih0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHlpLHhsID0geDAseHIgPSB4MCswLjUqaCx4aTtcbiAgICAgICAgICAgIGUxID0gZXZlbnQoeHIseW1pZFtpLTFdKTtcbiAgICAgICAgICAgIGV2ID0gYW5kKGx0KGUwLDApLGx0KDAsZTEpKTtcbiAgICAgICAgICAgIGlmKCFhbnkoZXYpKSB7IHhsID0geHI7IHhyID0geDAraDsgZTAgPSBlMTsgZTEgPSBldmVudCh4cix5MSk7IGV2ID0gYW5kKGx0KGUwLDApLGx0KDAsZTEpKTsgfVxuICAgICAgICAgICAgaWYoYW55KGV2KSkge1xuICAgICAgICAgICAgICAgIHZhciB4YywgeWMsIGVuLGVpO1xuICAgICAgICAgICAgICAgIHZhciBzaWRlPTAsIHNsID0gMS4wLCBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICB3aGlsZSgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlMCA9PT0gXCJudW1iZXJcIikgeGkgPSAoc3IqZTEqeGwtc2wqZTAqeHIpLyhzciplMS1zbCplMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqPWUwLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlMFtqXTwwICYmIGUxW2pdPjApIHhpID0gbWluKHhpLChzciplMVtqXSp4bC1zbCplMFtqXSp4cikvKHNyKmUxW2pdLXNsKmUwW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoeGkgPD0geGwgfHwgeGkgPj0geHIpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHJldC5fYXQoeGksIGktMSk7XG4gICAgICAgICAgICAgICAgICAgIGVpID0gZXZlbnQoeGkseWkpO1xuICAgICAgICAgICAgICAgICAgICBlbiA9IGFuZChsdChlMCwwKSxsdCgwLGVpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFueShlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhyID0geGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlMSA9IGVpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSBlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gLTEpIHNsICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugc2wgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZTAgPSBlaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gMSkgc3IgKj0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkxID0gcmV0Ll9hdCgwLjUqKHgwK3hpKSxpLTEpO1xuICAgICAgICAgICAgICAgIHJldC5mW2ldID0gZih4aSx5aSk7XG4gICAgICAgICAgICAgICAgcmV0LnhbaV0gPSB4aTtcbiAgICAgICAgICAgICAgICByZXQueVtpXSA9IHlpO1xuICAgICAgICAgICAgICAgIHJldC55bWlkW2ktMV0gPSB5MTtcbiAgICAgICAgICAgICAgICByZXQuZXZlbnRzID0gZXY7XG4gICAgICAgICAgICAgICAgcmV0Lml0ZXJhdGlvbnMgPSBpdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHgwICs9IGg7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIGUwID0gZTE7XG4gICAgICAgIGggPSBtaW4oMC44KmgqcG93KHRvbC9lcmluZiwwLjI1KSw0KmgpO1xuICAgIH1cbiAgICByZXQuaXRlcmF0aW9ucyA9IGl0O1xuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDExLiBBeCA9IGJcbm51bWVyaWMuTFUgPSBmdW5jdGlvbihBLCBmYXN0KSB7XG4gIGZhc3QgPSBmYXN0IHx8IGZhbHNlO1xuXG4gIHZhciBhYnMgPSBNYXRoLmFicztcbiAgdmFyIGksIGosIGssIGFic0FqaywgQWtrLCBBaywgUGssIEFpO1xuICB2YXIgbWF4O1xuICB2YXIgbiA9IEEubGVuZ3RoLCBuMSA9IG4tMTtcbiAgdmFyIFAgPSBuZXcgQXJyYXkobik7XG4gIGlmKCFmYXN0KSBBID0gbnVtZXJpYy5jbG9uZShBKTtcblxuICBmb3IgKGsgPSAwOyBrIDwgbjsgKytrKSB7XG4gICAgUGsgPSBrO1xuICAgIEFrID0gQVtrXTtcbiAgICBtYXggPSBhYnMoQWtba10pO1xuICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBhYnNBamsgPSBhYnMoQVtqXVtrXSk7XG4gICAgICBpZiAobWF4IDwgYWJzQWprKSB7XG4gICAgICAgIG1heCA9IGFic0FqaztcbiAgICAgICAgUGsgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBQW2tdID0gUGs7XG5cbiAgICBpZiAoUGsgIT0gaykge1xuICAgICAgQVtrXSA9IEFbUGtdO1xuICAgICAgQVtQa10gPSBBaztcbiAgICAgIEFrID0gQVtrXTtcbiAgICB9XG5cbiAgICBBa2sgPSBBa1trXTtcblxuICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBBW2ldW2tdIC89IEFraztcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47ICsraSkge1xuICAgICAgQWkgPSBBW2ldO1xuICAgICAgZm9yIChqID0gayArIDE7IGogPCBuMTsgKytqKSB7XG4gICAgICAgIEFpW2pdIC09IEFpW2tdICogQWtbal07XG4gICAgICAgICsrajtcbiAgICAgICAgQWlbal0gLT0gQWlba10gKiBBa1tqXTtcbiAgICAgIH1cbiAgICAgIGlmKGo9PT1uMSkgQWlbal0gLT0gQWlba10gKiBBa1tqXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIExVOiBBLFxuICAgIFA6ICBQXG4gIH07XG59XG5cbm51bWVyaWMuTFVzb2x2ZSA9IGZ1bmN0aW9uIExVc29sdmUoTFVQLCBiKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgTFUgPSBMVVAuTFU7XG4gIHZhciBuICAgPSBMVS5sZW5ndGg7XG4gIHZhciB4ID0gbnVtZXJpYy5jbG9uZShiKTtcbiAgdmFyIFAgICA9IExVUC5QO1xuICB2YXIgUGksIExVaSwgTFVpaSwgdG1wO1xuXG4gIGZvciAoaT1uLTE7aSE9PS0xOy0taSkgeFtpXSA9IGJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBQaSA9IFBbaV07XG4gICAgaWYgKFBbaV0gIT09IGkpIHtcbiAgICAgIHRtcCA9IHhbaV07XG4gICAgICB4W2ldID0geFtQaV07XG4gICAgICB4W1BpXSA9IHRtcDtcbiAgICB9XG5cbiAgICBMVWkgPSBMVVtpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgaTsgKytqKSB7XG4gICAgICB4W2ldIC09IHhbal0gKiBMVWlbal07XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgTFVpID0gTFVbaV07XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIHhbaV0gLT0geFtqXSAqIExVaVtqXTtcbiAgICB9XG5cbiAgICB4W2ldIC89IExVaVtpXTtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuXG5udW1lcmljLnNvbHZlID0gZnVuY3Rpb24gc29sdmUoQSxiLGZhc3QpIHsgcmV0dXJuIG51bWVyaWMuTFVzb2x2ZShudW1lcmljLkxVKEEsZmFzdCksIGIpOyB9XG5cbi8vIDEyLiBMaW5lYXIgcHJvZ3JhbW1pbmdcbm51bWVyaWMuZWNoZWxvbml6ZSA9IGZ1bmN0aW9uIGVjaGVsb25pemUoQSkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oQSksIG0gPSBzWzBdLCBuID0gc1sxXTtcbiAgICB2YXIgSSA9IG51bWVyaWMuaWRlbnRpdHkobSk7XG4gICAgdmFyIFAgPSBBcnJheShtKTtcbiAgICB2YXIgaSxqLGssbCxBaSxJaSxaLGE7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBkaXZlcSA9IG51bWVyaWMuZGl2ZXE7XG4gICAgQSA9IG51bWVyaWMuY2xvbmUoQSk7XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIElpID0gSVtpXTtcbiAgICAgICAgZm9yKGo9MTtqPG47KytqKSBpZihhYnMoQWlba10pPGFicyhBaVtqXSkpIGs9ajtcbiAgICAgICAgUFtpXSA9IGs7XG4gICAgICAgIGRpdmVxKElpLEFpW2tdKTtcbiAgICAgICAgZGl2ZXEoQWksQWlba10pO1xuICAgICAgICBmb3Ioaj0wO2o8bTsrK2opIGlmKGohPT1pKSB7XG4gICAgICAgICAgICBaID0gQVtqXTsgYSA9IFpba107XG4gICAgICAgICAgICBmb3IobD1uLTE7bCE9PS0xOy0tbCkgWltsXSAtPSBBaVtsXSphO1xuICAgICAgICAgICAgWiA9IElbal07XG4gICAgICAgICAgICBmb3IobD1tLTE7bCE9PS0xOy0tbCkgWltsXSAtPSBJaVtsXSphO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7STpJLCBBOkEsIFA6UH07XG59XG5cbm51bWVyaWMuX19zb2x2ZUxQID0gZnVuY3Rpb24gX19zb2x2ZUxQKGMsQSxiLHRvbCxtYXhpdCx4LGZsYWcpIHtcbiAgICB2YXIgc3VtID0gbnVtZXJpYy5zdW0sIGxvZyA9IG51bWVyaWMubG9nLCBtdWwgPSBudW1lcmljLm11bCwgc3ViID0gbnVtZXJpYy5zdWIsIGRvdCA9IG51bWVyaWMuZG90LCBkaXYgPSBudW1lcmljLmRpdiwgYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgdmFyIG0gPSBjLmxlbmd0aCwgbiA9IGIubGVuZ3RoLHk7XG4gICAgdmFyIHVuYm91bmRlZCA9IGZhbHNlLCBjYixpMD0wO1xuICAgIHZhciBhbHBoYSA9IDEuMDtcbiAgICB2YXIgZjAsZGYwLEFUID0gbnVtZXJpYy50cmFuc3Bvc2UoQSksIHN2ZCA9IG51bWVyaWMuc3ZkLHRyYW5zcG9zZSA9IG51bWVyaWMudHJhbnNwb3NlLGxlcSA9IG51bWVyaWMubGVxLCBzcXJ0ID0gTWF0aC5zcXJ0LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgbXVsZXEgPSBudW1lcmljLm11bGVxO1xuICAgIHZhciBub3JtID0gbnVtZXJpYy5ub3JtaW5mLCBhbnkgPSBudW1lcmljLmFueSxtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgYWxsID0gbnVtZXJpYy5hbGwsIGd0ID0gbnVtZXJpYy5ndDtcbiAgICB2YXIgcCA9IEFycmF5KG0pLCBBMCA9IEFycmF5KG4pLGU9bnVtZXJpYy5yZXAoW25dLDEpLCBIO1xuICAgIHZhciBzb2x2ZSA9IG51bWVyaWMuc29sdmUsIHogPSBzdWIoYixkb3QoQSx4KSksY291bnQ7XG4gICAgdmFyIGRvdGNjID0gZG90KGMsYyk7XG4gICAgdmFyIGc7XG4gICAgZm9yKGNvdW50PWkwO2NvdW50PG1heGl0OysrY291bnQpIHtcbiAgICAgICAgdmFyIGksaixkO1xuICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgQTBbaV0gPSBkaXYoQVtpXSx6W2ldKTtcbiAgICAgICAgdmFyIEExID0gdHJhbnNwb3NlKEEwKTtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHBbaV0gPSAoLyp4W2ldKyovc3VtKEExW2ldKSk7XG4gICAgICAgIGFscGhhID0gMC4yNSphYnMoZG90Y2MvZG90KGMscCkpO1xuICAgICAgICB2YXIgYTEgPSAxMDAqc3FydChkb3RjYy9kb3QocCxwKSk7XG4gICAgICAgIGlmKCFpc0Zpbml0ZShhbHBoYSkgfHwgYWxwaGE+YTEpIGFscGhhID0gYTE7XG4gICAgICAgIGcgPSBhZGQoYyxtdWwoYWxwaGEscCkpO1xuICAgICAgICBIID0gZG90KEExLEEwKTtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIEhbaV1baV0gKz0gMTtcbiAgICAgICAgZCA9IHNvbHZlKEgsZGl2KGcsYWxwaGEpLHRydWUpO1xuICAgICAgICB2YXIgdDAgPSBkaXYoeixkb3QoQSxkKSk7XG4gICAgICAgIHZhciB0ID0gMS4wO1xuICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYodDBbaV08MCkgdCA9IG1pbih0LC0wLjk5OSp0MFtpXSk7XG4gICAgICAgIHkgPSBzdWIoeCxtdWwoZCx0KSk7XG4gICAgICAgIHogPSBzdWIoYixkb3QoQSx5KSk7XG4gICAgICAgIGlmKCFhbGwoZ3QoeiwwKSkpIHJldHVybiB7IHNvbHV0aW9uOiB4LCBtZXNzYWdlOiBcIlwiLCBpdGVyYXRpb25zOiBjb3VudCB9O1xuICAgICAgICB4ID0geTtcbiAgICAgICAgaWYoYWxwaGE8dG9sKSByZXR1cm4geyBzb2x1dGlvbjogeSwgbWVzc2FnZTogXCJcIiwgaXRlcmF0aW9uczogY291bnQgfTtcbiAgICAgICAgaWYoZmxhZykge1xuICAgICAgICAgICAgdmFyIHMgPSBkb3QoYyxnKSwgQWcgPSBkb3QoQSxnKTtcbiAgICAgICAgICAgIHVuYm91bmRlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYocypBZ1tpXTwwKSB7IHVuYm91bmRlZCA9IGZhbHNlOyBicmVhazsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoeFttLTFdPj0wKSB1bmJvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgdW5ib3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih1bmJvdW5kZWQpIHJldHVybiB7IHNvbHV0aW9uOiB5LCBtZXNzYWdlOiBcIlVuYm91bmRlZFwiLCBpdGVyYXRpb25zOiBjb3VudCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzb2x1dGlvbjogeCwgbWVzc2FnZTogXCJtYXhpbXVtIGl0ZXJhdGlvbiBjb3VudCBleGNlZWRlZFwiLCBpdGVyYXRpb25zOmNvdW50IH07XG59XG5cbm51bWVyaWMuX3NvbHZlTFAgPSBmdW5jdGlvbiBfc29sdmVMUChjLEEsYix0b2wsbWF4aXQpIHtcbiAgICB2YXIgbSA9IGMubGVuZ3RoLCBuID0gYi5sZW5ndGgseTtcbiAgICB2YXIgc3VtID0gbnVtZXJpYy5zdW0sIGxvZyA9IG51bWVyaWMubG9nLCBtdWwgPSBudW1lcmljLm11bCwgc3ViID0gbnVtZXJpYy5zdWIsIGRvdCA9IG51bWVyaWMuZG90LCBkaXYgPSBudW1lcmljLmRpdiwgYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgdmFyIGMwID0gbnVtZXJpYy5yZXAoW21dLDApLmNvbmNhdChbMV0pO1xuICAgIHZhciBKID0gbnVtZXJpYy5yZXAoW24sMV0sLTEpO1xuICAgIHZhciBBMCA9IG51bWVyaWMuYmxvY2tNYXRyaXgoW1tBICAgICAgICAgICAgICAgICAgICwgICBKICBdXSk7XG4gICAgdmFyIGIwID0gYjtcbiAgICB2YXIgeSA9IG51bWVyaWMucmVwKFttXSwwKS5jb25jYXQoTWF0aC5tYXgoMCxudW1lcmljLnN1cChudW1lcmljLm5lZyhiKSkpKzEpO1xuICAgIHZhciB4MCA9IG51bWVyaWMuX19zb2x2ZUxQKGMwLEEwLGIwLHRvbCxtYXhpdCx5LGZhbHNlKTtcbiAgICB2YXIgeCA9IG51bWVyaWMuY2xvbmUoeDAuc29sdXRpb24pO1xuICAgIHgubGVuZ3RoID0gbTtcbiAgICB2YXIgZm9vID0gbnVtZXJpYy5pbmYoc3ViKGIsZG90KEEseCkpKTtcbiAgICBpZihmb288MCkgeyByZXR1cm4geyBzb2x1dGlvbjogTmFOLCBtZXNzYWdlOiBcIkluZmVhc2libGVcIiwgaXRlcmF0aW9uczogeDAuaXRlcmF0aW9ucyB9OyB9XG4gICAgdmFyIHJldCA9IG51bWVyaWMuX19zb2x2ZUxQKGMsIEEsIGIsIHRvbCwgbWF4aXQteDAuaXRlcmF0aW9ucywgeCwgdHJ1ZSk7XG4gICAgcmV0Lml0ZXJhdGlvbnMgKz0geDAuaXRlcmF0aW9ucztcbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5zb2x2ZUxQID0gZnVuY3Rpb24gc29sdmVMUChjLEEsYixBZXEsYmVxLHRvbCxtYXhpdCkge1xuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgbWF4aXQgPSAxMDAwO1xuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHRvbCA9IG51bWVyaWMuZXBzaWxvbjtcbiAgICBpZih0eXBlb2YgQWVxID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVtZXJpYy5fc29sdmVMUChjLEEsYix0b2wsbWF4aXQpO1xuICAgIHZhciBtID0gQWVxLmxlbmd0aCwgbiA9IEFlcVswXS5sZW5ndGgsIG8gPSBBLmxlbmd0aDtcbiAgICB2YXIgQiA9IG51bWVyaWMuZWNoZWxvbml6ZShBZXEpO1xuICAgIHZhciBmbGFncyA9IG51bWVyaWMucmVwKFtuXSwwKTtcbiAgICB2YXIgUCA9IEIuUDtcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgZmxhZ3NbUFtpXV0gPSAxO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSBpZihmbGFnc1tpXT09PTApIFEucHVzaChpKTtcbiAgICB2YXIgZyA9IG51bWVyaWMuZ2V0UmFuZ2U7XG4gICAgdmFyIEkgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKSwgSiA9IG51bWVyaWMubGluc3BhY2UoMCxvLTEpO1xuICAgIHZhciBBZXEyID0gZyhBZXEsSSxRKSwgQTEgPSBnKEEsSixQKSwgQTIgPSBnKEEsSixRKSwgZG90ID0gbnVtZXJpYy5kb3QsIHN1YiA9IG51bWVyaWMuc3ViO1xuICAgIHZhciBBMyA9IGRvdChBMSxCLkkpO1xuICAgIHZhciBBNCA9IHN1YihBMixkb3QoQTMsQWVxMikpLCBiNCA9IHN1YihiLGRvdChBMyxiZXEpKTtcbiAgICB2YXIgYzEgPSBBcnJheShQLmxlbmd0aCksIGMyID0gQXJyYXkoUS5sZW5ndGgpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgYzFbaV0gPSBjW1BbaV1dO1xuICAgIGZvcihpPVEubGVuZ3RoLTE7aSE9PS0xOy0taSkgYzJbaV0gPSBjW1FbaV1dO1xuICAgIHZhciBjNCA9IHN1YihjMixkb3QoYzEsZG90KEIuSSxBZXEyKSkpO1xuICAgIHZhciBTID0gbnVtZXJpYy5fc29sdmVMUChjNCxBNCxiNCx0b2wsbWF4aXQpO1xuICAgIHZhciB4MiA9IFMuc29sdXRpb247XG4gICAgaWYoeDIhPT14MikgcmV0dXJuIFM7XG4gICAgdmFyIHgxID0gZG90KEIuSSxzdWIoYmVxLGRvdChBZXEyLHgyKSkpO1xuICAgIHZhciB4ID0gQXJyYXkoYy5sZW5ndGgpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgeFtQW2ldXSA9IHgxW2ldO1xuICAgIGZvcihpPVEubGVuZ3RoLTE7aSE9PS0xOy0taSkgeFtRW2ldXSA9IHgyW2ldO1xuICAgIHJldHVybiB7IHNvbHV0aW9uOiB4LCBtZXNzYWdlOlMubWVzc2FnZSwgaXRlcmF0aW9uczogUy5pdGVyYXRpb25zIH07XG59XG5cbm51bWVyaWMuTVBTdG9MUCA9IGZ1bmN0aW9uIE1QU3RvTFAoTVBTKSB7XG4gICAgaWYoTVBTIGluc3RhbmNlb2YgU3RyaW5nKSB7IE1QUy5zcGxpdCgnXFxuJyk7IH1cbiAgICB2YXIgc3RhdGUgPSAwO1xuICAgIHZhciBzdGF0ZXMgPSBbJ0luaXRpYWwgc3RhdGUnLCdOQU1FJywnUk9XUycsJ0NPTFVNTlMnLCdSSFMnLCdCT1VORFMnLCdFTkRBVEEnXTtcbiAgICB2YXIgbiA9IE1QUy5sZW5ndGg7XG4gICAgdmFyIGksaix6LE49MCxyb3dzID0ge30sIHNpZ24gPSBbXSwgcmwgPSAwLCB2YXJzID0ge30sIG52ID0gMDtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgYyA9IFtdLCBBID0gW10sIGIgPSBbXTtcbiAgICBmdW5jdGlvbiBlcnIoZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ01QU3RvTFA6ICcrZSsnXFxuTGluZSAnK2krJzogJytNUFNbaV0rJ1xcbkN1cnJlbnQgc3RhdGU6ICcrc3RhdGVzW3N0YXRlXSsnXFxuJyk7IH1cbiAgICBmb3IoaT0wO2k8bjsrK2kpIHtcbiAgICAgICAgeiA9IE1QU1tpXTtcbiAgICAgICAgdmFyIHcwID0gei5tYXRjaCgvXFxTKi9nKTtcbiAgICAgICAgdmFyIHcgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqPHcwLmxlbmd0aDsrK2opIGlmKHcwW2pdIT09XCJcIikgdy5wdXNoKHcwW2pdKTtcbiAgICAgICAgaWYody5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICBmb3Ioaj0wO2o8c3RhdGVzLmxlbmd0aDsrK2opIGlmKHouc3Vic3RyKDAsc3RhdGVzW2pdLmxlbmd0aCkgPT09IHN0YXRlc1tqXSkgYnJlYWs7XG4gICAgICAgIGlmKGo8c3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUgPSBqO1xuICAgICAgICAgICAgaWYoaj09PTEpIHsgbmFtZSA9IHdbMV07IH1cbiAgICAgICAgICAgIGlmKGo9PT02KSByZXR1cm4geyBuYW1lOm5hbWUsIGM6YywgQTpudW1lcmljLnRyYW5zcG9zZShBKSwgYjpiLCByb3dzOnJvd3MsIHZhcnM6dmFycyB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgMDogY2FzZSAxOiBlcnIoJ1VuZXhwZWN0ZWQgbGluZScpO1xuICAgICAgICBjYXNlIDI6IFxuICAgICAgICAgICAgc3dpdGNoKHdbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOiBpZihOPT09MCkgTiA9IHdbMV07IGVsc2UgZXJyKCdUd28gb3IgbW9yZSBOIHJvd3MnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IDE7IGJbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IC0xO2JbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IDA7YltybF0gPSAwOyArK3JsOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGVycignUGFyc2UgZXJyb3IgJytudW1lcmljLnByZXR0eVByaW50KHcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZighdmFycy5oYXNPd25Qcm9wZXJ0eSh3WzBdKSkgeyB2YXJzW3dbMF1dID0gbnY7IGNbbnZdID0gMDsgQVtudl0gPSBudW1lcmljLnJlcChbcmxdLDApOyArK252OyB9XG4gICAgICAgICAgICB2YXIgcCA9IHZhcnNbd1swXV07XG4gICAgICAgICAgICBmb3Ioaj0xO2o8dy5sZW5ndGg7ais9Mikge1xuICAgICAgICAgICAgICAgIGlmKHdbal0gPT09IE4pIHsgY1twXSA9IHBhcnNlRmxvYXQod1tqKzFdKTsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICB2YXIgcSA9IHJvd3Nbd1tqXV07XG4gICAgICAgICAgICAgICAgQVtwXVtxXSA9IChzaWduW3FdPDA/LTE6MSkqcGFyc2VGbG9hdCh3W2orMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGZvcihqPTE7ajx3Lmxlbmd0aDtqKz0yKSBiW3Jvd3Nbd1tqXV1dID0gKHNpZ25bcm93c1t3W2pdXV08MD8tMToxKSpwYXJzZUZsb2F0KHdbaisxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OiAvKkZJWE1FKi8gYnJlYWs7XG4gICAgICAgIGNhc2UgNjogZXJyKCdJbnRlcm5hbCBlcnJvcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVycignUmVhY2hlZCBlbmQgb2YgZmlsZSB3aXRob3V0IEVOREFUQScpO1xufVxuLy8gc2VlZHJhbmRvbS5qcyB2ZXJzaW9uIDIuMC5cbi8vIEF1dGhvcjogRGF2aWQgQmF1IDQvMi8yMDExXG4vL1xuLy8gRGVmaW5lcyBhIG1ldGhvZCBNYXRoLnNlZWRyYW5kb20oKSB0aGF0LCB3aGVuIGNhbGxlZCwgc3Vic3RpdHV0ZXNcbi8vIGFuIGV4cGxpY2l0bHkgc2VlZGVkIFJDNC1iYXNlZCBhbGdvcml0aG0gZm9yIE1hdGgucmFuZG9tKCkuICBBbHNvXG4vLyBzdXBwb3J0cyBhdXRvbWF0aWMgc2VlZGluZyBmcm9tIGxvY2FsIG9yIG5ldHdvcmsgc291cmNlcyBvZiBlbnRyb3B5LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vICAgPHNjcmlwdCBzcmM9aHR0cDovL2RhdmlkYmF1LmNvbS9lbmNvZGUvc2VlZHJhbmRvbS1taW4uanM+PC9zY3JpcHQ+XG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oJ3lpcGVlJyk7IFNldHMgTWF0aC5yYW5kb20gdG8gYSBmdW5jdGlvbiB0aGF0IGlzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIGdpdmVuIGV4cGxpY2l0IHNlZWQuXG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oKTsgICAgICAgIFNldHMgTWF0aC5yYW5kb20gdG8gYSBmdW5jdGlvbiB0aGF0IGlzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZGVkIHVzaW5nIHRoZSBjdXJyZW50IHRpbWUsIGRvbSBzdGF0ZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgb3RoZXIgYWNjdW11bGF0ZWQgbG9jYWwgZW50cm9weS5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNlZWQgc3RyaW5nIGlzIHJldHVybmVkLlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKCd5b3d6YScsIHRydWUpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZWRzIHVzaW5nIHRoZSBnaXZlbiBleHBsaWNpdCBzZWVkIG1peGVkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9nZXRoZXIgd2l0aCBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuLy9cbi8vICAgPHNjcmlwdCBzcmM9XCJodHRwOi8vYml0Lmx5L3NyYW5kb20tNTEyXCI+PC9zY3JpcHQ+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlZHMgdXNpbmcgcGh5c2ljYWwgcmFuZG9tIGJpdHMgZG93bmxvYWRlZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gcmFuZG9tLm9yZy5cbi8vXG4vLyAgIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9qc29ubGliLmFwcHNwb3QuY29tL3VyYW5kb20/Y2FsbGJhY2s9TWF0aC5zZWVkcmFuZG9tXCI+XG4vLyAgIDwvc2NyaXB0PiAgICAgICAgICAgICAgICAgU2VlZHMgdXNpbmcgdXJhbmRvbSBiaXRzIGZyb20gY2FsbC5qc29ubGliLmNvbSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBpcyBmYXN0ZXIgdGhhbiByYW5kb20ub3JnLlxuLy9cbi8vIEV4YW1wbGVzOlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKFwiaGVsbG9cIik7ICAgICAgICAgICAgLy8gVXNlIFwiaGVsbG9cIiBhcyB0aGUgc2VlZC5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjU0NjM2NjM3NjgxNDA3MzRcbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjQzOTczNzkzNzcwNTkyMjM0XG4vLyAgIHZhciBybmcxID0gTWF0aC5yYW5kb207ICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgY3VycmVudCBwcm5nLlxuLy9cbi8vICAgdmFyIGF1dG9zZWVkID0gTWF0aC5zZWVkcmFuZG9tKCk7ICAgIC8vIE5ldyBwcm5nIHdpdGggYW4gYXV0b21hdGljIHNlZWQuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBQcmV0dHkgbXVjaCB1bnByZWRpY3RhYmxlLlxuLy9cbi8vICAgTWF0aC5yYW5kb20gPSBybmcxOyAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIFwiaGVsbG9cIiBwcm5nIHNlcXVlbmNlLlxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gQWx3YXlzIDAuNTU0NzY5NDMyNDczNDU1XG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oYXV0b3NlZWQpOyAgICAgICAgICAgLy8gUmVzdGFydCBhdCB0aGUgcHJldmlvdXMgc2VlZC5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIFJlcGVhdCB0aGUgJ3VucHJlZGljdGFibGUnIHZhbHVlLlxuLy9cbi8vIE5vdGVzOlxuLy9cbi8vIEVhY2ggdGltZSBzZWVkcmFuZG9tKCdhcmcnKSBpcyBjYWxsZWQsIGVudHJvcHkgZnJvbSB0aGUgcGFzc2VkIHNlZWRcbi8vIGlzIGFjY3VtdWxhdGVkIGluIGEgcG9vbCB0byBoZWxwIGdlbmVyYXRlIGZ1dHVyZSBzZWVkcyBmb3IgdGhlXG4vLyB6ZXJvLWFyZ3VtZW50IGZvcm0gb2YgTWF0aC5zZWVkcmFuZG9tLCBzbyBlbnRyb3B5IGNhbiBiZSBpbmplY3RlZCBvdmVyXG4vLyB0aW1lIGJ5IGNhbGxpbmcgc2VlZHJhbmRvbSB3aXRoIGV4cGxpY2l0IGRhdGEgcmVwZWF0ZWRseS5cbi8vXG4vLyBPbiBzcGVlZCAtIFRoaXMgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBNYXRoLnJhbmRvbSgpIGlzIGFib3V0XG4vLyAzLTEweCBzbG93ZXIgdGhhbiB0aGUgYnVpbHQtaW4gTWF0aC5yYW5kb20oKSBiZWNhdXNlIGl0IGlzIG5vdCBuYXRpdmVcbi8vIGNvZGUsIGJ1dCB0aGlzIGlzIHR5cGljYWxseSBmYXN0IGVub3VnaCBhbnl3YXkuICBTZWVkaW5nIGlzIG1vcmUgZXhwZW5zaXZlLFxuLy8gZXNwZWNpYWxseSBpZiB5b3UgdXNlIGF1dG8tc2VlZGluZy4gIFNvbWUgZGV0YWlscyAodGltaW5ncyBvbiBDaHJvbWUgNCk6XG4vL1xuLy8gT3VyIE1hdGgucmFuZG9tKCkgICAgICAgICAgICAtIGF2ZyBsZXNzIHRoYW4gMC4wMDIgbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vLyBzZWVkcmFuZG9tKCdleHBsaWNpdCcpICAgICAgIC0gYXZnIGxlc3MgdGhhbiAwLjUgbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vLyBzZWVkcmFuZG9tKCdleHBsaWNpdCcsIHRydWUpIC0gYXZnIGxlc3MgdGhhbiAyIG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy8gc2VlZHJhbmRvbSgpICAgICAgICAgICAgICAgICAtIGF2ZyBhYm91dCAzOCBtaWxsaXNlY29uZHMgcGVyIGNhbGxcbi8vXG4vLyBMSUNFTlNFIChCU0QpOlxuLy9cbi8vIENvcHlyaWdodCAyMDEwIERhdmlkIEJhdSwgYWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy8gXG4vLyAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vXG4vLyAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vIFxuLy8gICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoaXMgbW9kdWxlIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbi8vICAgICAgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbi8vICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyBcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vKipcbiAqIEFsbCBjb2RlIGlzIGluIGFuIGFub255bW91cyBjbG9zdXJlIHRvIGtlZXAgdGhlIGdsb2JhbCBuYW1lc3BhY2UgY2xlYW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXI9fSBvdmVyZmxvdyBcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc3RhcnRkZW5vbVxuICovXG5cbi8vIFBhdGNoZWQgYnkgU2ViIHNvIHRoYXQgc2VlZHJhbmRvbS5qcyBkb2VzIG5vdCBwb2xsdXRlIHRoZSBNYXRoIG9iamVjdC5cbi8vIE15IHRlc3RzIHN1Z2dlc3QgdGhhdCBkb2luZyBNYXRoLnRyb3VibGUgPSAxIG1ha2VzIE1hdGggbG9va3VwcyBhYm91dCA1JVxuLy8gc2xvd2VyLlxubnVtZXJpYy5zZWVkcmFuZG9tID0geyBwb3c6TWF0aC5wb3csIHJhbmRvbTpNYXRoLnJhbmRvbSB9O1xuXG4oZnVuY3Rpb24gKHBvb2wsIG1hdGgsIHdpZHRoLCBjaHVua3MsIHNpZ25pZmljYW5jZSwgb3ZlcmZsb3csIHN0YXJ0ZGVub20pIHtcblxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5tYXRoWydzZWVkcmFuZG9tJ10gPSBmdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIHVzZV9lbnRyb3B5KSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgdmFyIGFyYzQ7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICB1c2VfZW50cm9weSA/IFtzZWVkLCBwb29sXSA6XG4gICAgYXJndW1lbnRzLmxlbmd0aCA/IHNlZWQgOlxuICAgIFtuZXcgRGF0ZSgpLmdldFRpbWUoKSwgcG9vbCwgd2luZG93XSwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleShhcmM0LlMsIHBvb2wpO1xuXG4gIC8vIE92ZXJyaWRlIE1hdGgucmFuZG9tXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuXG4gIG1hdGhbJ3JhbmRvbSddID0gZnVuY3Rpb24gcmFuZG9tKCkgeyAgLy8gQ2xvc3VyZSB0byByZXR1cm4gYSByYW5kb20gZG91YmxlOlxuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyk7ICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgIHZhciBkID0gc3RhcnRkZW5vbTsgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgdmFyIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzZWVkIHRoYXQgd2FzIHVzZWRcbiAgcmV0dXJuIHNlZWQ7XG59O1xuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuLyoqIEBjb25zdHJ1Y3RvciAqL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIHUsIG1lID0gdGhpcywga2V5bGVuID0ga2V5Lmxlbmd0aDtcbiAgdmFyIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSBtZS5tID0gMDtcbiAgbWUuUyA9IFtdO1xuICBtZS5jID0gW107XG5cbiAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cbiAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxuXG4gIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG4gIHdoaWxlIChpIDwgd2lkdGgpIHsgbWUuU1tpXSA9IGkrKzsgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHQgPSBtZS5TW2ldO1xuICAgIGogPSBsb3diaXRzKGogKyB0ICsga2V5W2kgJSBrZXlsZW5dKTtcbiAgICB1ID0gbWUuU1tqXTtcbiAgICBtZS5TW2ldID0gdTtcbiAgICBtZS5TW2pdID0gdDtcbiAgfVxuXG4gIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cbiAgbWUuZyA9IGZ1bmN0aW9uIGdldG5leHQoY291bnQpIHtcbiAgICB2YXIgcyA9IG1lLlM7XG4gICAgdmFyIGkgPSBsb3diaXRzKG1lLmkgKyAxKTsgdmFyIHQgPSBzW2ldO1xuICAgIHZhciBqID0gbG93Yml0cyhtZS5qICsgdCk7IHZhciB1ID0gc1tqXTtcbiAgICBzW2ldID0gdTtcbiAgICBzW2pdID0gdDtcbiAgICB2YXIgciA9IHNbbG93Yml0cyh0ICsgdSldO1xuICAgIHdoaWxlICgtLWNvdW50KSB7XG4gICAgICBpID0gbG93Yml0cyhpICsgMSk7IHQgPSBzW2ldO1xuICAgICAgaiA9IGxvd2JpdHMoaiArIHQpOyB1ID0gc1tqXTtcbiAgICAgIHNbaV0gPSB1O1xuICAgICAgc1tqXSA9IHQ7XG4gICAgICByID0gciAqIHdpZHRoICsgc1tsb3diaXRzKHQgKyB1KV07XG4gICAgfVxuICAgIG1lLmkgPSBpO1xuICAgIG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICB9O1xuICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHkgZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy5cbiAgLy8gU2VlIGh0dHA6Ly93d3cucnNhLmNvbS9yc2FsYWJzL25vZGUuYXNwP2lkPTIwMDlcbiAgbWUuZyh3aWR0aCk7XG59XG5cbi8vXG4vLyBmbGF0dGVuKClcbi8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbi8vXG4vKiogQHBhcmFtIHtPYmplY3Q9fSByZXN1bHQgXG4gICogQHBhcmFtIHtzdHJpbmc9fSBwcm9wXG4gICogQHBhcmFtIHtzdHJpbmc9fSB0eXAgKi9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCwgcmVzdWx0LCBwcm9wLCB0eXApIHtcbiAgcmVzdWx0ID0gW107XG4gIHR5cCA9IHR5cGVvZihvYmopO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgaWYgKHByb3AuaW5kZXhPZignUycpIDwgNSkgeyAgICAvLyBBdm9pZCBGRjMgYnVnIChsb2NhbC9zZXNzaW9uU3RvcmFnZSlcbiAgICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiBvYmogKyAodHlwICE9ICdzdHJpbmcnID8gJ1xcMCcgOiAnJykpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbi8qKiBAcGFyYW0ge251bWJlcj19IHNtZWFyIFxuICAqIEBwYXJhbSB7bnVtYmVyPX0gaiAqL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSwgc21lYXIsIGopIHtcbiAgc2VlZCArPSAnJzsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBzZWVkIGlzIGEgc3RyaW5nXG4gIHNtZWFyID0gMDtcbiAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyBqKyspIHtcbiAgICBrZXlbbG93Yml0cyhqKV0gPVxuICAgICAgbG93Yml0cygoc21lYXIgXj0ga2V5W2xvd2JpdHMoaildICogMTkpICsgc2VlZC5jaGFyQ29kZUF0KGopKTtcbiAgfVxuICBzZWVkID0gJyc7XG4gIGZvciAoaiBpbiBrZXkpIHsgc2VlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleVtqXSk7IH1cbiAgcmV0dXJuIHNlZWQ7XG59XG5cbi8vXG4vLyBsb3diaXRzKClcbi8vIEEgcXVpY2sgXCJuIG1vZCB3aWR0aFwiIGZvciB3aWR0aCBhIHBvd2VyIG9mIDIuXG4vL1xuZnVuY3Rpb24gbG93Yml0cyhuKSB7IHJldHVybiBuICYgKHdpZHRoIC0gMSk7IH1cblxuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG5zdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyk7XG5zaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBzaWduaWZpY2FuY2UpO1xub3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyO1xuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlZmVyZSB3aXRoIGRldGVybWluc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIG1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uLlxuLy9cbm1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KFxuICBbXSwgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIG51bWVyaWMuc2VlZHJhbmRvbSwgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuICAyNTYsICAvLyB3aWR0aDogZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICA2LCAgICAvLyBjaHVua3M6IGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgNTIgICAgLy8gc2lnbmlmaWNhbmNlOiB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICkpO1xuLyogVGhpcyBmaWxlIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBxdWFkcHJvZy5qcyBmcm9tIEFsYmVydG8gU2FudGluaS5cbiAqIEl0IGhhcyBiZWVuIHNsaWdodGx5IG1vZGlmaWVkIGJ5IFPDqWJhc3RpZW4gTG9pc2VsIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGhhbmRsZXNcbiAqIDAtYmFzZWQgQXJyYXlzIGluc3RlYWQgb2YgMS1iYXNlZCBBcnJheXMuXG4gKiBMaWNlbnNlIGlzIGluIHJlc291cmNlcy9MSUNFTlNFLnF1YWRwcm9nICovXG4oZnVuY3Rpb24oZXhwb3J0cykge1xuXG5mdW5jdGlvbiBiYXNlMHRvMShBKSB7XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHsgcmV0dXJuIEE7IH1cbiAgICB2YXIgcmV0ID0gW10sIGksbj1BLmxlbmd0aDtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHJldFtpKzFdID0gYmFzZTB0bzEoQVtpXSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGJhc2UxdG8wKEEpIHtcbiAgICBpZih0eXBlb2YgQSAhPT0gXCJvYmplY3RcIikgeyByZXR1cm4gQTsgfVxuICAgIHZhciByZXQgPSBbXSwgaSxuPUEubGVuZ3RoO1xuICAgIGZvcihpPTE7aTxuO2krKykgcmV0W2ktMV0gPSBiYXNlMXRvMChBW2ldKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkcG9yaShhLCBsZGEsIG4pIHtcbiAgICB2YXIgaSwgaiwgaywga3AxLCB0O1xuXG4gICAgZm9yIChrID0gMTsgayA8PSBuOyBrID0gayArIDEpIHtcbiAgICAgICAgYVtrXVtrXSA9IDEgLyBhW2tdW2tdO1xuICAgICAgICB0ID0gLWFba11ba107XG4gICAgICAgIC8vfiBkc2NhbChrIC0gMSwgdCwgYVsxXVtrXSwgMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGFbaV1ba10gPSB0ICogYVtpXVtrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtwMSA9IGsgKyAxO1xuICAgICAgICBpZiAobiA8IGtwMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0ga3AxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgdCA9IGFba11bal07XG4gICAgICAgICAgICBhW2tdW2pdID0gMDtcbiAgICAgICAgICAgIC8vfiBkYXhweShrLCB0LCBhWzFdW2tdLCAxLCBhWzFdW2pdLCAxKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgYVtpXVtqXSA9IGFbaV1bal0gKyAodCAqIGFbaV1ba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGRwb3NsKGEsIGxkYSwgbiwgYikge1xuICAgIHZhciBpLCBrLCBrYiwgdDtcblxuICAgIGZvciAoayA9IDE7IGsgPD0gbjsgayA9IGsgKyAxKSB7XG4gICAgICAgIC8vfiB0ID0gZGRvdChrIC0gMSwgYVsxXVtrXSwgMSwgYlsxXSwgMSk7XG4gICAgICAgIHQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB0ID0gdCArIChhW2ldW2tdICogYltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBiW2tdID0gKGJba10gLSB0KSAvIGFba11ba107XG4gICAgfVxuXG4gICAgZm9yIChrYiA9IDE7IGtiIDw9IG47IGtiID0ga2IgKyAxKSB7XG4gICAgICAgIGsgPSBuICsgMSAtIGtiO1xuICAgICAgICBiW2tdID0gYltrXSAvIGFba11ba107XG4gICAgICAgIHQgPSAtYltrXTtcbiAgICAgICAgLy9+IGRheHB5KGsgLSAxLCB0LCBhWzFdW2tdLCAxLCBiWzFdLCAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgYltpXSA9IGJbaV0gKyAodCAqIGFbaV1ba10pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcG9mYShhLCBsZGEsIG4sIGluZm8pIHtcbiAgICB2YXIgaSwgaiwgam0xLCBrLCB0LCBzO1xuXG4gICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgaW5mb1sxXSA9IGo7XG4gICAgICAgIHMgPSAwO1xuICAgICAgICBqbTEgPSBqIC0gMTtcbiAgICAgICAgaWYgKGptMSA8IDEpIHtcbiAgICAgICAgICAgIHMgPSBhW2pdW2pdIC0gcztcbiAgICAgICAgICAgIGlmIChzIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbal1bal0gPSBNYXRoLnNxcnQocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAxOyBrIDw9IGptMTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgICAgICAgLy9+IHQgPSBhW2tdW2pdIC0gZGRvdChrIC0gMSwgYVsxXVtrXSwgMSwgYVsxXVtqXSwgMSk7XG4gICAgICAgICAgICAgICAgdCA9IGFba11bal07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdCAtIChhW2ldW2pdICogYVtpXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSB0IC8gYVtrXVtrXTtcbiAgICAgICAgICAgICAgICBhW2tdW2pdID0gdDtcbiAgICAgICAgICAgICAgICBzID0gcyArIHQgKiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IGFbal1bal0gLSBzO1xuICAgICAgICAgICAgaWYgKHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqXVtqXSA9IE1hdGguc3FydChzKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvWzFdID0gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHFwZ2VuMihkbWF0LCBkdmVjLCBmZGRtYXQsIG4sIHNvbCwgY3J2YWwsIGFtYXQsXG4gICAgYnZlYywgZmRhbWF0LCBxLCBtZXEsIGlhY3QsIG5hY3QsIGl0ZXIsIHdvcmssIGllcnIpIHtcblxuICAgIHZhciBpLCBqLCBsLCBsMSwgaW5mbywgaXQxLCBpd3p2LCBpd3J2LCBpd3JtLCBpd3N2LCBpd3V2LCBudmwsIHIsIGl3bmJ2LFxuICAgICAgICB0ZW1wLCBzdW0sIHQxLCB0dCwgZ2MsIGdzLCBudSxcbiAgICAgICAgdDFpbmYsIHQybWluLFxuICAgICAgICB2c21hbGwsIHRtcGEsIHRtcGIsXG4gICAgICAgIGdvO1xuXG4gICAgciA9IE1hdGgubWluKG4sIHEpO1xuICAgIGwgPSAyICogbiArIChyICogKHIgKyA1KSkgLyAyICsgMiAqIHEgKyAxO1xuXG4gICAgdnNtYWxsID0gMS4wZS02MDtcbiAgICBkbyB7XG4gICAgICAgIHZzbWFsbCA9IHZzbWFsbCArIHZzbWFsbDtcbiAgICAgICAgdG1wYSA9IDEgKyAwLjEgKiB2c21hbGw7XG4gICAgICAgIHRtcGIgPSAxICsgMC4yICogdnNtYWxsO1xuICAgIH0gd2hpbGUgKHRtcGEgPD0gMSB8fCB0bXBiIDw9IDEpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgd29ya1tpXSA9IGR2ZWNbaV07XG4gICAgfVxuICAgIGZvciAoaSA9IG4gKyAxOyBpIDw9IGw7IGkgPSBpICsgMSkge1xuICAgICAgICB3b3JrW2ldID0gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgaWFjdFtpXSA9IDA7XG4gICAgfVxuXG4gICAgaW5mbyA9IFtdO1xuXG4gICAgaWYgKGllcnJbMV0gPT09IDApIHtcbiAgICAgICAgZHBvZmEoZG1hdCwgZmRkbWF0LCBuLCBpbmZvKTtcbiAgICAgICAgaWYgKGluZm9bMV0gIT09IDApIHtcbiAgICAgICAgICAgIGllcnJbMV0gPSAyO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRwb3NsKGRtYXQsIGZkZG1hdCwgbiwgZHZlYyk7XG4gICAgICAgIGRwb3JpKGRtYXQsIGZkZG1hdCwgbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHNvbFtqXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGo7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHNvbFtqXSA9IHNvbFtqXSArIGRtYXRbaV1bal0gKiBkdmVjW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBkdmVjW2pdID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IGo7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgZHZlY1tqXSA9IGR2ZWNbal0gKyBkbWF0W2pdW2ldICogc29sW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3J2YWxbMV0gPSAwO1xuICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgIHNvbFtqXSA9IGR2ZWNbal07XG4gICAgICAgIGNydmFsWzFdID0gY3J2YWxbMV0gKyB3b3JrW2pdICogc29sW2pdO1xuICAgICAgICB3b3JrW2pdID0gMDtcbiAgICAgICAgZm9yIChpID0gaiArIDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBkbWF0W2ldW2pdID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcnZhbFsxXSA9IC1jcnZhbFsxXSAvIDI7XG4gICAgaWVyclsxXSA9IDA7XG5cbiAgICBpd3p2ID0gbjtcbiAgICBpd3J2ID0gaXd6diArIG47XG4gICAgaXd1diA9IGl3cnYgKyByO1xuICAgIGl3cm0gPSBpd3V2ICsgciArIDE7XG4gICAgaXdzdiA9IGl3cm0gKyAociAqIChyICsgMSkpIC8gMjtcbiAgICBpd25idiA9IGl3c3YgKyBxO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIGFtYXRbal1baV0gKiBhbWF0W2pdW2ldO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtbaXduYnYgKyBpXSA9IE1hdGguc3FydChzdW0pO1xuICAgIH1cbiAgICBuYWN0ID0gMDtcbiAgICBpdGVyWzFdID0gMDtcbiAgICBpdGVyWzJdID0gMDtcblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNTAoKSB7XG4gICAgICAgIGl0ZXJbMV0gPSBpdGVyWzFdICsgMTtcblxuICAgICAgICBsID0gaXdzdjtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGwgPSBsICsgMTtcbiAgICAgICAgICAgIHN1bSA9IC1idmVjW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBhbWF0W2pdW2ldICogc29sW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPCB2c21hbGwpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiBtZXEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2xdID0gc3VtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JrW2xdID0gLU1hdGguYWJzKHN1bSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYXRbal1baV0gPSAtYW1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidmVjW2ldID0gLWJ2ZWNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHdvcmtbaXdzdiArIGlhY3RbaV1dID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG52bCA9IDA7XG4gICAgICAgIHRlbXAgPSAwO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgaWYgKHdvcmtbaXdzdiArIGldIDwgdGVtcCAqIHdvcmtbaXduYnYgKyBpXSkge1xuICAgICAgICAgICAgICAgIG52bCA9IGk7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHdvcmtbaXdzdiArIGldIC8gd29ya1tpd25idiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudmwgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiA5OTk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzU1KCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgZG1hdFtqXVtpXSAqIGFtYXRbal1bbnZsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtbaV0gPSBzdW07XG4gICAgICAgIH1cblxuICAgICAgICBsMSA9IGl3enY7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2wxICsgaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IG5hY3QgKyAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2wxICsgaV0gPSB3b3JrW2wxICsgaV0gKyBkbWF0W2ldW2pdICogd29ya1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHQxaW5mID0gdHJ1ZTtcbiAgICAgICAgZm9yIChpID0gbmFjdDsgaSA+PSAxOyBpID0gaSAtIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHdvcmtbaV07XG4gICAgICAgICAgICBsID0gaXdybSArIChpICogKGkgKyAzKSkgLyAyO1xuICAgICAgICAgICAgbDEgPSBsIC0gaTtcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDw9IG5hY3Q7IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSAtIHdvcmtbbF0gKiB3b3JrW2l3cnYgKyBqXTtcbiAgICAgICAgICAgICAgICBsID0gbCArIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gPSBzdW0gLyB3b3JrW2wxXTtcbiAgICAgICAgICAgIHdvcmtbaXdydiArIGldID0gc3VtO1xuICAgICAgICAgICAgaWYgKGlhY3RbaV0gPCBtZXEpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MWluZiA9IGZhbHNlO1xuICAgICAgICAgICAgaXQxID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdDFpbmYpIHtcbiAgICAgICAgICAgIHQxID0gd29ya1tpd3V2ICsgaXQxXSAvIHdvcmtbaXdydiArIGl0MV07XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChpYWN0W2ldIDwgbWVxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtbaXdydiArIGldIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2l3dXYgKyBpXSAvIHdvcmtbaXdydiArIGldO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wIDwgdDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICBpdDEgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IGl3enYgKyAxOyBpIDw9IGl3enYgKyBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIHdvcmtbaV0gKiB3b3JrW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyhzdW0pIDw9IHZzbWFsbCkge1xuICAgICAgICAgICAgaWYgKHQxaW5mKSB7XG4gICAgICAgICAgICAgICAgaWVyclsxXSA9IDE7XG4gICAgICAgICAgICAgICAgLy8gR09UTyA5OTlcbiAgICAgICAgICAgICAgICByZXR1cm4gOTk5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2l3dXYgKyBpXSA9IHdvcmtbaXd1diArIGldIC0gdDEgKiB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd29ya1tpd3V2ICsgbmFjdCArIDFdID0gd29ya1tpd3V2ICsgbmFjdCArIDFdICsgdDE7XG4gICAgICAgICAgICAgICAgLy8gR09UTyA3MDBcbiAgICAgICAgICAgICAgICByZXR1cm4gNzAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgd29ya1tpd3p2ICsgaV0gKiBhbWF0W2ldW252bF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dCA9IC13b3JrW2l3c3YgKyBudmxdIC8gc3VtO1xuICAgICAgICAgICAgdDJtaW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0MWluZikge1xuICAgICAgICAgICAgICAgIGlmICh0MSA8IHR0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR0ID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHQybWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHNvbFtpXSA9IHNvbFtpXSArIHR0ICogd29ya1tpd3p2ICsgaV07XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNvbFtpXSkgPCB2c21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNydmFsWzFdID0gY3J2YWxbMV0gKyB0dCAqIHN1bSAqICh0dCAvIDIgKyB3b3JrW2l3dXYgKyBuYWN0ICsgMV0pO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2l3dXYgKyBpXSA9IHdvcmtbaXd1diArIGldIC0gdHQgKiB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtbaXd1diArIG5hY3QgKyAxXSA9IHdvcmtbaXd1diArIG5hY3QgKyAxXSArIHR0O1xuXG4gICAgICAgICAgICBpZiAodDJtaW4pIHtcbiAgICAgICAgICAgICAgICBuYWN0ID0gbmFjdCArIDE7XG4gICAgICAgICAgICAgICAgaWFjdFtuYWN0XSA9IG52bDtcblxuICAgICAgICAgICAgICAgIGwgPSBpd3JtICsgKChuYWN0IC0gMSkgKiBuYWN0KSAvIDIgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdCAtIDE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2xdID0gd29ya1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGwgKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuYWN0ID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbbF0gPSB3b3JrW25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG47IGkgPj0gbmFjdCArIDE7IGkgPSBpIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdjID0gTWF0aC5tYXgoTWF0aC5hYnMod29ya1tpIC0gMV0pLCBNYXRoLmFicyh3b3JrW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncyA9IE1hdGgubWluKE1hdGguYWJzKHdvcmtbaSAtIDFdKSwgTWF0aC5hYnMod29ya1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtbaSAtIDFdID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IC1NYXRoLmFicyhnYyAqIE1hdGguc3FydCgxICsgZ3MgKiBncyAvIChnYyAqIGdjKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2MgPSB3b3JrW2kgLSAxXSAvIHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBncyA9IHdvcmtbaV0gLyB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaSAtIDFdID0gZ3MgKiB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBkbWF0W2pdW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpIC0gMV0gPSBkbWF0W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWF0W2pdW2ldID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaSAtIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudSA9IGdzIC8gKDEgKyBnYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGdjICogZG1hdFtqXVtpIC0gMV0gKyBncyAqIGRtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baV0gPSBudSAqIChkbWF0W2pdW2kgLSAxXSArIHRlbXApIC0gZG1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpIC0gMV0gPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbbF0gPSB3b3JrW25hY3RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VtID0gLWJ2ZWNbbnZsXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBzb2xbal0gKiBhbWF0W2pdW252bF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChudmwgPiBtZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tpd3N2ICsgbnZsXSA9IHN1bTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2l3c3YgKyBudmxdID0gLU1hdGguYWJzKHN1bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYXRbal1bbnZsXSA9IC1hbWF0W2pdW252bF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBidmVjW252bF0gPSAtYnZlY1tudmxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdPVE8gNzAwXG4gICAgICAgICAgICAgICAgcmV0dXJuIDcwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNzk3KCkge1xuICAgICAgICBsID0gaXdybSArIChpdDEgKiAoaXQxICsgMSkpIC8gMiArIDE7XG4gICAgICAgIGwxID0gbCArIGl0MTtcbiAgICAgICAgaWYgKHdvcmtbbDFdID09PSAwKSB7XG4gICAgICAgICAgICAvLyBHT1RPIDc5OFxuICAgICAgICAgICAgcmV0dXJuIDc5ODtcbiAgICAgICAgfVxuICAgICAgICBnYyA9IE1hdGgubWF4KE1hdGguYWJzKHdvcmtbbDEgLSAxXSksIE1hdGguYWJzKHdvcmtbbDFdKSk7XG4gICAgICAgIGdzID0gTWF0aC5taW4oTWF0aC5hYnMod29ya1tsMSAtIDFdKSwgTWF0aC5hYnMod29ya1tsMV0pKTtcbiAgICAgICAgaWYgKHdvcmtbbDEgLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSAtTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgfVxuICAgICAgICBnYyA9IHdvcmtbbDEgLSAxXSAvIHRlbXA7XG4gICAgICAgIGdzID0gd29ya1tsMV0gLyB0ZW1wO1xuXG4gICAgICAgIGlmIChnYyA9PT0gMSkge1xuICAgICAgICAgICAgLy8gR09UTyA3OThcbiAgICAgICAgICAgIHJldHVybiA3OTg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBpdDEgKyAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2wxIC0gMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMSAtIDFdID0gd29ya1tsMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGwxID0gbDEgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZG1hdFtpXVtpdDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxXSA9IGRtYXRbaV1baXQxICsgMV07XG4gICAgICAgICAgICAgICAgZG1hdFtpXVtpdDEgKyAxXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudSA9IGdzIC8gKDEgKyBnYyk7XG4gICAgICAgICAgICBmb3IgKGkgPSBpdDEgKyAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIHdvcmtbbDEgLSAxXSArIGdzICogd29ya1tsMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMV0gPSBudSAqICh3b3JrW2wxIC0gMV0gKyB0ZW1wKSAtIHdvcmtbbDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDEgLSAxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgbDEgPSBsMSArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIGRtYXRbaV1baXQxXSArIGdzICogZG1hdFtpXVtpdDEgKyAxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MSArIDFdID0gbnUgKiAoZG1hdFtpXVtpdDFdICsgdGVtcCkgLSBkbWF0W2ldW2l0MSArIDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzc5OCgpIHtcbiAgICAgICAgbDEgPSBsIC0gaXQxO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGl0MTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2wxXSA9IHdvcmtbbF07XG4gICAgICAgICAgICBsID0gbCArIDE7XG4gICAgICAgICAgICBsMSA9IGwxICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtbaXd1diArIGl0MV0gPSB3b3JrW2l3dXYgKyBpdDEgKyAxXTtcbiAgICAgICAgaWFjdFtpdDFdID0gaWFjdFtpdDEgKyAxXTtcbiAgICAgICAgaXQxID0gaXQxICsgMTtcbiAgICAgICAgaWYgKGl0MSA8IG5hY3QpIHtcbiAgICAgICAgICAgIC8vIEdPVE8gNzk3XG4gICAgICAgICAgICByZXR1cm4gNzk3O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b183OTkoKSB7XG4gICAgICAgIHdvcmtbaXd1diArIG5hY3RdID0gd29ya1tpd3V2ICsgbmFjdCArIDFdO1xuICAgICAgICB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gPSAwO1xuICAgICAgICBpYWN0W25hY3RdID0gMDtcbiAgICAgICAgbmFjdCA9IG5hY3QgLSAxO1xuICAgICAgICBpdGVyWzJdID0gaXRlclsyXSArIDE7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZ28gPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGdvID0gZm5fZ290b181MCgpO1xuICAgICAgICBpZiAoZ28gPT09IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBnbyA9IGZuX2dvdG9fNTUoKTtcbiAgICAgICAgICAgIGlmIChnbyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvID09PSA5OTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ28gPT09IDcwMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdDEgPT09IG5hY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTkoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvID0gZm5fZ290b183OTgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnbyAhPT0gNzk3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gc29sdmVRUChEbWF0LCBkdmVjLCBBbWF0LCBidmVjLCBtZXEsIGZhY3Rvcml6ZWQpIHtcbiAgICBEbWF0ID0gYmFzZTB0bzEoRG1hdCk7XG4gICAgZHZlYyA9IGJhc2UwdG8xKGR2ZWMpO1xuICAgIEFtYXQgPSBiYXNlMHRvMShBbWF0KTtcbiAgICB2YXIgaSwgbiwgcSxcbiAgICAgICAgbmFjdCwgcixcbiAgICAgICAgY3J2YWwgPSBbXSwgaWFjdCA9IFtdLCBzb2wgPSBbXSwgd29yayA9IFtdLCBpdGVyID0gW10sXG4gICAgICAgIG1lc3NhZ2U7XG5cbiAgICBtZXEgPSBtZXEgfHwgMDtcbiAgICBmYWN0b3JpemVkID0gZmFjdG9yaXplZCA/IGJhc2UwdG8xKGZhY3Rvcml6ZWQpIDogW3VuZGVmaW5lZCwgMF07XG4gICAgYnZlYyA9IGJ2ZWMgPyBiYXNlMHRvMShidmVjKSA6IFtdO1xuXG4gICAgLy8gSW4gRm9ydHJhbiB0aGUgYXJyYXkgaW5kZXggc3RhcnRzIGZyb20gMVxuICAgIG4gPSBEbWF0Lmxlbmd0aCAtIDE7XG4gICAgcSA9IEFtYXRbMV0ubGVuZ3RoIC0gMTtcblxuICAgIGlmICghYnZlYykge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgYnZlY1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgaWFjdFtpXSA9IDA7XG4gICAgfVxuICAgIG5hY3QgPSAwO1xuICAgIHIgPSBNYXRoLm1pbihuLCBxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICBzb2xbaV0gPSAwO1xuICAgIH1cbiAgICBjcnZhbFsxXSA9IDA7XG4gICAgZm9yIChpID0gMTsgaSA8PSAoMiAqIG4gKyAociAqIChyICsgNSkpIC8gMiArIDIgKiBxICsgMSk7IGkgPSBpICsgMSkge1xuICAgICAgICB3b3JrW2ldID0gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSAyOyBpID0gaSArIDEpIHtcbiAgICAgICAgaXRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgcXBnZW4yKERtYXQsIGR2ZWMsIG4sIG4sIHNvbCwgY3J2YWwsIEFtYXQsXG4gICAgICAgIGJ2ZWMsIG4sIHEsIG1lcSwgaWFjdCwgbmFjdCwgaXRlciwgd29yaywgZmFjdG9yaXplZCk7XG5cbiAgICBtZXNzYWdlID0gXCJcIjtcbiAgICBpZiAoZmFjdG9yaXplZFsxXSA9PT0gMSkge1xuICAgICAgICBtZXNzYWdlID0gXCJjb25zdHJhaW50cyBhcmUgaW5jb25zaXN0ZW50LCBubyBzb2x1dGlvbiFcIjtcbiAgICB9XG4gICAgaWYgKGZhY3Rvcml6ZWRbMV0gPT09IDIpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwibWF0cml4IEQgaW4gcXVhZHJhdGljIGZ1bmN0aW9uIGlzIG5vdCBwb3NpdGl2ZSBkZWZpbml0ZSFcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb2x1dGlvbjogYmFzZTF0bzAoc29sKSxcbiAgICAgICAgdmFsdWU6IGJhc2UxdG8wKGNydmFsKSxcbiAgICAgICAgdW5jb25zdHJhaW5lZF9zb2x1dGlvbjogYmFzZTF0bzAoZHZlYyksXG4gICAgICAgIGl0ZXJhdGlvbnM6IGJhc2UxdG8wKGl0ZXIpLFxuICAgICAgICBpYWN0OiBiYXNlMXRvMChpYWN0KSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG59XG5leHBvcnRzLnNvbHZlUVAgPSBzb2x2ZVFQO1xufShudW1lcmljKSk7XG4vKlxyXG5TaGFudGkgUmFvIHNlbnQgbWUgdGhpcyByb3V0aW5lIGJ5IHByaXZhdGUgZW1haWwuIEkgaGFkIHRvIG1vZGlmeSBpdFxyXG5zbGlnaHRseSB0byB3b3JrIG9uIEFycmF5cyBpbnN0ZWFkIG9mIHVzaW5nIGEgTWF0cml4IG9iamVjdC5cclxuSXQgaXMgYXBwYXJlbnRseSB0cmFuc2xhdGVkIGZyb20gaHR0cDovL3N0aXRjaHBhbm9yYW1hLnNvdXJjZWZvcmdlLm5ldC9QeXRob24vc3ZkLnB5XHJcbiovXHJcblxyXG5udW1lcmljLnN2ZD0gZnVuY3Rpb24gc3ZkKEEpIHtcclxuICAgIHZhciB0ZW1wO1xyXG4vL0NvbXB1dGUgdGhlIHRoaW4gU1ZEIGZyb20gRy4gSC4gR29sdWIgYW5kIEMuIFJlaW5zY2gsIE51bWVyLiBNYXRoLiAxNCwgNDAzLTQyMCAoMTk3MClcclxuXHR2YXIgcHJlYz0gbnVtZXJpYy5lcHNpbG9uOyAvL01hdGgucG93KDIsLTUyKSAvLyBhc3N1bWVzIGRvdWJsZSBwcmVjXHJcblx0dmFyIHRvbGVyYW5jZT0gMS5lLTY0L3ByZWM7XHJcblx0dmFyIGl0bWF4PSA1MDtcclxuXHR2YXIgYz0wO1xyXG5cdHZhciBpPTA7XHJcblx0dmFyIGo9MDtcclxuXHR2YXIgaz0wO1xyXG5cdHZhciBsPTA7XHJcblx0XHJcblx0dmFyIHU9IG51bWVyaWMuY2xvbmUoQSk7XHJcblx0dmFyIG09IHUubGVuZ3RoO1xyXG5cdFxyXG5cdHZhciBuPSB1WzBdLmxlbmd0aDtcclxuXHRcclxuXHRpZiAobSA8IG4pIHRocm93IFwiTmVlZCBtb3JlIHJvd3MgdGhhbiBjb2x1bW5zXCJcclxuXHRcclxuXHR2YXIgZSA9IG5ldyBBcnJheShuKTtcclxuXHR2YXIgcSA9IG5ldyBBcnJheShuKTtcclxuXHRmb3IgKGk9MDsgaTxuOyBpKyspIGVbaV0gPSBxW2ldID0gMC4wO1xyXG5cdHZhciB2ID0gbnVtZXJpYy5yZXAoW24sbl0sMCk7XHJcbi8vXHR2Lnplcm8oKTtcclxuXHRcclxuIFx0ZnVuY3Rpb24gcHl0aGFnKGEsYilcclxuIFx0e1xyXG5cdFx0YSA9IE1hdGguYWJzKGEpXHJcblx0XHRiID0gTWF0aC5hYnMoYilcclxuXHRcdGlmIChhID4gYilcclxuXHRcdFx0cmV0dXJuIGEqTWF0aC5zcXJ0KDEuMCsoYipiL2EvYSkpXHJcblx0XHRlbHNlIGlmIChiID09IDAuMCkgXHJcblx0XHRcdHJldHVybiBhXHJcblx0XHRyZXR1cm4gYipNYXRoLnNxcnQoMS4wKyhhKmEvYi9iKSlcclxuXHR9XHJcblxyXG5cdC8vSG91c2Vob2xkZXIncyByZWR1Y3Rpb24gdG8gYmlkaWFnb25hbCBmb3JtXHJcblxyXG5cdHZhciBmPSAwLjA7XHJcblx0dmFyIGc9IDAuMDtcclxuXHR2YXIgaD0gMC4wO1xyXG5cdHZhciB4PSAwLjA7XHJcblx0dmFyIHk9IDAuMDtcclxuXHR2YXIgej0gMC4wO1xyXG5cdHZhciBzPSAwLjA7XHJcblx0XHJcblx0Zm9yIChpPTA7IGkgPCBuOyBpKyspXHJcblx0e1x0XHJcblx0XHRlW2ldPSBnO1xyXG5cdFx0cz0gMC4wO1xyXG5cdFx0bD0gaSsxO1xyXG5cdFx0Zm9yIChqPWk7IGogPCBtOyBqKyspIFxyXG5cdFx0XHRzICs9ICh1W2pdW2ldKnVbal1baV0pO1xyXG5cdFx0aWYgKHMgPD0gdG9sZXJhbmNlKVxyXG5cdFx0XHRnPSAwLjA7XHJcblx0XHRlbHNlXHJcblx0XHR7XHRcclxuXHRcdFx0Zj0gdVtpXVtpXTtcclxuXHRcdFx0Zz0gTWF0aC5zcXJ0KHMpO1xyXG5cdFx0XHRpZiAoZiA+PSAwLjApIGc9IC1nO1xyXG5cdFx0XHRoPSBmKmctc1xyXG5cdFx0XHR1W2ldW2ldPWYtZztcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzPSAwLjBcclxuXHRcdFx0XHRmb3IgKGs9aTsgayA8IG07IGsrKykgXHJcblx0XHRcdFx0XHRzICs9IHVba11baV0qdVtrXVtqXVxyXG5cdFx0XHRcdGY9IHMvaFxyXG5cdFx0XHRcdGZvciAoaz1pOyBrIDwgbTsgaysrKSBcclxuXHRcdFx0XHRcdHVba11bal0rPWYqdVtrXVtpXVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRxW2ldPSBnXHJcblx0XHRzPSAwLjBcclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBcclxuXHRcdFx0cz0gcyArIHVbaV1bal0qdVtpXVtqXVxyXG5cdFx0aWYgKHMgPD0gdG9sZXJhbmNlKVxyXG5cdFx0XHRnPSAwLjBcclxuXHRcdGVsc2VcclxuXHRcdHtcdFxyXG5cdFx0XHRmPSB1W2ldW2krMV1cclxuXHRcdFx0Zz0gTWF0aC5zcXJ0KHMpXHJcblx0XHRcdGlmIChmID49IDAuMCkgZz0gLWdcclxuXHRcdFx0aD0gZipnIC0gc1xyXG5cdFx0XHR1W2ldW2krMV0gPSBmLWc7XHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBlW2pdPSB1W2ldW2pdL2hcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBtOyBqKyspXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSAodVtqXVtrXSp1W2ldW2tdKVxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHVbal1ba10rPXMqZVtrXVxyXG5cdFx0XHR9XHRcclxuXHRcdH1cclxuXHRcdHk9IE1hdGguYWJzKHFbaV0pK01hdGguYWJzKGVbaV0pXHJcblx0XHRpZiAoeT54KSBcclxuXHRcdFx0eD15XHJcblx0fVxyXG5cdFxyXG5cdC8vIGFjY3VtdWxhdGlvbiBvZiByaWdodCBoYW5kIGd0cmFuc2Zvcm1hdGlvbnNcclxuXHRmb3IgKGk9bi0xOyBpICE9IC0xOyBpKz0gLTEpXHJcblx0e1x0XHJcblx0XHRpZiAoZyAhPSAwLjApXHJcblx0XHR7XHJcblx0XHQgXHRoPSBnKnVbaV1baSsxXVxyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgXHJcblx0XHRcdFx0dltqXVtpXT11W2ldW2pdL2hcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSB1W2ldW2tdKnZba11bal1cclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG47IGsrKykgXHJcblx0XHRcdFx0XHR2W2tdW2pdKz0ocyp2W2tdW2ldKVxyXG5cdFx0XHR9XHRcclxuXHRcdH1cclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0e1xyXG5cdFx0XHR2W2ldW2pdID0gMDtcclxuXHRcdFx0dltqXVtpXSA9IDA7XHJcblx0XHR9XHJcblx0XHR2W2ldW2ldID0gMTtcclxuXHRcdGc9IGVbaV1cclxuXHRcdGw9IGlcclxuXHR9XHJcblx0XHJcblx0Ly8gYWNjdW11bGF0aW9uIG9mIGxlZnQgaGFuZCB0cmFuc2Zvcm1hdGlvbnNcclxuXHRmb3IgKGk9bi0xOyBpICE9IC0xOyBpKz0gLTEpXHJcblx0e1x0XHJcblx0XHRsPSBpKzFcclxuXHRcdGc9IHFbaV1cclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBcclxuXHRcdFx0dVtpXVtqXSA9IDA7XHJcblx0XHRpZiAoZyAhPSAwLjApXHJcblx0XHR7XHJcblx0XHRcdGg9IHVbaV1baV0qZ1xyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBtOyBrKyspIHMgKz0gdVtrXVtpXSp1W2tdW2pdO1xyXG5cdFx0XHRcdGY9IHMvaFxyXG5cdFx0XHRcdGZvciAoaz1pOyBrIDwgbTsgaysrKSB1W2tdW2pdKz1mKnVba11baV07XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChqPWk7IGogPCBtOyBqKyspIHVbal1baV0gPSB1W2pdW2ldL2c7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdGZvciAoaj1pOyBqIDwgbTsgaisrKSB1W2pdW2ldID0gMDtcclxuXHRcdHVbaV1baV0gKz0gMTtcclxuXHR9XHJcblx0XHJcblx0Ly8gZGlhZ29uYWxpemF0aW9uIG9mIHRoZSBiaWRpYWdvbmFsIGZvcm1cclxuXHRwcmVjPSBwcmVjKnhcclxuXHRmb3IgKGs9bi0xOyBrICE9IC0xOyBrKz0gLTEpXHJcblx0e1xyXG5cdFx0Zm9yICh2YXIgaXRlcmF0aW9uPTA7IGl0ZXJhdGlvbiA8IGl0bWF4OyBpdGVyYXRpb24rKylcclxuXHRcdHtcdC8vIHRlc3QgZiBzcGxpdHRpbmdcclxuXHRcdFx0dmFyIHRlc3RfY29udmVyZ2VuY2UgPSBmYWxzZVxyXG5cdFx0XHRmb3IgKGw9azsgbCAhPSAtMTsgbCs9IC0xKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRpZiAoTWF0aC5hYnMoZVtsXSkgPD0gcHJlYylcclxuXHRcdFx0XHR7XHR0ZXN0X2NvbnZlcmdlbmNlPSB0cnVlXHJcblx0XHRcdFx0XHRicmVhayBcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKE1hdGguYWJzKHFbbC0xXSkgPD0gcHJlYylcclxuXHRcdFx0XHRcdGJyZWFrIFxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghdGVzdF9jb252ZXJnZW5jZSlcclxuXHRcdFx0e1x0Ly8gY2FuY2VsbGF0aW9uIG9mIGVbbF0gaWYgbD4wXHJcblx0XHRcdFx0Yz0gMC4wXHJcblx0XHRcdFx0cz0gMS4wXHJcblx0XHRcdFx0dmFyIGwxPSBsLTFcclxuXHRcdFx0XHRmb3IgKGkgPWw7IGk8aysxOyBpKyspXHJcblx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHRmPSBzKmVbaV1cclxuXHRcdFx0XHRcdGVbaV09IGMqZVtpXVxyXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKGYpIDw9IHByZWMpXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRnPSBxW2ldXHJcblx0XHRcdFx0XHRoPSBweXRoYWcoZixnKVxyXG5cdFx0XHRcdFx0cVtpXT0gaFxyXG5cdFx0XHRcdFx0Yz0gZy9oXHJcblx0XHRcdFx0XHRzPSAtZi9oXHJcblx0XHRcdFx0XHRmb3IgKGo9MDsgaiA8IG07IGorKylcclxuXHRcdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0XHR5PSB1W2pdW2wxXVxyXG5cdFx0XHRcdFx0XHR6PSB1W2pdW2ldXHJcblx0XHRcdFx0XHRcdHVbal1bbDFdID0gIHkqYysoeipzKVxyXG5cdFx0XHRcdFx0XHR1W2pdW2ldID0gLXkqcysoeipjKVxyXG5cdFx0XHRcdFx0fSBcclxuXHRcdFx0XHR9XHRcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB0ZXN0IGYgY29udmVyZ2VuY2VcclxuXHRcdFx0ej0gcVtrXVxyXG5cdFx0XHRpZiAobD09IGspXHJcblx0XHRcdHtcdC8vY29udmVyZ2VuY2VcclxuXHRcdFx0XHRpZiAoejwwLjApXHJcblx0XHRcdFx0e1x0Ly9xW2tdIGlzIG1hZGUgbm9uLW5lZ2F0aXZlXHJcblx0XHRcdFx0XHRxW2tdPSAtelxyXG5cdFx0XHRcdFx0Zm9yIChqPTA7IGogPCBuOyBqKyspXHJcblx0XHRcdFx0XHRcdHZbal1ba10gPSAtdltqXVtrXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhayAgLy9icmVhayBvdXQgb2YgaXRlcmF0aW9uIGxvb3AgYW5kIG1vdmUgb24gdG8gbmV4dCBrIHZhbHVlXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGl0ZXJhdGlvbiA+PSBpdG1heC0xKVxyXG5cdFx0XHRcdHRocm93ICdFcnJvcjogbm8gY29udmVyZ2VuY2UuJ1xyXG5cdFx0XHQvLyBzaGlmdCBmcm9tIGJvdHRvbSAyeDIgbWlub3JcclxuXHRcdFx0eD0gcVtsXVxyXG5cdFx0XHR5PSBxW2stMV1cclxuXHRcdFx0Zz0gZVtrLTFdXHJcblx0XHRcdGg9IGVba11cclxuXHRcdFx0Zj0gKCh5LXopKih5K3opKyhnLWgpKihnK2gpKS8oMi4wKmgqeSlcclxuXHRcdFx0Zz0gcHl0aGFnKGYsMS4wKVxyXG5cdFx0XHRpZiAoZiA8IDAuMClcclxuXHRcdFx0XHRmPSAoKHgteikqKHgreikraCooeS8oZi1nKS1oKSkveFxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0Zj0gKCh4LXopKih4K3opK2gqKHkvKGYrZyktaCkpL3hcclxuXHRcdFx0Ly8gbmV4dCBRUiB0cmFuc2Zvcm1hdGlvblxyXG5cdFx0XHRjPSAxLjBcclxuXHRcdFx0cz0gMS4wXHJcblx0XHRcdGZvciAoaT1sKzE7IGk8IGsrMTsgaSsrKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRnPSBlW2ldXHJcblx0XHRcdFx0eT0gcVtpXVxyXG5cdFx0XHRcdGg9IHMqZ1xyXG5cdFx0XHRcdGc9IGMqZ1xyXG5cdFx0XHRcdHo9IHB5dGhhZyhmLGgpXHJcblx0XHRcdFx0ZVtpLTFdPSB6XHJcblx0XHRcdFx0Yz0gZi96XHJcblx0XHRcdFx0cz0gaC96XHJcblx0XHRcdFx0Zj0geCpjK2cqc1xyXG5cdFx0XHRcdGc9IC14KnMrZypjXHJcblx0XHRcdFx0aD0geSpzXHJcblx0XHRcdFx0eT0geSpjXHJcblx0XHRcdFx0Zm9yIChqPTA7IGogPCBuOyBqKyspXHJcblx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHR4PSB2W2pdW2ktMV1cclxuXHRcdFx0XHRcdHo9IHZbal1baV1cclxuXHRcdFx0XHRcdHZbal1baS0xXSA9IHgqYyt6KnNcclxuXHRcdFx0XHRcdHZbal1baV0gPSAteCpzK3oqY1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR6PSBweXRoYWcoZixoKVxyXG5cdFx0XHRcdHFbaS0xXT0gelxyXG5cdFx0XHRcdGM9IGYvelxyXG5cdFx0XHRcdHM9IGgvelxyXG5cdFx0XHRcdGY9IGMqZytzKnlcclxuXHRcdFx0XHR4PSAtcypnK2MqeVxyXG5cdFx0XHRcdGZvciAoaj0wOyBqIDwgbTsgaisrKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHk9IHVbal1baS0xXVxyXG5cdFx0XHRcdFx0ej0gdVtqXVtpXVxyXG5cdFx0XHRcdFx0dVtqXVtpLTFdID0geSpjK3oqc1xyXG5cdFx0XHRcdFx0dVtqXVtpXSA9IC15KnMreipjXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVbbF09IDAuMFxyXG5cdFx0XHRlW2tdPSBmXHJcblx0XHRcdHFba109IHhcclxuXHRcdH0gXHJcblx0fVxyXG5cdFx0XHJcblx0Ly92dD0gdHJhbnNwb3NlKHYpXHJcblx0Ly9yZXR1cm4gKHUscSx2dClcclxuXHRmb3IgKGk9MDtpPHEubGVuZ3RoOyBpKyspIFxyXG5cdCAgaWYgKHFbaV0gPCBwcmVjKSBxW2ldID0gMFxyXG5cdCAgXHJcblx0Ly9zb3J0IGVpZ2VudmFsdWVzXHRcclxuXHRmb3IgKGk9MDsgaTwgbjsgaSsrKVxyXG5cdHtcdCBcclxuXHQvL3dyaXRlbG4ocSlcclxuXHQgZm9yIChqPWktMTsgaiA+PSAwOyBqLS0pXHJcblx0IHtcclxuXHQgIGlmIChxW2pdIDwgcVtpXSlcclxuXHQgIHtcclxuXHQvLyAgd3JpdGVsbihpLCctJyxqKVxyXG5cdCAgIGMgPSBxW2pdXHJcblx0ICAgcVtqXSA9IHFbaV1cclxuXHQgICBxW2ldID0gY1xyXG5cdCAgIGZvcihrPTA7azx1Lmxlbmd0aDtrKyspIHsgdGVtcCA9IHVba11baV07IHVba11baV0gPSB1W2tdW2pdOyB1W2tdW2pdID0gdGVtcDsgfVxyXG5cdCAgIGZvcihrPTA7azx2Lmxlbmd0aDtrKyspIHsgdGVtcCA9IHZba11baV07IHZba11baV0gPSB2W2tdW2pdOyB2W2tdW2pdID0gdGVtcDsgfVxyXG4vL1x0ICAgdS5zd2FwQ29scyhpLGopXHJcbi8vXHQgICB2LnN3YXBDb2xzKGksailcclxuXHQgICBpID0galx0ICAgXHJcblx0ICB9XHJcblx0IH1cdFxyXG5cdH1cclxuXHRcclxuXHRyZXR1cm4ge1U6dSxTOnEsVjp2fVxyXG59O1xyXG5cclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG52YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcbnZhciBkb250RW51bXMgPSBbXG5cdCd0b1N0cmluZycsXG5cdCd0b0xvY2FsZVN0cmluZycsXG5cdCd2YWx1ZU9mJyxcblx0J2hhc093blByb3BlcnR5Jyxcblx0J2lzUHJvdG90eXBlT2YnLFxuXHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHQnY29uc3RydWN0b3InXG5dO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbn07XG52YXIgZXhjbHVkZWRLZXlzID0ge1xuXHQkY29uc29sZTogdHJ1ZSxcblx0JGV4dGVybmFsOiB0cnVlLFxuXHQkZnJhbWU6IHRydWUsXG5cdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdCRmcmFtZXM6IHRydWUsXG5cdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0JGlubmVyV2lkdGg6IHRydWUsXG5cdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0JG91dGVyV2lkdGg6IHRydWUsXG5cdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHQkcGFyZW50OiB0cnVlLFxuXHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0JHNjcm9sbFg6IHRydWUsXG5cdCRzY3JvbGxZOiB0cnVlLFxuXHQkc2VsZjogdHJ1ZSxcblx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHQkd2luZG93OiB0cnVlXG59O1xudmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59KCkpO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHR9XG5cblx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGVLZXlzO1xufTtcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0cmV0dXJuIChPYmplY3Qua2V5cyhhcmd1bWVudHMpIHx8ICcnKS5sZW5ndGggPT09IDI7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVMgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9lczcnKTtcbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGlzRW51bWVyYWJsZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWx1ZXMoTykge1xuXHR2YXIgb2JqID0gRVMuUmVxdWlyZU9iamVjdENvZXJjaWJsZShPKTtcblx0dmFyIHZhbHMgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmIChoYXMob2JqLCBrZXkpICYmIGlzRW51bWVyYWJsZShvYmosIGtleSkpIHtcblx0XHRcdHZhbHMucHVzaChvYmpba2V5XSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWxzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QudmFsdWVzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LnZhbHVlcyA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbVZhbHVlcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyB2YWx1ZXM6IHBvbHlmaWxsIH0sIHtcblx0XHR2YWx1ZXM6IGZ1bmN0aW9uIHRlc3RWYWx1ZXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnZhbHVlcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsImltcG9ydCB7IEZVTkNUSU9OUyB9IGZyb20gJy4vcGFyc2VyL2Z1bmN0aW9ucyc7XG5cbi8qKlxuICogVG9rZW4gbGlzdFxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBFT0wgLSBFbmQgb2YgbGluZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBOVU1CRVIgLSBOdW1iZXIgY29uc3RhbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gU1RSSU5HIC0gU3RyaW5nIGNvbnN0YW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IEJPT0xFQU4gLSBCb29sZWFuIGNvbnN0YW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IEVSUk9SIC0gRXJyb3IgY29uc3RhbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gSUQgLSBGdW5jdGlvbiBuYW1lIG9yIENlbGwgcmVmZXJlbmNlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFNIRUVUIC0gU2hlZXQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gUkFOR0UgLSBSYW5nZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBQTFVTIC0gVGhlIHBsdXMgc2lnbiAoKykuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTUlOVVMgLSBUaGUgbWludXMgc2lnbiAoLSkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTVVMVCAtIFRoZSBtdWx0aXBsaWNhdGlvbiBzaWduICgqKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBESVYgLSBUaGUgZGl2aXNpb24gc2lnbiAoLykuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gUE9XIC0gVGhlIGV4cG9uZW50IHNpZ24gKF4pLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IExUIC0gVGhlIGxlc3MgdGhhbiBzaWduICg8KS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBHVCAtIFRoZSBncmVhdGVyIHRoYW4gc2lnbiAoPikuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gRVEgLSBUaGUgZXF1YWwgc2lnbiAoPSkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTEUgLSBUaGUgbGVzcyB0aGFuIG9yIGVxdWFsIHNpZ24gKDw9KS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBHRSAtIFRoZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgc2lnbiAoPj0pLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IE5FIC0gVGhlIG5vdCBlcXVhbCBzaWduICg8PikuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gQ09OQ0FUIC0gVGhlIHN0cmluZyBjb25jYXRlbmF0aW9uIHNpZ24gKCYpLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IEVYQ0xBTUFUSU9OIC0gVGhlIGV4Y2xhbWF0aW9uIHNpZ24gKCEpLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFBFUkNFTlQgLSBUaGUgcGVyY2VudCBzaWduICglKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDT0xPTiAtIFRoZSBjb2xvbiBzaWduICg6KS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDT01NQSAtIFRoZSBjb21tYSBzaWduICgsKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTRU1JQ09MT04gLSBUaGUgc2VtaS1jb2xvbiBzaWduICg7KS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBQRVJJT0QgLSBUaGUgZG90IHNpZ24gKC4pLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IERPTExBUiAtIFRoZSBkb2xsYXIgc2lnbiAoJCkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTFBBUkVOIC0gVGhlIGxlZnQgcGFyZW50aGVzZXMgc2lnbiAoKCkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gUlBBUkVOIC0gVGhlIHJpZ2h0IHBhcmVudGhlc2VzIHNpZ24gKCkpLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IExCUkFDRSAtIFRoZSBsZWZ0IGJyYWNlIHNpZ24gKHspLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFJCUkFDRSAtIFRoZSByaWdodCBicmFjZSBzaWduICh9KS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMQlJBQ0tFVCAtIFRoZSBsZWZ0IGJyYWNrZXQgc2lnbiAoWykuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gUkJSQUNLRVQgLSBUaGUgcmlnaHQgYnJhY2tldCBzaWduIChdKS5cbiAqL1xuZXhwb3J0IGNvbnN0IFRPS0VOUyA9IHtcbiAgICBFT0w6ICcoZW9sKScsXG5cbiAgICAvLyBDb25zdGFudHNcbiAgICBOVU1CRVI6ICcobnVtYmVyKScsXG4gICAgU1RSSU5HOiAnKHN0cmluZyknLFxuICAgIEJPT0xFQU46ICcoYm9vbGVhbiknLFxuICAgIEVSUk9SOiAnKGVycm9yKScsXG4gICAgSUQ6ICcoaWRlbnRpZmllciknLFxuICAgIFNIRUVUOiAnKHNoZWV0KScsXG4gICAgUkFOR0U6ICcocmFuZ2UpJyxcblxuICAgIC8vIE9wZXJhdG9yc1xuICAgIFBMVVM6ICcrJyxcbiAgICBNSU5VUzogJy0nLFxuICAgIE1VTFQ6ICcqJyxcbiAgICBESVY6ICcvJyxcbiAgICBQT1c6ICdeJyxcbiAgICBMVDogJzwnLFxuICAgIEdUOiAnPicsXG4gICAgRVE6ICc9JyxcbiAgICBMRTogJzw9JyxcbiAgICBHRTogJz49JyxcbiAgICBORTogJzw+JyxcbiAgICBDT05DQVQ6ICcmJyxcbiAgICBFWENMQU1BVElPTjogJyEnLFxuICAgIFBFUkNFTlQ6ICclJyxcbiAgICBDT0xPTjogJzonLFxuICAgIENPTU1BOiAnLCcsXG4gICAgU0VNSUNPTE9OOiAnOycsXG4gICAgUEVSSU9EOiAnLicsXG4gICAgRE9MTEFSOiAnJCcsXG4gICAgTFBBUkVOOiAnKCcsXG4gICAgUlBBUkVOOiAnKScsXG4gICAgTEJSQUNFOiAneycsXG4gICAgUkJSQUNFOiAnfScsXG4gICAgTEJSQUNLRVQ6ICdbJyxcbiAgICBSQlJBQ0tFVDogJ10nLFxufTtcblxuLyoqXG4gKiBTcHJlYWRzaGVldCBFcnJvciBsaXN0XG4gKiBAc2VlIHtAbGluayBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy9vZmZpY2UvdjEuMi9vcy9PcGVuRG9jdW1lbnQtdjEuMi1vcy1wYXJ0Mi5odG1sI19fUmVmSGVhZGluZ19fMTAxNzk2Nl83MTU5ODAxMTB8NS4xMkNvbnN0YW50IEVycm9yc31cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gI0RJVi8wISAtIEF0dGVtcHQgdG8gZGl2aWRlIGJ5IHplcm8sIGluY2x1ZGluZyBkaXZpc2lvbiBieSBhbiBlbXB0eSBjZWxsLiBFUlJPUi5UWVBFIG9mIDIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gI05BTUU/IC0gVW5yZWNvZ25pemVkL2RlbGV0ZWQgbmFtZS4gRVJST1IuVFlQRSBvZiA1LlxuICogQHByb3BlcnR5IHtzdHJpbmd9ICNOL0EgLSBOb3QgYXZhaWxhYmxlLiBJU05BKCkgYXBwbGllZCB0byB0aGlzIHZhbHVlIHdpbGwgcmV0dXJuIFRydWUuIExvb2t1cCBmdW5jdGlvbnMgd2hpY2ggZmFpbGVkLCBhbmQgTkEoKSwgcmV0dXJuIHRoaXMgdmFsdWUuIEVSUk9SLlRZUEUgb2YgNy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAjTlVMTCEgLSBJbnRlcnNlY3Rpb24gb2YgcmFuZ2VzIHByb2R1Y2VkIHplcm8gY2VsbHMuIEVSUk9SLlRZUEUgb2YgMS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAjTlVNISAtIEZhaWxlZCB0byBtZWV0IGRvbWFpbiBjb25zdHJhaW50cyAoZS5nLiwgaW5wdXQgd2FzIHRvbyBsYXJnZSBvciB0b28gc21hbGwpLiBFUlJPUi5UWVBFIG9mIDYuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gI1JFRiEgLSBSZWZlcmVuY2UgdG8gaW52YWxpZCBjZWxsIChlLmcuLCBiZXlvbmQgdGhlIGFwcGxpY2F0aW9uJ3MgYWJpbGl0aWVzKS4gRVJST1IuVFlQRSBvZiA0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9ICNWQUxVRSEgLSBQYXJhbWV0ZXIgaXMgd3JvbmcgdHlwZS4gRVJST1IuVFlQRSBvZiAzLlxuICovXG5leHBvcnQgY29uc3QgRVJST1JTID0ge1xuICAgIERJVjogJyNESVYvMCEnLFxuICAgIE5BTUU6ICcjTkFNRT8nLFxuICAgIE5BOiAnI04vQScsXG4gICAgTlVMTDogJyNOVUxMIScsXG4gICAgTlVNOiAnI05VTSEnLFxuICAgIFJFRjogJyNSRUYhJyxcbiAgICBWQUxVRTogJyNWQUxVRSEnLFxufTtcblxuLyoqXG4gKiBCYXNpYyBvcGVyYXRvcnNcbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gKyAtIFRoZSBwbHVzIHR5cGUsIFBMVVMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gLSAtIFRoZSBtaW51cyB0eXBlLCBNSU5VUy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAqIC0gVGhlIG11bHRpcGxpY2F0aW9uIHR5cGUsIE1VTFQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gLyAtIFRoZSBkaXZpc2lvbiB0eXBlLCBESVYuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gXiAtIFRoZSBleHBvbmVudCB0eXBlLCBQT1cuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gPCAtIFRoZSBsZXNzIHRoYW4gdHlwZSwgTFQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gPiAtIFRoZSBncmVhdGVyIHRoYW4gdHlwZSwgR1QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gPSAtIFRoZSBlcXVhbCB0eXBlLCBFUS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA8PSAtIFRoZSBsZXNzIHRoYW4gb3IgZXF1YWwgdHlwZSwgTEUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gPj0gLSBUaGUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHR5cGUsIEdFLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IDw+IC0gVGhlIG5vdCBlcXVhbCB0eXBlLCBORS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAmIC0gVGhlIHN0cmluZyBjb25jYXRlbmF0aW9uIHR5cGUsIENPTkNBVC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAhIC0gVGhlIGV4Y2xhbWF0aW9uIHR5cGUsIEVYQ0xBTUFUSU9OLlxuICogQHByb3BlcnR5IHtzdHJpbmd9ICUgLSBUaGUgcGVyY2VudCB0eXBlLCBQRVJDRU5ULlxuICogQHByb3BlcnR5IHtzdHJpbmd9IDogLSBUaGUgY29sb24gdHlwZSwgQ09MT04uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gLCAtIFRoZSBjb21tYSB0eXBlLCBDT01NQS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA7IC0gVGhlIHNlbWktY29sb24gdHlwZSwgU0VNSUNPTE9OLlxuICogQHByb3BlcnR5IHtzdHJpbmd9ICggLSBUaGUgbGVmdCBwYXJlbnRoZXNlcyB0eXBlLCBMUEFSRU4uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gKSAtIFRoZSByaWdodCBwYXJlbnRoZXNlcyB0eXBlLCBSUEFSRU4uXG4gKi9cbmV4cG9ydCBjb25zdCBPUEVSQVRPUlMgPSB7XG4gICAgJysnOiBUT0tFTlMuUExVUyxcbiAgICAnLSc6IFRPS0VOUy5NSU5VUyxcbiAgICAnKic6IFRPS0VOUy5NVUxULFxuICAgICcvJzogVE9LRU5TLkRJVixcbiAgICAnXic6IFRPS0VOUy5QT1csXG4gICAgJzwnOiBUT0tFTlMuTFQsXG4gICAgJz4nOiBUT0tFTlMuR1QsXG4gICAgJz0nOiBUT0tFTlMuRVEsXG4gICAgJzw9JzogVE9LRU5TLkxFLFxuICAgICc+PSc6IFRPS0VOUy5HRSxcbiAgICAnPD4nOiBUT0tFTlMuTkUsXG4gICAgJyYnOiBUT0tFTlMuQ09OQ0FULFxuICAgICchJzogVE9LRU5TLkVYQ0xBTUFUSU9OLFxuICAgICclJzogVE9LRU5TLlBFUkNFTlQsXG4gICAgJzonOiBUT0tFTlMuQ09MT04sXG4gICAgJywnOiBUT0tFTlMuQ09NTUEsXG4gICAgJzsnOiBUT0tFTlMuU0VNSUNPTE9OLFxuICAgICcuJzogVE9LRU5TLlBFUklPRCxcbiAgICAnKCc6IFRPS0VOUy5MUEFSRU4sXG4gICAgJyknOiBUT0tFTlMuUlBBUkVOLFxuICAgICd7JzogVE9LRU5TLkxCUkFDRSxcbiAgICAnfSc6IFRPS0VOUy5SQlJBQ0UsXG4gICAgJ1snOiBUT0tFTlMuTEJSQUNLRVQsXG4gICAgJ10nOiBUT0tFTlMuUkJSQUNLRVQsXG59O1xuXG4vKipcbiAqIE9wZXJhdGlvbiBmdW5jdGlvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgT1BfRlVOQ1RJT05TID0ge1xuICAgIC8vIEJhc2ljIG9wZXJhdGlvbnNcbiAgICAnKyc6IChsZWZ0LCByaWdodCkgPT4gKGxlZnQgKyByaWdodCksXG4gICAgJy0nOiAobGVmdCwgcmlnaHQpID0+IChsZWZ0IC0gcmlnaHQpLFxuICAgICcqJzogKGxlZnQsIHJpZ2h0KSA9PiAobGVmdCAqIHJpZ2h0KSxcbiAgICAnLyc6IChsZWZ0LCByaWdodCkgPT4gKGxlZnQgLyByaWdodCksXG4gICAgJ14nOiAobGVmdCwgcmlnaHQpID0+IEZVTkNUSU9OUy5QT1cobGVmdCwgcmlnaHQpLFxuXG4gICAgLy8gUmVsYXRpb25hbCBvcGVyYXRpb25zXG4gICAgJzwnOiAobGVmdCwgcmlnaHQpID0+IChsZWZ0IDwgcmlnaHQpLFxuICAgICc+JzogKGxlZnQsIHJpZ2h0KSA9PiAobGVmdCA+IHJpZ2h0KSxcbiAgICAnPSc6IChsZWZ0LCByaWdodCkgPT4gKGxlZnQgPT0gcmlnaHQpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICc8PSc6IChsZWZ0LCByaWdodCkgPT4gKGxlZnQgPD0gcmlnaHQpLFxuICAgICc+PSc6IChsZWZ0LCByaWdodCkgPT4gKGxlZnQgPj0gcmlnaHQpLFxuICAgICc8Pic6IChsZWZ0LCByaWdodCkgPT4gKGxlZnQgIT0gcmlnaHQpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4gICAgLy8gT3RoZXIgb3BlcmF0aW9uc1xuICAgICcmJzogKGxlZnQsIHJpZ2h0KSA9PiBGVU5DVElPTlMuQ09OQ0FUKGxlZnQsIHJpZ2h0KSxcbn07XG5cbmV4cG9ydCB7XG4gICAgRlVOQ1RJT05TLFxufTtcbiIsImltcG9ydCAnYmFiZWwtcG9seWZpbGwnO1xuaW1wb3J0ICogYXMgY29uc3RzIGZyb20gJy4vQ29uc3RhbnRzJztcblxuZXhwb3J0ICogZnJvbSAnLi9wYXJzZXInO1xuXG5leHBvcnQge1xuICAgIGNvbnN0cyxcbn07XG5cbmNvbnN0IFNpbnQgPSBleHBvcnRzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmdsb2JhbC5TaW50ID0gU2ludDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykgLy8gZXNsaW50LWRpc2FibGUtbGluZVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gU2ludDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufVxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG57XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAge1xuICAgICAgICByZXR1cm4gU2ludDtcbiAgICB9KTtcbn1cbmVsc2VcbntcbiAgICB3aW5kb3cuU2ludCA9IFNpbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn1cbiIsIi8qKlxuICogSXRlcmFibGUgbGlzdCBvZiBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFyYWN0ZXJzXG57XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgQ2hhcmFjdGVycyBvYmplY3RzIGZyb20gdGV4dC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dF0gLSBUaGUgdGV4dCBzb3VyY2UuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0ID0gJycpXG4gICAge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgYWR2YW5jZSgpXG4gICAge1xuICAgICAgICB0aGlzLnBvaW50ZXIrKztcblxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlZWsgdGhlIG5leHQgY2hhcmFjdGVyIHdpdGhvdXQgYWR2YW5jaW5nLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZ2V0IHBlZWsoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRbdGhpcy5wb2ludGVyICsgMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHBvaW50ZXIgaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRleHQgbGVuZ3RoLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IERpZCBwb2ludGVyIHJlYWNoIHRoZSBsYXN0IHBvc2l0aW9uP1xuICAgICAqL1xuICAgIGdldCBlbmQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRlciA+PSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZpcnN0IHRleHQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGdldCBzdGFydCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dFswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGdldCBjdXJyZW50KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0W3RoaXMucG9pbnRlcl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IHRleHQgYW5kIHNldCBwb2ludGVyIHRvIHplcm8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gLSBDb2RlIGNvbnRlbnQuXG4gICAgICovXG4gICAgc2V0IHRleHQodmFsdWUpXG4gICAge1xuICAgICAgICB0aGlzLl90ZXh0ID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb2ludGVyID0gMDtcbiAgICB9XG5cbiAgICBnZXQgdGV4dCgpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIHdoaXRlIHNwYWNlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaXMgYSB3aGl0ZSBzcGFjZS5cbiAgICAgKi9cbiAgICBpc1doaXRlc3BhY2UoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgvXlxccyskLykudGVzdCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYWxwaGFiZXRpYy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGlzIGEgYWxwaGFiZXRpYy5cbiAgICAgKi9cbiAgICBpc0FscGhhKClcbiAgICB7XG4gICAgICAgIHJldHVybiAoL15bYS16QS1aXSskLykudGVzdCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgVW5pY29kZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGlzIGEgbm9uLWFzY2lpIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBpc1VuaWNvZGUoKVxuICAgIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjEyNDAxMC9ncmVwLXJlZ2V4LXRvLW1hdGNoLW5vbi1hc2NpaS1jaGFyYWN0ZXJzXG4gICAgICAgIHJldHVybiAoL1teXFx4MDAtXFx4N0ZdKyQvKS50ZXN0KHRoaXMuY3VycmVudCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgZGlnaXQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBpcyBhIGRpZ2l0LlxuICAgICAqL1xuICAgIGlzRGlnaXQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgvXlswLTldKyQvKS50ZXN0KHRoaXMuY3VycmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIHZhbGlkIElkZW50aWZpZXIgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaXMgYSB2YWxpZCBpZGVudGlmaWVyLlxuICAgICAqL1xuICAgIGlzSWRlbnRpZmllcigpXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNBbHBoYSgpIHx8IHRoaXMuaXNVbmljb2RlKCkgfHwgdGhpcy5pc0RpZ2l0KCkgfHwgKC9eW1xcX1xcJFxcLl0rJC8pLnRlc3QodGhpcy5jdXJyZW50KSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHZhbHVlcyBmcm9tICdvYmplY3QudmFsdWVzJztcblxuaWYgKCFPYmplY3QudmFsdWVzKVxue1xuICAgIHZhbHVlcy5zaGltKCk7XG59XG5cbi8qKlxuICogRGF0YSBmcm9tIGEgV29ya3NoZWV0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhR3JpZFxue1xuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIERhdGEgbWFwLlxuICAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXNdIC0gTGlzdCBvZiB2YWx1ZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMgPSB7fSlcbiAgICB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIENlbGwgdmFsdWU7XG4gICAgICogQHBhcmFtIHtDZWxsSWRlbnRpZmllcn0gW2NlbGxdIC0gVGhlIENlbGwuXG4gICAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgICAgQ2VsbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZShjZWxsKVxuICAgIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNlbGwuY2xlYW4oKTtcblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgUmFuZ2UgYXJyYXkuXG4gICAgICogQHRvZG8gaW1wbGVtZW50IHRoaXMuXG4gICAgICogQHBhcmFtIHtSYW5nZVJlZmVyZW5jZX0gW3JhbmdlXSAtIFJhbmdlLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICBSYW5nZSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0UmFuZ2UocmFuZ2UpXG4gICAge1xuICAgICAgICBjb25zdCBbZmlyc3QsIGxhc3RdID0gcmFuZ2UucGFpcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC52YWx1ZXModGhpcy52YWx1ZXMpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IExleGVyIGZyb20gJy4vTGV4ZXInO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuL1BhcnNlcic7XG5pbXBvcnQgRGF0YUdyaWQgZnJvbSAnLi9EYXRhR3JpZCc7XG5pbXBvcnQgeyBBU1QgfSBmcm9tICcuL2FzdCc7XG5pbXBvcnQgeyBUT0tFTlMsIE9QX0ZVTkNUSU9OUywgRlVOQ1RJT05TIH0gZnJvbSAnLi8uLi9Db25zdGFudHMnO1xuaW1wb3J0IE5vZGVWaXNpdG9yIGZyb20gJy4vTm9kZVZpc2l0b3InO1xuXG4vKipcbiAqIEV4ZWN1dGUgYW4gQVNULlxuICogQHRvZG8gSW1wbGVtZW50IHByb21pc2VzIGFzIHJldHVybiBmcm9tIGZ1bmN0aW9uIGNhbGxzLlxuICogQHRvZG8gSW1wbGVtZW50IGVycm9yIGhhbmRsaW5nLlxuICogQHRvZG8gSW1wbGVtZW50IHdvcmtzaGVldCBkYXRhIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJwcmV0ZXIgZXh0ZW5kcyBOb2RlVmlzaXRvclxue1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEludGVycHJldGVyXG4gICAgICogQHBhcmFtIHtEYXRhR3JpZH0gW2RhdGFdIC0gRGF0YSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgW2xpc3RdIC0gTGlzdCBvZiBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIGxpc3QgPSBudWxsKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kYXRhID0gKGRhdGEgPyBkYXRhIDogbmV3IERhdGFHcmlkKCkpO1xuICAgICAgICB0aGlzLmZ1bmN0aW9ucyA9IChsaXN0ID8gbGlzdCA6IEZVTkNUSU9OUyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmlzaXQgYSBGdW5jdGlvbkNhbGwgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBmdW5jdGlvbiBkb2Vzbid0IGV4aXN0cy5cbiAgICAgKiBAcGFyYW0ge0FTVH0gW25vZGVdIC0gVGhlIHRyZWUgb3Igbm9kZS5cbiAgICAgKiBAcmV0dXJuIHsqfSBSZXN1bHQgb2Ygb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHZpc2l0RnVuY3Rpb25DYWxsKG5vZGUpXG4gICAge1xuICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICBjb25zdCBmbiA9IHRoaXMuZnVuY3Rpb25CeU5hbWUobmFtZSk7XG5cbiAgICAgICAgaWYgKGZuICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIG5vZGUucGFyYW1zKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IG5vZGUucGFyYW1zW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0KGFyZykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIFwiJHtuYW1lfVwiIGRvZXNuJ3QgZXhpc3RzLmApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZpc2l0IGEgQ2VsbElkZW50aWZpZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtBU1R9IFtub2RlXSAtIFRoZSB0cmVlIG9yIG5vZGUuXG4gICAgICogQHJldHVybiB7Kn0gICAgICAgICAgIENlbGwgdmFsdWUgb3IgbnVsbC5cbiAgICAgKi9cbiAgICB2aXNpdENlbGxJZGVudGlmaWVyKG5vZGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldFZhbHVlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmlzaXQgYSBSYW5nZVJlZmVyZW5jZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0FTVH0gW25vZGVdIC0gVGhlIHRyZWUgb3Igbm9kZS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgUmFuZ2UgYXMgYXJyYXkuXG4gICAgICovXG4gICAgdmlzaXRSYW5nZVJlZmVyZW5jZShub2RlKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXRSYW5nZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZpc2l0IGEgQmluT3Agb2JqZWN0XG4gICAgICogQHBhcmFtIHtBU1R9IFtub2RlXSAtIFRoZSB0cmVlIG9yIG5vZGUuXG4gICAgICogQHJldHVybiB7Kn0gUmVzdWx0IG9mIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICB2aXNpdEJpbk9wKG5vZGUpXG4gICAge1xuICAgICAgICBjb25zdCBzaWduID0gbm9kZS5vcC52YWx1ZTtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBPUF9GVU5DVElPTlNbc2lnbl07XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IodGhpcy52aXNpdChub2RlLmxlZnQpLCB0aGlzLnZpc2l0KG5vZGUucmlnaHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZpc2l0IGEgVW5hcnlPcCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0FTVH0gW25vZGVdIC0gVGhlIHRyZWUgb3Igbm9kZS5cbiAgICAgKiBAcmV0dXJuIHsqfSBSZXN1bHQgb2Ygb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHZpc2l0VW5hcnlPcChub2RlKVxuICAgIHtcbiAgICAgICAgaWYgKG5vZGUub3AudHlwZSA9PT0gVE9LRU5TLk1JTlVTKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gLSh0aGlzLnZpc2l0KG5vZGUuZXhwcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICsodGhpcy52aXNpdChub2RlLmV4cHIpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZpc2l0IGEgUG9zdGZpeE9wIG9iamVjdFxuICAgICAqIEBwYXJhbSB7QVNUfSBbbm9kZV0gLSBUaGUgdHJlZSBvciBub2RlLlxuICAgICAqIEByZXR1cm4geyp9IFJlc3VsdCBvZiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgdmlzaXRQb3N0Zml4T3Aobm9kZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy52aXNpdChub2RlLmV4cHIpIC8gMTAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWaXNpdCBhIEFycmF5Q29uc3RhbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtBU1R9IFtub2RlXSAtIFRoZSB0cmVlIG9yIG5vZGUuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBOb2RlIHZhbHVlLlxuICAgICAqL1xuICAgIHZpc2l0QXJyYXlDb25zdGFudChub2RlKVxuICAgIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUudmFsdWUpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gbm9kZS52YWx1ZTtcbiAgICAgICAgY29uc3QgY29uc3RhbnQgPSBbXTtcbiAgICAgICAgbGV0IGNvbHVtbiA9IFtdO1xuICAgICAgICBsZXQgcm93ID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBpIGluIGNvbHVtbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XG4gICAgICAgICAgICBjb25zdGFudFtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBqIGluIGNvbHVtbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb3cgPSBjb2x1bW5bal07XG4gICAgICAgICAgICAgICAgY29uc3RhbnRbaV1bal0gPSB0aGlzLnZpc2l0KHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmlzaXQgYSBOdW1iZXJDb25zdGFudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0FTVH0gW25vZGVdIC0gVGhlIHRyZWUgb3Igbm9kZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5vZGUgdmFsdWUuXG4gICAgICovXG4gICAgdmlzaXROdW1iZXJDb25zdGFudChub2RlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmlzaXQgYSBTdHJpbmdDb25zdGFudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0FTVH0gW25vZGVdIC0gVGhlIHRyZWUgb3Igbm9kZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IE5vZGUgdmFsdWUuXG4gICAgICovXG4gICAgdmlzaXRTdHJpbmdDb25zdGFudChub2RlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmlzaXQgYSBCb29sZWFuQ29uc3RhbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtBU1R9IFtub2RlXSAtIFRoZSB0cmVlIG9yIG5vZGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gTm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB2aXNpdEJvb2xlYW5Db25zdGFudChub2RlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmlzaXQgYSBFcnJvckNvbnN0YW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7QVNUfSBbbm9kZV0gLSBUaGUgdHJlZSBvciBub2RlLlxuICAgICAqIEByZXR1cm4ge251bGx9IE5vZGUgdmFsdWUuXG4gICAgICovXG4gICAgdmlzaXRFcnJvckNvbnN0YW50KG5vZGUpXG4gICAge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBmdW5jdGlvbiBmcm9tIGEgbGlzdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gRnVuY3Rpb24gbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uQnlOYW1lKG5hbWUpXG4gICAge1xuICAgICAgICBjb25zdCBmbnMgPSB0aGlzLmZ1bmN0aW9ucztcblxuICAgICAgICByZXR1cm4gZm5zW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBtb3JlIGZ1bmN0aW9ucyB0byB0aGUgZnVuY3Rpb24gbGlzdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IFtsaXN0XSAtIFBhaXJzIG9mIG5hbWUgOiBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEZ1bmN0aW9uIGxpc3QuXG4gICAgICovXG4gICAgYWRkRnVuY3Rpb25zKGxpc3QpXG4gICAge1xuICAgICAgICB0aGlzLmZ1bmN0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5mdW5jdGlvbnMsIGxpc3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gW2xpc3RdIC0gUGFpcnMgb2YgbmFtZSA6IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldCBmdW5jdGlvbnMobGlzdClcbiAgICB7XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9ucyA9IGxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEZ1bmN0aW9uIGxpc3QuXG4gICAgICovXG4gICAgZ2V0IGZ1bmN0aW9ucygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVuY3Rpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBBU1Qgb3IgcGFyc2UgYW5kIHRoZW4gZXhlY3V0ZSBhIGNvZGUuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIGlzIGEgaW52YWxpZCBjb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFTVH0gW3NvdXJjZV0gLSBTb3VyY2UgY29kZSBvciBBU1QuXG4gICAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgIFRoZSByZXN1bHQgb2YgdGhlIGNvZGUuXG4gICAgICovXG4gICAgZXhlY3V0ZShzb3VyY2UpXG4gICAge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKHNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGxleGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZSh0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBU1QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0KHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgQVNUIG9yIHBhcnNlIGFuZCB0aGVuIGV4ZWN1dGUgYSBjb2RlLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBpcyBhIGludmFsaWQgY29kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBU1R9IFtzb3VyY2VdIC0gU291cmNlIGNvZGUgb3IgQVNULlxuICAgICAqIEBwYXJhbSB7RGF0YUdyaWR9ICAgW2RhdGFdICAgLSBEYXRhIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgICAgVGhlIHJlc3VsdCBvZiB0aGUgY29kZS5cbiAgICAgKi9cbiAgICBydW4oc291cmNlID0gbnVsbCwgZGF0YSA9IG51bGwpXG4gICAge1xuICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoc291cmNlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUT0tFTlMsIE9QRVJBVE9SUywgRVJST1JTIH0gZnJvbSAnLi8uLi9Db25zdGFudHMnO1xuaW1wb3J0IENoYXJhY3RlcnMgZnJvbSAnLi9DaGFyYWN0ZXJzJztcbmltcG9ydCBUb2tlbiBmcm9tICcuL1Rva2VuJztcblxuY29uc3QgU1RBUlRfQ0hBUiA9ICc9JztcbmNvbnN0IFVOREVSU0NPUkUgPSAnXyc7XG5jb25zdCBET0xMQVJfU0lHTiA9ICckJztcbmNvbnN0IFNJTkdMRV9RVU9URSA9ICdcXCcnO1xuY29uc3QgRE9VQkxFX1FVT1RFID0gJ1wiJztcblxuLy8gRXJyb3IgY2hhcmFjdGVyZXNcbmNvbnN0IEhBU0hfU0lHTiA9ICcjJztcbmNvbnN0IEVYQ0xBTUFUSU9OX01BUksgPSAnISc7XG5jb25zdCBRVUVTVElPTl9NQVJLID0gJz8nO1xuY29uc3QgU0xBU0ggPSAnLyc7XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBpdCdzIGEgbnVtYmVyIG9yIG51bWJlciBzdHJpbmcuXG5mdW5jdGlvbiBpc051bWJlcihudW1iZXIpXG57XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG51bWJlcikpICYmIGlzRmluaXRlKG51bWJlcik7XG59XG5cbi8qKlxuICogQSBjbGFzcyB0byBkbyBMZXhpY2FsIGFuYWx5c2lzLlxuICpcbiAqIEBleHRlbmRzIENoYXJhY3RlcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV4ZXIgZXh0ZW5kcyBDaGFyYWN0ZXJzXG57XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgTGV4ZXIuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdIC0gQ29kZSBjb250ZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCA9ICcnKVxuICAgIHtcbiAgICAgICAgc3VwZXIodGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2tpcCB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICovXG4gICAgc2tpcFdoaXRlc3BhY2UoKVxuICAgIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVuZCAmJiB0aGlzLmlzV2hpdGVzcGFjZSgpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNvbnRlbnRzIGZyb20gdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRleHQgY29udGVudHMuXG4gICAgICovXG4gICAgY29udGVudHMoKVxuICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICghdGhpcy5lbmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbnN0YW50IG9yIEVPRi4gQ29uc3RhbnRzIGNhbiBiZSBTdHJpbmdzLCBudW1iZXJzIGFuZCBCb29sZWFucy5cbiAgICAgKiBAcmV0dXJuIHtUb2tlbn0gQSBDb25zdGFudCB0b2tlbi5cbiAgICAgKi9cbiAgICBjb25zdGFudCgpXG4gICAge1xuICAgICAgICBjb25zdCBpc1NpbmdsZVF1b3RlZCA9ICh0aGlzLmN1cnJlbnQgPT09IFNJTkdMRV9RVU9URSk7XG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGlzU2luZ2xlUXVvdGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udGVudHMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihUT0tFTlMuU1RSSU5HLCBTdHJpbmcocmVzdWx0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnRlbnRzKCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGxvd2VyLnRyaW0oKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gRVJST1JTKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChFUlJPUlNba2V5XSA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRva2VuKFRPS0VOUy5FUlJPUiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvd2VyID09PSAnVFJVRScpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihUT0tFTlMuQk9PTEVBTiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb3dlciA9PT0gJ0ZBTFNFJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRva2VuKFRPS0VOUy5CT09MRUFOLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc051bWJlcihyZXN1bHQpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4oVE9LRU5TLk5VTUJFUiwgcGFyc2VGbG9hdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihUT0tFTlMuU1RSSU5HLCBTdHJpbmcocmVzdWx0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRva2VuKFRPS0VOUy5FT0wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkaWdpdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBOdW1iZXIgc3RyaW5nLlxuICAgICAqL1xuICAgIGRpZ2l0KClcbiAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgICAgICB3aGlsZSAodGhpcy5pc0RpZ2l0KCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciB0b2tlbiBvciBhIHJhbmdlIChlLmcuIDE6MykgdG9rZW4uXG4gICAgICogQHJldHVybiB7VG9rZW59IEEgTnVtYmVyIG9yIFJhbmdlIHRva2VuLlxuICAgICAqL1xuICAgIG51bWJlcigpXG4gICAge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kaWdpdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQgPT09ICcuJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgZG90IHNpZ24uXG4gICAgICAgICAgICByZXN1bHQgPSBgJHtyZXN1bHR9LiR7dGhpcy5kaWdpdCgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50ID09PSAnOicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGNvbG9uIHNpZ24uXG4gICAgICAgICAgICByZXN1bHQgPSBgJHtyZXN1bHR9OiR7dGhpcy5kaWdpdCgpfWA7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4oVE9LRU5TLlJBTkdFLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQocmVzdWx0KTtcblxuICAgICAgICByZXR1cm4gbmV3IFRva2VuKFRPS0VOUy5OVU1CRVIsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGlkZW50aWZpZXIsIHRoYXQgY2FuIGJlIGEgRnVuY3Rpb24gbmFtZSwgY2VsbCByZWZlcmVuY2Ugb3IgcmFuZ2UuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBbiBJZGVudGlmaWVyLlxuICAgICAqL1xuICAgIG5hbWUoKVxuICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICghdGhpcy5lbmQgJiYgdGhpcy5pc0lkZW50aWZpZXIoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBpZGVudGlmaWVyIG9yIHJhbmdlIHRva2VuLlxuICAgICAqIEByZXR1cm4ge1Rva2VufSBBbiBJRCBvciBSQU5HRSB0b2tlbi5cbiAgICAgKi9cbiAgICBpZGVudGlmaWVyKClcbiAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm5hbWUoKTtcbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gKHJlc3VsdCA9PT0gJ1RSVUUnIHx8IHJlc3VsdCA9PT0gJ0ZBTFNFJyk7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIGl0cyBub3QgYSBmdW5jdGlvbiwgZS5nLiBUUlVFKCkgb3IgRkFMU0UoKS5cbiAgICAgICAgaWYgKGlzQm9vbGVhbilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5za2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudCAhPT0gJygnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4oVE9LRU5TLkJPT0xFQU4sIHJlc3VsdCA9PT0gJ1RSVUUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiBpdCdzIGEgUmFuZ2VcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCA9PT0gJzonKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBjb2xvbiBtYXJrLlxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMubmFtZSgpO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBgJHtmaXJzdH06JHtsYXN0fWA7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4oVE9LRU5TLlJBTkdFLCByZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIGl0J3MgYSBTaGVldFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50ID09PSAnIScpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGV4Y2xhbWF0aW9uIG1hcmsuXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihUT0tFTlMuU0hFRVQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRva2VuKFRPS0VOUy5JRCwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5kXSAtIHRoZSBFbmQgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHdob2xlIHN0cmluZy5cbiAgICAgKi9cbiAgICBsaXRlcmFsKGVuZCA9IERPVUJMRV9RVU9URSlcbiAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgICAgICAvLyBTa2lwIHRoZSBmaXJzdCBxdW90ZSBzaWduLlxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVuZCAmJiB0aGlzLmN1cnJlbnQgIT09IGVuZClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCB0aGUgbGFzdCBxdW90ZSBzaWduLlxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcblxuICAgICAgICByZXR1cm4gU3RyaW5nKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge1Rva2VufSBBIFN0cmluZyB0b2tlbi5cbiAgICAgKi9cbiAgICBzdHJpbmcoKVxuICAgIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5saXRlcmFsKERPVUJMRV9RVU9URSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihUT0tFTlMuU1RSSU5HLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaGVldCB0b2tlbi5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBhbiBlbXB0eSBzaGVldC5cbiAgICAgKiBAcmV0dXJuIHtUb2tlbn0gQSBJRCB0b2tlbi5cbiAgICAgKi9cbiAgICBzaGVldCgpXG4gICAge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmxpdGVyYWwoU0lOR0xFX1FVT1RFKS50cmltKCkudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRW1wdHkgc2hlZXQgbmFtZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBleGNsYW1hdGlvbiBwb2ludC5cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihUT0tFTlMuU0hFRVQsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEVycm9yIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QgYSB2YWxpZCBFcnJvci5cbiAgICAgKiBAcmV0dXJuIHtUb2tlbn0gQSBFcnJvciB0b2tlbi5cbiAgICAgKi9cbiAgICBlcnJvcigpXG4gICAge1xuICAgICAgICBjb25zdCBmaW5hbENoYXJzID0gW0VYQ0xBTUFUSU9OX01BUkssIFFVRVNUSU9OX01BUkssIFNMQVNIXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICghdGhpcy5lbmQgJiYgIWZpbmFsQ2hhcnMuaW5jbHVkZXModGhpcy5jdXJyZW50KSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNTbGFzaCA9ICh0aGlzLmN1cnJlbnQgPT09IFNMQVNIKTtcblxuICAgICAgICByZXN1bHQgKz0gdGhpcy5jdXJyZW50O1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcblxuICAgICAgICBpZiAoaXNTbGFzaClcbiAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmN1cnJlbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gI0RJVi8wIVxuICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLy8gI04vQVxuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gRVJST1JTKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoRVJST1JTW2tleV0gPT09IHJlc3VsdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRva2VuKFRPS0VOUy5FUlJPUiwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG9wZXJhdG9yXG4gICAgICogQHJldHVybiB7VG9rZW59IEEgU3RyaW5nIHRva2VuLlxuICAgICAqL1xuICAgIG9wZXJhdG9yKClcbiAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmFkdmFuY2UoKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSAnPCcgJiYgbmV4dCA9PT0gJz0nKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ID09PSAnPicgJiYgbmV4dCA9PT0gJz0nKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ID09PSAnPCcgJiYgbmV4dCA9PT0gJz4nKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRva2VuKE9QRVJBVE9SU1tyZXN1bHRdLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbmV4dCB0b2tlbiBhbmQgcmVzZXQgcG9pbnRlci5cbiAgICAgKiBAcmV0dXJuIHtUb2tlbn0gQSBUb2tlbi5cbiAgICAgKi9cbiAgICBwZWVrKClcbiAgICB7XG4gICAgICAgIGNvbnN0IG9sZFBvaW50ZXIgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgdGhpcy5wb2ludGVyID0gb2xkUG9pbnRlcjtcblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IHRva2VuIGZvciBhIGZvcm11bGFcbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgaXMgYSBpbnZhbGlkIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtUb2tlbn0gQSBUb2tlbi5cbiAgICAgKi9cbiAgICBfbmV4dFRva2VuKClcbiAgICB7XG4gICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3Rlciwgc2tpcCBpdC5cbiAgICAgICAgaWYgKHRoaXMucG9pbnRlciA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4oVE9LRU5TLkVRLCBTVEFSVF9DSEFSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICghdGhpcy5lbmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFdoaWxlIGlzIFdoaXRlc3BhY2UsIHNraXAuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1doaXRlc3BhY2UoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBudW1iZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RpZ2l0KCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBpZGVudGlmaWVyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0FscGhhKCkgfHwgdGhpcy5pc1VuaWNvZGUoKSB8fCB0aGlzLmN1cnJlbnQgPT09IFVOREVSU0NPUkUgfHwgdGhpcy5jdXJyZW50ID09PSBET0xMQVJfU0lHTilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBTdHJpbmdzXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50ID09PSBET1VCTEVfUVVPVEUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBTaGVldHNcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQgPT09IFNJTkdMRV9RVU9URSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaGVldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgRXJyb3JcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQgPT09IEhBU0hfU0lHTilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgT3BlcmF0b3JzXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50IGluIE9QRVJBVE9SUylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIFwiJHt0aGlzLmN1cnJlbnR9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4oVE9LRU5TLkVPTCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IHRva2VuXG4gICAgICogQHJldHVybiB7VG9rZW59IEEgVG9rZW4uXG4gICAgICovXG4gICAgbmV4dCgpXG4gICAge1xuICAgICAgICAvLyBDaGVjayBpZiBzdGFydHMgd2l0aCBcIj1cIi5cbiAgICAgICAgaWYgKHRoaXMuc3RhcnQgPT09IFNUQVJUX0NIQVIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXh0VG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhIFN0cmluZywgTnVtYmVyIG9yIEJvb2xlYW5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RhbnQoKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIE5vZGUgdmlzaXRvciBpcyBhIHdhbGtlciBmb3IgdGhlIGFic3RyYWN0IHN5c250YXggdHJlZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZVZpc2l0b3JcbntcbiAgICAvKipcbiAgICAgKiBWaXNpdCBhbGwgbm9kZXMgb2YgYSB0cmVlLlxuICAgICAqIEBwYXJhbSB7QVNUfSBbbm9kZV0gLSBUaGUgdHJlZSBvciBub2RlLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgdmlzaXRpbmcgYWxsIG5vZGVzLlxuICAgICAqL1xuICAgIHZpc2l0KG5vZGUpXG4gICAge1xuICAgICAgICBsZXQgbWV0aG9kTmFtZTtcbiAgICAgICAgbGV0IHZpc2l0b3I7XG5cbiAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSBgdmlzaXQke25vZGUuY29uc3RydWN0b3IuZGlzcGxheU5hbWV9YDtcbiAgICAgICAgICAgIHZpc2l0b3IgPSB0aGlzW21ldGhvZE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2aXNpdG9yKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vICR7bWV0aG9kTmFtZX0gbWV0aG9kYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaXRvci5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFRPS0VOUyB9IGZyb20gJy4vLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7XG4gICAgRnVuY3Rpb25DYWxsLFxuICAgIENlbGxJZGVudGlmaWVyLFxuICAgIFJhbmdlUmVmZXJlbmNlLFxuICAgIEJpbk9wLFxuICAgIFVuYXJ5T3AsXG4gICAgUG9zdGZpeE9wLFxuICAgIEFycmF5Q29uc3RhbnQsXG4gICAgTnVtYmVyQ29uc3RhbnQsXG4gICAgU3RyaW5nQ29uc3RhbnQsXG4gICAgQm9vbGVhbkNvbnN0YW50LFxuICAgIEVycm9yQ29uc3RhbnQsXG59IGZyb20gJy4vYXN0JztcblxuLyoqXG4gKiBTeW50YXggYW5hbHl6ZXJcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5HcmFtbWFyOjwvY2FwdGlvbj5cbiAqXG4gKiBzdGFydCA6IGNvbnN0YW50XG4gKiAgICAgICB8ICc9JyBleHByXG4gKiAgICAgICA7XG4gKlxuICogZXhwciA6IHJlbEV4cCAoKEVRIHwgTkUpIHJlbEV4cCkqIDtcbiAqXG4gKiByZWxFeHAgOiBhZGRFeHAgKChMVCB8IExFIHwgR1QgfCBHRSkgYWRkRXhwKSogO1xuICpcbiAqIGFkZEV4cCA6IG11bEV4cCAoKFBMVVMgfCBNSU5VUyB8IENPTkNBVCkgbXVsRXhwKSogO1xuICpcbiAqIG11bEV4cCA6IGV4cEV4cCAoKE1VTFQgfCBESVYpIGV4cEV4cCkqIDtcbiAqXG4gKiBleHBFeHAgOiB0ZXJtICgoRVhQKSB0ZXJtKSogO1xuICpcbiAqIHRlcm0gOiAoUExVUyB8IE1JTlVTKSBmYWN0b3IgKFBFUkNFTlQpPyA7XG4gKlxuICogZmFjdG9yIDogY29uc3RhbnRcbiAqICAgICAgICB8IGZvcm11bGFcbiAqICAgICAgICB8ICd7JyBhcnJheWNvbHVtbnMgJ30nXG4gKiAgICAgICAgfCAnKCcgZXhwciAnKSdcbiAqICAgICAgICA7XG4gKlxuICogYXJyYXljb2x1bW5zIDogYXJyYXlyb3dzXG4gKiAgICAgICAgICAgICAgfCBhcnJheXJvd3MgJzsnIGFycmF5Y29sdW1uc1xuICogICAgICAgICAgICAgIDtcbiAqXG4gKiBhcnJheXJvd3MgOiBleHByXG4gKiAgICAgICAgICAgfCBleHByICcsJyBhcnJheXJvd3NcbiAqICAgICAgICAgICA7XG4gKlxuICogZm9ybXVsYSA6IChTSEVFVCk/IHJlZmVyZW5jZSA7XG4gKlxuICogcmVmZXJlbmNlIDogSUQgKCcoJyBwYXJhbWV0ZXJzICcpJyk/XG4gKiAgICAgICAgICAgfCBSQU5HRVxuICogICAgICAgICAgIDtcbiAqXG4gKiBwYXJhbWV0ZXJzIDogZXhwciAoJywnIGV4cHIpXG4gKiAgICAgICAgICAgIHwgZW1wdHlcbiAqICAgICAgICAgICAgO1xuICpcbiAqIGNvbnN0YW50IDogTlVNQkVSXG4gKiAgICAgICAgICB8IFNUUklOR1xuICogICAgICAgICAgfCBCT09MXG4gKiAgICAgICAgICB8IEVSUk9SXG4gKiAgICAgICAgICA7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlclxue1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQYXJzZXIuXG4gICAgICogQHBhcmFtIHtMZXhlcn0gbGV4ZXIgLSBMZXhpY2FsIGFuYWx5emVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZXhlciA9IG51bGwpXG4gICAge1xuICAgICAgICB0aGlzLmxleGVyID0gbGV4ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgcnVsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdyYW1tYXI6PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogIHN0YXJ0IDogY29uc3RhbnRcbiAgICAgKiAgICAgICAgfCAnPScgZXhwclxuICAgICAqICAgICAgICA7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBU1R9IEFic3RyYWN0IFN5bnRheCB0cmVlLlxuICAgICAqL1xuICAgIHN0YXJ0KClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSBUT0tFTlMuRVEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLkVRKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RhbnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHByZXNzaW9uIHJ1bGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HcmFtbWFyOjwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIGV4cHIgOiByZWxFeHAgKChFUSB8IE5FKSByZWxFeHApKiA7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBU1R9IEFic3RyYWN0IFN5bnRheCB0cmVlLlxuICAgICAqL1xuICAgIGV4cHIoKVxuICAgIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJlbEV4cCgpO1xuXG4gICAgICAgIHdoaWxlIChbVE9LRU5TLkVRLCBUT0tFTlMuTkVdLmluY2x1ZGVzKHRoaXMubG9va2FoZWFkLnR5cGUpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXG4gICAgICAgICAgICB0aGlzLm1hdGNoKHRva2VuLnR5cGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBCaW5PcChub2RlLCB0b2tlbiwgdGhpcy5yZWxFeHAoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGlvbmFsIG9wZXJhdG9ycyBydWxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R3JhbW1hcjo8L2NhcHRpb24+XG4gICAgICpcbiAgICAgKiByZWxFeHAgOiBhZGRFeHAgKChMVCB8IExFIHwgR1QgfCBHRSkgYWRkRXhwKSogO1xuICAgICAqXG4gICAgICogQHJldHVybiB7QVNUfSBBYnN0cmFjdCBTeW50YXggdHJlZS5cbiAgICAgKi9cbiAgICByZWxFeHAoKVxuICAgIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmFkZEV4cCgpO1xuXG4gICAgICAgIHdoaWxlIChbVE9LRU5TLkxULCBUT0tFTlMuTEUsIFRPS0VOUy5HVCwgVE9LRU5TLkdFXS5pbmNsdWRlcyh0aGlzLmxvb2thaGVhZC50eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblxuICAgICAgICAgICAgdGhpcy5tYXRjaCh0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQmluT3Aobm9kZSwgdG9rZW4sIHRoaXMuYWRkRXhwKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gYW5kIHN1YnRyYWN0aW9uIEV4cHJlc3Npb24gcnVsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdyYW1tYXI6PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogYWRkRXhwIDogbXVsRXhwICgoUExVUyB8IE1JTlVTIHwgQ09OQ0FUKSBtdWxFeHApKiA7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBU1R9IEFic3RyYWN0IFN5bnRheCB0cmVlLlxuICAgICAqL1xuICAgIGFkZEV4cCgpXG4gICAge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubXVsRXhwKCk7XG5cbiAgICAgICAgd2hpbGUgKFtUT0tFTlMuUExVUywgVE9LRU5TLk1JTlVTLCBUT0tFTlMuQ09OQ0FUXS5pbmNsdWRlcyh0aGlzLmxvb2thaGVhZC50eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblxuICAgICAgICAgICAgdGhpcy5tYXRjaCh0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQmluT3Aobm9kZSwgdG9rZW4sIHRoaXMubXVsRXhwKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGljYXRpb24gYW5kIGRpdmlzaW9uIHJ1bGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HcmFtbWFyOjwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIG11bEV4cCA6IGV4cEV4cCAoKE1VTFQgfCBESVYpIGV4cEV4cCkqIDtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FTVH0gQWJzdHJhY3QgU3ludGF4IHRyZWUuXG4gICAgICovXG4gICAgbXVsRXhwKClcbiAgICB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5leHBFeHAoKTtcblxuICAgICAgICB3aGlsZSAoW1RPS0VOUy5NVUxULCBUT0tFTlMuRElWXS5pbmNsdWRlcyh0aGlzLmxvb2thaGVhZC50eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblxuICAgICAgICAgICAgdGhpcy5tYXRjaCh0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQmluT3Aobm9kZSwgdG9rZW4sIHRoaXMuZXhwRXhwKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb25lbnRpYXRpb24gcnVsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdyYW1tYXI6PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogZXhwRXhwIDogdGVybSAoKEVYUCkgdGVybSkqIDtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FTVH0gQWJzdHJhY3QgU3ludGF4IHRyZWUuXG4gICAgICovXG4gICAgZXhwRXhwKClcbiAgICB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy50ZXJtKCk7XG5cbiAgICAgICAgd2hpbGUgKFtUT0tFTlMuUE9XXS5pbmNsdWRlcyh0aGlzLmxvb2thaGVhZC50eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblxuICAgICAgICAgICAgdGhpcy5tYXRjaCh0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQmluT3Aobm9kZSwgdG9rZW4sIHRoaXMudGVybSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlcm0gcnVsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdyYW1tYXI6PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogdGVybSA6IChQTFVTIHwgTUlOVVMpIGZhY3RvciAoUEVSQ0VOVCk/IDtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FTVH0gQWJzdHJhY3QgU3ludGF4IHRyZWUuXG4gICAgICovXG4gICAgdGVybSgpXG4gICAge1xuICAgICAgICBsZXQgdW5hcnkgPSBudWxsO1xuICAgICAgICBsZXQgcG9zdGZpeCA9IG51bGw7XG5cbiAgICAgICAgaWYgKFtUT0tFTlMuUExVUywgVE9LRU5TLk1JTlVTXS5pbmNsdWRlcyh0aGlzLmxvb2thaGVhZC50eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdW5hcnkgPSB0aGlzLmxvb2thaGVhZDtcbiAgICAgICAgICAgIHRoaXMubWF0Y2godGhpcy5sb29rYWhlYWQudHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5mYWN0b3IoKTtcblxuICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gVE9LRU5TLlBFUkNFTlQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvc3RmaXggPSB0aGlzLmxvb2thaGVhZDtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLlBFUkNFTlQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuYXJ5ICE9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocG9zdGZpeCAhPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvc3RmaXhPcChwb3N0Zml4LCBuZXcgVW5hcnlPcCh1bmFyeSwgbm9kZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuYXJ5T3AodW5hcnksIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc3RmaXggIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zdGZpeE9wKHBvc3RmaXgsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhY3RvciBydWxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R3JhbW1hcjo8L2NhcHRpb24+XG4gICAgICpcbiAgICAgKiBmYWN0b3IgOiBjb25zdGFudFxuICAgICAqICAgICAgICB8IGZvcm11bGFcbiAgICAgKiAgICAgICAgfCAneycgYXJyYXljb2x1bW5zICd9J1xuICAgICAqICAgICAgICB8ICcoJyBleHByICcpJ1xuICAgICAqICAgICAgICA7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBU1R9IEFic3RyYWN0IFN5bnRheCB0cmVlLlxuICAgICAqL1xuICAgIGZhY3RvcigpXG4gICAge1xuICAgICAgICBjb25zdCBjb25zdGFudHMgPSBbVE9LRU5TLk5VTUJFUiwgVE9LRU5TLlNUUklORywgVE9LRU5TLkJPT0xFQU4sIFRPS0VOUy5FUlJPUl07XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS0VOUy5MUEFSRU4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLkxQQVJFTik7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmV4cHIoKTtcblxuICAgICAgICAgICAgdGhpcy5tYXRjaChUT0tFTlMuUlBBUkVOKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS0VOUy5MQlJBQ0UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLkxCUkFDRSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5hcnJheWNvbHVtbnMoKTtcblxuICAgICAgICAgICAgdGhpcy5tYXRjaChUT0tFTlMuUkJSQUNFKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvbnN0YW50KGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25zdGFudHMuaW5jbHVkZXModG9rZW4udHlwZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0YW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtdWxhKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgQ29sdW1ucyBydWxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R3JhbW1hcjo8L2NhcHRpb24+XG4gICAgICpcbiAgICAgKiBhcnJheWNvbHVtbnMgOiBhcnJheXJvd3NcbiAgICAgKiAgICAgICAgICAgICAgfCBhcnJheXJvd3MgJzsnIGFycmF5Y29sdW1uc1xuICAgICAqICAgICAgICAgICAgICA7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBU1R9IEFic3RyYWN0IFN5bnRheCB0cmVlLlxuICAgICAqL1xuICAgIGFycmF5Y29sdW1ucygpXG4gICAge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gW3RoaXMuYXJyYXlyb3dzKCldO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlID09PSBUT0tFTlMuU0VNSUNPTE9OKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRPS0VOUy5TRU1JQ09MT04pO1xuXG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmFycmF5cm93cygpO1xuXG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFycmF5IFJvd3MgcnVsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdyYW1tYXI6PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogYXJyYXlyb3dzIDogZXhwclxuICAgICAqICAgICAgICAgICB8IGV4cHIgJywnIGFycmF5cm93c1xuICAgICAqICAgICAgICAgICA7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBU1R9IEFic3RyYWN0IFN5bnRheCB0cmVlLlxuICAgICAqL1xuICAgIGFycmF5cm93cygpXG4gICAge1xuICAgICAgICBjb25zdCByb3dzID0gW3RoaXMuZXhwcigpXTtcblxuICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gVE9LRU5TLkNPTU1BKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRPS0VOUy5DT01NQSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZXhwcigpO1xuXG4gICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm11bGEgcnVsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdyYW1tYXI6PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogZm9ybXVsYSA6IChTSEVFVCk/IHJlZmVyZW5jZSA7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBU1R9IEFic3RyYWN0IFN5bnRheCB0cmVlLlxuICAgICAqL1xuICAgIGZvcm11bGEoKVxuICAgIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcbiAgICAgICAgbGV0IG5hbWUgPSBudWxsO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUT0tFTlMuU0hFRVQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLlNIRUVUKTtcbiAgICAgICAgICAgIG5hbWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZShuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgcnVsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdyYW1tYXI6PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogcmVmZXJlbmNlIDogSUQgKCcoJyBwYXJhbWV0ZXJzICcpJyk/XG4gICAgICogICAgICAgICAgIHwgUkFOR0VcbiAgICAgKiAgICAgICAgICAgO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzaGVldF0gLSBTaGVldCBuYW1lXG4gICAgICogQHJldHVybiB7QVNUfSBBYnN0cmFjdCBTeW50YXggdHJlZS5cbiAgICAgKi9cbiAgICByZWZlcmVuY2Uoc2hlZXQgPSBudWxsKVxuICAgIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblxuICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW4oKS50eXBlID09PSBUT0tFTlMuTFBBUkVOKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRPS0VOUy5JRCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRPS0VOUy5MUEFSRU4pO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnMoKTtcblxuICAgICAgICAgICAgdGhpcy5tYXRjaChUT0tFTlMuUlBBUkVOKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwodG9rZW4udmFsdWUsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVE9LRU5TLlJBTkdFKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRPS0VOUy5SQU5HRSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VSZWZlcmVuY2UodG9rZW4sIHNoZWV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLklEKTtcblxuICAgICAgICByZXR1cm4gbmV3IENlbGxJZGVudGlmaWVyKHRva2VuLnZhbHVlLCBzaGVldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVycyBydWxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R3JhbW1hcjo8L2NhcHRpb24+XG4gICAgICpcbiAgICAgKiBwYXJhbWV0ZXJzIDogZXhwciAoJywnIGV4cHIpXG4gICAgICogICAgICAgICAgICB8IGVtcHR5XG4gICAgICogICAgICAgICAgICA7XG4gICAgICpcbiAgICAgKiBAdG9kbyAgIFNob3VsZCBhY2NlcHQgZW1wdHkgcGFyYW1ldGVycyBsaWtlIFwiPUNPVU5UKCwsLCwpXCIuXG4gICAgICogQHJldHVybiB7QVNUfSBBYnN0cmFjdCBTeW50YXggdHJlZS5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJzKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSBUT0tFTlMuUlBBUkVOICYmIHRoaXMubG9va2FoZWFkLnR5cGUgIT09IFRPS0VOUy5FT0wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5leHByKCk7XG5cbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IFRPS0VOUy5DT01NQSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKFRPS0VOUy5DT01NQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IHJ1bGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HcmFtbWFyOjwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIGNvbnN0YW50IDogTlVNQkVSXG4gICAgICogICAgICAgICAgfCBTVFJJTkdcbiAgICAgKiAgICAgICAgICB8IEJPT0xcbiAgICAgKlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBpdCdzIG5vdCBhIGNvbnN0YW50LlxuICAgICAqIEByZXR1cm4ge0FTVH0gQWJzdHJhY3QgU3ludGF4IHRyZWUuXG4gICAgICovXG4gICAgY29uc3RhbnQoKVxuICAgIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcbiAgICAgICAgbGV0IG5vZGU7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS0VOUy5OVU1CRVIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLk5VTUJFUik7XG4gICAgICAgICAgICBub2RlID0gbmV3IE51bWJlckNvbnN0YW50KHRva2VuLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUT0tFTlMuU1RSSU5HKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRPS0VOUy5TVFJJTkcpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBTdHJpbmdDb25zdGFudCh0b2tlbi52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVE9LRU5TLkJPT0xFQU4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVE9LRU5TLkJPT0xFQU4pO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBCb29sZWFuQ29uc3RhbnQodG9rZW4udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRPS0VOUy5FUlJPUilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tYXRjaChUT0tFTlMuRVJST1IpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBFcnJvckNvbnN0YW50KHRva2VuLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCB0b2tlblxuICAgICAqIEByZXR1cm4ge1Rva2VufSBOZXh0IHRva2VuXG4gICAgICovXG4gICAgbmV4dFRva2VuKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxleGVyLnBlZWsoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaCB0aGUgY3VycmVudCB0b2tlbiBhbmQgbW92ZSB0byB0aGUgbmV4dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5UeXBlIC0gVG9rZW4gdHlwZS5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgaXMgYSBpbnZhbGlkIHRva2VuLlxuICAgICAqL1xuICAgIG1hdGNoKHRva2VuVHlwZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSB0b2tlblR5cGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubG9va2FoZWFkID0gdGhpcy5sZXhlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgc3ludGF4LiBFeHBlY3RpbmcgXCIke3Rva2VuVHlwZX1cImApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBsaXN0IG9mIHRva2Vucy5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgaXMgYSBpbnZhbGlkIHRva2VuLlxuICAgICAqIEByZXR1cm4ge0FTVH0gQWJzdHJhY3QgU3ludGF4IHRyZWUuXG4gICAgICovXG4gICAgcGFyc2UoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IFRPS0VOUy5FT0wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBzeW50YXguIEV4cGVjdGluZyBlbmQgb2YgbGluZS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyBMZXhlci5cbiAgICAgKiBAcGFyYW0ge0xleGVyfSB2YWx1ZSAtIExleGljYWwgYW5hbHl6ZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIHNldCBsZXhlcih2YWx1ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xleGVyID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9sZXhlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB0aGlzLl9sZXhlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGV4ZXIoKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZXhlcjtcbiAgICB9XG59XG4iLCIvKipcbiAqIFBvc2l0aW9uIG9iamVjdC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25cbntcbiAgICAvKipcbiAgICAgKiBDZWxsIFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIENlbGwgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBDZWxsIHJvdy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW4gPSAwLCByb3cgPSAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMucm93ID0gcm93O1xuICAgIH1cbn1cbiIsIi8qKlxuICogUmFuZ2Ugb2JqZWN0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYW5nZVxue1xuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIFJhbmdlLlxuICAgICogQHBhcmFtIHtQb3NpdGlvbn0gZmlyc3QgLSBGaXJzdCBwb3NpdGlvbi5cbiAgICAqIEBwYXJhbSB7UG9zaXRpb259IGxhc3QgLSBMYXN0IHBvc2l0aW9uLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoZmlyc3QsIGxhc3QpXG4gICAge1xuICAgICAgICB0aGlzLmZpcnN0ID0gZmlyc3Q7XG4gICAgICAgIHRoaXMubGFzdCA9IGxhc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb3JyZWN0IHJhbmdlLCBldmVuIGlmIGxhc3QgY29sdW1uIG9yIHJvdyBpcyBzbWFsbGVyIHRoYW4gZmlyc3QuXG4gICAgICogQHJldHVybiB7UmFuZ2V9IENvcnJlY3QgcmFuZ2UuXG4gICAgICovXG4gICAgY29ycmVjdCgpXG4gICAge1xuICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXMuZmlyc3Q7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLmxhc3Q7XG5cbiAgICAgICAgaWYgKGZpcnN0LmNvbHVtbiA+IGxhc3QuY29sdW1uKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvbGRDb2wgPSBmaXJzdC5jb2x1bW47XG5cbiAgICAgICAgICAgIGZpcnN0LmNvbHVtbiA9IGxhc3QuY29sdW1uO1xuICAgICAgICAgICAgbGFzdC5jb2x1bW4gPSBvbGRDb2w7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3Qucm93ID4gbGFzdC5yb3cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFJvdyA9IGZpcnN0LnJvdztcblxuICAgICAgICAgICAgZmlyc3Qucm93ID0gbGFzdC5yb3c7XG4gICAgICAgICAgICBsYXN0LnJvdyA9IG9sZFJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoZmlyc3QsIGxhc3QpO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQSBMZXhpY2FsIHRva2VuLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlblxue1xuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIFRva2VuLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUb2tlbiBUeXBlLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVG9rZW4gdmFsdWUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSA9IG51bGwpXG4gICAge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBBYnN0cmFjdCBTeW50YXggVHJlZSBub2RlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFTVFxue1xufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5cbi8qKlxuICogQXJyYXlDb25zdGFudCByZXByZXNlbnRzIGFuIGFycmF5LlxuICpcbiAqIEBleHRlbmRzIEFTVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcnJheUNvbnN0YW50IGV4dGVuZHMgQVNUXG57XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQXJyYXkgY29uc3RhbnQuXG4gICAgICogQHBhcmFtIHthcnJheX0gdmFsdWUgLSBMaXN0IG9mIGl0ZW1zLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5cbi8qKlxuICogQmluYXJ5IE9wZXJhdG9yLiBBIGJpbmFyeSBvcGVyYXRvciBpcyBhbiBvcGVyYXRvciB0aGF0IG9wZXJhdGVzIG9uIHR3byBvcGVyYW5kcy5cbiAqXG4gKiBAZXh0ZW5kcyBBU1RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmluT3AgZXh0ZW5kcyBBU1RcbntcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBCaW5hcnkgT3BlcmF0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnQgLSBMZWZ0IG9wZXJhbmQuXG4gICAgICogQHBhcmFtIHtUb2tlbn0gb3AgLSBPcGVyYXRvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHQgLSBSaWdodCBvcGVyYW5kLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIG9wLCByaWdodClcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRoaXMub3AgPSBvcDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH1cbn1cbiIsImltcG9ydCBBU1QgZnJvbSAnLi9BU1QnO1xuXG4vKipcbiAqIEJvb2xlYW5Db25zdGFudCByZXByZXNlbnRzIEJvb2xlYW5zLlxuICpcbiAqIEBleHRlbmRzIEFTVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb29sZWFuQ29uc3RhbnQgZXh0ZW5kcyBBU1RcbntcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBCb29sZWFuIGNvbnN0YW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBCb29sZWFuLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5pbXBvcnQgUG9zaXRpb24gZnJvbSAnLi8uLi9Qb3NpdGlvbic7XG5cbi8qKlxuICogQ2VsbCBpZGVudGlmaWVyLlxuICpcbiAqIEBleHRlbmRzIEFTVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDZWxsSWRlbnRpZmllciBleHRlbmRzIEFTVFxue1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIENlbGwgaWRlbnRpZmllciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIEZ1bmN0aW9uIG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzaGVldF0gLSBTaGVldCBuYW1lLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNoZWV0ID0gbnVsbClcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjZWxsIG5hbWUgKHdpdGhvdXQgZG9sbGFyIHNpZ24pLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ2VsbCBuYW1lLlxuICAgICAqL1xuICAgIGNsZWFuKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9cXCQvZywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjZWxsIGNvbHVtbiBhbmQgcm93IG51bWJlcnMuXG4gICAgICogQHJldHVybiB7UG9zaXRpb259IENlbGwgcG9zaXRpb24uXG4gICAgICovXG4gICAgcG9zaXRpb24oKVxuICAgIHtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5jbGVhbigpO1xuICAgICAgICBjb25zdCBjb2x1bW5TdHJpbmcgPSByZWYucmVwbGFjZSgvW15hLXpdL2dpLCAnJyk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IENlbGxJZGVudGlmaWVyLnRvRGVjaW1hbChjb2x1bW5TdHJpbmcpO1xuICAgICAgICBjb25zdCByb3dTdHJpbmcgPSByZWYucmVwbGFjZSgvW14wLTldL2csICcnKTtcbiAgICAgICAgY29uc3Qgcm93ID0gcGFyc2VJbnQocm93U3RyaW5nLCAxMCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihjb2x1bW4sIHJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnJvbSBDb2x1bW4gc3RyaW5nIHRvIG51bWJlci4gRXhhbXBsZTogQUEgPT4gMjdcbiAgICAgKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI2OTkwMzAvaW1wbGVtZW50LW51bWJlcmluZy1zY2hlbWUtbGlrZS1hLWItYy1hYS1hYi1hYWEtc2ltaWxhci10by1jb252ZXJ0aW5nLWEtbnVtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIENvbHVtbiBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvbHVtbiBudW1iZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9EZWNpbWFsKHN0cilcbiAgICB7XG4gICAgICAgIGxldCBkZWNpbWFsID0gMDtcbiAgICAgICAgY29uc3QgbGV0dGVycyA9IHN0ci50b1VwcGVyQ2FzZSgpLnNwbGl0KG5ldyBSZWdFeHAoKSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGxldHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gKGxldHRlcnNbaV0uY2hhckNvZGVBdCgwKSAtIDY0KSAqIChNYXRoLnBvdygyNiwgbGV0dGVycy5sZW5ndGggLSAoaSArIDEpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVjaW1hbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcm9tIENvbHVtbiBudW1iZXIgdG8gc3RyaW5nLiBFeGFtcGxlOiAyNyA9PiBBQVxuICAgICAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjY5OTAzMC9pbXBsZW1lbnQtbnVtYmVyaW5nLXNjaGVtZS1saWtlLWEtYi1jLWFhLWFiLWFhYS1zaW1pbGFyLXRvLWNvbnZlcnRpbmctYS1udW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBDb2x1bW4gbnVtYmVyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb2x1bW4gc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIHRvTGV0dGVycyh2YWx1ZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGRpZ2l0cyA9IFtcbiAgICAgICAgICAgICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJyxcbiAgICAgICAgICAgICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJyxcbiAgICAgICAgICAgICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgLSAxO1xuICAgICAgICBpZiAodmFsdWUgPT09IDApIHsgcmV0dXJuIGRpZ2l0c1swXTsgfVxuXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQudW5zaGlmdChkaWdpdHNbdmFsdWUgJSAyNl0pO1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMjYpIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5cbi8qKlxuICogRXJyb3JDb25zdGFudCByZXByZXNlbnRzIEVycm9yIHJlZmVyZW5jZXMuXG4gKlxuICogQGV4dGVuZHMgQVNUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9yQ29uc3RhbnQgZXh0ZW5kcyBBU1RcbntcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBFcnJvciBjb25zdGFudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSAtIEVycm9yIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5cbi8qKlxuICogRnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAZXh0ZW5kcyBBU1RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVuY3Rpb25DYWxsIGV4dGVuZHMgQVNUXG57XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRnVuY3Rpb24gY2FsbCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIEZ1bmN0aW9uIG5hbWUuXG4gICAgICogQHBhcmFtIHthcnJheX0gW3BhcmFtc10gLSBGdW5jdGlvbiBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhcmFtcylcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5cbi8qKlxuICogTnVtYmVyQ29uc3RhbnQgcmVwcmVzZW50cyBOdW1iZXJzLlxuICpcbiAqIEBleHRlbmRzIEFTVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOdW1iZXJDb25zdGFudCBleHRlbmRzIEFTVFxue1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIE51bWJlciBjb25zdGFudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBJbnRlZ2VyIG9yIGZsb2F0IHZhbHVlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5cbi8qKlxuICogQW4gQVNUIG5vZGUgY2xhc3MgdG8gcmVwcmVzZW50IHBvc3RmaXggb3BlcmF0b3JzXG4gKlxuICogQGV4dGVuZHMgQVNUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RmaXhPcCBleHRlbmRzIEFTVFxue1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFBvc3RmaXggT3BlcmF0b3IuXG4gICAgICogQHBhcmFtIHtUb2tlbn0gb3AgLSBPcGVyYXRvci5cbiAgICAgKiBAcGFyYW0ge0FTVH0gZXhwciAtIEV4cHJlc3Npb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3AsIGV4cHIpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMudG9rZW4gPSB0aGlzLm9wID0gb3A7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5pbXBvcnQgQ2VsbElkZW50aWZpZXIgZnJvbSAnLi9DZWxsSWRlbnRpZmllcic7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi8uLi9SYW5nZSc7XG5cbi8qKlxuICogUmFuZ2UgcmVmZXJlbmNlLlxuICpcbiAqIEBleHRlbmRzIEFTVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYW5nZVJlZmVyZW5jZSBleHRlbmRzIEFTVFxue1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIENlbGwgaWRlbnRpZmllciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtUb2tlbn0gW3Rva2VuXSAtIFJhbmdlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2hlZXRdIC0gU2hlZXQgbmFtZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbiwgc2hlZXQgPSBudWxsKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMucmFuZ2VWYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IFJhbmdlIHBhaXJcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gVHdvIENlbGxJZGVudGlmaWVyXG4gICAgICovXG4gICAgcGFpcigpXG4gICAge1xuICAgICAgICBjb25zdCBwYWlycyA9IHRoaXMucmFuZ2VWYWx1ZS5zcGxpdCgnOicpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ2VsbElkZW50aWZpZXIocGFpcnNbMF0pLFxuICAgICAgICAgICAgbmV3IENlbGxJZGVudGlmaWVyKHBhaXJzWzFdKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmFuZ2UgaW5mb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtSYW5nZX0gUmFuZ2Ugb2JqZWN0XG4gICAgICovXG4gICAgcmFuZ2UoKVxuICAgIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSB0aGlzLnBhaXIoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHBhaXJzWzBdLnBvc2l0aW9uKCksIHBhaXJzWzFdLnBvc2l0aW9uKCkpO1xuICAgIH1cbn1cbiIsImltcG9ydCBBU1QgZnJvbSAnLi9BU1QnO1xuXG4vKipcbiAqIFN0cmluZ0NvbnN0YW50IHJlcHJlc2VudHMgU3RyaW5ncy5cbiAqXG4gKiBAZXh0ZW5kcyBBU1RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nQ29uc3RhbnQgZXh0ZW5kcyBBU1RcbntcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdHJpbmcgY29uc3RhbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gU3RyaW5nLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5cbi8qKlxuICogQW4gQVNUIG5vZGUgY2xhc3MgdG8gcmVwcmVzZW50IHVuYXJ5IG9wZXJhdG9yc1xuICpcbiAqIEBleHRlbmRzIEFTVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbmFyeU9wIGV4dGVuZHMgQVNUXG57XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgVW5hcnkgT3BlcmF0b3IuXG4gICAgICogQHBhcmFtIHtUb2tlbn0gb3AgLSBPcGVyYXRvci5cbiAgICAgKiBAcGFyYW0ge0FTVH0gZXhwciAtIEV4cHJlc3Npb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3AsIGV4cHIpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMudG9rZW4gPSB0aGlzLm9wID0gb3A7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgfVxufVxuIiwiaW1wb3J0IEFTVCBmcm9tICcuL0FTVCc7XG5pbXBvcnQgRnVuY3Rpb25DYWxsIGZyb20gJy4vRnVuY3Rpb25DYWxsJztcbmltcG9ydCBDZWxsSWRlbnRpZmllciBmcm9tICcuL0NlbGxJZGVudGlmaWVyJztcbmltcG9ydCBSYW5nZVJlZmVyZW5jZSBmcm9tICcuL1JhbmdlUmVmZXJlbmNlJztcbmltcG9ydCBCaW5PcCBmcm9tICcuL0Jpbk9wJztcbmltcG9ydCBVbmFyeU9wIGZyb20gJy4vVW5hcnlPcCc7XG5pbXBvcnQgUG9zdGZpeE9wIGZyb20gJy4vUG9zdGZpeE9wJztcbmltcG9ydCBBcnJheUNvbnN0YW50IGZyb20gJy4vQXJyYXlDb25zdGFudCc7XG5pbXBvcnQgTnVtYmVyQ29uc3RhbnQgZnJvbSAnLi9OdW1iZXJDb25zdGFudCc7XG5pbXBvcnQgU3RyaW5nQ29uc3RhbnQgZnJvbSAnLi9TdHJpbmdDb25zdGFudCc7XG5pbXBvcnQgQm9vbGVhbkNvbnN0YW50IGZyb20gJy4vQm9vbGVhbkNvbnN0YW50JztcbmltcG9ydCBFcnJvckNvbnN0YW50IGZyb20gJy4vRXJyb3JDb25zdGFudCc7XG5cbmV4cG9ydCB7XG4gICAgQVNULFxuICAgIEZ1bmN0aW9uQ2FsbCxcbiAgICBDZWxsSWRlbnRpZmllcixcbiAgICBSYW5nZVJlZmVyZW5jZSxcbiAgICBCaW5PcCxcbiAgICBVbmFyeU9wLFxuICAgIFBvc3RmaXhPcCxcbiAgICBBcnJheUNvbnN0YW50LFxuICAgIE51bWJlckNvbnN0YW50LFxuICAgIFN0cmluZ0NvbnN0YW50LFxuICAgIEJvb2xlYW5Db25zdGFudCxcbiAgICBFcnJvckNvbnN0YW50LFxufTtcbiIsImltcG9ydCAqIGFzIGZvcm11bGEgZnJvbSAnZm9ybXVsYWpzJztcblxuY29uc3QgREFURV9USU1FX0ZVTkNUSU9OUyA9IHtcbiAgICBEQVRFOiBmb3JtdWxhLkRBVEUsXG4gICAgLy8gREFURVZBTFVFOiBmb3JtdWxhLkRBVEVWQUxVRSwgLy8gTm90IHdvcmtpbmdcbiAgICBEQVk6IGZvcm11bGEuREFZLFxuICAgIC8vIERBWVM6IGZvcm11bGEuREFZUyxcbiAgICAvLyBEQVlTMzYwOiBmb3JtdWxhLkRBWVMzNjAsXG4gICAgLy8gRURBVEU6IGZvcm11bGEuRURBVEUsXG4gICAgLy8gRU9NT05USDogZm9ybXVsYS5FT01PTlRILFxuICAgIC8vIEhPVVI6IGZvcm11bGEuSE9VUiwgLy8gTm90IHdvcmtpbmdcbiAgICAvLyBJTlRFUlZBTDogZm9ybXVsYS5JTlRFUlZBTCxcbiAgICAvLyBJU09XRUVLTlVNOiBmb3JtdWxhLklTT1dFRUtOVU0sXG4gICAgLy8gTUlOVVRFOiBmb3JtdWxhLk1JTlVURSwgLy8gTm90IHdvcmtpbmdcbiAgICBNT05USDogZm9ybXVsYS5NT05USCxcbiAgICAvLyBORVRXT1JLREFZUzogZm9ybXVsYS5ORVRXT1JLREFZUyxcbiAgICBOT1c6IGZvcm11bGEuTk9XLFxuICAgIC8vIFNFQ09ORDogZm9ybXVsYS5TRUNPTkQsIC8vIE5vdCB3b3JraW5nXG4gICAgVElNRTogZm9ybXVsYS5USU1FLFxuICAgIC8vIFRJTUVWQUxVRTogZm9ybXVsYS5USU1FVkFMVUUsXG4gICAgVE9EQVk6IGZvcm11bGEuVE9EQVksXG4gICAgLy8gV0VFS0RBWTogZm9ybXVsYS5XRUVLREFZLFxuICAgIC8vIFdFRUtOVU06IGZvcm11bGEuV0VFS05VTSxcbiAgICAvLyBXT1JLREFZOiBmb3JtdWxhLldPUktEQVksXG4gICAgWUVBUjogZm9ybXVsYS5ZRUFSLFxuICAgIC8vIFlFQVJGUkFDOiBmb3JtdWxhLllFQVJGUkFDLFxufTtcblxuZXhwb3J0IHtcbiAgICBEQVRFX1RJTUVfRlVOQ1RJT05TLFxufTtcbiIsIi8vIGltcG9ydCB7IERBVEFCQVNFX0ZVTkNUSU9OUyB9IGZyb20gJy4vZGF0YWJhc2UnO1xuaW1wb3J0IHsgREFURV9USU1FX0ZVTkNUSU9OUyB9IGZyb20gJy4vZGF0ZS10aW1lJztcbi8vIGltcG9ydCB7IEVOR0lORUVSSU5HX0ZVTkNUSU9OUyB9IGZyb20gJy4vZW5naW5lZXJpbmcnO1xuLy8gaW1wb3J0IHsgRklOQU5DSUFMX0ZVTkNUSU9OUyB9IGZyb20gJy4vZmluYW5jaWFsJztcbmltcG9ydCB7IElORk9STUFUSU9OX0ZVTkNUSU9OUyB9IGZyb20gJy4vaW5mb3JtYXRpb24nO1xuaW1wb3J0IHsgTE9HSUNBTF9GVU5DVElPTlMgfSBmcm9tICcuL2xvZ2ljYWwnO1xuLy8gaW1wb3J0IHsgTE9PS1VQX1JFRkVSRU5DRV9GVU5DVElPTlMgfSBmcm9tICcuL2xvb2t1cC1yZWZlcmVuY2UnO1xuaW1wb3J0IHsgTUFUSF9UUklHX0ZVTkNUSU9OUyB9IGZyb20gJy4vbWF0aC10cmlnJztcbmltcG9ydCB7IE1JU0NFTExBTkVPVVNfRlVOQ1RJT05TIH0gZnJvbSAnLi9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IFNUQVRJU1RJQ0FMX0ZVTkNUSU9OUyB9IGZyb20gJy4vc3RhdGlzdGljYWwnO1xuaW1wb3J0IHsgVEVYVF9GVU5DVElPTlMgfSBmcm9tICcuL3RleHQnO1xuXG4vKipcbiAqIERlZmF1bHQgZnVuY3Rpb25zXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICovXG5jb25zdCBGVU5DVElPTlMgPSBPYmplY3QuYXNzaWduKFxuICAgIERBVEVfVElNRV9GVU5DVElPTlMsXG4gICAgLy8gREFUQUJBU0VfRlVOQ1RJT05TLFxuICAgIC8vIEVOR0lORUVSSU5HX0ZVTkNUSU9OUyxcbiAgICAvLyBGSU5BTkNJQUxfRlVOQ1RJT05TLFxuICAgIElORk9STUFUSU9OX0ZVTkNUSU9OUyxcbiAgICBMT0dJQ0FMX0ZVTkNUSU9OUyxcbiAgICAvLyBMT09LVVBfUkVGRVJFTkNFX0ZVTkNUSU9OUyxcbiAgICBNQVRIX1RSSUdfRlVOQ1RJT05TLFxuICAgIE1JU0NFTExBTkVPVVNfRlVOQ1RJT05TLFxuICAgIFNUQVRJU1RJQ0FMX0ZVTkNUSU9OUyxcbiAgICBURVhUX0ZVTkNUSU9OU1xuKTtcblxuZXhwb3J0IHtcbiAgICBGVU5DVElPTlMsXG59O1xuIiwiaW1wb3J0ICogYXMgZm9ybXVsYSBmcm9tICdmb3JtdWxhanMnO1xuXG5jb25zdCBJTkZPUk1BVElPTl9GVU5DVElPTlMgPSB7XG4gICAgLy8gSU5GTzogZm9ybXVsYS5JTkZPLFxuICAgIC8vIElTQkxBTks6IGZvcm11bGEuSVNCTEFOSyxcbiAgICBJU0JJTkFSWTogZm9ybXVsYS5JU0JJTkFSWSxcbiAgICAvLyBJU0VSUjogZm9ybXVsYS5JU0VSUiwgLy8gSG93IHRvIGhhbmRsZSBlcnJvcj9cbiAgICBJU0VSUjogZm9ybXVsYS5JU0VSUixcbiAgICBJU0VSUk9SOiBmb3JtdWxhLklTRVJST1IsIC8vIEB0b2RvIHRlc3QgdGhpc1xuICAgIElTRVZFTjogZm9ybXVsYS5JU0VWRU4sXG4gICAgLy8gSVNGT1JNVUxBOiBmb3JtdWxhLklTRk9STVVMQSwgLy8gSG93IHRvIGhhbmRsZSBmb3JtdWxhP1xuICAgIElTTE9HSUNBTDogZm9ybXVsYS5JU0xPR0lDQUwsXG4gICAgLy8gSVNOQTogZm9ybXVsYS5JU05BLCAvLyBIb3cgdG8gaGFuZGxlIGVycm9yP1xuICAgIElTTk9OVEVYVDogZm9ybXVsYS5JU05PTlRFWFQsXG4gICAgSVNOVU1CRVI6IGZvcm11bGEuSVNOVU1CRVIsXG4gICAgSVNPREQ6IGZvcm11bGEuSVNPREQsXG4gICAgLy8gSVNSRUY6IGZvcm11bGEuSVNSRUYsIC8vIEhvdyB0byBoYW5kbGUgcmVmZXJlbmNlP1xuICAgIElTVEVYVDogZm9ybXVsYS5JU1RFWFQsXG4gICAgTjogKHZhbHVlKSA9PiBmb3JtdWxhLk4uYXBwbHkoSU5GT1JNQVRJT05fRlVOQ1RJT05TLCBbdmFsdWVdKSxcbiAgICAvLyBOQTogZm9ybXVsYS5OQSwgLy8gSG93IHRvIGhhbmRsZSBlcnJvcj9cbiAgICAvLyBTSEVFVDogZm9ybXVsYS5TSEVFVCxcbiAgICAvLyBTSEVFVFM6IGZvcm11bGEuU0hFRVRTLFxuICAgIFRZUEU6ICh2YWx1ZSkgPT4gZm9ybXVsYS5UWVBFLmFwcGx5KElORk9STUFUSU9OX0ZVTkNUSU9OUywgW3ZhbHVlXSksXG59O1xuXG5leHBvcnQge1xuICAgIElORk9STUFUSU9OX0ZVTkNUSU9OUyxcbn07XG4iLCJpbXBvcnQgKiBhcyBmb3JtdWxhIGZyb20gJ2Zvcm11bGFqcyc7XG5cbmNvbnN0IExPR0lDQUxfRlVOQ1RJT05TID0ge1xuICAgIEFORDogZm9ybXVsYS5BTkQsXG4gICAgLy8gQ0hPT1NFOiBmb3JtdWxhLkNIT09TRSxcbiAgICBGQUxTRTogZm9ybXVsYS5GQUxTRSxcbiAgICBJRjogZm9ybXVsYS5JRixcbiAgICAvLyBJRkVSUk9SOiBmb3JtdWxhLklGRVJST1IsXG4gICAgLy8gSUZOQTogZm9ybXVsYS5JRk5BLFxuICAgIE5PVDogZm9ybXVsYS5OT1QsXG4gICAgT1I6IGZvcm11bGEuT1IsXG4gICAgVFJVRTogZm9ybXVsYS5UUlVFLFxuICAgIC8vIFhPUjogZm9ybXVsYS5YT1IsXG4gICAgLy8gU1dJVENIOiBmb3JtdWxhLlNXSVRDSCxcbn07XG5cbmV4cG9ydCB7XG4gICAgTE9HSUNBTF9GVU5DVElPTlMsXG59O1xuIiwiaW1wb3J0ICogYXMgZm9ybXVsYSBmcm9tICdmb3JtdWxhanMnO1xuXG5jb25zdCBNQVRIX1RSSUdfRlVOQ1RJT05TID0ge1xuICAgIEFCUzogZm9ybXVsYS5BQlMsXG4gICAgLy8gQUNPUzogZm9ybXVsYS5BQ09TLFxuICAgIC8vIEFDT1NIOiBmb3JtdWxhLkFDT1NILFxuICAgIC8vIEFDT1Q6IGZvcm11bGEuQUNPVCxcbiAgICAvLyBBQ09USDogZm9ybXVsYS5BQ09USCxcbiAgICAvLyBBR0dSRUdBVEU6IGZvcm11bGEuQUdHUkVHQVRFLFxuICAgIC8vIFBST0RVQ1Q6IGZvcm11bGEuUFJPRFVDVCxcbiAgICBTVU06IGZvcm11bGEuU1VNLFxuICAgIEFSQUJJQzogZm9ybXVsYS5BUkFCSUMsXG4gICAgLy8gQVNJTjogZm9ybXVsYS5BU0lOLFxuICAgIC8vIEFTSU5IOiBmb3JtdWxhLkFTSU5ILFxuICAgIC8vIEFUQU46IGZvcm11bGEuQVRBTixcbiAgICAvLyBBVEFOMjogZm9ybXVsYS5BVEFOMixcbiAgICAvLyBBVEFOSDogZm9ybXVsYS5BVEFOSCxcbiAgICAvLyBCQVNFOiBmb3JtdWxhLkJBU0UsXG4gICAgLy8gQ0VJTElORzogZm9ybXVsYS5DRUlMSU5HLFxuICAgIFJPVU5EOiBmb3JtdWxhLlJPVU5ELFxuICAgIC8vIENPTUJJTjogZm9ybXVsYS5DT01CSU4sXG4gICAgLy8gRkFDVDogZm9ybXVsYS5GQUNULFxuICAgIC8vIENPTUJJTkE6IGZvcm11bGEuQ09NQklOQSxcbiAgICAvLyBDT1M6IGZvcm11bGEuQ09TLFxuICAgIC8vIENPU0g6IGZvcm11bGEuQ09TSCxcbiAgICAvLyBDT1Q6IGZvcm11bGEuQ09ULFxuICAgIC8vIENPVEg6IGZvcm11bGEuQ09USCxcbiAgICAvLyBDU0M6IGZvcm11bGEuQ1NDLFxuICAgIC8vIENTQ0g6IGZvcm11bGEuQ1NDSCxcbiAgICAvLyBERUNJTUFMOiBmb3JtdWxhLkRFQ0lNQUwsXG4gICAgLy8gREVHUkVFUzogZm9ybXVsYS5ERUdSRUVTLFxuICAgIC8vIEVWRU46IGZvcm11bGEuRVZFTixcbiAgICAvLyBFWFA6IGZvcm11bGEuRVhQLFxuICAgIC8vIEZBQ1RET1VCTEU6IGZvcm11bGEuRkFDVERPVUJMRSxcbiAgICAvLyBGTE9PUjogZm9ybXVsYS5GTE9PUixcbiAgICAvLyBHQ0Q6IGZvcm11bGEuR0NELFxuICAgIC8vIElOVDogZm9ybXVsYS5JTlQsXG4gICAgLy8gSVNPOiBmb3JtdWxhLklTTyxcbiAgICAvLyBMQ006IGZvcm11bGEuTENNLFxuICAgIC8vIExOOiBmb3JtdWxhLkxOLFxuICAgIC8vIExPRzogZm9ybXVsYS5MT0csXG4gICAgLy8gTE9HMTA6IGZvcm11bGEuTE9HMTAsXG4gICAgLy8gTURFVEVSTTogZm9ybXVsYS5NREVURVJNLFxuICAgIC8vIE1JTlZFUlNFOiBmb3JtdWxhLk1JTlZFUlNFLFxuICAgIC8vIE1NVUxUOiBmb3JtdWxhLk1NVUxULFxuICAgIE1PRDogZm9ybXVsYS5NT0QsXG4gICAgLy8gTVJPVU5EOiBmb3JtdWxhLk1ST1VORCxcbiAgICAvLyBNVUxUSU5PTUlBTDogZm9ybXVsYS5NVUxUSU5PTUlBTCxcbiAgICAvLyBNVU5JVDogZm9ybXVsYS5NVU5JVCxcbiAgICAvLyBPREQ6IGZvcm11bGEuT0RELFxuICAgIFBJOiBmb3JtdWxhLlBJLFxuICAgIC8vIFBPV0VSOiBmb3JtdWxhLlBPV0VSLFxuICAgIC8vIFFVT1RJRU5UOiBmb3JtdWxhLlFVT1RJRU5ULFxuICAgIFJBRElBTlM6IGZvcm11bGEuUkFESUFOUyxcbiAgICBSQU5EOiBmb3JtdWxhLlJBTkQsXG4gICAgUkFOREJFVFdFRU46IGZvcm11bGEuUkFOREJFVFdFRU4sXG4gICAgUk9NQU46IGZvcm11bGEuUk9NQU4sXG4gICAgUk9VTkRET1dOOiBmb3JtdWxhLlJPVU5ERE9XTixcbiAgICBST1VORFVQOiBmb3JtdWxhLlJPVU5EVVAsXG4gICAgLy8gU0VDOiBmb3JtdWxhLlNFQyxcbiAgICAvLyBTRUNIOiBmb3JtdWxhLlNFQ0gsXG4gICAgLy8gU0VSSUVTU1VNOiBmb3JtdWxhLlNFUklFU1NVTSxcbiAgICBTSUdOOiBmb3JtdWxhLlNJR04sXG4gICAgLy8gU0lOOiBmb3JtdWxhLlNJTixcbiAgICAvLyBTSU5IOiBmb3JtdWxhLlNJTkgsXG4gICAgU1FSVDogZm9ybXVsYS5TUVJULFxuICAgIC8vIFNRUlRQSTogZm9ybXVsYS5TUVJUUEksXG4gICAgLy8gU1VCVE9UQUw6IGZvcm11bGEuU1VCVE9UQUwsXG4gICAgQUREOiBmb3JtdWxhLkFERCxcbiAgICBNSU5VUzogZm9ybXVsYS5NSU5VUyxcbiAgICBESVZJREU6IGZvcm11bGEuRElWSURFLFxuICAgIE1VTFRJUExZOiBmb3JtdWxhLk1VTFRJUExZLFxuICAgIEdURTogZm9ybXVsYS5HVEUsXG4gICAgTFQ6IGZvcm11bGEuTFQsXG4gICAgTFRFOiBmb3JtdWxhLkxURSxcbiAgICBFUTogZm9ybXVsYS5FUSxcbiAgICBORTogZm9ybXVsYS5ORSxcbiAgICBQT1c6IGZvcm11bGEuUE9XLFxuICAgIC8vIFNVTUlGOiBmb3JtdWxhLlNVTUlGLFxuICAgIC8vIFNVTUlGUzogZm9ybXVsYS5TVU1JRlMsXG4gICAgU1VNUFJPRFVDVDogZm9ybXVsYS5TVU1QUk9EVUNULFxuICAgIFNVTVNROiBmb3JtdWxhLlNVTVNRLFxuICAgIC8vIFNVTVgyTVkyOiBmb3JtdWxhLlNVTVgyTVkyLFxuICAgIC8vIFNVTVgyUFkyOiBmb3JtdWxhLlNVTVgyUFkyLFxuICAgIC8vIFNVTVhNWTI6IGZvcm11bGEuU1VNWE1ZMixcbiAgICAvLyBUQU46IGZvcm11bGEuVEFOLFxuICAgIC8vIFRBTkg6IGZvcm11bGEuVEFOSCxcbiAgICAvLyBUUlVOQzogZm9ybXVsYS5UUlVOQyxcbn07XG5cbmV4cG9ydCB7XG4gICAgTUFUSF9UUklHX0ZVTkNUSU9OUyxcbn07XG4iLCJpbXBvcnQgKiBhcyBmb3JtdWxhIGZyb20gJ2Zvcm11bGFqcyc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnZm9ybXVsYWpzL2xpYi91dGlscyc7XG5cbmNvbnN0IE1JU0NFTExBTkVPVVNfRlVOQ1RJT05TID0ge1xuICAgIFVOSVFVRTogKC4uLmFyZ3MpID0+IGZvcm11bGEuVU5JUVVFLmFwcGx5KG51bGwsIGZsYXR0ZW4oYXJncykpLFxuICAgIC8vIEZMQVRURU46IGZvcm11bGEuRkxBVFRFTixcbiAgICAvLyBBUkdTMkFSUkFZOiBmb3JtdWxhLkFSR1MyQVJSQVksXG4gICAgLy8gUkVGRVJFTkNFOiBmb3JtdWxhLlJFRkVSRU5DRSxcbiAgICAvLyBKT0lOOiBmb3JtdWxhLkpPSU4sXG4gICAgLy8gTlVNQkVSUzogZm9ybXVsYS5OVU1CRVJTLFxuICAgIC8vIE5VTUVSQUw6IGZvcm11bGEuTlVNRVJBTCxcbn07XG5cbmV4cG9ydCB7XG4gICAgTUlTQ0VMTEFORU9VU19GVU5DVElPTlMsXG59O1xuIiwiaW1wb3J0ICogYXMgZm9ybXVsYSBmcm9tICdmb3JtdWxhanMnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJ2Zvcm11bGFqcy9saWIvdXRpbHMnO1xuXG5jb25zdCBTVEFUSVNUSUNBTF9GVU5DVElPTlMgPSB7XG4gICAgQVZFUkFHRTogZm9ybXVsYS5BVkVSQUdFLFxuICAgIEFWRVJBR0VBOiBmb3JtdWxhLkFWRVJBR0VBLFxuICAgIC8vIEFWRVJBR0VJRjogZm9ybXVsYS5BVkVSQUdFSUYsIC8vIE5vdCBzZWN1cmUsIGNhbiBwYXNzIGFueSBKUyBjb2RlIGFzIGNyaXRlcmlhXG4gICAgLy8gQVZFUkFHRUlGUzogZm9ybXVsYS5BVkVSQUdFSUZTLFxuICAgIC8vIENPTFVNTjogZm9ybXVsYS5DT0xVTU4sXG4gICAgLy8gQ09MVU1OUzogZm9ybXVsYS5DT0xVTU5TLFxuICAgIC8vIENPUlJFTDogZm9ybXVsYS5DT1JSRUwsXG4gICAgQ09VTlQ6IGZvcm11bGEuQ09VTlQsXG4gICAgQ09VTlRBOiBmb3JtdWxhLkNPVU5UQSxcbiAgICBDT1VOVEJMQU5LOiBmb3JtdWxhLkNPVU5UQkxBTkssXG4gICAgQ09VTlRJTjogKHJhbmdlLCB2YWx1ZSkgPT4gZm9ybXVsYS5DT1VOVElOKGZsYXR0ZW4ocmFuZ2UpLCB2YWx1ZSksXG4gICAgLy8gQ09VTlRJRjogZm9ybXVsYS5DT1VOVElGLFxuICAgIC8vIENPVU5USUZTOiBmb3JtdWxhLkNPVU5USUZTLFxuICAgIENPVU5UVU5JUVVFOiBmb3JtdWxhLkNPVU5UVU5JUVVFLFxuICAgIC8vIERFVlNROiBmb3JtdWxhLkRFVlNRLFxuICAgIC8vIEZJU0hFUjogZm9ybXVsYS5GSVNIRVIsXG4gICAgLy8gRklTSEVSSU5WOiBmb3JtdWxhLkZJU0hFUklOVixcbiAgICAvLyBGT1JFQ0FTVDogZm9ybXVsYS5GT1JFQ0FTVCxcbiAgICAvLyBGUkVRVUVOQ1k6IGZvcm11bGEuRlJFUVVFTkNZLFxuICAgIC8vIEdBTU1BOiBmb3JtdWxhLkdBTU1BLFxuICAgIC8vIEdBTU1BTE46IGZvcm11bGEuR0FNTUFMTixcbiAgICAvLyBHQVVTUzogZm9ybXVsYS5HQVVTUyxcbiAgICAvLyBHRU9NRUFOOiBmb3JtdWxhLkdFT01FQU4sXG4gICAgLy8gR1JPV1RIOiBmb3JtdWxhLkdST1dUSCxcbiAgICAvLyBIQVJNRUFOOiBmb3JtdWxhLkhBUk1FQU4sXG4gICAgLy8gSU5URVJDRVBUOiBmb3JtdWxhLklOVEVSQ0VQVCxcbiAgICAvLyBLVVJUOiBmb3JtdWxhLktVUlQsXG4gICAgLy8gTEFSR0U6IGZvcm11bGEuTEFSR0UsXG4gICAgLy8gTElORVNUOiBmb3JtdWxhLkxJTkVTVCxcbiAgICAvLyBMT0dFU1Q6IGZvcm11bGEuTE9HRVNULFxuICAgIE1BWDogZm9ybXVsYS5NQVgsXG4gICAgLy8gTUFYQTogZm9ybXVsYS5NQVhBLFxuICAgIC8vIE1FRElBTjogZm9ybXVsYS5NRURJQU4sXG4gICAgTUlOOiBmb3JtdWxhLk1JTixcbiAgICAvLyBNSU5BOiBmb3JtdWxhLk1JTkEsXG4gICAgLy8gUEVBUlNPTjogZm9ybXVsYS5QRUFSU09OLFxuICAgIC8vIFBFUk1VVDogZm9ybXVsYS5QRVJNVVQsXG4gICAgLy8gUEVSTVVUQVRJT05BOiBmb3JtdWxhLlBFUk1VVEFUSU9OQSxcbiAgICAvLyBQSEk6IGZvcm11bGEuUEhJLFxuICAgIC8vIFBST0I6IGZvcm11bGEuUFJPQixcbiAgICAvLyBST1c6IGZvcm11bGEuUk9XLFxuICAgIC8vIFJPV1M6IGZvcm11bGEuUk9XUyxcbiAgICAvLyBSU1E6IGZvcm11bGEuUlNRLFxuICAgIC8vIFNLRVc6IGZvcm11bGEuU0tFVyxcbiAgICAvLyBTTE9QRTogZm9ybXVsYS5TTE9QRSxcbiAgICAvLyBTTUFMTDogZm9ybXVsYS5TTUFMTCxcbiAgICAvLyBTVEFOREFSRElaRTogZm9ybXVsYS5TVEFOREFSRElaRSxcbiAgICAvLyBTVERFVjogZm9ybXVsYS5TVERFVixcbiAgICAvLyBTVERFVkE6IGZvcm11bGEuU1RERVZBLFxuICAgIC8vIFZBUkE6IGZvcm11bGEuVkFSQSxcbiAgICAvLyBTVERFVlBBOiBmb3JtdWxhLlNUREVWUEEsXG4gICAgLy8gVkFSUEE6IGZvcm11bGEuVkFSUEEsXG4gICAgLy8gU1RFWVg6IGZvcm11bGEuU1RFWVgsXG4gICAgLy8gVFJBTlNQT1NFOiBmb3JtdWxhLlRSQU5TUE9TRSxcbiAgICAvLyBUUkVORDogZm9ybXVsYS5UUkVORCxcbiAgICAvLyBUUklNTUVBTjogZm9ybXVsYS5UUklNTUVBTixcbiAgICAvLyBCRVRBRElTVDogZm9ybXVsYS5CRVRBRElTVCxcbiAgICAvLyBCRVRBSU5WOiBmb3JtdWxhLkJFVEFJTlYsXG4gICAgLy8gQklOT01ESVNUOiBmb3JtdWxhLkJJTk9NRElTVCxcbiAgICAvLyBDRUlMSU5HOiBmb3JtdWxhLkNFSUxJTkcsXG4gICAgLy8gSVNPQ0VJTElORzogZm9ybXVsYS5JU09DRUlMSU5HLFxuICAgIC8vIENFSUxJTkdNQVRIOiBmb3JtdWxhLkNFSUxJTkdNQVRILFxuICAgIC8vIENFSUxJTkdQUkVDSVNFOiBmb3JtdWxhLkNFSUxJTkdQUkVDSVNFLFxuICAgIC8vIENISURJU1Q6IGZvcm11bGEuQ0hJRElTVCxcbiAgICAvLyBDSElESVNUUlQ6IGZvcm11bGEuQ0hJRElTVFJULFxuICAgIC8vIENISUlOVjogZm9ybXVsYS5DSElJTlYsXG4gICAgLy8gQ0hJSU5WUlQ6IGZvcm11bGEuQ0hJSU5WUlQsXG4gICAgLy8gQ0hJVEVTVDogZm9ybXVsYS5DSElURVNULFxuICAgIC8vIENPVkFSOiBmb3JtdWxhLkNPVkFSLFxuICAgIC8vIENPVkFSSUFOQ0VQOiBmb3JtdWxhLkNPVkFSSUFOQ0VQLFxuICAgIC8vIENPVkFSSUFOQ0VTOiBmb3JtdWxhLkNPVkFSSUFOQ0VTLFxuICAgIC8vIENSSVRCSU5PTTogZm9ybXVsYS5DUklUQklOT00sXG4gICAgLy8gRVhQT05ESVNUOiBmb3JtdWxhLkVYUE9ORElTVCxcbiAgICAvLyBFUkZDUFJFQ0lTRTogZm9ybXVsYS5FUkZDUFJFQ0lTRSxcbiAgICAvLyBFUkZQUkVDSVNFOiBmb3JtdWxhLkVSRlBSRUNJU0UsXG4gICAgLy8gRkRJU1Q6IGZvcm11bGEuRkRJU1QsXG4gICAgLy8gRkRJU1RSVDogZm9ybXVsYS5GRElTVFJULFxuICAgIC8vIEZJTlZSVDogZm9ybXVsYS5GSU5WUlQsXG4gICAgLy8gRklOVjogZm9ybXVsYS5GSU5WLFxuICAgIC8vIEZMT09SOiBmb3JtdWxhLkZMT09SLFxuICAgIC8vIEZMT09STUFUSDogZm9ybXVsYS5GTE9PUk1BVEgsXG4gICAgLy8gRkxPT1JQUkVDSVNFOiBmb3JtdWxhLkZMT09SUFJFQ0lTRSxcbiAgICAvLyBGVEVTVDogZm9ybXVsYS5GVEVTVCxcbiAgICAvLyBHQU1NQURJU1Q6IGZvcm11bGEuR0FNTUFESVNULFxuICAgIC8vIEdBTU1BSU5WOiBmb3JtdWxhLkdBTU1BSU5WLFxuICAgIC8vIEdBTU1BTE5QUkVDSVNFOiBmb3JtdWxhLkdBTU1BTE5QUkVDSVNFLFxuICAgIC8vIEhZUEdFT01ESVNUOiBmb3JtdWxhLkhZUEdFT01ESVNULFxuICAgIC8vIExPR0lOVjogZm9ybXVsYS5MT0dJTlYsXG4gICAgLy8gTE9HTk9STUlOVjogZm9ybXVsYS5MT0dOT1JNSU5WLFxuICAgIC8vIExPR05PUk1ESVNUOiBmb3JtdWxhLkxPR05PUk1ESVNULFxuICAgIC8vIE1PREVNVUxUOiBmb3JtdWxhLk1PREVNVUxULFxuICAgIC8vIE1PREVTTkdMOiBmb3JtdWxhLk1PREVTTkdMLFxuICAgIC8vIE5FR0JJTk9NRElTVDogZm9ybXVsYS5ORUdCSU5PTURJU1QsXG4gICAgLy8gTkVUV09SS0RBWVNJTlRMOiBmb3JtdWxhLk5FVFdPUktEQVlTSU5UTCxcbiAgICAvLyBOT1JNRElTVDogZm9ybXVsYS5OT1JNRElTVCxcbiAgICAvLyBOT1JNSU5WOiBmb3JtdWxhLk5PUk1JTlYsXG4gICAgLy8gTk9STVNESVNUOiBmb3JtdWxhLk5PUk1TRElTVCxcbiAgICAvLyBOT1JNU0lOVjogZm9ybXVsYS5OT1JNU0lOVixcbiAgICAvLyBQRVJDRU5USUxFRVhDOiBmb3JtdWxhLlBFUkNFTlRJTEVFWEMsXG4gICAgLy8gUEVSQ0VOVElMRUlOQzogZm9ybXVsYS5QRVJDRU5USUxFSU5DLFxuICAgIC8vIFBFUkNFTlRSQU5LRVhDOiBmb3JtdWxhLlBFUkNFTlRSQU5LRVhDLFxuICAgIC8vIFBFUkNFTlRSQU5LSU5DOiBmb3JtdWxhLlBFUkNFTlRSQU5LSU5DLFxuICAgIC8vIFBPSVNTT05ESVNUOiBmb3JtdWxhLlBPSVNTT05ESVNULFxuICAgIC8vIFFVQVJUSUxFRVhDOiBmb3JtdWxhLlFVQVJUSUxFRVhDLFxuICAgIC8vIFFVQVJUSUxFSU5DOiBmb3JtdWxhLlFVQVJUSUxFSU5DLFxuICAgIC8vIFJBTktBVkc6IGZvcm11bGEuUkFOS0FWRyxcbiAgICAvLyBSQU5LRVE6IGZvcm11bGEuUkFOS0VRLFxuICAgIC8vIFNLRVdQOiBmb3JtdWxhLlNLRVdQLFxuICAgIC8vIFNUREVWUDogZm9ybXVsYS5TVERFVlAsXG4gICAgLy8gU1RERVZTOiBmb3JtdWxhLlNUREVWUyxcbiAgICAvLyBURElTVDogZm9ybXVsYS5URElTVCxcbiAgICAvLyBURElTVFJUOiBmb3JtdWxhLlRESVNUUlQsXG4gICAgLy8gVElOVjogZm9ybXVsYS5USU5WLFxuICAgIC8vIFRURVNUOiBmb3JtdWxhLlRURVNULFxuICAgIC8vIFZBUlA6IGZvcm11bGEuVkFSUCxcbiAgICAvLyBWQVJTOiBmb3JtdWxhLlZBUlMsXG4gICAgLy8gV0VJQlVMTERJU1Q6IGZvcm11bGEuV0VJQlVMTERJU1QsXG4gICAgLy8gV09SS0RBWUlOVEw6IGZvcm11bGEuV09SS0RBWUlOVEwsXG4gICAgLy8gWlRFU1Q6IGZvcm11bGEuWlRFU1QsXG59O1xuXG5leHBvcnQge1xuICAgIFNUQVRJU1RJQ0FMX0ZVTkNUSU9OUyxcbn07XG4iLCJpbXBvcnQgKiBhcyBmb3JtdWxhIGZyb20gJ2Zvcm11bGFqcyc7XG5cbmNvbnN0IFRFWFRfRlVOQ1RJT05TID0ge1xuICAgIC8vIEFTQzogZm9ybXVsYS5BU0MsXG4gICAgLy8gQkFIVFRFWFQ6IGZvcm11bGEuQkFIVFRFWFQsXG4gICAgLy8gQ0hBUjogZm9ybXVsYS5DSEFSLFxuICAgIC8vIENMRUFOOiBmb3JtdWxhLkNMRUFOLFxuICAgIC8vIENPREU6IGZvcm11bGEuQ09ERSxcbiAgICBDT05DQVQ6IChsZWZ0LCByaWdodCkgPT4gZm9ybXVsYS5DT05DQVRFTkFURShsZWZ0LCByaWdodCksXG4gICAgQ09OQ0FURU5BVEU6IGZvcm11bGEuQ09OQ0FURU5BVEUsXG4gICAgLy8gREJDUzogZm9ybXVsYS5EQkNTLFxuICAgIC8vIERPTExBUjogZm9ybXVsYS5ET0xMQVIsXG4gICAgLy8gRVhBQ1Q6IGZvcm11bGEuRVhBQ1QsXG4gICAgLy8gRklORDogZm9ybXVsYS5GSU5ELFxuICAgIC8vIEZJWEVEOiBmb3JtdWxhLkZJWEVELFxuICAgIC8vIEhUTUwyVEVYVDogZm9ybXVsYS5IVE1MMlRFWFQsXG4gICAgTEVGVDogZm9ybXVsYS5MRUZULFxuICAgIExFTjogZm9ybXVsYS5MRU4sXG4gICAgTE9XRVI6IGZvcm11bGEuTE9XRVIsXG4gICAgTUlEOiBmb3JtdWxhLk1JRCxcbiAgICAvLyBOVU1CRVJWQUxVRTogZm9ybXVsYS5OVU1CRVJWQUxVRSxcbiAgICAvLyBQUk9ORVRJQzogZm9ybXVsYS5QUk9ORVRJQyxcbiAgICBQUk9QRVI6IGZvcm11bGEuUFJPUEVSLFxuICAgIC8vIFJFR0VYRVhUUkFDVDogZm9ybXVsYS5SRUdFWEVYVFJBQ1QsXG4gICAgLy8gUkVHRVhNQVRDSDogZm9ybXVsYS5SRUdFWE1BVENILFxuICAgIC8vIFJFR0VYUkVQTEFDRTogZm9ybXVsYS5SRUdFWFJFUExBQ0UsXG4gICAgLy8gUkVQTEFDRTogZm9ybXVsYS5SRVBMQUNFLFxuICAgIFJFUFQ6IGZvcm11bGEuUkVQVCxcbiAgICBSSUdIVDogZm9ybXVsYS5SSUdIVCxcbiAgICAvLyBTRUFSQ0g6IGZvcm11bGEuU0VBUkNILFxuICAgIC8vIFNQTElUOiBmb3JtdWxhLlNQTElULFxuICAgIC8vIFNVQlNUSVRVVEU6IGZvcm11bGEuU1VCU1RJVFVURSxcbiAgICAvLyBUOiBmb3JtdWxhLlQsXG4gICAgVEVYVDogZm9ybXVsYS5URVhULFxuICAgIFRSSU06IGZvcm11bGEuVFJJTSxcbiAgICAvLyBVTklDSEFSOiBmb3JtdWxhLlVOSUNIQVIsXG4gICAgLy8gVU5JQ09ERTogZm9ybXVsYS5VTklDT0RFLFxuICAgIFVQUEVSOiBmb3JtdWxhLlVQUEVSLFxuICAgIC8vIFZBTFVFOiBmb3JtdWxhLlZBTFVFLFxufTtcblxuZXhwb3J0IHtcbiAgICBURVhUX0ZVTkNUSU9OUyxcbn07XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIFRva2VuIH0gZnJvbSAnLi9Ub2tlbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENoYXJhY3RlcnMgfSBmcm9tICcuL0NoYXJhY3RlcnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMZXhlciB9IGZyb20gJy4vTGV4ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYXJzZXIgfSBmcm9tICcuL1BhcnNlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vZGVWaXNpdG9yIH0gZnJvbSAnLi9Ob2RlVmlzaXRvcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEludGVycHJldGVyIH0gZnJvbSAnLi9JbnRlcnByZXRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERhdGFHcmlkIH0gZnJvbSAnLi9EYXRhR3JpZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvc2l0aW9uIH0gZnJvbSAnLi9Qb3NpdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhbmdlIH0gZnJvbSAnLi9SYW5nZSc7XG5leHBvcnQgKiBmcm9tICcuL2FzdCc7XG4iXX0=
